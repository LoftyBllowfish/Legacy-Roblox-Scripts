<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Model" referent="RBXC78FB5E5EB574711A768BA700FD80408">
		<Properties>
			<CoordinateFrame name="ModelInPrimary">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">Strife</string>
			<Ref name="PrimaryPart">null</Ref>
		</Properties>
		<Item class="HopperBin" referent="RBXFAB939F763A842DAAD37D48C3B078EDC">
			<Properties>
				<bool name="Active">false</bool>
				<token name="BinType">0</token>
				<string name="Name">Vulca</string>
				<Content name="TextureId"><null></null></Content>
			</Properties>
			<Item class="LocalScript" referent="RBXD1255BCFE0104D6DBBA74F6C1F883C24">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LocalScript</string>
					<string name="ScriptGuid">{1B78802F-6506-4FAC-B068-9C91B7999497}</string>
					<ProtectedString name="Source"><![CDATA[Player = game:GetService("Players").LocalPlayer
Character = Player.Character
PlayerGui = Player.PlayerGui
Backpack = Player.Backpack
Torso = Character.Torso
Head = Character.Head
Humanoid = Character.Humanoid
LeftArm = Character["Left Arm"]
LeftLeg = Character["Left Leg"]
RightArm = Character["Right Arm"]
RightLeg = Character["Right Leg"]
LS = Torso["Left Shoulder"]
LH = Torso["Left Hip"]
RS = Torso["Right Shoulder"]
RH = Torso["Right Hip"]
Neck = Torso.Neck
it = Instance.new
vt = Vector3.new
cf = CFrame.new
euler = CFrame.fromEulerAnglesXYZ
angles = CFrame.Angles
necko = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
necko2 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
LHC0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
LHC1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
RHC0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RHC1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RootPart = Character.HumanoidRootPart
RootJoint = RootPart.RootJoint
RootCF = euler(-1.57, 0, 3.14)
attack = false
attackdebounce = false
MMouse = nil
combo = 0
local hitfloor, posfloor = nil, nil
local idle = 0
local Anim = "Idle"
local Effects = {}
local Weapon = {}
local Welds = {}
local decreaseatk = 0
local decreasedef = 0
local decreasemvmt = 0
local gun = false
local shoot = false
local perfaim = false
local redimbue = false
local move1 = "(Z)\nFiery Wave"
local move2 = "(X)\nRed Field"
local move3 = "(C)\nRed Imbue"
local move4 = "(V)\nPower of Red"
local cooldowns = {}
local cooldown1 = 0
table.insert(cooldowns, cooldown1)
local cooldown2 = 0
table.insert(cooldowns, cooldown2)
local cooldown3 = 0
table.insert(cooldowns, cooldown3)
local cooldown4 = 0
table.insert(cooldowns, cooldown4)
local cooldownsadd = {}
local cooldownadd1 = 0.55
table.insert(cooldownsadd, cooldownadd1)
local cooldownadd2 = 0.15
table.insert(cooldownsadd, cooldownadd2)
local cooldownadd3 = 0.2
table.insert(cooldownsadd, cooldownadd3)
local cooldownadd4 = 0.04
table.insert(cooldownsadd, cooldownadd4)
local cooldownmax = 100
--local damageFunc = workspace.damageFunc
player = nil
RSH = nil
LW = Instance.new("Motor")
RW = Instance.new("Motor")
RW.Name = "Right Shoulder"
LW.Name = "Left Shoulder"
LH = Torso["Left Hip"]
RH = Torso["Right Hip"]
TorsoColor = Torso.BrickColor
local mdec = Instance.new("NumberValue", Decrease)
mdec.Name = "DecreaseDef"
mdec.Value = 0.4
local mdec2 = Instance.new("NumberValue", Decrease)
mdec2.Name = "DecreaseMvmt"
mdec2.Value = 0.1
local Animate = Humanoid.Animator
local canjump = true
removeControl = function()
  canjump = false
end
resumeControl = function()
  canjump = true
end
Player.Character.Humanoid.Changed:connect(function()
  if canjump == false then
    Player.Character.Humanoid.Jump = false
  end
end)
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 0, num do
			ArtificialHB.Event:wait()
		end
	end
end
if Character:findFirstChild("Ignis", true) ~= nil then
  Character:findFirstChild("Ignis", true).Parent = nil
end
if Player.PlayerGui:findFirstChild("WeaponGUI", true) ~= nil then
  Player.PlayerGui:findFirstChild("WeaponGUI", true).Parent = nil
end
if Character:findFirstChild("Stats", true) ~= nil then
  Character:findFirstChild("Stats", true).Parent = nil
end
local Stats = Instance.new("BoolValue")
Stats.Name = "Stats"
Stats.Parent = Character
local Atk = Instance.new("NumberValue")
Atk.Name = "Damage"
Atk.Parent = Stats
Atk.Value = 1
local Def = Instance.new("NumberValue")
Def.Name = "Defense"
Def.Parent = Stats
Def.Value = 1
local Mvmt = Instance.new("NumberValue")
Mvmt.Name = "Movement"
Mvmt.Parent = Stats
Mvmt.Value = 1
local Block = Instance.new("BoolValue")
Block.Name = "Block"
Block.Parent = Stats
Block.Value = false
local Stun = Instance.new("NumberValue")
Stun.Name = "Stun"
Stun.Parent = Stats
Stun.Value = 0
local StunT = Instance.new("NumberValue")
StunT.Name = "StunThreshold"
StunT.Parent = Stats
StunT.Value = 100
local Rooted = Instance.new("BoolValue")
Rooted.Name = "Rooted"
Rooted.Parent = Stats
Rooted.Value = false
local Stunned = Instance.new("BoolValue")
Stunned.Name = "Stunned"
Stunned.Parent = Stats
Stunned.Value = false
local Stagger = Instance.new("BoolValue")
Stagger.Name = "Stagger"
Stagger.Parent = Stats
Stagger.Value = false
local StaggerHit = Instance.new("BoolValue")
StaggerHit.Name = "StaggerHit"
StaggerHit.Parent = Stats
StaggerHit.Value = false
local RecentEnemy = Instance.new("ObjectValue")
RecentEnemy.Name = "RecentEnemy"
RecentEnemy.Parent = Stats
RecentEnemy.Value = nil
local Decrease = Instance.new("BoolValue")
Decrease.Name = "Decrease"
Decrease.Parent = Stats
Decrease.Value = false
local mana = Instance.new("NumberValue")
mana.Name = "Mana"
mana.Parent = Stats
mana.Value = 0
local passive = Instance.new("NumberValue", Decrease)
passive.Name = "DecreaseAtk"
passive.Value = 0
local passive2 = Instance.new("NumberValue", Decrease)
passive2.Name = "DecreaseMvmt"
passive2.Value = 0
NoOutline = function(Part)
  Part.TopSurface = 10
end
part = function(formfactor, parent, reflectance, transparency, brickcolor, name, size)
  local fp = it("Part")
  fp.formFactor = formfactor
  fp.Parent = parent
  fp.Reflectance = reflectance
  fp.Transparency = transparency
  fp.CanCollide = false
  fp.Locked = true
  fp.BrickColor = brickcolor
  fp.Name = name
  fp.Size = size
  fp.Position = Torso.Position
  NoOutline(fp)
  fp.Material = "SmoothPlastic"
  fp:BreakJoints()
  return fp
end
mesh = function(Mesh, part, meshtype, meshid, offset, scale)
  local mesh = it(Mesh)
  mesh.Parent = part
  if Mesh == "SpecialMesh" then
    mesh.MeshType = meshtype
    if meshid ~= "nil" then
      mesh.MeshId = "http://www.roblox.com/asset/?id=" .. meshid
    end
  end
  mesh.Offset = offset
  mesh.Scale = scale
  return mesh
end
weld = function(parent, part0, part1, c0)
  local weld = it("Motor")
  weld.Parent = parent
  weld.Part0 = part0
  weld.Part1 = part1
  weld.C0 = c0
  return weld
end
gui = function(GuiType, parent, text, backtrans, backcol, pos, size)
  local gui = it(GuiType)
  gui.Parent = parent
  gui.Text = text
  gui.BackgroundTransparency = backtrans
  gui.BackgroundColor3 = backcol
  gui.SizeConstraint = "RelativeXY"
  gui.TextXAlignment = "Center"
  gui.TextYAlignment = "Center"
  gui.Position = pos
  gui.Size = size
  gui.Font = "SourceSans"
  gui.FontSize = "Size14"
  gui.TextWrapped = false
  gui.TextStrokeTransparency = 0
  gui.TextColor = BrickColor.new("White")
  return gui
end
local Color1 = Torso.BrickColor
local fengui = it("GuiMain")
fengui.Parent = Player.PlayerGui
fengui.Name = "WeaponGUI"
local fenframe = it("Frame")
fenframe.Parent = fengui
fenframe.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe.BackgroundTransparency = 1
fenframe.BorderColor3 = Color3.new(17, 17, 17)
fenframe.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe.Position = UDim2.new(0.95, 0, 0.7, 0)
local fenframe2 = it("Frame")
fenframe2.Parent = fengui
fenframe2.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe2.BackgroundTransparency = 1
fenframe2.BorderColor3 = Color3.new(17, 17, 17)
fenframe2.Size = UDim2.new(0.2, 0, 0.1, 0)
fenframe2.Position = UDim2.new(0.4, 0, 0.85, 0)
local fenframe3 = it("Frame")
fenframe3.Parent = fengui
fenframe3.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe3.BackgroundTransparency = 1
fenframe3.BorderColor3 = Color3.new(17, 17, 17)
fenframe3.Size = UDim2.new(0.2, 0, 0.2, 0)
fenframe3.Position = UDim2.new(0.8, 0, 0.8, 0)
fenframe3.Name = "MoveFrame"
local fenframe4 = it("Frame")
fenframe4.Parent = fengui
fenframe4.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe4.BackgroundTransparency = 1
fenframe4.BorderColor3 = Color3.new(17, 17, 17)
fenframe4.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe4.Position = UDim2.new(0, 0, 0.7, 0)
local pressedf = false
local fenframe5 = it("Frame")
fenframe5.Parent = fengui
fenframe5.BackgroundColor3 = Color3.new(0, 0, 0)
fenframe5.BackgroundTransparency = 1
fenframe5.BorderColor3 = Color3.new(0, 0, 0)
fenframe5.Size = UDim2.new(1, 0, 1, 0)
fenframe5.Position = UDim2.new(0, 0, 0, 0)
fenframe5.ZIndex = 2
local tellbar = gui("TextLabel", fenframe5, "-Damage buffs are slightly increased (+)\n-Fiery Wave moves slightly faster and lasts slightly longer (+)\n-Red Imbue mana cost slightly reduced (+)\n-Red Imbue does not buff damage anymore, but instead, all of Vulca\'s sword combo attacks creates a red wave (+/-)\n-Fiery Wave cooldown is slightly shorter but deals less damage (-)\n-Mana regain decreased and ability cooldowns also increased (-)\n-Defense debuffs are increased (-)", 1, Color3.new(0, 0, 0), UDim2.new(0.25, 0, 0.25, 0), UDim2.new(0.5, 0, 0.5, 0))
tellbar.Font = "Arial"
tellbar.TextScaled = true
tellbar.TextTransparency = 1
tellbar.TextStrokeTransparency = 1
tellbar.ZIndex = 2
local fnumb = 0
local fenbarmana1 = gui("TextLabel", fenframe, "", 0, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarmana2 = gui("TextLabel", fenframe, "", 0, BrickColor.new("Really red").Color, UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarmana4 = gui("TextLabel", fenframe, "Mana(" .. mana.Value .. ")", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbardamage = gui("TextLabel", fenframe2, "Damage", 0.55, Color3.new(0.6078431372549, 0, 0), UDim2.new(-0.23, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbardef = gui("TextLabel", fenframe2, "Defense", 0.55, Color3.new(0, 0, 0.6078431372549), UDim2.new(-0.46, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarmove = gui("TextLabel", fenframe2, "Walkspeed", 0.55, Color3.new(0, 0.6078431372549, 0), UDim2.new(1.03, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarhp1 = gui("TextLabel", fenframe2, "", 0, Color3.new(0, 0, 0), UDim2.new(-0.46, 0, 1, 0), UDim2.new(1.92, 0, 0.4, 0))
local fenbarhp2 = gui("TextLabel", fenbarhp1, "", 0, Color3.new(1, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarhp3 = gui("TextLabel", fenbarhp1, "(100)", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
local fenbarstun1 = gui("TextLabel", fenframe4, "", 0, Color3.new(0, 0, 0), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarstun2 = gui("TextLabel", fenframe4, "", 0, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarstun3 = gui("TextLabel", fenframe4, "Stun(" .. Stun.Value .. ")", 1, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbarmove1 = gui("TextButton", fenframe3, move1, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove1.ZIndex = 2
local fenbarmove1b = gui("TextLabel", fenbarmove1, "", 0.55, BrickColor.new("Bright red").Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove2 = gui("TextButton", fenframe3, move2, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove2.ZIndex = 2
local fenbarmove2b = gui("TextLabel", fenbarmove2, "", 0.55, BrickColor.new("Bright red").Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove3 = gui("TextButton", fenframe3, move3, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove3.ZIndex = 2
local fenbarmove3b = gui("TextLabel", fenbarmove3, "", 0.55, BrickColor.new("Bright red").Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove4 = gui("TextButton", fenframe3, move4, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove4.ZIndex = 2
local fenbarmove4b = gui("TextLabel", fenbarmove4, "", 0.55, BrickColor.new("Bright red").Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local modelzorz = Instance.new("Model")
modelzorz.Parent = Character
modelzorz.Name = "Ignis"
local prt1 = part(3, modelzorz, 0, 0, TorsoColor, "Part01", vt())
local prt2 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Part02", vt())
local prt3 = part(3, modelzorz, 0.5, 0, BrickColor.new("Reddish brown"), "Part03", vt())
local prt4 = part(3, modelzorz, 0.5, 0, BrickColor.new("Reddish brown"), "Part04", vt())
local prt8 = part(3, modelzorz, 0.5, 0, BrickColor.new("Reddish brown"), "Part08", vt())
local prt9 = part(3, modelzorz, 0.5, 0, BrickColor.new("Reddish brown"), "Part09", vt())
local prt10 = part(3, modelzorz, 0.5, 0, BrickColor.new("Reddish brown"), "Part10", vt())
local prt11 = part(3, modelzorz, 0.5, 0, BrickColor.new("Reddish brown"), "Part11", vt())
local prt12 = part(3, modelzorz, 0.5, 0, BrickColor.new("Reddish brown"), "Part12", vt())
local prt13 = part(3, modelzorz, 0.3, 0.5, BrickColor.new("Really red"), "Part13", vt())
local prt14 = part(3, modelzorz, 0.3, 0.5, BrickColor.new("Really red"), "Part14", vt())
local gprt1 = part(3, modelzorz, 0, 0.9, BrickColor.new("Dusty Rose"), "Gun Part01", vt())
local gprt2 = part(3, modelzorz, 0.2, 0, BrickColor.new("Dusty Rose"), "Gun Part02", vt())
local gprt3 = part(3, modelzorz, 0.2, 0, BrickColor.new("Dusty Rose"), "Gun Part03", vt())
local gprt4 = part(3, modelzorz, 0.2, 0, BrickColor.new("Dusty Rose"), "Gun Part04", vt())
local gprt5 = part(3, modelzorz, 0.2, 0, BrickColor.new("Dusty Rose"), "Gun Part05", vt())
local gprt6 = part(3, modelzorz, 0.2, 0, BrickColor.new("Dusty Rose"), "Gun Part06", vt())
local gprt7 = part(3, modelzorz, 0, 0, BrickColor.new("Really black"), "Gun Part07", vt())
local gprt8 = part(3, modelzorz, 0.2, 0, BrickColor.new("Dusty Rose"), "Gun Part08", vt())
local gprt9 = part(3, modelzorz, 0, 0, BrickColor.new("Really black"), "Gun Part09", vt())
local gprt10 = part(3, modelzorz, 0.2, 0, BrickColor.new("Dusty Rose"), "Gun Part10", vt())
local gprt11 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Gun Part11", vt())
local gprt12 = part(3, modelzorz, 0, 0, BrickColor.new("Really red"), "Gun Part12", vt())
local gprt13 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Gun Part13", vt())
local gprt14 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Gun Part14", vt())
local gprt15 = part(3, modelzorz, 0, 0, BrickColor.new("Really red"), "Gun Part15", vt())
local gprt16 = part(3, modelzorz, 0, 0.2, BrickColor.new("Really red"), "Gun Part16", vt())
msh1 = mesh("SpecialMesh", prt1, "Head", "nil", vt(0, 0, 0), vt(2.5, 6, 2.5))
msh2 = mesh("BlockMesh", prt2, "", "", vt(0, 0, 0), vt(1.5, 7, 1.5))
msh3 = mesh("BlockMesh", prt3, "", "", vt(0, 0, 0), vt(1.6, 3, 1.6))
msh4 = mesh("BlockMesh", prt4, "", "", vt(0, 0, 0), vt(1.6, 9, 1))
msh8 = mesh("BlockMesh", prt8, "", "", vt(0, 0, 0), vt(1.6, 4, 1))
msh9 = mesh("BlockMesh", prt9, "", "", vt(0, 0, 0), vt(1.6, 20, 2))
msh10 = mesh("SpecialMesh", prt10, "Wedge", "nil", vt(0, 0, 0), vt(1.6, 3, 2))
msh11 = mesh("BlockMesh", prt11, "", "", vt(0, 0, 0), vt(1.6, 17.5, 1.5))
msh12 = mesh("SpecialMesh", prt12, "Wedge", "nil", vt(0, 0, 0), vt(1.6, 2.1, 1.5))
msh13 = mesh("BlockMesh", prt13, "", "", vt(0, 0, 0), vt(1, 17.5, 5))
msh14 = mesh("SpecialMesh", prt14, "Wedge", "nil", vt(0, 0, 0), vt(1, 7, 5))
gmsh1 = mesh("BlockMesh", gprt1, "", "", vt(0, 0, 0), vt(1, 1, 1))
gmsh2 = mesh("BlockMesh", gprt2, "", "", vt(0, 0, 0), vt(2, 4, 2))
gmsh3 = mesh("SpecialMesh", gprt3, "Wedge", "nil", vt(0, 0, 0), vt(2, 2, 1))
gmsh4 = mesh("BlockMesh", gprt4, "", "", vt(0, 0, 0), vt(1.99, 6, 2))
gmsh5 = mesh("SpecialMesh", gprt5, "Wedge", "nil", vt(0, 0, 0), vt(1.99, 2, 2))
gmsh6 = mesh("BlockMesh", gprt6, "", "", vt(0, 0, 0), vt(2.1, 8.6, 2))
gmsh7 = mesh("BlockMesh", gprt7, "", "", vt(0, 0, 0), vt(2, 8.5, 1.99))
gmsh8 = mesh("CylinderMesh", gprt8, "", "", vt(0, 0, 0), vt(2, 2, 2))
gmsh9 = mesh("CylinderMesh", gprt9, "", "", vt(0, 0, 0), vt(1.5, 2.01, 1.5))
gmsh10 = mesh("SpecialMesh", gprt10, "Wedge", "nil", vt(0, 0, 0), vt(2, 2, 2))
gmsh11 = mesh("BlockMesh", gprt11, "", "", vt(0, 0, 0), vt(2.2, 2, 1))
gmsh12 = mesh("BlockMesh", gprt12, "", "", vt(0, 0, 0), vt(2.21, 1.8, 0.8))
gmsh13 = mesh("BlockMesh", gprt13, "", "", vt(0, 0, 0), vt(2.22, 0.5, 1))
gmsh14 = mesh("BlockMesh", gprt14, "", "", vt(0, 0, 0), vt(2.2, 6, 1))
gmsh15 = mesh("BlockMesh", gprt15, "", "", vt(0, 0, 0), vt(2.21, 5, 0.9))
local wld1 = weld(prt1, prt1, Torso, euler(0, 1.57, -2.1) * cf(-1.8, -1.7, -0.5))
local wld2 = weld(prt1, prt2, prt1, euler(0, 0, 0) * cf(0, 0, 0))
local wld3 = weld(prt1, prt3, prt2, euler(0, 0, 0) * cf(0, -1, 0))
local wld4 = weld(prt1, prt4, prt3, euler(0, 0, 0) * cf(0, -1.2, -0.1))
local wld8 = weld(prt1, prt8, prt4, euler(1.57, 0, 0) * cf(0, 0, -0.5))
local wld9 = weld(prt1, prt9, prt4, euler(0, 0, 0) * cf(0, -3, 0))
local wld10 = weld(prt1, prt10, prt9, euler(0, 3.14, 0) * cf(0, -2.3, 0))
local wld11 = weld(prt1, prt11, prt4, euler(0, 0, 0) * cf(0, -2.85, -0.36))
local wld12 = weld(prt1, prt12, prt11, euler(0, 3.14, 0) * cf(0, -1.95, 0))
local wld13 = weld(prt1, prt13, prt9, euler(0, 0, 0) * cf(0, 0.4, -0.3))
local wld14 = weld(prt1, prt14, prt13, euler(0, 3.14, 0) * cf(0, -2.45, 0))
local gwld1 = weld(gprt1, gprt1, LeftLeg, euler(2.3, 0, 0) * cf(0.6, -0.8, 0.3))
local gwld2 = weld(prt1, gprt2, gprt1, euler(0.7, 0, 0) * cf(0, 0, 0))
local gwld3 = weld(prt1, gprt3, gprt2, euler(1.57, 3.14, 0) * cf(0, 0.5, 0))
local gwld4 = weld(prt1, gprt4, gprt2, euler(0.87, 0, 0) * cf(0, -0.6, 0.3))
local gwld5 = weld(prt1, gprt5, gprt4, euler(0, 3.14, 0) * cf(0, -0.8, 0))
local gwld6 = weld(prt1, gprt6, gprt4, euler(0, 0, 0) * cf(0, -0.25, -0.1))
local gwld7 = weld(prt1, gprt7, gprt4, euler(0, 0, 0) * cf(0, -0.25, -0.1))
local gwld8 = weld(prt1, gprt8, gprt7, euler(0, 0, 0) * cf(0, -0.9, 0))
local gwld9 = weld(prt1, gprt9, gprt8, euler(0, 0, 0) * cf(0, 0, 0))
local gwld10 = weld(prt1, gprt10, gprt6, euler(0, 0, 3.14) * cf(0, 1.05, 0))
local gwld11 = weld(prt1, gprt11, gprt6, euler(0, 0, 0) * cf(0, 0.5, 0.1))
local gwld12 = weld(prt1, gprt12, gprt11, euler(0, 0, 0) * cf(0, 0, 0))
local gwld13 = weld(prt1, gprt13, gprt11, euler(0, 0, 0) * cf(0, 0, 0))
local gwld14 = weld(prt1, gprt14, gprt6, euler(0, 0, 0) * cf(0, -0.1, -0.11))
local gwld15 = weld(prt1, gprt15, gprt14, euler(0, 0, 0) * cf(0, 0.05, 0))
local gwld16 = weld(prt1, gprt16, gprt11, euler(-1.57, 0, 0) * cf(0, 0, 0))
num = 0
num2 = 0
for i = 1, 10 do
  local prt5 = part(3, modelzorz, 0.5, 0, BrickColor.new("Reddish brown"), "Part05", vt())
  local msh5 = mesh("BlockMesh", prt5, "", "", vt(0, 0, 0), vt(1.61, 2, 1.61))
  local wld5 = weld(prt1, prt5, prt4, cf(0, 0, 1.05) * euler(1.57 + num, 0, 0))
  if 3 <= i and i <= 9 then
    local prt6 = part(3, modelzorz, 0.5, 0, BrickColor.new("Reddish brown"), "Part06", vt())
    local msh6 = mesh("BlockMesh", prt6, "", "", vt(0, 0, 0), vt(1.6, 1.5, 2))
    local wld6 = weld(prt1, prt6, prt5, cf(0, 0.1, 0.3))
    local prt7 = part(3, modelzorz, 0.5, 0, BrickColor.new("Reddish brown"), "Part07", vt())
    local msh7 = mesh("SpecialMesh", prt7, "FileMesh", "9756362", vt(0, 0, 0), vt(0.3, 0.3, 0.6))
    local wld7 = weld(prt1, prt7, prt6, euler(0, 0, 0.785) * cf(0, 0, 0.2))
  end
  do
    do
      num = num + 0.348
      -- DECOMPILER ERROR at PC2592: LeaveBlock: unexpected jumping out DO_STMT

    end
  end
end
num = 0
for i = 1, 4 do
  local gprt11 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Gun Part11", vt())
  local gmsh11 = mesh("CylinderMesh", gprt11, "", "", vt(0, 0, 0), vt(0.6, 2.2, 0.6))
  local gwld11 = weld(prt1, gprt11, gprt6, euler(0, 0, 1.57) * cf(0, -0.5 - num, 0.1))
  num = num - 0.2
end
for _,c in pairs(modelzorz:children()) do
  table.insert(Weapon, c)
end
for _,c in pairs(prt1:children()) do
  if c.className == "Motor" then
    table.insert(Welds, c)
  end
end
local hitbox = part(3, modelzorz, 0, 1, BrickColor.new("Black"), "Hitbox2", vt())
hitbox.Anchored = false
local hbwld = weld(hitbox, hitbox, RootPart, euler(0, 0, 0) * cf(0, 0, 0))
local hitbox2 = part(3, nil, 0, 1, BrickColor.new("Black"), "Hitbox", vt(1, 1, 1))
hitbox2.Anchored = true
local hitboxCF = cf(0, 0, 0)
hboxpos = Instance.new("BodyPosition", nil)
hboxpos.P = 2000
hboxpos.D = 100
hboxpos.maxForce = Vector3.new(545000, 545000, 545000)
local nr = NumberRange.new
local ns = NumberSequence.new
local cs = ColorSequence.new
nsk = NumberSequenceKeypoint.new
local parti = it("ParticleEmitter")
parti.Color = cs(Color3.new(0.88627450980392, 0.47450980392157, 0), Color3.new(0.49411764705882, 0, 0))
parti.LightEmission = 0.5
parti.Size = ns(0.2)
parti.Texture = "http://www.roblox.com/asset/?id=248625108"
sizeseq = ns({nsk(0, 1.62), nsk(0.123, 1.5), nsk(0.154, 1.44), nsk(0.357, 1.31), nsk(0.555, 1.25), nsk(0.725, 0.875), nsk(1, 0.125)})
transseq = ns({nsk(0, 0), nsk(0.133, 0.544), nsk(0.321, 0.737), nsk(0.388, 0), nsk(0.469, 0.725), nsk(0.522, 0.456), nsk(0.616, 0.637), nsk(0.64, 0), nsk(0.745, 0.525), nsk(1, 0)})
parti.Transparency = transseq
parti.Size = sizeseq
parti.ZOffset = 0
parti.Acceleration = vt(0, 10, 0)
parti.LockedToPart = false
parti.EmissionDirection = "Front"
parti.Lifetime = nr(0, 1)
parti.Rate = 200
parti.Rotation = nr(4, 9)
parti.RotSpeed = nr(5, 9)
parti.Speed = nr(2, 4)
parti.VelocitySpread = 28
parti.Parent = nil
parti.Parent = hitbox
parti.Enabled = false
hitboxweld = function()
  hbwld.Parent = modelzorz
  hbwld.Part0 = hitbox
  hbwld.Part1 = prt9
end
if script.Parent.className ~= "HopperBin" then
  Tool = Instance.new("HopperBin")
  Tool.Parent = Backpack
  Tool.Name = "Ignis"
  script.Parent = Tool
end
Bin = script.Parent
if Bin.Name == "Vulca: Wave Burster" then
  Bin.Name = "Ignis"
end
local bodvel = Instance.new("BodyVelocity")
local bg = Instance.new("BodyGyro")
so = function(id, par, vol, pit)
  local sou = Instance.new("Sound", par or workspace)
  sou.Volume = vol
  sou.Pitch = pit or 1
  sou.SoundId = "http://www.roblox.com/asset/?id=" .. id
  coroutine.resume(coroutine.create(function(Sound)
    swait()
    Sound:play()
  end), sou)
  game:GetService("Debris"):AddItem(sou, 6)
end
function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end
hideanim = function()
  equipped = false
  for i = 0, 1, 0.5 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(0, -1.57, -1) * euler(0.4, 0, 0) * cf(0, 1, 0), 0.4)
    gwld1.C0 = clerp(gwld1.C0, euler(2, 0, 0) * cf(0, 1, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.4), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(2, 0, 0.2), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.2, 0, 0.2), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
  end
  for i = 0, 1, 0.2 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(0, -1.57, -1) * euler(0.4, 0, 0) * cf(0, 1, 0), 0.4)
    gwld1.C0 = clerp(gwld1.C0, euler(2, 0, 0) * cf(0, 1, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.4), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(3.4, 0, 0.2), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.2, 0, 0.2), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, RHC0, 0.4)
    LH.C0 = clerp(LH.C0, LHC0, 0.4)
  end
  mdec2.Parent = nil
  wld1.Part1 = Torso
  wld1.C0 = euler(0, 1.57, -2.1) * cf(-1.8, -1.7, -0.5)
  gwld1.Part1 = LeftLeg
  gwld1.C0 = euler(2.3, 0, 0) * cf(0.6, -0.8, 0.3)
  for i = 0, 1, 0.3 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
  end
  mdec.Parent = Decrease
end
mdec.Parent = Decrease
equipanim = function()
  equipped = true
  mdec.Parent = nil
  for i = 0, 1, 0.5 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.4), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(2, 0, 0.2), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.2, 0, 0.2), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
  end
  for i = 0, 1, 0.2 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.4), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(3.4, 0, 0.2), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.2, 0, 0.2), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
  end
  mdec2.Parent = Decrease
  wld1.Part1 = RightArm
  wld1.C0 = euler(0, -1.57, -1) * euler(0.4, 0, 0) * cf(0, 1, 0)
  gwld1.Part1 = LeftArm
  gwld1.C0 = euler(2, 0, 0) * cf(0, 1, 0)
end
StaggerAnim = function()
  attack = true
  removeControl()
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.35 do
    swait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -40
    end
    wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 3.14) * cf(0, 1, 0.2), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, -0.4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.7) * euler(0, -0.7, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  for i = 0, 1, 0.2 do
    swait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -40
    end
    wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 3.14) * cf(0, 1, 0.2), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(-0.5, 0, -0.4), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.7) * euler(0, -0.7, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.5), 0.4)
  end
  for i = 0, 1, 0.1 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 3.14) * cf(0, 1, 0.2), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(0.5, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.8) * euler(-0.2, 0, -0.4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.3, 0, 0.4) * euler(0, -0.4, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.3, 0, -0.2) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 1.2), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, 0, -1) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  for i = 1, 50 do
    swait()
    if StunT.Value <= Stun.Value then
      break
    end
  end
  do
    resumeControl()
    combo = 0
    attack = false
  end
end
StaggerHitt = function()
  attack = true
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.1 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 3.14) * cf(0, 1, 0.2), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.7) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, -0.6), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.9) * euler(0, -0.7, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, -0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  attack = false
end
StunAnim = function()
  attack = true
  removeControl()
  Stunned.Value = true
  showDamage(Character, "Stunned", "Interrupt")
  local dec = Instance.new("NumberValue", Decrease)
  dec.Name = "DecreaseMvmt"
  dec.Value = 10
  for i = 0, 1, 0.3 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 3.14) * cf(0, 1, 0.2), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.2, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1, 0, 0.4) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.3), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, 0), 0.25)
  end
  for i = 0, 1, 0.3 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 3.14) * cf(0, 1, 0.2), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0.8, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1.2, 0, 0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(0.1, 0, 0.7), 0.25)
  end
  for i = 0, 1, 0.3 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 3.14) * cf(0, 1, 0.2), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -1), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1.57, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, -0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.1, 0, 0.3), 0.25)
  end
  local gairost = Instance.new("BodyGyro")
  gairost.Parent = RootPart
  gairost.maxTorque = Vector3.new(400000, 0, 400000) * math.huge
  gairost.P = 20000
  gairost.cframe = cf(0, 0, 0)
  for i = 0, 1, 0.1 do
    swait()
    if hitfloor ~= nil then
      Torso.Velocity = vt(0, 0, 0)
    end
    wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 3.14) * cf(0, 1, 0.2), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2.5) * euler(1.57, 0, -3.14), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1.5) * euler(0.2, 0, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.5, 0, -1.57) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 0), 0.3)
  end
  for i = 1, 70 do
    swait()
    gairost.cframe = RootPart.CFrame
    if hitfloor ~= nil then
      Torso.Velocity = vt(0, 0, 0)
    end
  end
  for i = 0, 1, 0.2 do
    swait()
    Stun.Value = 0
    gairost.cframe = RootPart.CFrame
    wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 3.14) * cf(0, 1, 0.2), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1, 0, -4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1) * euler(0.2, -1, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, 0.2) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, -1) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 1), 0.3)
  end
  resumeControl()
  gairost.Parent = nil
  dec.Parent = nil
  Stun.Value = 0
  combo = 0
  Stunned.Value = false
  attack = false
  for i = 1, 10 do
    swait()
    Stun.Value = 0
  end
end
attackone = function()
  attack = true
  for i = 0, 1, 0.2 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(2.9, 0, 3.14) * cf(0, 1, 0.2), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0.5), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.5), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(2, 0, 1), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.3, 0.5, -0.3) * euler(0.4, 0, 0.2) * euler(0, -0.2, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.5, 0), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC195: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC195: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("199150686", prt9, 1, 1)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(0.5, 7, 1)
  hitboxCF = prt9.CFrame * cf(0, -1, 0.4)
  hitbox.CFrame = hitboxCF
  blcf = nil
  scfr = nil
  for i = 0, 1, 0.3 do
    swait()
    hitboxCF = prt9.CFrame * cf(0, -1, 0.4)
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 6, 5, 10, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(3, 8)), nil, true)
    wld1.C0 = clerp(wld1.C0, euler(1.2, 0, 3.14) * cf(0, 1, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.5) * euler(0.2, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.5), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.2, 0.5, -0.3) * euler(0.2, 0, -0.2) * euler(0, -0.5, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.2), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.5, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, -0.5, 0), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC466: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC466: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  if Stagger.Value ~= true and StunT.Value > Stun.Value and (StaggerHit.Value ~= true or redimbue == true) then
    so("199144160", prt9, 1, math.random(80, 130) / 100)
    CF = RootPart.CFrame
    ref = part(3, workspace, 0, 1, BrickColor.new("Really red"), "FireWave", vt(10, 1, 5))
    ref.Anchored = true
    ref.CFrame = CF * cf(0, 0, -2) * euler(0, 0, 0.6)
    local parti2 = parti:Clone()
    parti2.Rate = 20
    parti2.Parent = ref
    parti2.Enabled = true
    game:GetService("Debris"):AddItem(ref, 5)
    rmsh = mesh("BlockMesh", ref, "", "", vt(0, 0, 0), vt(1, 1, 1))
    d = Instance.new("Decal")
    d.Parent = ref
    d.Texture = "http://www.roblox.com/asset/?id=182703461"
    d.Face = "Top"
    d2 = Instance.new("Decal")
    d2.Parent = ref
    d2.Texture = "http://www.roblox.com/asset/?id=182703461"
    d2.Face = "Bottom"
    table.insert(Effects, {ref, "Wave", 2, 1.3, 30, d, d2, parti2})
  end
  do
    for i = 0, 1, 0.2 do
      swait()
      hitboxCF = prt9.CFrame * cf(0, -1, 0.4)
      hitbox.CFrame = hitboxCF
      MagniDamage(hitbox, 6, 4, 6, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(3, 8)), nil, true)
      wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 3.14) * euler(0, 0, 0.3) * cf(0, 1, 0), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.5) * euler(0.2, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.5), 0.4)
      RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(0.6, 0, -1) * euler(0, -0.7, 0), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.2), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.5, 0), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, -0.5, 0), 0.4)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC842: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC842: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    hitbox.Parent = modelzorz
    hitbox.Size = vt()
    hitboxweld()
    hboxpos.Parent = nil
    attack = false
  end
end
attacktwo = function()
  attack = true
  for i = 0, 1, 0.2 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 3.14) * cf(0, 1, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.7) * euler(0.2, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.7), 0.4)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -1) * euler(0, 1.2, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.8, 0, -0.4), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.2) * euler(0, 1.57, 0) * euler(0, -0.7, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.8, -1, 0.2) * euler(0, -1.57, 0) * euler(0, -0.7, 0), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC201: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC201: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("199146359", prt9, 1, 1)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(0.5, 7, 1)
  hitboxCF = prt9.CFrame * cf(0, -1, 0.4)
  hitbox.CFrame = hitboxCF
  blcf = nil
  scfr = nil
  for i = 0, 1, 0.3 do
    swait()
    hitboxCF = prt9.CFrame * cf(0, -1, 0.4)
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 6, 5, 10, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(3, 8)), nil, true)
    wld1.C0 = clerp(wld1.C0, euler(0.5, 0, 3.14) * cf(0, 1, 0.2), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.5), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.3, 0, 1) * euler(0, 1.6, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.2), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.5, 0), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC472: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC472: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  if Stagger.Value ~= true and StunT.Value > Stun.Value and (StaggerHit.Value ~= true or redimbue == true) then
    so("199144160", prt9, 1, math.random(80, 130) / 100)
    CF = RootPart.CFrame
    ref = part(3, workspace, 0, 1, BrickColor.new("Really red"), "FireWave", vt(10, 1, 5))
    ref.Anchored = true
    ref.CFrame = CF * cf(0, 0, -2) * euler(0, 0, -0.2)
    local parti2 = parti:Clone()
    parti2.Rate = 20
    parti2.Parent = ref
    parti2.Enabled = true
    game:GetService("Debris"):AddItem(ref, 5)
    rmsh = mesh("BlockMesh", ref, "", "", vt(0, 0, 0), vt(1, 1, 1))
    d = Instance.new("Decal")
    d.Parent = ref
    d.Texture = "http://www.roblox.com/asset/?id=182703461"
    d.Face = "Top"
    d2 = Instance.new("Decal")
    d2.Parent = ref
    d2.Texture = "http://www.roblox.com/asset/?id=182703461"
    d2.Face = "Bottom"
    table.insert(Effects, {ref, "Wave", 2, 1.3, 30, d, d2, parti2})
  end
  do
    for i = 0, 1, 0.2 do
      swait()
      hitboxCF = prt9.CFrame * cf(0, -1, 0.4)
      hitbox.CFrame = hitboxCF
      MagniDamage(hitbox, 6, 4, 6, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(3, 8)), nil, true)
      wld1.C0 = clerp(wld1.C0, euler(0.3, 0, 3.14) * cf(0, 1, 0.2), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.5), 0.4)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 0.8) * euler(0, 1.3, 0), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.2), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, 0), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.5, 0), 0.4)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC842: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC842: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    hitbox.Parent = modelzorz
    hitbox.Size = vt()
    hitboxweld()
    hboxpos.Parent = nil
    attack = false
  end
end
attackthree = function()
  attack = true
  for i = 0, 1, 0.15 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(2.9, 0, 3.14) * cf(0, 1, 0.2), 0.4)
    gwld1.C0 = clerp(gwld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.57), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1.57), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.3, 0, 0.5), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, -1.57), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.5, -1, -0.2) * euler(0, 1.57, 0) * euler(-0.4, 1.57, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.5, -1, 0.2) * euler(0, -1.57, 0) * euler(0.2, 1.57, 0), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC213: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC213: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  for i = 1, 2 do
    so("199144089", gprt8, 1, 1)
    LW.C0 = cf(-1.5, 0.5, 0) * euler(1.57, 0, -1.57)
    Shootcombo()
    for i = 0, 1, 0.3 do
      swait()
      gwld6.C0 = clerp(gwld6.C0, euler(0, 0, 0) * cf(0, 0.5, -0.1), 0.6)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, -1.57) * euler(0.5, 0, 0), 0.5)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC320: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC320: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    for i = 0, 1, 0.2 do
      swait()
      gwld6.C0 = clerp(gwld6.C0, euler(0, 0, 0) * cf(0, -0.25, -0.1), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, -1.57), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC396: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC396: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC412: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC412: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  attack = false
end
attackfour = function()
  attack = true
  for i = 0, 1, 0.2 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 3.14) * cf(0, 1, 0.2), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.2), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.3), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 1.2) * euler(0, -2, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.4, 0.5, -0.2) * euler(0.7, 0, 0.1) * euler(0, -0.4, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.3, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.3, 0), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC201: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC201: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("199146359", prt9, 1, 0.8)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(0.5, 7, 1)
  hitboxCF = prt9.CFrame * cf(0, -1, 0.4)
  hitbox.CFrame = hitboxCF
  blcf = nil
  scfr = nil
  for i = 0, 1, 0.1 do
    swait()
    if i == 0.2 and Stagger.Value ~= true and StunT.Value > Stun.Value and (StaggerHit.Value ~= true or redimbue == true) then
      so("199144160", prt9, 1, math.random(80, 130) / 100)
      CF = RootPart.CFrame
      ref = part(3, workspace, 0, 1, BrickColor.new("Really red"), "FireWave", vt(10, 1, 5))
      ref.Anchored = true
      ref.CFrame = CF * cf(0, 0, -2) * euler(0, 0, 0.2)
      local parti2 = parti:Clone()
      parti2.Rate = 20
      parti2.Parent = ref
      parti2.Enabled = true
      game:GetService("Debris"):AddItem(ref, 5)
      rmsh = mesh("BlockMesh", ref, "", "", vt(0, 0, 0), vt(1, 1, 1))
      d = Instance.new("Decal")
      d.Parent = ref
      d.Texture = "http://www.roblox.com/asset/?id=182703461"
      d.Face = "Top"
      d2 = Instance.new("Decal")
      d2.Parent = ref
      d2.Texture = "http://www.roblox.com/asset/?id=182703461"
      d2.Face = "Bottom"
      table.insert(Effects, {ref, "Wave", 2, 1.3, 30, d, d2, parti2})
    end
    do
      if Rooted.Value == false then
        Torso.Velocity = RootPart.CFrame.lookVector * 40
      end
      hitboxCF = prt9.CFrame * cf(0, -1, 0.4)
      hitbox.CFrame = hitboxCF
      MagniDamage(hitbox, 6, 10, 15, math.random(5, 10), "Normal", RootPart, 0.5, 2, (math.random(5, 10)), nil, true)
      wld1.C0 = clerp(wld1.C0, euler(0.5, 0, 3.14) * cf(0, 1, 0.2), 0.35)
      Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, -0.6), 0.35)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.6), 0.35)
      RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.2, 0, -1.2) * euler(0, -1.2, 0), 0.35)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.35)
      LW.C0 = clerp(LW.C0, cf(-1.4, 0.5, -0.2) * euler(-0.4, 0, -0.7) * euler(0, 0, 0), 0.35)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.35)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.6, 0), 0.35)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, -0.6, 0), 0.35)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC620: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC620: LeaveBlock: unexpected jumping out IF_STMT

          -- DECOMPILER ERROR at PC620: LeaveBlock: unexpected jumping out DO_STMT

        end
      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
Punishment = function()
  attack = true
  local ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Effect", vt())
  ref.Anchored = true
  ref.CFrame = RootPart.CFrame * cf(0, 0, -2)
  game:GetService("Debris"):AddItem(ref, 1)
  for _,c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("HumanoidRootPart")
      if head ~= nil and GetDist(head, ref, 3) == true and head.Parent:findFirstChild("Stats") ~= nil and head.Parent.Stats.Stunned.Value == true then
        Mvmt.Value = Mvmt.Value - 1
        for i = 0, 1, 0.3 do
          swait()
          wld1.C0 = clerp(wld1.C0, euler(-2, 0, 3.14) * cf(0, 1, 0.2), 0.4)
          gwld1.C0 = clerp(gwld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.4)
          Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57) * euler(0.2, 0, 0), 0.4)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1.57), 0.4)
          RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.57) * euler(2, 0, 0), 0.4)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
          LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4), 0.4)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
          RH.C0 = clerp(RH.C0, cf(0.5, -1, 0.2) * euler(0, 1.57, 0) * euler(0, -1.57, 0), 0.4)
          LH.C0 = clerp(LH.C0, cf(-0.5, -1, -0.2) * euler(0, -1.57, 0) * euler(0, -1.57, 0), 0.4)
        end
        for i = 0, 1, 0.18 do
          swait()
          wld1.C0 = clerp(wld1.C0, euler(-1.57, 0, 3.14) * cf(0, 1, 0.2), 0.4)
          gwld1.C0 = clerp(gwld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.4)
          Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57) * euler(0.2, 0, 0), 0.4)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1.57), 0.4)
          RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.57), 0.4)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
          LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4), 0.4)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
          RH.C0 = clerp(RH.C0, cf(0.5, -1, 0.2) * euler(0, 1.57, 0) * euler(0, -1.57, 0), 0.4)
          LH.C0 = clerp(LH.C0, cf(-0.5, -1, -0.2) * euler(0, -1.57, 0) * euler(0, -1.57, 0), 0.4)
        end
        DecreaseStat(head.Parent, "Defense", 0.3, 300)
        Damagefunc(head, 10, 20, math.random(5, 10), "Normal", RootPart, 0.2, 2, 0, nil, nil, false)
        for i = 0, 1, 0.05 do
          swait()
          MagicBlock(BrickColor.new("Really red"), cf(head.Parent.Torso.Position), 1, 1, 1, 2, 2, 2, 0.1, 1)
          wld1.C0 = clerp(wld1.C0, euler(-1.17, 0, 3.14) * cf(0, 1, 0.2), 0.2)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1.57), 0.2)
          RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.57) * euler(-0.4, 0, 0), 0.2)
          LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4), 0.4)
          RH.C0 = clerp(RH.C0, cf(0.5, -1, 0.2) * euler(0, 1.57, 0) * euler(0, -1.57, 0), 0.4)
          LH.C0 = clerp(LH.C0, cf(-0.5, -1, -0.2) * euler(0, -1.57, 0) * euler(0, -1.57, 0), 0.4)
        end
        Neck.C0 = necko * euler(0, 0, -1.57) * euler(0.2, 0, 0)
        swait(10)
        Mvmt.Value = Mvmt.Value + 1
      end
    end
  end
  attack = false
end
GunStance = function()
  attack = true
  gun = true
  perfaim = false
  local dec = Instance.new("NumberValue", Decrease)
  dec.Name = "DecreaseMvmt"
  dec.Value = 0.4
  for i = 0, 1, 0.1 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(2.9, 0, 3.14) * cf(0, 1, 0.2), 0.2)
    gwld6.C0 = clerp(gwld6.C0, euler(0, 0, 0) * cf(0, -0.25, -0.1), 0.4)
    gwld1.C0 = euler(1.57 - 8 * i, 0, 0) * cf(0, 1, 0)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.57) * euler(-0.4, 0, 0), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1.57), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.3, 0, 1), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, -1.57) * euler(1, 0, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(0.5, -1, -0.2) * euler(0, 1.57, 0) * euler(-0.4, 1.57, 0), 0.2)
    LH.C0 = clerp(LH.C0, cf(-0.5, -1, 0.2) * euler(0, -1.57, 0) * euler(0.2, 1.57, 0), 0.2)
  end
  RootJoint.C0 = RootCF * cf(0, 0, -0.2) * euler(0, 0, -1.57)
  LW.C0 = cf(-1.5, 0.5, 0) * euler(1.57, 0, -1.57)
  gairo = Instance.new("BodyGyro")
  gairo.Parent = RootPart
  gairo.maxTorque = Vector3.new(400000, 400000, 400000) * math.huge
  gairo.P = 20000
  gairo.cframe = RootPart.CFrame
  local offset = nil
  while gun == true do
    swait()
    perfaim = true
    local gunpos = vt(MMouse.Hit.p.x, Head.Position.Y, MMouse.Hit.p.z)
    offset = (gprt8.Position.y - MMouse.Hit.p.y) / 60
    mag = (gprt8.Position - MMouse.Hit.p).magnitude / 66
    offset = offset / mag
    gairo.cframe = cf(Head.Position, gunpos)
    gwld1.C0 = clerp(gwld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.57), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(offset, 0, 0), 0.2)
  end
  do
    dec.Parent = nil
    if shoot == true then
      so("199144089", gprt8, 1, 1)
      for i = 0, 1, 0.1 do
        swait()
        gwld6.C0 = clerp(gwld6.C0, euler(0, 0, 0) * cf(0, 0.5, -0.1), 0.6)
        gwld1.C0 = clerp(gwld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.57) * euler(0, 0, 0), 0.2)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, -1.57) * euler(1, 0, 0), 0.2)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
      end
    end
    do
      gairo.Parent = nil
      shoot = false
      attack = false
    end
  end
end
do1 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[1] and mana.Value >= 20 then
    attack = true
    mana.Value = mana.Value - 20
    cooldowns[1] = 0
    for i = 0, 1, 0.2 do
      swait()
      wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 3.14) * cf(0, 1, 0), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.7) * euler(0.2, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.7), 0.4)
      RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -1) * euler(0, 1.2, 0), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.8, 0, -0.4), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.2) * euler(0, 1.57, 0) * euler(0, -0.7, 0), 0.4)
      LH.C0 = clerp(LH.C0, cf(-0.8, -1, 0.2) * euler(0, -1.57, 0) * euler(0, -0.7, 0), 0.4)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC236: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC236: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    so("199144160", prt9, 1, math.random(80, 130) / 100)
    for i = 0, 1, 0.4 do
      swait()
      wld1.C0 = clerp(wld1.C0, euler(0.5, 0, 3.14) * cf(0, 1, 0.2), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.5), 0.4)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.3, 0, 1) * euler(0, 1.6, 0), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.2), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, 0), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.5, 0), 0.4)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC447: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC447: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      if StaggerHit.Value ~= true then
        DecreaseStat(Character, "Damage", -0.25, 300)
        DecreaseStat(Character, "Defense", 0.2, 300)
            for i = -0.785, 0.785, 0.785 do
              CF = RootPart.CFrame
              ref = part(3, workspace, 0, 1, BrickColor.new("Really red"), "FireWave", vt(10, 1, 5))
              ref.Anchored = true
              ref.CFrame = CF * cf(0, 0, -2) * euler(0, i, 0) * euler(0, 0, -0.2)
              local parti2 = parti:Clone()
              parti2.Rate = 20
              parti2.Parent = ref
              parti2.Enabled = true
              game:GetService("Debris"):AddItem(ref, 5)
              rmsh = mesh("BlockMesh", ref, "", "", vt(0, 0, 0), vt(1, 1, 1))
              d = Instance.new("Decal")
              d.Parent = ref
              d.Texture = "http://www.roblox.com/asset/?id=182703461"
              d.Face = "Top"
              d2 = Instance.new("Decal")
              d2.Parent = ref
              d2.Texture = "http://www.roblox.com/asset/?id=182703461"
              d2.Face = "Bottom"
              table.insert(Effects, {ref, "Wave", 2, 1.3, 100, d, d2, parti2})
            end
              for i = 0, 1, 0.3 do
                swait()
                wld1.C0 = clerp(wld1.C0, euler(0.3, 0, 3.14) * cf(0, 1, 0.2), 0.4)
                Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.4)
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.5), 0.4)
                RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 1) * euler(0, 1.3, 0), 0.4)
                RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
                LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.2), 0.4)
                LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
                RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, 0), 0.4)
                LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.5, 0), 0.4)
                if Stagger.Value ~= true and StunT.Value > Stun.Value then
                  do
                    if StaggerHit.Value == true then
                      break
                    end
                    -- DECOMPILER ERROR at PC903: LeaveBlock: unexpected jumping out IF_THEN_STMT

                    -- DECOMPILER ERROR at PC903: LeaveBlock: unexpected jumping out IF_STMT

                  end
                end
              end
              attack = false
            end
          end
        end
end
do2 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[2] and mana.Value >= 30 then
    attack = true
    cooldowns[2] = 0
    mana.Value = mana.Value - 30
    Humanoid.Jump = true
    so("199144226", prt9, 1, 1)
    blcf = nil
    scfr = nil
    for i = 0, 1, 0.1 do
      swait()
      RootJoint.C0 = RootCF * cf(0, 0, 1 * i) * euler(6.28 * i, 0, 0)
      wld1.C0 = clerp(wld1.C0, euler(-1.8, 0, 3.14) * cf(0, 1, 0.2), 0.2)
      gwld1.C0 = clerp(gwld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
      Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.2)
      RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.8) * euler(1.57, 0, -1) * euler(1, 0, 0), 0.2)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4), 0.2)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
      RH.C0 = clerp(RH.C0, cf(1, -1, -0.3) * euler(-0.5, 1.57, 0) * euler(-0.2, 0, 0), 0.2)
      LH.C0 = clerp(LH.C0, cf(-1, -1, -0.3) * euler(-0.5, -1.57, 0) * euler(-0.2, 0, 0), 0.2)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC261: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC261: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    for i = 0, 1, 0.15 do
      swait()
      wld1.C0 = clerp(wld1.C0, euler(-1.57, 0, 3.14) * cf(0, 1, 0.2), 0.4)
      gwld1.C0 = clerp(gwld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, -0.5), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.5), 0.4)
      RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.8) * euler(1.57, 0, 0.7) * euler(0, 0, 0), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.5, 0), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, -0.5, 0), 0.4)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC473: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC473: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    while 1 do
	swait()
      if hitfloor == nil then
        swait()
  else
	 break
      end
      if Stagger.Value ~= true and StunT.Value > Stun.Value and StaggerHit.Value == true then
        break
      end
    end
    so("199144529", prt9, 1, 1)
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = 1
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      if StaggerHit.Value ~= true then
        DecreaseStat(Character, "Damage", -0.35, 400)
        DecreaseStat(Character, "Defense", 0.2, 400)
        if redimbue == true then
          so("199144160", prt9, 1, math.random(80, 130) / 100)
          for i = 0.785, 6.28, 0.785 do
            CF = RootPart.CFrame
            ref = part(3, workspace, 0, 1, BrickColor.new("Really red"), "FireWave", vt(10, 1, 5))
            ref.Anchored = true
            ref.CFrame = CF * cf(0, 0, 0) * euler(0, i, 0)
            local parti2 = parti:Clone()
            parti2.Rate = 20
            parti2.Parent = ref
            parti2.Enabled = true
            game:GetService("Debris"):AddItem(ref, 5)
            rmsh = mesh("BlockMesh", ref, "", "", vt(0, 0, 0), vt(1, 1, 1))
            d = Instance.new("Decal")
            d.Parent = ref
            d.Texture = "http://www.roblox.com/asset/?id=182703461"
            d.Face = "Top"
            d2 = Instance.new("Decal")
            d2.Parent = ref
            d2.Texture = "http://www.roblox.com/asset/?id=182703461"
            d2.Face = "Bottom"
            table.insert(Effects, {ref, "Wave", 2.5, 1.3, 40, d, d2, parti2})
          end
        end
        do
          MagniDamage(RootPart, 30, 7, 12, math.random(-50, -30), "Knockdown2", RootPart, 0, 1, (math.random(5, 15)), nil, nil, false)
          MagicCircle(BrickColor.new("Bright red"), cf(prt9.Position) * cf(0, 2, 0), 1, 2, 1, 10, 1, 10, 0.03)
          for i = 1, 10 do
            swait()
            for i = 1, 2 do
              MagicCircle(BrickColor.new("Bright red"), cf(prt9.Position) * cf(0, 2, 0) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 0.5, 12, 0.5, 0.05)
            end
            if Stagger.Value ~= true and StunT.Value > Stun.Value then
              do
                if StaggerHit.Value == true then
                  break
                end
                -- DECOMPILER ERROR at PC773: LeaveBlock: unexpected jumping out IF_THEN_STMT

                -- DECOMPILER ERROR at PC773: LeaveBlock: unexpected jumping out IF_STMT

              end
            end
          end
          for i = 1, 10 do
            swait()
            if Stagger.Value ~= true and StunT.Value > Stun.Value then
              do
                if StaggerHit.Value == true then
                  break
                end
                -- DECOMPILER ERROR at PC795: LeaveBlock: unexpected jumping out IF_THEN_STMT

                -- DECOMPILER ERROR at PC795: LeaveBlock: unexpected jumping out IF_STMT

              end
            end
          end
          dec.Parent = nil
          attack = false
        end
      end
    end
  end
end
do3 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[3] and mana.Value >= 15 then
    attack = true
    mana.Value = mana.Value - 15
    cooldowns[3] = 0
    redimbue = true
    so("199144561", prt9, 1, 1)
    MagicCircle(BrickColor.new("Bright red"), prt9.CFrame, 0.1, 8, 0.2, 0.5, 2, 1, 0.05)
    MagicCircle(BrickColor.new("Bright red"), gprt6.CFrame, 2, 2, 2, 1, 1, 1, 0.05)
    DecreaseStat(Character, "Damage", -0.2, 500)
    DecreaseStat(Character, "Movement", -0.05, 500)
    DecreaseStat(Character, "Defense", 0.15, 600)
    attack = false
  end
end
do4 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[4] and mana.Value >= 50 then
    attack = true
    parti.Enabled = true
    mana.Value = mana.Value - 50
    cooldowns[4] = 0
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = -0.4
    DecreaseStat(Character, "Damage", -0.3, 300)
    DecreaseStat(Character, "Defense", 0.25, 300)
    so("199144608", prt9, 1, 1)
    for i = 1, 4 do
      for i = 0, 1, 0.2 do
        swait()
        wld1.C0 = clerp(wld1.C0, euler(2.9, 0, 3.14) * cf(0, 1, 0.2), 0.4)
        Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0.5), 0.4)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.5) * euler(0.1, 0, 0), 0.4)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(2, 0, 1), 0.4)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
        LW.C0 = clerp(LW.C0, cf(-1.3, 0.5, -0.3) * euler(0.4, 0, 0.2) * euler(0, -0.2, 0), 0.4)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
        RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, -0.4), 0.4)
        LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.5, 0.2), 0.4)
        Stagger.Value = false
        StaggerHit.Value = false
        if StunT.Value <= Stun.Value then
          break
        end
      end
      do
        so("199144647", prt9, 1, 1)
        hbwld.Parent = nil
        hboxpos.Parent = hitbox
        hitbox.Parent = modelzorz
        hitbox.Size = vt(1, 7.5, 1.5)
        hitboxCF = prt9.CFrame * cf(0, -1, 0.4)
        hitbox.CFrame = hitboxCF
        blcf = nil
        scfr = nil
        for i = 0, 1, 0.15 do
          swait()
          hitboxCF = prt9.CFrame * cf(0, -1, 0.4)
          hitbox.CFrame = hitboxCF
		  if attackdebounce == false then
          MagniDamage(hitbox, 6, 5, 8, 0, "Fire", RootPart, 0.2, 1, (math.random(5, 10)), nil, true, false, "FireWave")
		  end
          wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 3.14) * euler(0, 0, 0.3) * cf(0, 1, 0), 0.4)
          Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.5) * euler(0.2, 0, 0), 0.4)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.4)
          RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(0.6, 0, -1) * euler(0, -0.7, 0), 0.4)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
          LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.2), 0.4)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
          RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.5, -0.2), 0.4)
          LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, -0.5, 0.4), 0.4)
          Stagger.Value = false
          StaggerHit.Value = false
          if StunT.Value <= Stun.Value then
            break
          end
        end
        do
          for i = 0, 1, 0.2 do
            swait()
            hitboxCF = prt9.CFrame * cf(0, -1, 0.4)
            hitbox.CFrame = hitboxCF
            wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 3.14) * cf(0, 1, 0), 0.4)
            Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.7) * euler(0.2, 0, 0), 0.4)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.7) * euler(0.1, 0, 0), 0.4)
            RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -1) * euler(0, 1.2, 0), 0.4)
            RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.8, 0, -0.4), 0.4)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
            RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.2) * euler(0, 1.57, 0) * euler(0, -0.7, -0.2), 0.4)
            LH.C0 = clerp(LH.C0, cf(-0.8, -1, 0.2) * euler(0, -1.57, 0) * euler(0, -0.7, 0.4), 0.4)
            Stagger.Value = false
            StaggerHit.Value = false
            if StunT.Value <= Stun.Value then
              break
            end
          end
          do
            blcf = nil
            scfr = nil
            so("199144678", prt9, 1, 1)
            for i = 0, 1, 0.2 do
              swait()
              hitboxCF = prt9.CFrame * cf(0, -1, 0.4)
              hitbox.CFrame = hitboxCF
              MagniDamage(hitbox, 6, 5, 8, 0, "Fire", RootPart, 0.2, 1, (math.random(5, 10)), nil, true, false, "FireWave")
              wld1.C0 = clerp(wld1.C0, euler(0.3, 0, 3.14) * cf(0, 1, 0.2), 0.4)
              Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.4)
              RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.5) * euler(0.1, 0, 0), 0.4)
              RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 0.8) * euler(0, 1.3, 0), 0.4)
              RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
              LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.2), 0.4)
              LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
              RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, -0.4), 0.4)
              LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.5, 0.2), 0.4)
              Stagger.Value = false
              StaggerHit.Value = false
              if StunT.Value <= Stun.Value then
                break
              end
            end
            do
              do
                hitbox.Parent = modelzorz
                hitbox.Size = vt()
                hitboxweld()
                hboxpos.Parent = nil
                -- DECOMPILER ERROR at PC1010: LeaveBlock: unexpected jumping out DO_STMT

                -- DECOMPILER ERROR at PC1010: LeaveBlock: unexpected jumping out DO_STMT

                -- DECOMPILER ERROR at PC1010: LeaveBlock: unexpected jumping out DO_STMT

                -- DECOMPILER ERROR at PC1010: LeaveBlock: unexpected jumping out DO_STMT

              end
            end
          end
        end
      end
    end
    dec.Parent = nil
    parti.Enabled = false
    attack = false
  end
end
Shootcombo = function()
  table.insert(Effects, {gprt16.CFrame.lookVector, "Shoot", 30, gprt8.Position, 3, 5, 0, 1})
end
Shoot1 = function()
  table.insert(Effects, {gprt16.CFrame.lookVector, "Shoot", 100, gprt8.Position, 8, 12, math.random(10, 20), 2})
end
DecreaseStat = function(Model, Stat, Amount, Duration)
  if Model:findFirstChild("Stats") ~= nil and Model.Stats[Stat] ~= nil then
    Model.Stats[Stat].Value = Model.Stats[Stat].Value - Amount
    d = Instance.new("NumberValue", Model.Stats.Decrease)
    dur = Instance.new("NumberValue", d)
    dur.Name = "Duration"
    dur.Value = Duration
    game:GetService("Debris"):AddItem(d, 20)
    if Stat == "Damage" then
      d.Name = "DecreaseAtk"
    else
      if Stat == "Defense" then
        d.Name = "DecreaseDef"
      else
        if Stat == "Movement" then
          d.Name = "DecreaseMvmt"
        end
      end
    end
    if Model:findFirstChild("Torso") ~= nil then
      display = ""
      if Stat == "Damage" then
        if Amount > 0 then
          display = "-Damage"
        else
          display = "+Damage"
        end
      else
        if Stat == "Defense" then
          if Amount > 0 then
            display = "-Defense"
          else
            display = "+Defense"
          end
        else
          if Stat == "Movement" then
            if Amount > 0 then
              display = "-Movement"
            else
              display = "+Movement"
            end
          end
        end
      end
      showDamage(Model, display, "Debuff")
    end
    d.Value = Amount
  end
end
GetDist = function(Part1, Part2, magni)
  local targ = Part1.Position - Part2.Position
  local mag = targ.magnitude
  if mag <= magni then
    return true
  else
    return false
  end
end
MagniDamage = function(Part, magni, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, Sound)
  for _,c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = nil
      for _,d in pairs(c:children()) do
        if d.className == "Model" and ranged ~= true then
          head = d:findFirstChild("Hitbox")
          if d.Parent == Character then
            break
          end
          if head ~= nil then
            local targ = head.Position - Part.Position
            local mag = targ.magnitude
            if mag <= magni and c.Name ~= Player.Name then
              ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
              ref.Anchored = true
              ref.CFrame = cf(head.Position)
              game:GetService("Debris"):AddItem(ref, 1)
              hitnum = math.random(1, 5)
              if hitnum == 1 then
                so("199148971", ref, 1, 1)
              else
                if hitnum == 2 then
                  so("199149025", ref, 1, 1)
                else
                  if hitnum == 3 then
                    so("199149072", ref, 1, 1)
                  else
                    if hitnum == 4 then
                      so("199149109", ref, 1, 1)
                    else
                      if hitnum == 5 then
                        so("199149119", ref, 1, 1)
                      end
                    end
                  end
                end
              end
              StaggerHit.Value = true
            end
          end
        end
        do
          if d.className == "Part" then
            head = d
            if head ~= nil then
              local targ = head.Position - Part.Position
              local mag = targ.magnitude
              if mag <= magni and c.Name ~= Player.Name then
                if stun == nil then
                  stun = math.random(5, 10)
                end
                local Rang = nil
                if Ranged == false then
                  Rang = true
                end
                local stag = nil
                if shbash == true then
                  stag = true
                end
                Damagefunc(head, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, Sound)
              end
            end
          end
          do
            -- DECOMPILER ERROR at PC181: LeaveBlock: unexpected jumping out DO_STMT

          end
        end
      end
    end
  end
end
rayCast = function(Pos, Dir, Max, Ignore)
  return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
end
local Point = Torso.CFrame * cf(0, Torso.Size.Y, 0)
LastPoint = Point
effect = function(Color, Ref, LP, P1, returnn)
  if LP == nil or P1 == nil then
    return 
  end
  local effectsmsh = Instance.new("CylinderMesh")
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  effectsmsh.Name = "Mesh"
  local effectsg = Instance.new("Part")
  NoOutline(effectsg)
  effectsg.formFactor = 3
  effectsg.CanCollide = false
  effectsg.Name = "Eff"
  effectsg.Locked = true
  effectsg.Anchored = true
  effectsg.Size = Vector3.new(0.5, 1, 0.5)
  effectsg.Parent = workspace
  effectsmsh.Parent = effectsg
  effectsg.BrickColor = BrickColor.new(Color)
  effectsg.Reflectance = Ref
  local point1 = P1
  local mg = LP.p - point1.p.magnitude
  effectsg.Size = Vector3.new(0.5, mg, 0.5)
  effectsg.CFrame = cf((LP.p + point1.p) / 2, point1.p) * CFrame.Angles(math.rad(90), 0, 0)
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  game:GetService("Debris"):AddItem(effectsg, 2)
  if returnn then
    return effectsg
  end
  if not returnn then
    table.insert(Effects, {effectsg, "Cylinder", 0.2, 0.01, 0, 0.01, effectsmsh})
  end
end
local CFrameFromTopBack = function(at, top, back)
  local right = top:Cross(back)
  return CFrame.new(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end
Triangle = function(a, b, c)
  local edg1 = c - a:Dot(b - a.unit)
  local edg2 = a - b:Dot(c - b.unit)
  local edg3 = b - c:Dot(a - c.unit)
  if edg1 <= b - a.magnitude and edg1 >= 0 then
    a = a
  else
    -- DECOMPILER ERROR at PC35: Overwrote pending register: R1 in 'AssignReg'

    if edg2 <= c - b.magnitude and edg2 >= 0 then
      a = b
    else
      -- DECOMPILER ERROR at PC46: Overwrote pending register: R2 in 'AssignReg'

      -- DECOMPILER ERROR at PC47: Overwrote pending register: R1 in 'AssignReg'

      if edg3 <= a - c.magnitude and edg3 >= 0 then
        a = c
      else
        assert(false, "unreachable")
      end
    end
  end
  local len1 = c - a:Dot(b - a.unit)
  local len2 = b - a.magnitude - len1
  local width = a + b - a.unit * len1 - c.magnitude
  local maincf = CFrameFromTopBack(a, b - a:Cross(c - b).unit, -b - a.unit)
  local list = {}
  if len1 > 0.01 then
    local w1 = Instance.new("WedgePart", m)
    game:GetService("Debris"):AddItem(w1, 5)
    w1.Material = "SmoothPlastic"
    w1.FormFactor = "Custom"
    w1.BrickColor = BrickColor.new("Bright red")
    w1.Transparency = 0
    w1.Reflectance = 0
    w1.Material = "SmoothPlastic"
    w1.CanCollide = false
    NoOutline(w1)
    local sz = Vector3.new(0.2, width, len1)
    w1.Size = sz
    local sp = Instance.new("SpecialMesh", w1)
    sp.MeshType = "Wedge"
    sp.Scale = Vector3.new(0, 1, 1) * sz / w1.Size
    w1:BreakJoints()
    w1.Anchored = true
    w1.Parent = workspace
    w1.Transparency = 0.7
    table.insert(Effects, {w1, "Disappear", 0.05})
    w1.CFrame = maincf * CFrame.Angles(math.pi, 0, math.pi / 2) * CFrame.new(0, width / 2, len1 / 2)
    table.insert(list, w1)
  end
  do
    if len2 > 0.01 then
      local w2 = Instance.new("WedgePart", m)
      game:GetService("Debris"):AddItem(w2, 5)
      w2.Material = "SmoothPlastic"
      w2.FormFactor = "Custom"
      w2.BrickColor = BrickColor.new("Bright red")
      w2.Transparency = 0
      w2.Reflectance = 0
      w2.Material = "SmoothPlastic"
      w2.CanCollide = false
      NoOutline(w2)
      local sz = Vector3.new(0.2, width, len2)
      w2.Size = sz
      local sp = Instance.new("SpecialMesh", w2)
      sp.MeshType = "Wedge"
      sp.Scale = Vector3.new(0, 1, 1) * sz / w2.Size
      w2:BreakJoints()
      w2.Anchored = true
      w2.Parent = workspace
      w2.Transparency = 0.7
      table.insert(Effects, {w2, "Disappear", 0.05})
      w2.CFrame = maincf * CFrame.Angles(math.pi, math.pi, -math.pi / 2) * CFrame.new(0, width / 2, -len1 - len2 / 2)
      table.insert(list, w2)
    end
    do
      return unpack(list)
    end
  end
end
MagicBlock = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type, parent)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  if Type == 1 or Type == nil then
    table.insert(Effects, {prt, "Block1", delay, x3, y3, z3, msh})
  else
    if Type == 2 then
      table.insert(Effects, {prt, "Block2", delay, x3, y3, z3, msh})
    end
  end
end
MagicCircle = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicCylinder = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicHead = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Head", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
ClangEffect = function(brickcolor, cframe, duration, decrease, size, power)
  local prt = part(3, workspace, 0, 1, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(5, 5, 5))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "CylinderClang", duration, decrease, size, power, prt.CFrame, nil})
end
MagicWave = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "FileMesh", "20329976", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicFire = function(brickcolor, cframe, x1, y1, z1, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Fire", delay, 1, 1, 1, msh})
end
MagicFireWave = function(brickcolor, cframe, x1, y1, z1)
  local prt = part(3, workspace, 0, 1, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  d = Instance.new("Decal")
  d.Parent = prt
  d.Texture = "http://www.roblox.com/asset/?id=26356434"
  d.Face = "Top"
  d = Instance.new("Decal")
  d.Parent = prt
  d.Texture = "http://www.roblox.com/asset/?id=26356434"
  d.Face = "Bottom"
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "FireWave", 1, 30, math.random(400, 600) / 100, msh})
end
ElecEffect = function(cff, x, y, z)
  local prt = part(3, workspace, 0, 0, BrickColor.new("Bright red"), "Part", vt(1, 1, 1))
  prt.Anchored = true
  prt.CFrame = cff * cf(math.random(-x, x), math.random(-y, y), math.random(-z, z))
  prt.CFrame = cf(prt.Position)
  game:GetService("Debris"):AddItem(prt, 10)
  xval = math.random() / 3
  yval = math.random() / 3
  zval = math.random() / 3
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(xval, yval, zval))
  Effects[#Effects + 1] = {prt, "Elec", 0.2, x, y, z, xval, yval, zval, msh}
end
Damagefunc = function(hit, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, Sound)
  if hit.Parent == nil then
    return 
  end
  if hit.Name == "Hitbox" and hit.Parent ~= modelzorz and ranged ~= true then
    ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
    ref.Anchored = true
    ref.CFrame = cf(hit.Position)
    game:GetService("Debris"):AddItem(ref, 1)
    hitnum = math.random(1, 5)
    if hitnum == 1 then
      so("199148971", ref, 1, 1)
    else
      if hitnum == 2 then
        so("199149025", ref, 1, 1)
      else
        if hitnum == 3 then
          so("199149072", ref, 1, 1)
        else
          if hitnum == 4 then
            so("199149109", ref, 1, 1)
          else
            if hitnum == 5 then
              so("199149119", ref, 1, 1)
            end
          end
        end
      end
    end
    StaggerHit.Value = true
  end
  if hit.Parent.Parent:FindFirstChild("Torso") ~= nil then
    hit = hit.Parent.Parent:findFirstChild("Torso")
    h = hit.Parent.Parent:FindFirstChild("Humanoid")
  end
  if hit.Parent.className == "Hat" then
    hit = hit.Parent.Parent:findFirstChild("Head")
  end
  h = hit.Parent:FindFirstChild("Humanoid")
  if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
    if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
      return 
    end
    if Player.Neutral == false then
      if hit.Parent:findFirstChild("Alignment") ~= nil and hit.Parent.Alignment.Value == Player.TeamColor.Color then
        return 
      end
      if game.Players:GetPlayerFromCharacter(hit.Parent) ~= nil and game.Players:GetPlayerFromCharacter(hit.Parent).TeamColor == Player.TeamColor then
        return 
      end
    end
    if Sound == "Gun" then
      so("199144144", hit, 1, 1)
    else
      if Sound == "FireWave" then
        so("199144588", hit, 1, math.random(70, 110) / 100)
      end
    end
    c = Instance.new("ObjectValue")
    c.Name = "creator"
    c.Value = game:service("Players").LocalPlayer
    c.Parent = h
    RecentEnemy.Value = hit.Parent
    game:GetService("Debris"):AddItem(c, 0.5)
    minim = minim * Atk.Value
    maxim = maxim * Atk.Value
    Damage = 0
    if minim == maxim then
      Damage = maxim
    else
      Damage = math.random(minim, maxim)
    end
    dist = (RootPart.Position - hit.Position).magnitude / 200
    if dist >= 1 then
      Damage = Damage / dist
    end
    blocked = false
    enblock = nil
    Stats = hit.Parent:findFirstChild("Stats")
    if Stats ~= nil then
      invis = Stats:findFirstChild("Invisibility")
      isinvis = Stats:findFirstChild("IsInvisible")
      if (ranged == false or ranged == nil) and invis ~= nil and isinvis.Value == true then
        invis.Value = 0
      end
      enblock = Stats:findFirstChild("Block")
      if enblock ~= nil and enblock.Value == true then
        blocked = true
      end
      if Stats:findFirstChild("Defense") ~= nil then
        Damage = Damage / Stats.Defense.Value
        if Damage <= 3 and (ranged == false or ranged == nil) and blocked ~= true then
          hitnum = math.random(1, 5)
          if hitnum == 1 then
            so("199149321", hit, 1, 1)
          else
            if hitnum == 2 then
              so("199149338", hit, 1, 1)
            else
              if hitnum == 3 then
                so("199149367", hit, 1, 1)
              else
                if hitnum == 4 then
                  so("199149409", hit, 1, 1)
                else
                  if hitnum == 5 then
                    so("199149452", hit, 1, 1)
                  end
                end
              end
            end
          end
        else
          if ranged == false or ranged == nil and blocked ~= true then
            hitnum = math.random(1, 6)
            if hitnum == 1 then
              so("199149137", hit, 1, 1)
            else
              if hitnum == 2 then
                so("199149186", hit, 1, 1)
              else
                if hitnum == 3 then
                  so("199149221", hit, 1, 1)
                else
                  if hitnum == 4 then
                    so("199149235", hit, 1, 1)
                  else
                    if hitnum == 5 then
                      so("199149269", hit, 1, 1)
                    else
                      if hitnum == 6 then
                        so("199149297", hit, 1, 1)
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if Damage <= 3 and staghit == true and ranged ~= true then
          StaggerHit.Value = true
        end
      end
      if Stats:findFirstChild("Stun") ~= nil then
        if blocked == true then
          incstun = incstun / 2
        end
        if Stats.Stun.Value < Stats.StunThreshold.Value then
          Stats.Stun.Value = Stats.Stun.Value + incstun
        end
      end
      if Stats:findFirstChild("Stagger") ~= nil and stagger == true then
        Stats.Stagger.Value = true
      end
    end
    if blocked == true then
      showDamage(hit.Parent, "Block", "Damage")
      if ranged ~= true then
        enblock.Value = false
        Stagger.Value = true
        hitnum = math.random(1, 2)
        if hitnum == 1 then
          so("199148933", hit, 1, 1)
        else
          if hitnum == 2 then
            so("199148947", hit, 1, 1)
          end
        end
      end
    else
      Damage = math.floor(Damage)
      coroutine.resume(coroutine.create(function(Hum, Dam)
	if attackdebounce == false then
    Hum:TakeDamage(Damage)
	attackdebounce = true
	wait(0.5)
	attackdebounce = false
	end
  end), h, Damage)
      showDamage(hit.Parent, Damage, "Damage")
      if Type == "NormalDecreaseMvmt1" then
        DecreaseStat(hit.Parent, "Movement", 0.1, 200)
      end
      if Type == "Knockdown" then
        hum = hit.Parent.Humanoid
        hum.PlatformStand = true
        coroutine.resume(coroutine.create(function(HHumanoid)
    swait(1)
    HHumanoid.PlatformStand = false
  end), hum)
        local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
        local bodvol = Instance.new("BodyVelocity")
        bodvol.velocity = angle * knockback
        bodvol.P = 5000
        bodvol.maxForce = Vector3.new(8000, 8000, 8000)
        bodvol.Parent = hit
        rl = Instance.new("BodyAngularVelocity")
        rl.P = 3000
        rl.maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000
        rl.angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10))
        rl.Parent = hit
        game:GetService("Debris"):AddItem(bodvol, 0.5)
        game:GetService("Debris"):AddItem(rl, 0.5)
      else
        do
          if Type == "Knockdown2" or Type == "Fire" then
            hum = hit.Parent.Humanoid
            local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
            local bodvol = Instance.new("BodyVelocity")
            bodvol.velocity = angle * knockback
            bodvol.P = 5000
            bodvol.maxForce = Vector3.new(8000, 8000, 8000)
            bodvol.Parent = hit
            if knockback <= 0 then
              bodvol.Parent = nil
            end
            game:GetService("Debris"):AddItem(bodvol, 0.5)
            if Type == "Fire" then
              MagicFireWave(BrickColor.new("Bright red"), hit.CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1)
            end
          else
            do
              if Type == "Normal" or Type == "NormalDecreaseMvmt1" then
                vp = Instance.new("BodyVelocity")
                vp.P = 500
                vp.maxForce = Vector3.new(math.huge, 0, math.huge)
                if KnockbackType == 1 then
                  vp.velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
                else
                  if KnockbackType == 2 then
                    vp.velocity = Property.CFrame.lookVector * knockback
                  end
                end
                game:GetService("Debris"):AddItem(vp, 0.5)
                if knockback > 0 then
                  vp.Parent = hit.Parent.Torso
                end
              end
              debounce = Instance.new("BoolValue")
              debounce.Name = "DebounceHit"
              debounce.Parent = hit.Parent
              debounce.Value = true
              game:GetService("Debris"):AddItem(debounce, Delay)
              c = Instance.new("ObjectValue")
              c.Name = "creator"
              c.Value = Player
              c.Parent = h
              game:GetService("Debris"):AddItem(c, 0.5)
              CRIT = false
            end
          end
        end
      end
    end
  end
end
showDamage = function(Char, Dealt, Type)
  m = Instance.new("Model")
  m.Name = "Effect"
  c = Instance.new("Part")
  c.Transparency = 1
  c.Name = "Head"
  c.TopSurface = 0
  c.BottomSurface = 0
  c.formFactor = "Plate"
  c.Size = Vector3.new(1, 0.4, 1)
  b = Instance.new("BillboardGui", c)
  b.Size = UDim2.new(5, 0, 5, 0)
  b.AlwaysOnTop = true
  damgui = gui("TextLabel", b, tostring(Dealt), 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
  if Type == "Damage" then
    damgui.Font = "SourceSans"
    if Dealt == "Block" then
      damgui.TextColor3 = BrickColor.new("Bright blue").Color
    else
      if Dealt < 3 then
        damgui.TextColor3 = BrickColor.new("White").Color
      else
        if Dealt >= 3 and Dealt < 20 then
          damgui.TextColor3 = BrickColor.new("Bright yellow").Color
        else
          damgui.TextColor3 = BrickColor.new("Really red").Color
          damgui.Font = "SourceSansBold"
        end
      end
    end
  else
    if Type == "Debuff" then
      damgui.TextColor3 = BrickColor.new("White").Color
    else
      if Type == "Interrupt" then
        damgui.TextColor3 = BrickColor.new("New Yeller").Color
      end
    end
  end
  damgui.TextScaled = true
  ms = Instance.new("CylinderMesh")
  ms.Scale = Vector3.new(0.8, 0.8, 0.8)
  ms.Parent = c
  c.Reflectance = 0
  Instance.new("BodyGyro").Parent = c
  c.Parent = m
  if Char:findFirstChild("Head") ~= nil then
    c.CFrame = cf(Char.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
  else
    if Char.Parent:findFirstChild("Head") ~= nil then
      c.CFrame = cf(Char.Parent.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
    end
  end
  f = Instance.new("BodyPosition")
  f.P = 2000
  f.D = 100
  f.maxForce = Vector3.new(545000, 545000, 545000)
  if Type == "Damage" then
    f.position = c.Position + Vector3.new(0, 3, 0)
  else
    if Type == "Debuff" or Type == "Interrupt" then
      f.position = c.Position + Vector3.new(0, 5, 0)
    end
  end
  f.Parent = c
  game:GetService("Debris"):AddItem(m, 5)
  table.insert(Effects, {m, "showDamage", damgui, f, 10, 1, 15, 50, 100})
  c.CanCollide = false
  m.Parent = workspace
  c.CanCollide = false
end
combo = 0
ob1d = function(mouse)
  if gun == true and mana.Value >= 10 then
    mana.Value = mana.Value - 10
    shoot = true
    Shoot1()
    gun = false
  end
  if attack == true or equipped == false then
    return 
  end
  hold = true
  if combo == 0 then
    combo = 1
    attackone()
  else
    if combo == 1 then
      combo = 2
      attacktwo()
    else
      if combo == 2 then
        combo = 3
        if redimbue == false then
          attackthree()
        else
          combo = 0
          attackfour()
        end
      else
        if combo == 3 then
          combo = 0
          attackfour()
        end
      end
    end
  end
  coroutine.resume(coroutine.create(function()
    for i = 1, 50 do
      if attack == false then
        swait()
      end
    end
    if attack == false then
      combo = 0
    end
  end))
end
ob1u = function(mouse)
  hold = false
end
buttonhold = false
fenbarmove1.MouseButton1Click:connect(do1)
fenbarmove2.MouseButton1Click:connect(do2)
fenbarmove3.MouseButton1Click:connect(do3)
fenbarmove4.MouseButton1Click:connect(do4)
eul = 0
equipped = false
key = function(key)
  if key == "e" and gun == true then
    gun = false
  end
  if attack == true then
    return 
  end
  if key == "f" then
    pressedf = true
    fnumb = 0
    attack = true
    if equipped == false then
      equipped = true
      RSH = ch.Torso["Right Shoulder"]
      LSH = ch.Torso["Left Shoulder"]
      RSH.Parent = nil
      LSH.Parent = nil
      RW.Name = "Right Shoulder"
      RW.Part0 = ch.Torso
      RW.C0 = cf(1.5, 0.5, 0)
      RW.C1 = cf(0, 0.5, 0)
      RW.Part1 = ch["Right Arm"]
      RW.Parent = ch.Torso
      LW.Name = "Left Shoulder"
      LW.Part0 = ch.Torso
      LW.C0 = cf(-1.5, 0.5, 0)
      LW.C1 = cf(0, 0.5, 0)
      LW.Part1 = ch["Left Arm"]
      LW.Parent = ch.Torso
      Animate.Parent = nil
      equipanim()
    else
      equipped = false
      hideanim()
      LH.C1 = LHC1
      RH.C1 = RHC1
      Animate.Parent = Humanoid
      swait(0)
      RW.Parent = nil
      LW.Parent = nil
      RSH.Parent = player.Character.Torso
      LSH.Parent = player.Character.Torso
    end
    attack = false
  end
  if equipped == false then
    return 
  end
  if key == "e" and gun == false then
    GunStance()
  end
  if key == "z" then
    do1()
  end
  if key == "x" then
    do2()
  end
  if key == "c" then
    do3()
  end
  if key == "v" then
    do4()
  end
  -- DECOMPILER ERROR at PC162: Unhandled construct in 'MakeBoolean' P1

  if key ~= "h" or attack == false then
    RecentEnemy.Value = nil
  end
end
key2 = function(key)
end
s = function(mouse)
  mouse.Button1Down:connect(function()
    ob1d(mouse)
  end)
  mouse.Button1Up:connect(function()
    ob1u(mouse)
  end)
  mouse.KeyDown:connect(key)
  mouse.KeyUp:connect(key2)
  player = Player
  ch = Character
  MMouse = mouse
end
ds = function(mouse)
end
Bin.Selected:connect(s)
Bin.Deselected:connect(ds)
print("Vulca loaded.")
local mananum = 0
local donum = 0
local stunnum = 0
local staggeranim = false
local stunanim = false
local Point, LastPoint = nil, nil
local walk = 0
local walkforw = true
local elecnum = 0
while 1 do
  swait()
  if Humanoid.Health <= 0 then
    attack = true
    resumeControl()
    modelzorz.Parent = workspace
    game:GetService("Debris"):AddItem(modelzorz, 30)
    for i = 1, #Weapon do
      Weapon[i].Parent = modelzorz
      Weapon[i].CanCollide = true
    end
    for i = 1, #Welds do
      if Welds[i].Part0.Parent == Character or Welds[i].Part1.Parent == Character then
        Welds[i].Parent = nil
      else
        Welds[i].Parent = prt1
      end
    end
  end
  do
    if fnumb < 21 then
      fnumb = fnumb + 1
      if pressedf == false then
        fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency - 0.025
        tellbar.TextTransparency = tellbar.TextTransparency - 0.05
        tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency - 0.05
      else
        if fnumb == 20 then
          fenframe5.Parent = nil
          print("daigui")
        end
        fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency + 0.025
        tellbar.TextTransparency = tellbar.TextTransparency + 0.05
        tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency + 0.05
      end
    end
    if Humanoid.Health <= 20 then
      passive.Value = -0.3
      passive2.Value = -0.4
      prt13.Transparency = 0.3
      prt14.Transparency = 0.3
    else
      if Humanoid.Health <= 50 then
        passive.Value = -0.2
        passive2.Value = -0.2
        prt13.Transparency = 0.5
        prt14.Transparency = 0.5
      else
        passive.Value = 0
        passive2.Value = 0
        prt13.Transparency = 1
        prt14.Transparency = 1
      end
    end
    if 70 <= cooldowns[3] then
      redimbue = false
    else
      if redimbue == true then
        if 4 <= elecnum then
          elecnum = 0
          ElecEffect(prt9.CFrame, 1, 4, 2)
        end
        elecnum = elecnum + 1
      end
    end
    if hbwld.Parent == nil then
      hitbox2.Name = "Hitbox"
    else
      hitbox2.Name = "Hitbox2"
    end
    hitbox2.Parent = hitbox.Parent
    hitbox2.Size = hitbox.Size
    hitbox2.CFrame = hitboxCF
    hboxpos.position = hitbox2.Position + vt(math.random(-100, 100) / 100, math.random(-100, 100) / 100, math.random(-100, 100) / 100)
    if Stagger.Value == true and staggeranim == false then
      coroutine.resume(coroutine.create(function()
  staggeranim = true
  while attack == true do
    swait()
  end
  StaggerAnim()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end))
    end
    if StaggerHit.Value == true and staggeranim == false then
      coroutine.resume(coroutine.create(function()
  staggeranim = true
  while attack == true do
    swait()
  end
  StaggerHitt()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end))
    end
    if Mvmt.Value < 0 or Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true or Rooted.Value == true then
      Humanoid.WalkSpeed = 0
    else
      Humanoid.WalkSpeed = 16 * Mvmt.Value
    end
    if StunT.Value <= Stun.Value and stunanim == false then
      coroutine.resume(coroutine.create(function()
  stunanim = true
  while attack == true do
    swait()
  end
  StunAnim()
  Stun.Value = 0
  stunanim = false
end))
    end
    local stunnum2 = 50
    if stunnum2 <= stunnum then
      if 0 < Stun.Value then
        Stun.Value = Stun.Value - 1
      end
      stunnum = 0
    end
    stunnum = stunnum + 1
    if 0.5 <= donum then
      handidle = true
    else
      if donum <= 0 then
        handidle = false
      end
    end
    if handidle == false then
      donum = donum + 0.003
    else
      donum = donum - 0.003
    end
    local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
    local velderp = RootPart.Velocity.y
    hitfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
    if equipped == true then
      if attack == false then
        idle = idle + 1
      else
        idle = 0
      end
      if (500 <= idle and attack ~= false) or Anim == "Walk" then
        if walkforw == true then
          RH.C1 = clerp(RH.C1, RHC1 * cf(0.2, -0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
          LH.C1 = clerp(LH.C1, LHC1 * cf(0.1, 0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
        else
          RH.C1 = clerp(RH.C1, RHC1 * cf(-0.1, 0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
          LH.C1 = clerp(LH.C1, LHC1 * cf(-0.2, -0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
        end
      else
        RH.C1 = clerp(RH.C1, RHC1, 0.2)
        LH.C1 = clerp(LH.C1, LHC1, 0.2)
      end
      if 1 < RootPart.Velocity.y and hitfloor == nil then
        Anim = "Jump"
        if attack == false then
          wld1.C0 = clerp(wld1.C0, euler(2.9, 0, 3.14) * cf(0, 1, 0.2), 0.2)
          Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0), 0.2)
          Neck.C1 = clerp(Neck.C1, necko2 * euler(0, 0, 0), 0.2)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
          RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 0.5), 0.2)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
          LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1, 0, 0.8) * euler(0, -0.7, 0), 0.2)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
          RH.C0 = clerp(RH.C0, cf(1, -1, -0.3) * euler(-0.5, 1.57, 0) * euler(-0.2, 0, 0), 0.2)
          LH.C0 = clerp(LH.C0, cf(-1, -1, -0.3) * euler(-0.5, -1.57, 0) * euler(-0.2, 0, 0), 0.2)
        end
      else
        if RootPart.Velocity.y < -1 and hitfloor == nil then
          Anim = "Fall"
          if attack == false then
            wld1.C0 = clerp(wld1.C0, euler(2.9, 0, 3.14) * cf(0, 1, 0.2), 0.2)
            Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, 0), 0.2)
            Neck.C1 = clerp(Neck.C1, necko2 * euler(0, 0, 0), 0.2)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(2, 0, 1), 0.2)
            RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.3, 0, -0.2), 0.2)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
            RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0.4, 1.57, 0), 0.2)
            LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(-0.2, -1.57, 0), 0.2)
          end
        else
          if torvel < 1 and hitfloor ~= nil then
            Anim = "Idle"
            if attack == false then
              wld1.C0 = clerp(wld1.C0, euler(2.9 + (donum) / 3, 0, 3.14) * cf(0, 1, 0.2), 0.15)
              gwld6.C0 = clerp(gwld6.C0, euler(0, 0, 0) * cf(0, -0.25, -0.1), 0.15)
              gwld1.C0 = clerp(gwld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.15)
              Neck.C0 = clerp(Neck.C0, necko * euler(0.2 - (donum) / 5, 0, 0), 0.15)
              RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.15)
              RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.3 + (donum) / 3, 0, 0.5 - (donum) / 3), 0.15)
              RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.15)
              LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(0.7 + (donum) / 3, 0, 0.4 + (donum) / 3) * euler(0, -0.4, 0), 0.15)
              LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.15)
              RH.C0 = clerp(RH.C0, RHC0, 0.2)
              LH.C0 = clerp(LH.C0, LHC0, 0.2)
            end
          else
            if 2 < torvel and torvel < 30 and hitfloor ~= nil then
              Anim = "Walk"
              walk = walk + 1
              if 15 - 5 * Mvmt.Value <= walk then
                walk = 0
                if walkforw == true then
                  walkforw = false
                else
                  if walkforw == false then
                    walkforw = true
                  end
                end
              end
              if attack == false then
                gwld6.C0 = clerp(gwld6.C0, euler(0, 0, 0) * cf(0, -0.25, -0.1), 0.2)
                wld1.C0 = clerp(wld1.C0, euler(2.9 + (donum) / 3, 0, 3.14) * euler(0, 0.5, 0) * cf(0, 1, 0.2), 0.2)
                Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5), 0.2)
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.1, 0, -0.5), 0.2)
                RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1 - (donum) / 3, 0, 0.8 - (donum) / 3), 0.2)
                RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(0.5 + (donum) / 3, 0, 0.8 + (donum) / 3) * euler(0, -0.7, 0), 0.2)
                LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.6, 0), 0.2)
                LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.5, 0), 0.2)
              end
            else
              if 30 <= torvel and hitfloor ~= nil then
                Anim = "Run"
                if attack == false then
                  gwld6.C0 = clerp(gwld6.C0, euler(0, 0, 0) * cf(0, -0.25, -0.1), 0.4)
                  wld1.C0 = clerp(wld1.C0, euler(-1.57, 0, 3.14) * cf(0, 1, 0), 0.4)
                  Neck.C0 = clerp(Neck.C0, necko * euler(0.1, 0, 0), 0.4)
                  RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.4) * euler(0.1, 0, 0), 0.4)
                  RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.67, 0, -0.8), 0.4)
                  RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
                  LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.5, 0, -0.4) * euler(0, 0, 0), 0.4)
                  LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
                  RH.C0 = clerp(RH.C0, cf(1, -0.7, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.2), 0.4)
                  LH.C0 = clerp(LH.C0, cf(-1, -0.7, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, -0.2), 0.4)
                end
              end
            end
          end
        end
      end
    end
    if 0 < #Effects then
      for e = 1, #Effects do
        if Effects[e] ~= nil then
          local Thing = Effects[e]
          if Thing ~= nil then
            local Part = Thing[1]
            local Mode = Thing[2]
            local Delay = Thing[3]
            local IncX = Thing[4]
            local IncY = Thing[5]
            local IncZ = Thing[6]
            if Thing[2] == "Shoot" then
              Look = Thing[1]
              local hit, pos = rayCast(Thing[4], Look, 20, modelzorz)
              local mag = (Thing[4] - pos).magnitude
              MagicHead(BrickColor.new("Really red"), CFrame.new((Thing[4] + pos) / 2, pos) * angles(1.57, 0, 0), 1, mag * 5, 1, 0.5, 0, 0.5, 0.1)
              Thing[4] = Thing[4] + Look * 20
              Thing[3] = Thing[3] - 1
              if hit ~= nil then
                Thing[3] = 0
                if Thing[8] == 1 then
                  Damagefunc(hit, Thing[5], Thing[6], Thing[7], "Normal", RootPart, 0, 2, (math.random(1, 5)), nil, nil, true, "Gun")
                else
                  if Thing[8] == 2 then
                    Damagefunc(hit, Thing[5], Thing[6], Thing[7], "NormalDecreaseMvmt1", RootPart, 0, 2, (math.random(1, 5)), nil, nil, true, "Gun")
                  end
                end
                ref = part(3, workspace, 0, 1, BrickColor.new("Really red"), "Reference", vt())
                ref.Anchored = true
                ref.CFrame = cf(pos)
                MagicCircle(BrickColor.new("Really red"), cf(pos), 5, 5, 5, 1, 1, 1, 0.03)
                game:GetService("Debris"):AddItem(ref, 1)
              end
              if Thing[3] <= 0 then
                table.remove(Effects, e)
              end
            end
            do
              do
                if Thing[2] == "CylinderClang" then
                  if Thing[3] <= 1 then
                    Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, 2.5 * Thing[5], 0) * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
                    Thing[7] = Thing[1].CFrame
                    effect("New Yeller", 0, Thing[8], Thing[7])
                    Thing[8] = Thing[7]
                    Thing[3] = Thing[3] + Thing[4]
                  else
                    Part.Parent = nil
                    table.remove(Effects, e)
                  end
                end
                if Thing[2] == "Wave" then
                  if Thing[4] <= Thing[5] then
                    Thing[1].CFrame = Thing[1].CFrame * cf(0, 0, -Thing[3])
                    Thing[4] = Thing[4] + 1
                    MagniDamage(Thing[1], 7, 4, 7, 0, "Normal", RootPart, 0.5, 1, (math.random(7, 8)), nil, nil, true)
                  else
                    Thing[6].Parent = nil
                    Thing[7].Parent = nil
                    Thing[8].Enabled = false
                    Part.Transparency = 1
                    table.remove(Effects, e)
                  end
                end
                if Thing[2] == "FireWave" then
                  if Thing[3] <= Thing[4] then
                    Thing[1].CFrame = Thing[1].CFrame * euler(0, 1, 0)
                    Thing[3] = Thing[3] + 1
                    Thing[6].Scale = Thing[6].Scale + vt(Thing[5], 0, Thing[5])
                  else
                    Part.Parent = nil
                    table.remove(Effects, e)
                  end
                end
                if Thing[2] == "showDamage" then
                  if Thing[6] < Thing[5] then
                    Thing[6] = Thing[6] + 1
                  else
                    if Thing[6] < Thing[7] then
                      Thing[4].position = Thing[4].position + vt(0, -0.2, 0)
                      Thing[6] = Thing[6] + 1
                    else
                      if Thing[6] < Thing[8] then
                        Thing[6] = Thing[6] + 1
                      else
                        if Thing[6] < Thing[9] then
                          Thing[6] = Thing[6] + 1
                          Thing[4].position = Thing[4].position + vt(0, 0.2, 0)
                          Thing[3].TextStrokeTransparency = Thing[3].TextStrokeTransparency + 0.1
                          Thing[3].TextTransparency = Thing[3].TextTransparency + 0.1
                        else
                          Thing[1].Parent = nil
                          table.remove(Effects, e)
                        end
                      end
                    end
                  end
                end
                if Thing[2] ~= "Shoot" and Thing[2] ~= "DecreaseStat" and Thing[2] ~= "Wave" and Thing[2] ~= "FireWave" and Thing[2] ~= "showDamage" then
                  if Thing[1].Transparency <= 1 then
                    if Thing[2] == "Block1" then
                      Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                      Mesh = Thing[7]
                      Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                      Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                    else
                      if Thing[2] == "Block2" then
                        Thing[1].CFrame = Thing[1].CFrame
                        Mesh = Thing[7]
                        Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                        Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                      else
                        if Thing[2] == "Fire" then
                          Thing[1].CFrame = cf(Thing[1].Position) + vt(0, 0.2, 0)
                          Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                          Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                        else
                          if Thing[2] == "Cylinder" then
                            Mesh = Thing[7]
                            Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                            Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                          else
                            if Thing[2] == "Blood" then
                              Mesh = Thing[7]
                              Thing[1].CFrame = Thing[1].CFrame * cf(0, 0.5, 0)
                              Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                              Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            else
                              if Thing[2] == "Elec" then
                                Mesh = Thing[10]
                                Mesh.Scale = Mesh.Scale + vt(Thing[7], Thing[8], Thing[9])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                              else
                                if Thing[2] == "Disappear" then
                                  Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  else
                    Part.Parent = nil
                    table.remove(Effects, e)
                  end
                end
                -- DECOMPILER ERROR at PC5807: LeaveBlock: unexpected jumping out DO_STMT

                -- DECOMPILER ERROR at PC5807: LeaveBlock: unexpected jumping out IF_THEN_STMT

                -- DECOMPILER ERROR at PC5807: LeaveBlock: unexpected jumping out IF_STMT

                -- DECOMPILER ERROR at PC5807: LeaveBlock: unexpected jumping out IF_THEN_STMT

                -- DECOMPILER ERROR at PC5807: LeaveBlock: unexpected jumping out IF_STMT

              end
            end
          end
        end
      end
    end
    fenbarmana2:TweenSize((UDim2.new(0.4, 0, -4 * mana.Value / 100, 0)), nil, 1, 0.4, true)
    fenbarmana4.Text = "Mana(" .. mana.Value .. ")"
    fenbarhp2.BackgroundColor3 = Color3.new(Humanoid.Health / Humanoid.MaxHealth, 0, 0)
    fenbarhp2:TweenSize((UDim2.new(Humanoid.Health / Humanoid.MaxHealth, 0, 1, 0)), nil, 1, 0.4, true)
    fenbarhp3.Text = "(" .. math.floor(Humanoid.Health) .. ")"
    fenbarmove1b:TweenSize((UDim2.new(1 * cooldowns[1] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
    fenbarmove2b:TweenSize((UDim2.new(1 * cooldowns[2] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
    fenbarmove3b:TweenSize((UDim2.new(1 * cooldowns[3] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
    fenbarmove4b:TweenSize((UDim2.new(1 * cooldowns[4] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
    for _,c in pairs(Decrease:children()) do
      if (c:findFirstChild("Duration")) ~= nil then
        c.Duration.Value = c.Duration.Value - 1
        if c.Duration.Value <= 0 then
          c.Parent = nil
        end
      end
      if c.Name == "DecreaseAtk" then
        decreaseatk = decreaseatk + c.Value
      else
        if c.Name == "DecreaseDef" then
          decreasedef = decreasedef + c.Value
        else
          if c.Name == "DecreaseMvmt" then
            decreasemvmt = decreasemvmt + c.Value
          end
        end
      end
    end
    Atk.Value = 1 - (decreaseatk)
    if Atk.Value <= 0 then
      Atk.Value = 0
    end
    Def.Value = 1 - (decreasedef)
    if Def.Value <= 0 then
      Def.Value = 0.01
    end
    Mvmt.Value = 1 - (decreasemvmt)
    if Mvmt.Value <= 0 then
      Mvmt.Value = 0
    end
    decreaseatk = 0
    decreasedef = 0
    decreasemvmt = 0
    AtkVal = Atk.Value * 100
    AtkVal = math.floor(AtkVal)
    AtkVal = AtkVal / 100
    fenbardamage.Text = "Damage\n(" .. AtkVal .. ")"
    DefVal = Def.Value * 100
    DefVal = math.floor(DefVal)
    DefVal = DefVal / 100
    fenbardef.Text = "Defense\n(" .. DefVal .. ")"
    MvmtVal = Mvmt.Value * 100
    MvmtVal = math.floor(MvmtVal)
    MvmtVal = MvmtVal / 100
    if Rooted.Value == true then
      MvmtVal = 0
    end
    fenbarmove.Text = "Walkspeed\n(" .. MvmtVal .. ")"
    if StunT.Value <= Stun.Value then
      fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4, 0)), nil, 1, 0.4, true)
    else
      fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4 * Stun.Value / StunT.Value, 0)), nil, 1, 0.4, true)
    end
    fenbarstun3.Text = "Stun(" .. Stun.Value .. ")"
    gmsh15.Scale = vt(2.21, 5 * mana.Value / 100, 0.9)
    gwld15.C0 = euler(0, 0, 0) * cf(0, 0, 0) * cf(0, 0.5 / (100 / (100 - mana.Value)), 0)
    if 100 <= mana.Value then
      mana.Value = 100
    else
      if mananum <= 8 then
        mananum = mananum + 1
      else
        mananum = 0
        mana.Value = mana.Value + 1
      end
    end
    for i = 1, #cooldowns do
      if cooldownmax <= cooldowns[i] then
        cooldowns[i] = cooldownmax
      else
        cooldowns[i] = cooldowns[i] + cooldownsadd[i]
      end
    end
    -- DECOMPILER ERROR at PC6204: LeaveBlock: unexpected jumping out DO_STMT

  end
end

]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="HopperBin" referent="RBXA00E2F81D46E44F5B3306E35023329C9">
			<Properties>
				<bool name="Active">false</bool>
				<token name="BinType">0</token>
				<string name="Name">Renegade</string>
				<Content name="TextureId"><null></null></Content>
			</Properties>
			<Item class="LocalScript" referent="RBX783EB489726C4A958CDC7F3E20E26895">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LocalScript</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[Player = game:GetService("Players").LocalPlayer
Character = Player.Character
PlayerGui = Player.PlayerGui
Backpack = Player.Backpack
Torso = Character.Torso
Head = Character.Head
Humanoid = Character.Humanoid
Face = Head.face
LeftArm = Character["Left Arm"]
LeftLeg = Character["Left Leg"]
RightArm = Character["Right Arm"]
RightLeg = Character["Right Leg"]
LS = Torso["Left Shoulder"]
LH = Torso["Left Hip"]
RS = Torso["Right Shoulder"]
RH = Torso["Right Hip"]
Neck = Torso.Neck
it = Instance.new
vt = Vector3.new
cf = CFrame.new
euler = CFrame.fromEulerAnglesXYZ
angles = CFrame.Angles
necko = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
necko2 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
LHC0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
LHC1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
RHC0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RHC1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RootPart = Character.HumanoidRootPart
RootJoint = RootPart.RootJoint
RootCF = euler(-1.57, 0, 3.14)
attack = false
attackdebounce = false
MMouse = nil
combo = 0
local hitfloor, posfloor = nil, nil
local idle = 0
local Anim = "Idle"
local Effects = {}
local Weapon = {}
local Welds = {}
local invisible = false
local doing2 = false
local doing4 = false
local Marked = {}
local MarkedGUI = {}
local decreaseatk = 0
local decreasedef = 0
local decreasemvmt = 0
local pursuitnum = 0
local move1 = "(Z)\nTerror"
local move2 = "(X)\nGash"
local move3 = "(C)\nTrauma"
local move4 = "(V)\nExecution"
local cooldowns = {}
local cooldown1 = 0
table.insert(cooldowns, cooldown1)
local cooldown2 = 0
table.insert(cooldowns, cooldown2)
local cooldown3 = 0
table.insert(cooldowns, cooldown3)
local cooldown4 = 0
table.insert(cooldowns, cooldown4)
local cooldownsadd = {}
local cooldownadd1 = 0.35
table.insert(cooldownsadd, cooldownadd1)
local cooldownadd2 = 0.3
table.insert(cooldownsadd, cooldownadd2)
local cooldownadd3 = 0.2
table.insert(cooldownsadd, cooldownadd3)
local cooldownadd4 = 0.1
table.insert(cooldownsadd, cooldownadd4)
local cooldownmax = 100
player = nil
RSH = nil
RW = Instance.new("Motor")
LW = Instance.new("Motor")
RW.Name = "Right Shoulder"
LW.Name = "Left Shoulder"
LH = Torso["Left Hip"]
RH = Torso["Right Hip"]
TorsoColor = Torso.BrickColor
TorsoRed = TorsoColor.Color.r
TorsoGreen = TorsoColor.Color.g
TorsoBlue = TorsoColor.Color.b
NewCol = Color3.new(1, TorsoGreen / 2, TorsoBlue / 2)
NewCol2 = Color3.new(0.5, TorsoGreen / 4, TorsoBlue / 4)
if Player:findFirstChild("Color1") ~= nil then
  NewCol = Player.Color1.Value
end
if Player:findFirstChild("Color2") ~= nil then
  NewCol2 = Player.Color2.Value
end
print(BrickColor.new(NewCol))
local mdec = Instance.new("NumberValue", Decrease)
mdec.Name = "DecreaseDef"
mdec.Value = 0.4
local mdec2 = Instance.new("NumberValue", Decrease)
mdec2.Name = "DecreaseMvmt"
mdec2.Value = 0.1
if Character:findFirstChild("Effects", true) ~= nil then
  Character:findFirstChild("Effects", true).Parent = nil
end
local effects = it("Model", Character)
effects.Name = "Effects"
local Animate = Humanoid.Animator
local canjump = true
removeControl = function()
  canjump = false
end
resumeControl = function()
  canjump = true
end
Player.Character.Humanoid.Changed:connect(function()
  if canjump == false then
    Player.Character.Humanoid.Jump = false
  end
end)
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

frame = 1 / 40
tf = 0
allowframeloss = true
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
    tf = tf + s
    if tf >= frame then
        if allowframeloss then
            script.Heartbeat:Fire()
            lastframe = tick()
        else
            for i = 1, math.floor(tf / frame) do
                script.Heartbeat:Fire()
            end
            lastframe = tick()
        end
        if tossremainder then
            tf = 0
        else
            tf = tf - frame * math.floor(tf / frame)
        end
    end
end)

function swait(num)
    if num == 0 or num == nil then
        ArtificialHB.Event:wait()
    else
        for i = 0, num do
            ArtificialHB.Event:wait()
        end
    end
end
if Character:findFirstChild("Carnufico", true) ~= nil then
  Character:findFirstChild("Carnufico", true).Parent = nil
end
if Player.PlayerGui:findFirstChild("WeaponGUI", true) ~= nil then
  Player.PlayerGui:findFirstChild("WeaponGUI", true).Parent = nil
end
if Character:findFirstChild("Stats", true) ~= nil then
  Character:findFirstChild("Stats", true).Parent = nil
end
local Stats = Instance.new("BoolValue")
Stats.Name = "Stats"
Stats.Parent = Character
local Atk = Instance.new("NumberValue")
Atk.Name = "Damage"
Atk.Parent = Stats
Atk.Value = 1
local Def = Instance.new("NumberValue")
Def.Name = "Defense"
Def.Parent = Stats
Def.Value = 1
local Mvmt = Instance.new("NumberValue")
Mvmt.Name = "Movement"
Mvmt.Parent = Stats
Mvmt.Value = 1
local Block = Instance.new("BoolValue")
Block.Name = "Block"
Block.Parent = Stats
Block.Value = false
local Stun = Instance.new("NumberValue")
Stun.Name = "Stun"
Stun.Parent = Stats
Stun.Value = 0
local StunT = Instance.new("NumberValue")
StunT.Name = "StunThreshold"
StunT.Parent = Stats
StunT.Value = 100
local Rooted = Instance.new("BoolValue")
Rooted.Name = "Rooted"
Rooted.Parent = Stats
Rooted.Value = false
local Stunned = Instance.new("BoolValue")
Stunned.Name = "Stunned"
Stunned.Parent = Stats
Stunned.Value = false
local Stagger = Instance.new("BoolValue")
Stagger.Name = "Stagger"
Stagger.Parent = Stats
Stagger.Value = false
local StaggerHit = Instance.new("BoolValue")
StaggerHit.Name = "StaggerHit"
StaggerHit.Parent = Stats
StaggerHit.Value = false
local RecentEnemy = Instance.new("ObjectValue")
RecentEnemy.Name = "RecentEnemy"
RecentEnemy.Parent = Stats
RecentEnemy.Value = nil
local Decrease = Instance.new("BoolValue")
Decrease.Name = "Decrease"
Decrease.Parent = Stats
Decrease.Value = false
local mana = Instance.new("NumberValue")
mana.Name = "Mana"
mana.Parent = Stats
mana.Value = 0
local invisnum = Instance.new("NumberValue")
invisnum.Name = "Pursuit"
invisnum.Parent = Stats
invisnum.Value = 0
local isinvis = Instance.new("BoolValue")
isinvis.Name = "IsInvisible"
isinvis.Parent = Stats
isinvis.Value = false
local passive = Instance.new("NumberValue", Decrease)
passive.Name = "DecreaseAtk"
passive.Value = 0
local passive2 = Instance.new("NumberValue", nil)
passive2.Name = "DecreaseDef"
passive2.Value = 0.2
local passive3 = Instance.new("NumberValue", nil)
passive3.Name = "DecreaseMvmt"
passive3.Value = -0.2
NoOutline = function(Part)
Part.TopSurface = 10
Part.BottomSurface = 10
Part.RightSurface = 10
Part.LeftSurface = 10
Part.BackSurface = 10
Part.FrontSurface = 10
end
part = function(formfactor, parent, reflectance, transparency, brickcolor, name, size)
  local fp = it("Part")
  fp.formFactor = formfactor
  fp.Parent = parent
  fp.Reflectance = reflectance
  fp.Transparency = transparency
  fp.CanCollide = false
  fp.Locked = true
  fp.BrickColor = brickcolor
  fp.Name = name
  fp.Size = size
  fp.Position = Torso.Position
  NoOutline(fp)
  fp.Material = "SmoothPlastic"
  fp:BreakJoints()
  return fp
end
mesh = function(Mesh, part, meshtype, meshid, offset, scale)
  local mesh = it(Mesh)
  mesh.Parent = part
  if Mesh == "SpecialMesh" then
    mesh.MeshType = meshtype
    if meshid ~= "nil" then
      mesh.MeshId = "http://www.roblox.com/asset/?id=" .. meshid
    end
  end
  mesh.Offset = offset
  mesh.Scale = scale
  return mesh
end
weld = function(parent, part0, part1, c0)
  local weld = it("Motor")
  weld.Parent = parent
  weld.Part0 = part0
  weld.Part1 = part1
  weld.C0 = c0
  return weld
end
gui = function(GuiType, parent, text, backtrans, backcol, pos, size)
  local gui = it(GuiType)
  gui.Parent = parent
  gui.Text = text
  gui.BackgroundTransparency = backtrans
  gui.BackgroundColor3 = backcol
  gui.SizeConstraint = "RelativeXY"
  gui.TextXAlignment = "Center"
  gui.TextYAlignment = "Center"
  gui.Position = pos
  gui.Size = size
  gui.Font = "SourceSans"
  gui.FontSize = "Size14"
  gui.TextWrapped = false
  gui.TextStrokeTransparency = 0
  gui.TextColor = BrickColor.new("White")
  return gui
end
local Color1 = Torso.BrickColor
local fengui = it("GuiMain")
fengui.Parent = Player.PlayerGui
fengui.Name = "WeaponGUI"
local fenframe = it("Frame")
fenframe.Parent = fengui
fenframe.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe.BackgroundTransparency = 1
fenframe.BorderColor3 = Color3.new(17, 17, 17)
fenframe.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe.Position = UDim2.new(0.95, 0, 0.7, 0)
local fenframe2 = it("Frame")
fenframe2.Parent = fengui
fenframe2.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe2.BackgroundTransparency = 1
fenframe2.BorderColor3 = Color3.new(17, 17, 17)
fenframe2.Size = UDim2.new(0.2, 0, 0.1, 0)
fenframe2.Position = UDim2.new(0.4, 0, 0.85, 0)
local fenframe3 = it("Frame")
fenframe3.Parent = fengui
fenframe3.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe3.BackgroundTransparency = 1
fenframe3.BorderColor3 = Color3.new(17, 17, 17)
fenframe3.Size = UDim2.new(0.2, 0, 0.2, 0)
fenframe3.Position = UDim2.new(0.8, 0, 0.8, 0)
fenframe3.Name = "MoveFrame"
local fenframe4 = it("Frame")
fenframe4.Parent = fengui
fenframe4.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe4.BackgroundTransparency = 1
fenframe4.BorderColor3 = Color3.new(17, 17, 17)
fenframe4.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe4.Position = UDim2.new(0, 0, 0.7, 0)
local pressedf = false
local fenframe5 = it("Frame")
fenframe5.Parent = fengui
fenframe5.BackgroundColor3 = Color3.new(0, 0, 0)
fenframe5.BackgroundTransparency = 1
fenframe5.BorderColor3 = Color3.new(0, 0, 0)
fenframe5.Size = UDim2.new(1, 0, 1, 0)
fenframe5.Position = UDim2.new(0, 0, 0, 0)
fenframe5.ZIndex = 2
local tellbar = gui("TextLabel", fenframe5, "-Fixed by kent911t\n-Renegade\'s passive is slightly changed such that damaging an enemy with full stacks now gives Renegade a random buff or debuffs the enemy and does not remove the mark (+)\n-Execution changed to a two-slash attack that both fully marks the enemy. The last slash deals huge knockback. Both slashes deal a fixed 10 damage (+)\n-Invisibility is changed to Pursuit where Renegade slowly drains the Pursuit bar to gain a short surge of increased movement. Pursuit increases when Renegade damages enemies and decreases when not attacking (+/-)\n-Gash changed to a toggleable ability that decreases mana over time, but Renegade\'s attacks ignore defense and increase the buffs/debuffs from reaping marks (+/-)\n-Terror increases Renegade\'s own damage by .2 instead of debuffing enemies (+/-)\n-Damage of combo attacks slightly reduced (-)\n-Renegade no longer ignores defense when attacking an enemy with more than 5 stacks (-)\n-Execution no longer starts with the dark field and no longer instantly kills any enemy below 30 health (-)", 1, Color3.new(0, 0, 0), UDim2.new(0.25, 0, 0.25, 0), UDim2.new(0.5, 0, 0.5, 0))
tellbar.Font = "Arial"
tellbar.TextScaled = true
tellbar.TextTransparency = 1
tellbar.TextStrokeTransparency = 1
tellbar.ZIndex = 2
local fnumb = 0
local fenbarmana1 = gui("TextLabel", fenframe, "", 0, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarmana2 = gui("TextLabel", fenframe, "", 0, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarmana4 = gui("TextLabel", fenframe, "Mana(" .. mana.Value .. ")", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbarblock1 = gui("TextLabel", fenframe, "", 0, Color3.new(0, 0, 0), UDim2.new(-0.7, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarblock2 = gui("TextLabel", fenframe, "", 0, BrickColor.new("Black").Color, UDim2.new(-0.7, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarblock3 = gui("TextLabel", fenframe, "Pursuit(" .. invisnum.Value .. ")", 1, Color3.new(0, 0, 0), UDim2.new(-0.7, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbardamage = gui("TextLabel", fenframe2, "Damage", 0.55, Color3.new(0.6078431372549, 0, 0), UDim2.new(-0.23, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbardef = gui("TextLabel", fenframe2, "Defense", 0.55, Color3.new(0, 0, 0.6078431372549), UDim2.new(-0.46, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarmove = gui("TextLabel", fenframe2, "Walkspeed", 0.55, Color3.new(0, 0.6078431372549, 0), UDim2.new(1.03, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarhp1 = gui("TextLabel", fenframe2, "", 0, Color3.new(0, 0, 0), UDim2.new(-0.46, 0, 1, 0), UDim2.new(1.92, 0, 0.4, 0))
local fenbarhp2 = gui("TextLabel", fenbarhp1, "", 0, Color3.new(1, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarhp3 = gui("TextLabel", fenbarhp1, "(100)", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
local fenbarstun1 = gui("TextLabel", fenframe4, "", 0, Color3.new(0, 0, 0), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarstun2 = gui("TextLabel", fenframe4, "", 0, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarstun3 = gui("TextLabel", fenframe4, "Stun(" .. Stun.Value .. ")", 1, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbarmove1 = gui("TextButton", fenframe3, move1, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove1.ZIndex = 2
local fenbarmove1b = gui("TextLabel", fenbarmove1, "", 0.55, BrickColor.new("Black").Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove2 = gui("TextButton", fenframe3, move2, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove2.ZIndex = 2
local fenbarmove2b = gui("TextLabel", fenbarmove2, "", 0.55, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove3 = gui("TextButton", fenframe3, move3, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove3.ZIndex = 2
local fenbarmove3b = gui("TextLabel", fenbarmove3, "", 0.55, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove4 = gui("TextButton", fenframe3, move4, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove4.ZIndex = 2
local fenbarmove4b = gui("TextLabel", fenbarmove4, "", 0.55, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local testpart = part(3, effects, 0, 1, BrickColor.new("Black"), "Handle", vt())
testpart.Anchored = true
local scarfp2 = part(3, effects, 0, 1, BrickColor.new("Black"), "Handle", vt())
scarfp2.Anchored = true
local modelzorz = Instance.new("Model")
modelzorz.Parent = Character
modelzorz.Name = "Carnufico"
local handle = part(3, modelzorz, 0, 0.5, BrickColor.new(NewCol), "Handle", vt())
local prt1 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol2), "Part01", vt())
local prt2 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Part02", vt())
local prt3 = part(3, modelzorz, 0, 0, BrickColor.new("Medium stone grey"), "Part03", vt())
local prt4 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Part04", vt())
local prt5 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Part05", vt())
local prt6 = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Part06", vt())
local prt7 = part(3, modelzorz, 0.5, 0, BrickColor.new("Really black"), "Part07", vt())
local prt8 = part(3, modelzorz, 0.5, 0, BrickColor.new(NewCol), "Part07", vt())
local prt9 = part(3, modelzorz, 0.5, 0, BrickColor.new("Really black"), "Part09", vt())
local prt10 = part(3, modelzorz, 0.5, 0, BrickColor.new(NewCol), "Part10", vt())
msh1 = mesh("CylinderMesh", prt1, "", "", vt(0, 0, 0), vt(2, 30, 2))
msh2 = mesh("SpecialMesh", prt2, "FileMesh", "4770583", vt(0, 0, 0), vt(1, 1, 1))
msh3 = mesh("CylinderMesh", prt3, "", "", vt(0, 0, 0), vt(3, 3, 3))
msh4 = mesh("SpecialMesh", prt4, "FileMesh", "15158080", vt(0, 0, 0), vt(1, 1, 1))
msh5 = mesh("SpecialMesh", prt5, "FileMesh", "15158080", vt(0, 0, 0), vt(1, 1, 1))
msh6 = mesh("SpecialMesh", prt6, "FileMesh", "9756362", vt(0, 0, 0), vt(0.8, 1, 0.5))
msh7 = mesh("BlockMesh", prt7, "", "", vt(0, 0, 0), vt(1, 2, 2))
msh8 = mesh("BlockMesh", prt8, "", "", vt(0, 0, 0), vt(1, 1, 2))
msh9 = mesh("SpecialMesh", prt9, "Wedge", "nil", vt(0, 0, 0), vt(1, 2, 4))
msh10 = mesh("SpecialMesh", prt10, "Wedge", "nil", vt(0, 0, 0), vt(1, 2, 4))
local handlewld = weld(handle, handle, Torso, euler(-2, 1.57, 0) * cf(-1, -0.5, -0.6))
local wld1 = weld(prt1, prt1, handle, euler(0, 0, 0) * cf(0, 0, 0))
local wld2 = weld(prt1, prt2, prt1, euler(3.14, 0, 0) * cf(0, 3, 0))
local wld3 = weld(prt1, prt3, prt1, euler(0, 0, 0) * cf(0, -3.2, 0))
local wld4 = weld(prt1, prt4, prt3, euler(-1.57, 0, 1.57) * euler(0, -0.7, 0) * cf(-0.16, -0.2, -0.1))
local wld5 = weld(prt1, prt5, prt3, euler(-1.57, 0, -1.57) * euler(0, 0.7, 0) * cf(0.16, -0.2, -0.1))
local wld6 = weld(prt1, prt6, prt3, euler(0, 0, 0) * cf(0, -0.2, 0.1))
local wld7 = weld(prt1, prt7, prt6, euler(0, 0, 0) * cf(0, 0.2, 0.2))
local wld8 = weld(prt1, prt8, prt6, euler(0, 0, 0) * cf(0, -0.1, 0.2))
local wld9 = weld(prt1, prt9, prt7, euler(0, 0, 0) * cf(0, 0, 0.7))
local wld10 = weld(prt1, prt10, prt8, euler(0, 0, 0) * cf(0, -0.1, 0.7))
for i = 0, 2.355, 0.785 do
  local prt4 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Part04", vt())
  msh4 = mesh("SpecialMesh", prt4, "FileMesh", "9756362", vt(0, 0, 0), vt(1, 0.2, 0.2))
  local wld4 = weld(prt1, prt4, prt3, euler(0, i, 0) * cf(0, 0.6, 0))
end
oldprt = prt9
oldprt2 = prt10
cff = 0.1
eul = 0.02
siz = 0.99
for i = 1, 6 do
  local prt11 = part(3, modelzorz, 0.5, 0, BrickColor.new("Really black"), "Part11", vt())
  msh11 = mesh("SpecialMesh", prt11, "Wedge", "nil", vt(0, 0, 0), vt(siz, 2, 6))
  local wld11 = weld(prt1, prt11, oldprt, euler(0, 0, 0) * cf(0, 0, cff) * euler(eul, 0, 0))
  if i < 4 then
    num = 6
    if i == 3 then
      num = 6.8
    end
    local prt12 = part(3, modelzorz, 0.5, 0, BrickColor.new("Black"), "Part12", vt())
    msh12 = mesh("BlockMesh", prt12, "", "", vt(0, 0, 0), vt(siz / 2, 2, num))
    local wld12 = weld(prt1, prt12, prt11, euler(0, 0, 0) * cf(0, 0, cff) * euler(eul, 0, 0))
  end
  do
    do
      oldprt = prt11
      cff = 0.6
      eul = 0.15
      siz = siz - 0.1
      -- DECOMPILER ERROR at PC2114: LeaveBlock: unexpected jumping out DO_STMT

    end
  end
end
oldprt2 = prt10
cff = 0.1
eul = 0.02
siz = 0.99
for i = 1, 7 do
  local prt13 = part(3, modelzorz, 0.5, 0, BrickColor.new(NewCol), "Part13", vt())
  msh13 = mesh("SpecialMesh", prt13, "Wedge", "nil", vt(0, 0, 0), vt(siz, 2, 6))
  local wld13 = weld(prt1, prt13, oldprt2, euler(0, 0, 0) * cf(0, 0, cff) * euler(eul, 0, 0))
  oldprt2 = prt13
  cff = 0.6
  eul = 0.14
  siz = siz - 0.1
end
for _,c in pairs(modelzorz:children()) do
  table.insert(Weapon, c)
end
for _,c in pairs(prt1:children()) do
  if c.className == "Motor" then
    table.insert(Welds, c)
  end
end
local hitbox = part(3, modelzorz, 0, 1, BrickColor.new("Black"), "Hitbox2", vt())
hitbox.Anchored = false
local hbwld = weld(hitbox, hitbox, RootPart, euler(0, 0, 0) * cf(0, 0, 0))
local hitbox2 = part(3, nil, 0, 1, BrickColor.new("Black"), "Hitbox", vt(1, 1, 1))
hitbox2.Anchored = true
local hitboxCF = cf(0, 0, 0)
hboxpos = Instance.new("BodyPosition", nil)
hboxpos.P = 2000
hboxpos.D = 100
hboxpos.maxForce = Vector3.new(545000, 545000, 545000)
hitboxweld = function()
  hbwld.Parent = modelzorz
  hbwld.Part0 = hitbox
  hbwld.Part1 = prt6
end
Bin = script.Parent
script.Parent = Bin
Bin.Name = "Carnufico"
local bodvel = Instance.new("BodyVelocity")
local bg = Instance.new("BodyGyro")
so = function(id, par, vol, pit)
  local sou = Instance.new("Sound", par or workspace)
  sou.Volume = vol
  sou.Pitch = pit or 1
  sou.SoundId = "http://www.roblox.com/asset/?id=" .. id
  coroutine.resume(coroutine.create(function(Sound)
    swait()
    Sound:play()
  end), sou)
  game:GetService("Debris"):AddItem(sou, 6)
end
function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end
hideanim = function()
  equipped = false
  for i = 0, 1, 0.5 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(0, -1.57, 0) * cf(0, 1, 0), 0.4)
    wld1.C0 = clerp(wld1.C0, cf(0, -1.5, 0) * euler(0.2, 0, 0.4), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.4), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(3, 0, 1), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.2), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
  end
  for i = 0, 1, 0.2 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(0, -1.57, 0) * cf(0, 1, 0), 0.4)
    wld1.C0 = clerp(wld1.C0, cf(0, -1.5, 0) * euler(0.2, 0, 0.4), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.4), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(4, 0, 1), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.2), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, RHC0, 0.4)
    LH.C0 = clerp(LH.C0, LHC0, 0.4)
  end
  mdec2.Parent = nil
  handlewld.Part1 = Torso
  handlewld.C0 = euler(-2, 1.57, 0) * cf(-1, -0.5, -0.6)
  wld1.C0 = euler(0, 0, 0) * cf(0, 0, 0)
  for i = 0, 1, 0.3 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
  end
  mdec.Parent = Decrease
end
mdec.Parent = Decrease
equipanim = function()
  equipped = true
  mdec.Parent = nil
  for i = 0, 1, 0.5 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.4), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(2, 0, 0.2), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.2), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
  end
  for i = 0, 1, 0.2 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.4), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(4, 0, 1), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.2), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
  end
  mdec2.Parent = Decrease
  handlewld.Part1 = RightArm
  handlewld.C0 = euler(0, -1.57, 0) * cf(0, 1, 0)
  wld1.C0 = cf(0, -1.5, 0) * euler(0.2, 0, 0.4)
end
StaggerAnim = function()
  attack = true
  removeControl()
  if invisible == true then
    Clone(0.1)
  end
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.35 do
    swait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -40
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, -0.4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.7) * euler(0, -0.7, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  for i = 0, 1, 0.2 do
    swait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -40
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(-0.5, 0, -0.4), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.7) * euler(0, -0.7, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.5), 0.4)
  end
  for i = 0, 1, 0.1 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(0.5, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.8) * euler(-0.2, 0, -0.4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.3, 0, 0.4) * euler(0, -0.4, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.3, 0, -0.2) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 1.2), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, 0, -1) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  for i = 1, 50 do
    swait()
    if StunT.Value <= Stun.Value then
      break
    end
  end
  do
    resumeControl()
    combo = 0
    attack = false
  end
end
StaggerHitt = function()
  attack = true
  if invisible == true then
    Clone(0.1)
  end
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.1 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.7) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, -0.6), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.9) * euler(0, -0.7, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, -0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  attack = false
end
StunAnim = function()
  attack = true
  removeControl()
  Stunned.Value = true
  showDamage(Character, "Stunned", "Interrupt")
  local dec = Instance.new("NumberValue", Decrease)
  dec.Name = "DecreaseMvmt"
  dec.Value = 10
  for i = 0, 1, 0.3 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
    wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0) * euler(1.57, 0, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.2, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1, 0, 0.4) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.3), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, 0), 0.25)
  end
  for i = 0, 1, 0.3 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
    wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0) * euler(1.57, 0, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0.8, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1.2, 0, 0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(0.1, 0, 0.7), 0.25)
  end
  for i = 0, 1, 0.3 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -1), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1.57, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, -0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.1, 0, 0.3), 0.25)
  end
  local gairost = Instance.new("BodyGyro")
  gairost.Parent = RootPart
  gairost.maxTorque = Vector3.new(400000, 0, 400000) * math.huge
  gairost.P = 20000
  gairost.cframe = cf(0, 0, 0)
  for i = 0, 1, 0.1 do
    swait()
    if hitfloor ~= nil then
      Torso.Velocity = vt(0, 0, 0)
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2.5) * euler(1.57, 0, -3.14), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1.5) * euler(0.2, 0, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.5, 0, -1.57) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 0), 0.3)
  end
  for i = 1, 70 do
    swait()
    gairost.cframe = RootPart.CFrame
    if hitfloor ~= nil then
      Torso.Velocity = vt(0, 0, 0)
    end
  end
  for i = 0, 1, 0.2 do
    swait()
    Stun.Value = 0
    gairost.cframe = RootPart.CFrame
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1, 0, -4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1) * euler(0.2, -1, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, 0.2) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, -1) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 1), 0.3)
  end
  resumeControl()
  gairost.Parent = nil
  dec.Parent = nil
  Stun.Value = 0
  combo = 0
  Stunned.Value = false
  attack = false
  for i = 1, 10 do
    swait()
    Stun.Value = 0
  end
end
attackone = function()
  attack = true
  for i = 0, 1, 0.2 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.5)
    wld1.C0 = clerp(wld1.C0, euler(0, -0.4, 0) * cf(0, -2, 0) * euler(1.8, 0, 0), 0.5)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.6) * euler(0.4, 0, 0), 0.5)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 1.4), 0.5)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -0.5) * euler(0, 1.8, 0), 0.5)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
    LW.C0 = clerp(LW.C0, cf(-1.4, 0.5, -0.2) * euler(0.9, 0, -0.3) * euler(0, 1.57, 0), 0.5)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.5) * euler(0, 1.57, 0) * euler(0, -1.4, -0.1), 0.5)
    LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.5) * euler(0, -1.57, 0) * euler(0, -1.4, 0.3), 0.5)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC237: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC237: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("92597369", prt6, 1, 0.6)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(3, 2, 7)
  hitboxCF = prt6.CFrame * euler(-0.3, 0, 0) * cf(0, 0, -2.2)
  hitbox.CFrame = hitboxCF
  for i = 0, 1, 0.15 do
    swait()
    hitboxCF = prt6.CFrame * euler(-0.3, 0, 0) * cf(0, 0, -2.2)
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 4, 5, 7, math.random(5, 10), "Normal", RootPart, 0.5, 2, (math.random(5, 7)), nil, true)
    handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.4)
    wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, -2, 0) * euler(2.5, 0, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.4) * euler(0, 1.8, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1, 0, -1), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, -0.3) * euler(0, 1.57, 0) * euler(0, 1, -0.3), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.8, -1, 0.3) * euler(0, -1.57, 0) * euler(0, 1, 0.1), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC546: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC546: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
attacktwo = function()
  attack = true
  for i = 0, 1, 0.2 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.4)
    wld1.C0 = clerp(wld1.C0, euler(0, -1.57, 0) * cf(0, 0, 0) * euler(2.5, 0, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.7) * euler(0, 1.8, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.5, 0, -0.5), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, -0.3) * euler(0, 1.57, 0) * euler(0, 1, -0.3), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.8, -1, 0.3) * euler(0, -1.57, 0) * euler(0, 1, 0.1), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC231: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC231: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("92597369", prt6, 1, 0.8)
  so("92597296", prt6, 1, 1)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(1, 2, 7)
  hitboxCF = prt6.CFrame * euler(-0.3, 0, 0) * cf(0, 0, -2.2)
  hitbox.CFrame = hitboxCF
  for i = 0, 1, 0.05 do
    swait()
    if (i >= 0.3 and i <= 0.33) or i >= 0.7 and i <= 0.73 then
      so("92597369", prt6, 1, 0.8)
      so("92597296", prt6, 1, 1)
    end
    hitboxCF = prt6.CFrame * euler(-0.3, 0, 0) * cf(0, 0, -2.2)
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 4, 4, 6, math.random(5, 10), "Normal", RootPart, 0.2, 2, (math.random(2, 5)), nil, true)
    handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.5)
    wld1.C0 = euler(22 * i, -1.57 + 1.7 * i, 0) * euler(0, 0, 0) * cf(0, 0, 0) * euler(2.5 - 0.93 * i, 0, 0)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1) * euler(0, 0, 0), 0.5)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 1), 0.5)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1) * euler(0, 0, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1.3), 0.5)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.3) * euler(0, 1.57, 0) * euler(0, -1, -0.1), 0.5)
    LH.C0 = clerp(LH.C0, cf(-0.8, -1, -0.3) * euler(0, -1.57, 0) * euler(0, -1, 0.3), 0.5)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC569: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC569: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  RW.C0 = cf(1.5, 0.5, 0) * euler(1.57, 0, 1) * euler(0, 0, 0)
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
attackthree = function()
  attack = true
  for i = 0, 1, 0.2 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.5)
    wld1.C0 = clerp(wld1.C0, euler(0, -0.4, 0) * cf(0, -2, 0) * euler(1.8, 0, 0), 0.5)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.6) * euler(0.4, 0, 0), 0.5)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 1.4), 0.5)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -0.5) * euler(0, 1.8, 0), 0.5)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
    LW.C0 = clerp(LW.C0, cf(-1.4, 0.5, -0.2) * euler(0.9, 0, -0.3) * euler(0.1, 57, 0), 0.5)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.5) * euler(0, 1.57, 0) * euler(0, -1.4, -0.1), 0.5)
    LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.5) * euler(0, -1.57, 0) * euler(0, -1.4, 0.3), 0.5)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC237: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC237: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("92597369", prt6, 1, 0.5)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(1, 2, 7)
  hitboxCF = prt6.CFrame * euler(-0.3, 0, 0) * cf(0, 0, -2.2)
  hitbox.CFrame = hitboxCF
  for i = 0, 1, 0.05 do
    swait()
    if i >= 0.7 and i <= 0.73 then
      so("92597369", prt6, 1, 0.5)
    end
    hitboxCF = prt6.CFrame * euler(-0.3, 0, 0) * cf(0, 0, -2.2)
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 4, 5, 6, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(4, 6)), nil, true)
    handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.4)
    wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, -2, 0) * euler(2.5, 0, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(0, 0, 0), 0.4)
    RootJoint.C0 = RootCF * cf(0, 0, -0.2) * euler(0, 0, 1.4 - 9.28 * i)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.4) * euler(0, 1.8, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1, 0, -1), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, -0.3) * euler(0, 1.57, 0) * euler(0, 1, -0.3), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.8, -1, 0.3) * euler(0, -1.57, 0) * euler(0, 1, 0.1), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC552: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC552: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
attackfour = function()
  attack = true
  for i = 0, 1, 0.1 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
    wld1.C0 = clerp(wld1.C0, euler(0, 0.8, 0) * cf(0, -2, 0) * euler(1.57, 0, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1, 1.2, 0) * euler(3.6, 0, -0.8), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1, 1.2, 0) * euler(3.6, 0, 0.8), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, -0.2), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0.2), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC213: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC213: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("28144425", prt6, 1, 1)
  so("92597369", prt6, 1, 0.6)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(1, 2, 7)
  hitboxCF = prt6.CFrame * euler(-0.3, 0, 0) * cf(0, 0, -2.2)
  hitbox.CFrame = hitboxCF
  blcf = nil
  scfr = nil
  for i = 0, 1, 0.1 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
    wld1.C0 = clerp(wld1.C0, euler(0, 0.8, 0) * cf(0, -2, 0) * euler(1.57, 0, 0), 0.3)
    hitboxCF = prt6.CFrame * euler(-0.3, 0, 0) * cf(0, 0, -2.2)
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 4, 5, 7, math.random(5, 10), "Normal", RootPart, 0.5, 2, (math.random(5, 8)), nil, true)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.4, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1, 0.3, -0.5) * euler(0.5, 0, -0.8), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1, 0.3, -0.5) * euler(0.5, 0, 0.8), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.3), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, -0.7), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC514: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC514: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
Invisibility = function()
  if invisible == false then
    so("324867021", Torso, 1, 1.4)
    MagicWave(BrickColor.new("Black"), scarfp2.CFrame * euler(math.rad(180), 0, 0), 1, 1, 1, 0.5, 1.5, 0.5, 0.1)
    MagicWave(BrickColor.new("Black"), scarfp2.CFrame * euler(math.rad(180), 0, 0), 1, 1, 1, 1, 0.5, 1, 0.1)
    invisnum.Value = invisnum.Value - 10
    for _,c in pairs(Decrease:children()) do
      if c.Name == "DecreaseMvmt" and c:findFirstChild("Renegade") ~= nil then
        c.Parent = nil
      end
    end
    d = Instance.new("NumberValue", Decrease)
    d.Name = "DecreaseMvmt"
    d.Value = -0.5
    dur = Instance.new("NumberValue", d)
    dur.Name = "Duration"
    dur.Value = 50
    display = "+Movement"
    showDamage(Character, display, "Debuff")
    da = Instance.new("BoolValue", d)
    da.Name = "Renegade"
    DecreaseStat(Character, "Defense", 0.1, 80)
    invisible = true
    isinvis.Value = true
    passive3.Parent = Decrease
  else
    invisible = false
    isinvis.Value = false
    passive3.Parent = nil
  end
end
do1 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[1] and mana.Value >= 10 then
    attack = true
    cooldowns[1] = 0
    local doinvisatk = false
    if doinvisatk == false then
      for i = 0, 1, 0.1 do
        swait()
        handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
        wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0) * euler(1.57, 0, 0), 0.3)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.57) * euler(0, 0, 0), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1.57), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 1) * euler(0, 1.5, 0), 0.3)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, -1.57) * euler(0, 0, 0), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(0.5, -1, -0.3) * euler(0, 1.57, 0) * euler(0, 1.57, -0.3), 0.3)
        LH.C0 = clerp(LH.C0, cf(-0.5, -1, 0.3) * euler(0, -1.57, 0) * euler(0, 1.57, 0.1), 0.3)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
          end
        end
      end
          mana.Value = mana.Value - 10
          CF = LeftArm.CFrame * cf(0, -2, 0)
          ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
          ref.Anchored = true
          ref.CFrame = CF
          game:GetService("Debris"):AddItem(ref, 2)
          so("160772554", ref, 1, 1)
          hbwld.Parent = nil
          hboxpos.Parent = hitbox
          hitbox.Parent = modelzorz
          hitbox.Size = vt(2, 2, 2)
          MagicSkull(BrickColor.new("Black"), CF * euler(-1.57, 0, 0), 1, 1, 1, 1, 1, 1, 0.05, 0.1)
          MagicCylinder2(BrickColor.new("Really black"), CF, 5, 5, 5, 2, -0.05, 2, 0.02, 0.1)
          hitboxCF = CF
          hitbox.CFrame = hitboxCF
          DecreaseStat(Character, "Damage", -0.1, 200)
          for i = 0, 1, 0.05 do
            swait()
            MagicBlock(BrickColor.new("Really black"), CF, 0.5, 0.5, 0.5, 0.2, 0.2, 0.2, 0.05, 3)
            CF = CF * cf(0, -0.4, 0)
            hitboxCF = CF
            hitbox.CFrame = hitboxCF
            hitbox.Size = hitbox.Size + vt(0.6, 0.6, 0.6)
if i == 0.6 then
            MagniDamage(hitbox, hitbox.Size.Y, 8, 15, math.random(20, 40), "Knockdown2", ref, 1, 2, (math.random(5, 8)), nil, false, true)
          end
end
          hitbox.Parent = modelzorz
          hitbox.Size = vt()
          hitboxweld()
          hboxpos.Parent = nil
attack = false
-- u can choose to miss out the line above me and below me using -- so that it does 2 terrors
elseif doinvisatk == true then
          for i = 0, 1, 0.2 do
            swait()
            handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
            wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0) * euler(0.8, 1, 0), 0.3)
            Neck.C0 = clerp(Neck.C0, necko * euler(-0.4, 0, 0.2), 0.4)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.5) * euler(0.8, 0, -0.5), 0.4)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.4), 0.4)
            RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.4, 0, -0.5), 0.4)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
            RH.C0 = clerp(RH.C0, RHC0 * cf(0.5, 1, 0) * euler(0.5, 0, 0.5), 0.4)
            LH.C0 = clerp(LH.C0, LHC0 * cf(0, 0, 0) * euler(0, 0.5, 0.5), 0.4)
            if Stagger.Value ~= true and StunT.Value > Stun.Value then
              do
                if StaggerHit.Value == true then
                  break
                end
              end
            end
          end
              mana.Value = mana.Value - 20
              CF = LeftArm.CFrame * cf(0, -1, 0) * euler(2.5, 0, 0)
              ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
              ref.Anchored = true
              ref.CFrame = CF
              game:GetService("Debris"):AddItem(ref, 2)
              so("160772554", ref, 1, 1)
              hbwld.Parent = nil
              hboxpos.Parent = hitbox
              hitbox.Parent = modelzorz
              hitbox.Size = vt(2, 2, 2)
              MagicSkull(BrickColor.new("Black"), CF * euler(-1.57, 0, 0), 1, 1, 1, 1.5, 1.5, 1.5, 0.05, 0.1)
              MagicCylinder2(BrickColor.new("Really black"), CF, 5, 5, 5, 3, -0.05, 3, 0.02, 0)
              hitboxCF = CF
              hitbox.CFrame = hitboxCF
              for i = 0, 1, 0.05 do
                swait()
                MagicBlock(BrickColor.new("Really black"), CF, 0.5, 0.5, 0.5, 0.2, 0.2, 0.2, 0.05, 3)
                CF = CF * cf(0, -0.2, 0)
                hitboxCF = CF
                hitbox.CFrame = hitboxCF
                hitbox.Size = hitbox.Size + vt(0.8, 0.8, 0.8)
                MagniDamage(hitbox, hitbox.Size.Y, 5, 10, math.random(20, 40), "Knockdown2", ref, 1, 2, (math.random(5, 8)), nil, false, true, "Movement", 0.4, 200)
              end
              hitbox.Parent = modelzorz
              hitbox.Size = vt()
              hitboxweld()
              hboxpos.Parent = nil
              attack = false
            end
          end
        end
do2 = function()
  if doing2 == true then
    cooldowns[2] = 0
    doing2 = false
    return 
  end
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[2] and mana.Value >= 25 then
    cooldowns[2] = 0
    doing2 = true
    local doinvisatk = false
	attack = true
  for i = 0, 1, 0.2 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.5)
    wld1.C0 = clerp(wld1.C0, euler(0, -0.4, 0) * cf(0, -2, 0) * euler(1.8, 0, 0), 0.5)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.6) * euler(0.4, 0, 0), 0.5)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 1.4), 0.5)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -0.5) * euler(0, 1.8, 0), 0.5)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
    LW.C0 = clerp(LW.C0, cf(-1.4, 0.5, -0.2) * euler(0.9, 0, -0.3) * euler(0.1, 57, 0), 0.5)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.5) * euler(0, 1.57, 0) * euler(0, -1.4, -0.1), 0.5)
    LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.5) * euler(0, -1.57, 0) * euler(0, -1.4, 0.3), 0.5)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC237: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC237: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("92597369", prt6, 1, 0.5)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(1, 2, 7)
  hitboxCF = prt6.CFrame * euler(-0.3, 0, 0) * cf(0, 0, -2.2)
  hitbox.CFrame = hitboxCF
  for i = 0, 3, 0.05 do
    swait()
    if i >= 2.1 and i <= 2.19 then
      so("92597369", prt6, 1, 0.5)
    end
    hitboxCF = prt6.CFrame * euler(-0.3, 0, 0) * cf(0, 0, -2.2)
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 4, 5, 6, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(4, 6)), nil, true)
    handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.4)
    wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, -2, 0) * euler(2.5, 0, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(0, 0, 0), 0.4)
    RootJoint.C0 = RootCF * cf(0, 0, -0.2) * euler(0, 0, 1.4 - 9.28 * i)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.4) * euler(0, 1.8, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1, 0, -1), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, -0.3) * euler(0, 1.57, 0) * euler(0, 1, -0.3), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.8, -1, 0.3) * euler(0, -1.57, 0) * euler(0, 1, 0.1), 0.4)
	MagicBlock(BrickColor.new("Bright red"), prt6.CFrame, 1, 1, 1, 1, 1, 1, 0.1, 1)
    MagicBlock(BrickColor.new("Really black"), prt6.CFrame, 1, 1, 1, 1, 1, 1, 0.1, 1)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC552: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC552: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
  doing2 = false
  end
end
do3 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[3] and mana.Value >= 30 then
    attack = true
    cooldowns[3] = 0
    local doinvisatk = false
    for i = 0, 1, 0.1 do
      swait()
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
      wld1.C0 = clerp(wld1.C0, euler(0, 0.8, 0) * cf(0, -2, 0) * euler(1.57, 0, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, 0), 0.3)
      RW.C0 = clerp(RW.C0, cf(1, 1.2, 0) * euler(3.6, 0, -0.8), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1, 1.2, 0) * euler(3.6, 0, 0.8), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, -0.2), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0.2), 0.3)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
        end
      end
    end
    so("92597369", prt6, 0.6, 1)
    blcf = nil
    scfr = nil
    for i = 0, 1, 0.1 do
      swait()
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
      wld1.C0 = clerp(wld1.C0, euler(0, 0.8, 0) * cf(0, -2, 0) * euler(1.57, 0, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.4, 0, 0), 0.4)
      RW.C0 = clerp(RW.C0, cf(1, 0.3, -0.5) * euler(0.5, 0, -0.8), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1, 0.3, -0.5) * euler(0.5, 0, 0.8), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.3), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, -0.7), 0.4)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
        end
      end
    end
    attack = false
      CF = RootPart.CFrame * cf(0, 0, -30)
      ref2 = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
      ref2.Anchored = true
      ref2.CFrame = CF
      game:GetService("Debris"):AddItem(ref2, 5)
      so("161006069", ref2, 1, 0.5)
      hitfloor2, posfloor2 = rayCast(ref2.Position, CFrame.new(ref2.Position, ref2.Position - Vector3.new(0, 1, 0)).lookVector, 100, Character)
      if hitfloor2 ~= nil then
        mana.Value = mana.Value - 30
        ref2.CFrame = cf(posfloor2)
        MagicCircle(BrickColor.new("Really black"), cf(posfloor2), 200, 1, 200, 0, 0, 0, 0.05)
        for i = 0, 1, 0.05 do
          swait()
          MagicBlock(BrickColor.new("Bright red"), cf(posfloor2) * cf(math.random(-2000, 2000) / 100, math.random(0, 300) / 100, math.random(-2000, 2000) / 100), 15, 15, 15, -3, -3, -3, 0.1, 1)
          MagicBlock(BrickColor.new("Black"), cf(posfloor2) * cf(math.random(-2000, 2000) / 100, math.random(0, 300) / 100, math.random(-2000, 2000) / 100), 3, 3, 3, 1, 1, 1, 0.1, 3)
        end
        so("161006069", ref2, 1, 1)
        MagniDamage(ref2, 20, 5, 15, math.random(-50, -30), "Knockdown2", RootPart, 0, 1, (math.random(5, 10)), nil, nil, true)
        MagicBlock(BrickColor.new("Bright red"), cf(posfloor2), 200, 200, 200, -10, -10, -10, 0.05, 1)
        MagicCircle(BrickColor.new("Really black"), cf(posfloor2), 200, 1, 200, 10, 0, 10, 0.05)
      end
    end
end
do4 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[4] and mana.Value >= 50 then
    attack = true
    cooldowns[4] = 0
    mana.Value = mana.Value - 50
    for i = 0, 1, 0.05 do
      swait()
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.15)
      wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 1, 0) * euler(2.2, 0, 0), 0.15)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0.2, 0, 1), 0.15)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1), 0.15)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(2.8, 0, 0.5) * euler(0, -1, 0), 0.15)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.15)
      LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(2.4, 0, 0.8) * euler(0, -1, 0), 0.15)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.15)
      RH.C0 = clerp(RH.C0, cf(0.8, -1, -0.3) * euler(0, 1.57, 0) * euler(0, 1, -0.3), 0.15)
      LH.C0 = clerp(LH.C0, cf(-0.8, -1, 0.3) * euler(0, -1.57, 0) * euler(0, 1, 0.1), 0.15)
    end
    doing4 = true
    so("28144425", prt6, 1, 0.6)
    hbwld.Parent = nil
    hboxpos.Parent = hitbox
    hitbox.Parent = modelzorz
    hitbox.Size = vt(1, 2, 7)
    hitboxCF = prt6.CFrame * euler(-0.3, 0, 0) * cf(0, 0, -2.2)
    hitbox.CFrame = hitboxCF
    blcf = nil
    scfr = nil
    for i = 0, 1, 0.05 do
      swait()
      if i > 0.18 and i <= 0.2 then
        MagicCircle(BrickColor.new("Really red"), hitbox2.CFrame * euler(1.57, 0, 0), 5, 5, 5, -0.05, 10, -0.05, 0.01)
      end
      hitboxCF = prt6.CFrame * euler(-0.3, 0, 0) * cf(0, 0, -2.2)
      hitbox.CFrame = hitboxCF
if i == 0.2 then
      MagniDamage(hitbox, 6, 10, 10, 0, "Knockdown2", RootPart, 1, 1, (math.random(10, 20)), nil, nil, false, nil, nil, nil, true, true)
end
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.4)
      wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, -2, 0) * euler(2.2, 0, 0), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0.2, 0, -1), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 1), 0.4)
      RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(0.5, 0, -0.5) * euler(0, -0.5, 0), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(0.4, 0, 0.6) * euler(0, 1, 0), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.3) * euler(0, 1.57, 0) * euler(0, -1, -0.1), 0.4)
      LH.C0 = clerp(LH.C0, cf(-0.8, -1, -0.3) * euler(0, -1.57, 0) * euler(0, -1, 0.3), 0.4)
    end
    hitbox.Parent = modelzorz
    hitbox.Size = vt()
    hitboxweld()
    hboxpos.Parent = nil
    for i = 0, 1, 0.05 do
      swait()
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.15)
      wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, -1, 0) * euler(2.2, 0, 0), 0.15)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0.4, 0, -1.3), 0.15)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 1.3), 0.15)
      RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.3, 0, -0.5) * euler(0, 1.8, 0), 0.15)
      LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.4, 0, 0.4) * euler(0, 1, 0), 0.15)
      RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.3) * euler(0, 1.57, 0) * euler(0, -1.3, -0.1), 0.15)
      LH.C0 = clerp(LH.C0, cf(-0.8, -1, -0.3) * euler(0, -1.57, 0) * euler(0, -1.3, 0.3), 0.15)
    end
    so("28144425", prt6, 1, 0.65)
    hbwld.Parent = nil
    hboxpos.Parent = hitbox
    hitbox.Parent = modelzorz
    hitbox.Size = vt(1, 2, 7)
    hitboxCF = prt6.CFrame * euler(-0.3, 0, 0) * cf(0, 0, -2.2)
    hitbox.CFrame = hitboxCF
    blcf = nil
    scfr = nil
    daa = 0
    for i = 0, 1, 0.05 do
      swait()
      daa = daa + 1
      hitboxCF = prt6.CFrame * euler(-0.3, 0, 0) * cf(0, 0, -2.2)
      hitbox.CFrame = hitboxCF
      if daa == 4 then
        print("SLASH")
        MagicCircle(BrickColor.new("Really red"), hitbox2.CFrame * euler(1.57, 0, 0), 5, 5, 5, -0.05, 10, -0.05, 0.01)
      end
if i == 0.05 then
      MagniDamage(hitbox, 6, 10, 10, math.random(30, 50), "Knockdown2", RootPart, 1, 1, (math.random(10, 20)), nil, nil, false, nil, nil, nil, true, true)
end
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.35)
      wld1.C0 = clerp(wld1.C0, euler(0, -0.5, 0) * cf(0, -2, 0) * euler(2.2, 0, 0), 0.35)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0.2, 0, 1.3), 0.35)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1.3), 0.35)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(2.5, 0, 1) * euler(0, 2.5, 0), 0.35)
      LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.4, 0, 0.4) * euler(0, 0, 0), 0.35)
      RH.C0 = clerp(RH.C0, cf(0.8, -1, -0.3) * euler(0, 1.57, 0) * euler(0, 1, -0.3), 0.35)
      LH.C0 = clerp(LH.C0, cf(-0.8, -1, 0.3) * euler(0, -1.57, 0) * euler(0, 1, 0.1), 0.35)
    end
    swait(10)
    doing4 = false
    attack = false
  end
end
DecreaseStat = function(Model, Stat, Amount, Duration, cangui)
  if Model:findFirstChild("Stats") ~= nil and Model.Stats[Stat] ~= nil then
    Model.Stats[Stat].Value = Model.Stats[Stat].Value - Amount
    d = Instance.new("NumberValue", Model.Stats.Decrease)
    dur = Instance.new("NumberValue", d)
    dur.Name = "Duration"
    dur.Value = Duration
    game:GetService("Debris"):AddItem(d, 20)
    if Stat == "Damage" then
      d.Name = "DecreaseAtk"
    else
      if Stat == "Defense" then
        d.Name = "DecreaseDef"
      else
        if Stat == "Movement" then
          d.Name = "DecreaseMvmt"
        end
      end
    end
    if Model:findFirstChild("Torso") ~= nil then
      display = ""
      if Stat == "Damage" then
        if Amount > 0 then
          display = "-Damage"
        else
          display = "+Damage"
        end
      else
        if Stat == "Defense" then
          if Amount > 0 then
            display = "-Defense"
          else
            display = "+Defense"
          end
        else
          if Stat == "Movement" then
            if Amount > 0 then
              display = "-Movement"
            else
              display = "+Movement"
            end
          end
        end
      end
      if cangui ~= true then
        showDamage(Model, display, "Debuff")
      end
    end
    d.Value = Amount
  end
end
GetDist = function(Part1, Part2, magni)
  local targ = Part1.Position - Part2.Position
  local mag = targ.magnitude
  if mag <= magni then
    return true
  else
    return false
  end
end
MagniDamage = function(Part, magni, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
  for _,c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = nil
      for _,d in pairs(c:children()) do
        if d.className == "Model" and ranged ~= true then
          head = d:findFirstChild("Hitbox")
          if d.Parent == Character then
            break
          end
          if head ~= nil then
            local targ = head.Position - Part.Position
            local mag = targ.magnitude
            if mag <= magni and c.Name ~= Player.Name then
              ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
              ref.Anchored = true
              ref.CFrame = cf(head.Position)
              game:GetService("Debris"):AddItem(ref, 1)
              hitnum = math.random(1, 5)
              if hitnum == 1 then
                so("199148971", ref, 1, 1)
              else
                if hitnum == 2 then
                  so("199149025", ref, 1, 1)
                else
                  if hitnum == 3 then
                    so("199149072", ref, 1, 1)
                  else
                    if hitnum == 4 then
                      so("199149109", ref, 1, 1)
                    else
                      if hitnum == 5 then
                        so("199149119", ref, 1, 1)
                      end
                    end
                  end
                end
              end
              StaggerHit.Value = true
            end
          end
        end
        do
          if d.className == "Part" and d.Name=="Torso" then
            head = d
            if head ~= nil then
              local targ = head.Position - Part.Position
              local mag = targ.magnitude
              if mag <= magni and c.Name ~= Player.Name then
                if stun == nil then
                  stun = math.random(5, 10)
                end
                local Rang = nil
                if Ranged == false then
                  Rang = true
                end
                local stag = nil
                if shbash == true then
                  stag = true
                end
                Damagefunc(head, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
              end
            end
          end
          do
            -- DECOMPILER ERROR at PC183: LeaveBlock: unexpected jumping out DO_STMT

          end
        end
      end
    end
  end
end
rayCast = function(Pos, Dir, Max, Ignore)
  return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
end
local Point = Torso.CFrame * cf(0, Torso.Size.Y, 0)
LastPoint = Point
effect = function(Color, Ref, LP, P1, returnn)
  if LP == nil or P1 == nil then
    return 
  end
  local effectsmsh = Instance.new("CylinderMesh")
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  effectsmsh.Name = "Mesh"
  local effectsg = Instance.new("Part")
  NoOutline(effectsg)
  effectsg.formFactor = 3
  effectsg.CanCollide = false
  effectsg.Name = "Eff"
  effectsg.Locked = true
  effectsg.Anchored = true
  effectsg.Size = Vector3.new(0.5, 1, 0.5)
  effectsg.Parent = workspace
  effectsmsh.Parent = effectsg
  effectsg.BrickColor = BrickColor.new(Color)
  effectsg.Reflectance = Ref
  local point1 = P1
  local mg = (LP.p - point1.p).magnitude
  effectsg.Size = Vector3.new(0.5, mg, 0.5)
  effectsg.CFrame = cf((LP.p + point1.p) / 2, point1.p) * CFrame.Angles(math.rad(90), 0, 0)
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  game:GetService("Debris"):AddItem(effectsg, 2)
  if returnn then
    return effectsg
  end
  if not returnn then
    table.insert(Effects, {effectsg, "Cylinder", 0.2, 0.01, 0, 0.01, effectsmsh})
  end
end
MagicBlock = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type, parent)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  if Type == 1 or Type == nil then
    table.insert(Effects, {prt, "Block1", delay, x3, y3, z3, msh})
  else
    if Type == 2 then
      table.insert(Effects, {prt, "Block2", delay, x3, y3, z3, msh})
    else
      if Type == 3 then
        table.insert(Effects, {prt, "Block3", delay, x3, y3, z3, msh, prt.CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 0})
      end
    end
  end
end
MagicSkull = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, goe)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("SpecialMesh", prt, "FileMesh", "4770583", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Skull", delay, x3, y3, z3, msh, goe})
end
MagicCircle = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicCircle2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, push)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Blood", delay, x3, y3, z3, msh, push})
end
MagicCylinder = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicCylinder2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, goe)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder2", delay, x3, y3, z3, msh, goe})
end
MagicHead = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Head", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
ClangEffect = function(brickcolor, cframe, duration, decrease, size, power)
  local prt = part(3, workspace, 0, 1, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(5, 5, 5))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "CylinderClang", duration, decrease, size, power, prt.CFrame, nil})
end
MagicWave = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "FileMesh", "20329976", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicFire = function(brickcolor, cframe, x1, y1, z1, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Fire", delay, 1, 1, 1, msh})
end
MagicFireWave = function(brickcolor, cframe, x1, y1, z1)
  local prt = part(3, workspace, 0, 1, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  d = Instance.new("Decal")
  d.Parent = prt
  d.Texture = "http://www.roblox.com/asset/?id=26356434"
  d.Face = "Top"
  d = Instance.new("Decal")
  d.Parent = prt
  d.Texture = "http://www.roblox.com/asset/?id=26356434"
  d.Face = "Bottom"
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "FireWave", 1, 30, math.random(400, 600) / 100, msh})
end
ElecEffect = function(cff, x, y, z)
  local prt = part(3, workspace, 0, 0, BrickColor.new("Bright red"), "Part", vt(1, 1, 1))
  prt.Anchored = true
  prt.CFrame = cff * cf(math.random(-x, x), math.random(-y, y), math.random(-z, z))
  prt.CFrame = cf(prt.Position)
  game:GetService("Debris"):AddItem(prt, 10)
  xval = math.random() / 3
  yval = math.random() / 3
  zval = math.random() / 3
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(xval, yval, zval))
  Effects[#Effects + 1] = {prt, "Elec", 0.2, x, y, z, xval, yval, zval, msh}
end
CloneBody = function()
  for _,v in pairs(Torso.Parent:children()) do
    if v.className == "Part" and v.Name ~= "HumanoidRootPart" then
      local c = part(3, workspace, 0, 0.5, BrickColor.new("Really black"), "Effect", v.Size)
      c.Anchored = true
      c.CFrame = v.CFrame
      game:GetService("Debris"):AddItem(c, 5)
      if v.Name == "Head" then
        cmsh = mesh("SpecialMesh", c, "Head", "nil", vt(0, 0, 0), v.Mesh.Scale)
      end
      table.insert(Effects, {c, "Disappear", 0.05})
    end
  end
end
Clone = function(duration)
  for _,v in pairs(Torso.Parent:children()) do
    if v.className == "Part" and v.Name ~= "HumanoidRootPart" then
      local c = part(3, workspace, 0, 0, BrickColor.new("Really black"), "Effect", v.Size)
      c.Anchored = true
      c.CFrame = v.CFrame
      game:GetService("Debris"):AddItem(c, 5)
      if v.Name == "Head" then
        cmsh = mesh("SpecialMesh", c, "Head", "nil", vt(0, 0, 0), v.Mesh.Scale)
      end
      table.insert(Effects, {c, "Disappear", duration})
    else
      do
        do
          if v.className == "Hat" then
            n = v.Handle:clone()
            n:BreakJoints()
            n.archivable = true
            n.Anchored = true
            n.CanCollide = false
            n.Name = "Effect"
            n.BrickColor = BrickColor.new("Really black")
            n.Parent = workspace
            n.CFrame = v.Handle.CFrame
            n.Transparency = 0
            n:BreakJoints()
            table.insert(Effects, {n, "Disappear", duration})
          end
          -- DECOMPILER ERROR at PC108: LeaveBlock: unexpected jumping out DO_STMT

          -- DECOMPILER ERROR at PC108: LeaveBlock: unexpected jumping out IF_ELSE_STMT

          -- DECOMPILER ERROR at PC108: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
  end
  for _,v in pairs(modelzorz:children()) do
    if v.className == "Part" and v.Name ~= "Hitbox" and v.Name ~= "Hitbox2" then
      n = v:clone()
      for _,b in pairs(n:children()) do
        if b.className == "Motor" then
          b.Parent = nil
        end
      end
      n.archivable = true
      n.Anchored = true
      n.CanCollide = false
      n.Name = "Effect"
      n.BrickColor = BrickColor.new("Really black")
      n.Parent = workspace
      n.CFrame = v.CFrame
      n.Transparency = 0
      n:BreakJoints()
      table.insert(Effects, {n, "Disappear", duration})
    end
  end
end
Cloak = function()
  so("2767090", Torso, 1, 1)
  Face.Parent = nil
  Clone(0.02)
  for _,v in pairs(Torso.Parent:children()) do
    do
      if v.className == "Part" and v.Name ~= "HumanoidRootPart" then
        coroutine.resume(coroutine.create(function()
    for i = 0, 1, 0.1 do
      wait()
      v.Transparency = v.Transparency + 0.1
    end
    v.Transparency = 1
  end))
      end
      if v.className == "Hat" then
        do
          hatp = v.Handle
          coroutine.resume(coroutine.create(function(derp)
    for i = 0, 1, 0.1 do
      wait()
      derp.Transparency = derp.Transparency + 0.1
    end
    derp.Transparency = 1
  end), hatp)
          -- DECOMPILER ERROR at PC45: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC45: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
  end
  for _,v in pairs(modelzorz:children()) do
    if v.className == "Part" and v.Name ~= "Hitbox" and v.Name ~= "Hitbox2" then
      coroutine.resume(coroutine.create(function()
    for i = 0, 1, 0.1 do
      wait()
      v.Transparency = v.Transparency + 0.1
    end
    v.Transparency = 1
  end))
    end
  end
end
UnCloak = function()
  so("2767090", Torso, 1, 1.1)
  Face.Parent = Head
  for _,v in pairs(Torso.Parent:children()) do
    do
      if v.className == "Part" and v.Name ~= "HumanoidRootPart" then
        coroutine.resume(coroutine.create(function()
    for i = 0, 1, 0.1 do
      wait()
      v.Transparency = v.Transparency - 0.1
    end
    v.Transparency = 0
  end))
      end
      if v.className == "Hat" then
        do
          hatp = v.Handle
          coroutine.resume(coroutine.create(function(derp)
    for i = 0, 1, 0.1 do
      wait()
      derp.Transparency = derp.Transparency - 0.1
    end
    derp.Transparency = 0
  end), hatp)
          -- DECOMPILER ERROR at PC43: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC43: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
  end
  for _,v in pairs(modelzorz:children()) do
    if v.className == "Part" and v.Name ~= "Hitbox" and v.Name ~= "Hitbox2" then
      coroutine.resume(coroutine.create(function()
    for i = 0, 1, 0.1 do
      wait()
      v.Transparency = v.Transparency - 0.1
    end
    for i = 0, 1, 0.3 do
      wait()
      v.Transparency = 0
    end
  end))
    end
  end
end
Damagefunc = function(hit, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
  if hit.Parent == nil then
    return 
  end
  if hit.Name == "Hitbox" and hit.Parent ~= modelzorz and ranged ~= true then
    ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
    ref.Anchored = true
    ref.CFrame = cf(hit.Position)
    game:GetService("Debris"):AddItem(ref, 1)
    hitnum = math.random(1, 5)
    if hitnum == 1 then
      so("199148971", ref, 1, 1)
    else
      if hitnum == 2 then
        so("199149025", ref, 1, 1)
      else
        if hitnum == 3 then
          so("199149072", ref, 1, 1)
        else
          if hitnum == 4 then
            so("199149109", ref, 1, 1)
          else
            if hitnum == 5 then
              so("199149119", ref, 1, 1)
            end
          end
        end
      end
    end
    StaggerHit.Value = true
  end
  h = hit.Parent:FindFirstChild("Humanoid")
  if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
    if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
      return 
    end
    if Player.Neutral == false then
      if hit.Parent:findFirstChild("Alignment") ~= nil and hit.Parent.Alignment.Value == Player.TeamColor.Color then
        return 
      end
      if game.Players:GetPlayerFromCharacter(hit.Parent) ~= nil and game.Players:GetPlayerFromCharacter(hit.Parent).TeamColor == Player.TeamColor then
        return 
      end
    end
    c = Instance.new("ObjectValue")
    c.Name = "creator"
    c.Value = game:service("Players").LocalPlayer
    c.Parent = h
    RecentEnemy.Value = hit.Parent
    game:GetService("Debris"):AddItem(c, 0.5)
    if doing4 == false then
      minim = minim * Atk.Value
      maxim = maxim * Atk.Value
    end
    Damage = 0
    if minim == maxim then
      Damage = maxim
    else
      Damage = math.random(minim, maxim)
    end
    blocked = false
    enblock = nil
    Stats = hit.Parent:findFirstChild("Stats")
if Stats == nil then
	Character.Stats:Clone().Parent=hit.Parent
end
    if Stats ~= nil then
	Stats.Defense.Value=1
      invis = Stats:findFirstChild("Invisibility")
      if (ranged == false or ranged == nil) and invis ~= nil then
        invis.Value = 0
      end
      enblock = Stats:findFirstChild("Block")
      if enblock ~= nil and enblock.Value == true then
        blocked = true
      end
      if Stats:findFirstChild("Defense") ~= nil then
        if doing2 ~= true and doing4 ~= true then
          local divide = Stats.Defense.Value
          Damage = Damage / divide
        end
          do
            Damage = Damage
            if Damage <= 3 and (ranged == false or ranged == nil) and blocked ~= true then
              hitnum = math.random(1, 5)
              if hitnum == 1 then
                so("199149321", hit, 1, 1)
              else
                if hitnum == 2 then
                  so("199149338", hit, 1, 1)
                else
                  if hitnum == 3 then
                    so("199149367", hit, 1, 1)
                  else
                    if hitnum == 4 then
                      so("199149409", hit, 1, 1)
                    else
                      if hitnum == 5 then
                        so("199149452", hit, 1, 1)
                      end
                    end
                  end
                end
              end
            else
              if ranged == false or ranged == nil and blocked ~= true then
                hitnum = math.random(1, 6)
                if hitnum == 1 then
                  so("199149137", hit, 1, 1)
                else
                  if hitnum == 2 then
                    so("199149186", hit, 1, 1)
                  else
                    if hitnum == 3 then
                      so("199149221", hit, 1, 1)
                    else
                      if hitnum == 4 then
                        so("199149235", hit, 1, 1)
                      else
                        if hitnum == 5 then
                          so("199149269", hit, 1, 1)
                        else
                          if hitnum == 6 then
                            so("199149297", hit, 1, 1)
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
            if Damage <= 3 and staghit == true and ranged ~= true then
              StaggerHit.Value = true
            end
            if Stats:findFirstChild("Stun") ~= nil then
              if blocked == true then
                incstun = incstun / 2
              end
              if Stats.Stun.Value < Stats.StunThreshold.Value then
                Stats.Stun.Value = Stats.Stun.Value + incstun
              end
            end
            if Stats:findFirstChild("Stagger") ~= nil and stagger == true then
              Stats.Stagger.Value = true
            end
            if blocked == true then
              showDamage(hit.Parent, "Block", "Damage")
              if ranged ~= true then
                enblock.Value = false
                Stagger.Value = true
                hitnum = math.random(1, 2)
                if hitnum == 1 then
                  so("199148933", hit, 1, 1)
                else
                  if hitnum == 2 then
                    so("199148947", hit, 1, 1)
                  end
                end
              end
            else
              Damage = math.floor(Damage)
              if hit.Parent:findFirstChild("Mark") == nil then
                d = it("BoolValue", hit.Parent)
                d.Name = "Mark"
                b = it("NumberValue", d)
                b.Name = "MarkTime"
                b.Value = 200
                v = it("NumberValue", d)
                v.Name = "MarkValue"
                v.Value = 0
                if doing4 == true then
                  v.Value = 10
                end
                sz = it("NumberValue", d)
                sz.Name = "MarkSize"
                sz.Value = 5
                st = it("StringValue", d)
                st.Name = "MarkType"
                st.Value = "Adjudicator"
                local tehpart = hit.Parent:findFirstChild("HumanoidRootPart")
                if tehpart == nil then
                  tehpart = hit.Parent:findFirstChild("Torso")
                end
                if hit.Parent.Name == "Neflhelm" then
                  tehpart = hit
                end
                if tehpart ~= nil then
                  markgui = it("BillboardGui", tehpart)
                  markgui.Name = "Mark Gui"
                  markgui.Size = UDim2.new(7, 0, 7, 0)
                  markgui.StudsOffset = vt(0, 10, 0)
                  markgui.AlwaysOnTop = true
                  markscy = it("ImageLabel", markgui)
                  markscy.Name = "Scythe"
                  markscy.BackgroundTransparency = 1
                  markscy.Image = "rbxassetid://258927927"
                  markscy.ImageColor3 = Color3.new(1, 0, 0)
                  markscy.Size = UDim2.new(1, 0, 1, 0)
                  table.insert(MarkedGUI, {markgui, markscy})
                end
                table.insert(Marked, {d, b, v, sz})
              else
                  mark = hit.Parent:findFirstChild("Mark")
                  if mark:findFirstChild("MarkTime") ~= nil then
                    mark.MarkTime.Value = 700
                  end
                  if mark:findFirstChild("MarkValue") ~= nil then
                    if mark.MarkValue.Value >= 10 then
                      if mark:findFirstChild("MarkTime") ~= nil then
                        mark.MarkTime.Value = 400
                      end
                      if mark.MarkType.Value == "Classic" then
                        mark.Parent = nil
                        Damage = Damage * 2
                        print("double damage")
                        if hit.Parent:findFirstChild("HumanoidRootPart") ~= nil then
                          ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
                          ref.Anchored = true
                          ref.CFrame = hit.Parent.HumanoidRootPart.CFrame
                          game:GetService("Debris"):AddItem(ref, 5)
                          local nr = NumberRange.new
                          local ns = NumberSequence.new
                          local cs = ColorSequence.new
                          local parti = it("ParticleEmitter")
                          parti.Color = cs(NewCol, Color3.new(0, 0, 0))
                          parti.LightEmission = 0
                          parti.Size = ns(10)
                          parti.Texture = "http://www.roblox.com/asset/?id=243660364"
                          transseq = ns({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 1)})
                          parti.Transparency = transseq
                          parti.ZOffset = 1
                          parti.Acceleration = vt(0, 0, 0)
                          parti.Lifetime = nr(1)
                          parti.Rate = 20
                          parti.Rotation = nr(0, 360)
                          parti.Speed = nr(0)
                          parti.VelocitySpread = 0
                          parti.Parent = ref
                          parti.Enabled = true
                          table.insert(Effects, {parti, "PartiEmi", 20})
                          markscy = it("ImageLabel", markgui)
                          markscy.Name = "Scythe"
                          markscy.BackgroundTransparency = 1
                          markscy.Image = "rbxassetid://258927926"
                          markscy.ImageColor3 = Color3.new(1, 0, 0)
                          markscy.Size = UDim2.new(1, 0, 1, 0)
                          table.insert(Effects, {markgui, "AdjuEff", 10, markscy})
                        end
                      elseif mark.MarkType.Value == "Adjudicator" and hit.Parent:findFirstChild("HumanoidRootPart") ~= nil then
                            da = math.random(1, 4)
                            inc = 1
                            if doing2 == true then
                              inc = 2
                            end
                            if da == 1 then
                              DecreaseStat(Character, "Damage", -math.random(6, 10) / 100 * inc, 150, true)
                              DecreaseStat(Character, "Movement", -math.random(2, 6) / 100 * inc, 200, true)
                            else
                              if da == 2 then
                                DecreaseStat(Character, "Defense", -math.random(2, 6) / 100 * inc, 150, true)
                                DecreaseStat(Character, "Movement", -math.random(2, 6) / 100 * inc, 200, true)
                              else
                                if da == 3 then
                                  DecreaseStat(hit.Parent, "Damage", math.random(6, 10) / 100 * inc, 150, true)
                                  DecreaseStat(hit.Parent, "Movement", math.random(1, 3) / 100 * inc, 200, true)
                                else
                                  if da == 4 then
                                    DecreaseStat(hit.Parent, "Defense", math.random(2, 6) / 100 * inc, 150, true)
                                    DecreaseStat(hit.Parent, "Movement", math.random(1, 3) / 100 * inc, 200, true)
                                  end
                                end
                              end
                            end
                            ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
                            ref.Anchored = true
                            ref.CFrame = hit.Parent.HumanoidRootPart.CFrame
                            game:GetService("Debris"):AddItem(ref, 5)
                            markgui = it("BillboardGui", ref)
                            markgui.Name = "Mark Gui"
                            markgui.Size = UDim2.new(7, 0, 7, 0)
                            markgui.StudsOffset = vt(0, 10, 0)
                            markgui.AlwaysOnTop = true
                            markscy = it("ImageLabel", markgui)
                            markscy.Name = "Scythe"
                            markscy.BackgroundTransparency = 1
                            markscy.Image = "rbxassetid://258857562"
                            markscy.ImageColor3 = Color3.new(1, 0, 0)
                            markscy.Size = UDim2.new(1, 0, 1, 0)
                            table.insert(Effects, {markgui, "AdjuEff", 10, markscy})
                          end
                          elseif --[[mark.MarkType.Value ~= "Thanatos" or --]]doing4 == true then
                            mark.MarkValue.Value = 10
                          else
                            mark.MarkValue.Value = mark.MarkValue.Value + 1
                          end
end
                          if mark:findFirstChild("MarkSize") ~= nil then
                            mark.MarkSize.Value = 5
                          end
                          coroutine.resume(coroutine.create(function(Hum, Dam)
    hit.Parent.Humanoid:TakeDamage(Damage)
  end), h, Damage)
                          pursuitnum = 0
                          if isinvis.Value == false then
                            invisnum.Value = math.floor(invisnum.Value + math.random(4, 8) + Damage / 5)
                          end
                          showDamage(hit.Parent, Damage, "Damage")
                          if DecreaseState ~= nil then
                            DecreaseStat(hit.Parent, DecreaseState, DecreaseAmount, Duration)
                          end
                          if Type == "NormalDecreaseMvmt1" then
                            DecreaseStat(hit.Parent, "Movement", 0.1, 200)
                          end
                          if Type == "Knockdown" then
                            hum = hit.Parent.Humanoid
                            hum.PlatformStand = true
                            coroutine.resume(coroutine.create(function(HHumanoid)
    swait(1)
    HHumanoid.PlatformStand = false
  end), hum)
                            local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
                            local bodvol = Instance.new("BodyVelocity")
                            bodvol.velocity = angle * knockback
                            bodvol.P = 500
                            bodvol.maxForce = Vector3.new(2000, 2000, 2000)
                            bodvol.Parent = hit
                            rl = Instance.new("BodyAngularVelocity")
                            rl.P = 3000
                            rl.maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000
                            rl.angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10))
                            rl.Parent = hit
                            game:GetService("Debris"):AddItem(bodvol, 0.5)
                            game:GetService("Debris"):AddItem(rl, 0.5)
                          else
                            do
                              if Type == "Knockdown2" then
                                hum = hit.Parent.Humanoid
                                local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
                                local bodvol = Instance.new("BodyVelocity")
                                bodvol.velocity = angle * knockback
                                bodvol.P = 500
                                bodvol.maxForce = Vector3.new(2000, 2000, 2000)
                                bodvol.Parent = hit
                                game:GetService("Debris"):AddItem(bodvol, 0.5)
                              else
                                do
                                  if Type == "Normal" or Type == "NormalDecreaseMvmt1" then
                                    vp = Instance.new("BodyVelocity")
                                    vp.P = 500
                                    vp.maxForce = Vector3.new(math.huge, 0, math.huge)
                                    if KnockbackType == 1 then
                                      vp.velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
                                    else
                                      if KnockbackType == 2 then
                                        vp.velocity = Property.CFrame.lookVector * knockback
                                      end
                                    end
                                    game:GetService("Debris"):AddItem(vp, 0.5)
                                    if knockback > 0 then
                                      vp.Parent = hit.Parent.Torso
                                    end
                                  end
                                  debounce = Instance.new("BoolValue")
                                  debounce.Name = "DebounceHit"
                                  debounce.Parent = hit.Parent
                                  debounce.Value = true
                                  game:GetService("Debris"):AddItem(debounce, Delay)
                                  c = Instance.new("ObjectValue")
                                  c.Name = "creator"
                                  c.Value = Player
                                  c.Parent = h
                                  game:GetService("Debris"):AddItem(c, 0.5)
                                  CRIT = false
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
         -- end
        --end
      --end
    --end
  --end
showDamage = function(Char, Dealt, Type)
  m = Instance.new("Model")
  m.Name = "Effect"
  c = Instance.new("Part")
  c.Transparency = 1
  c.Name = "Head"
  c.TopSurface = 0
  c.BottomSurface = 0
  c.formFactor = "Plate"
  c.Size = Vector3.new(1, 0.4, 1)
  b = Instance.new("BillboardGui", c)
  b.Size = UDim2.new(5, 0, 5, 0)
  b.AlwaysOnTop = true
  damgui = gui("TextLabel", b, tostring(Dealt), 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
  if Type == "Damage" then
    damgui.Font = "SourceSans"
    if Dealt == "Block" then
      damgui.TextColor3 = BrickColor.new("Bright blue").Color
    else
      if Dealt < 3 then
        damgui.TextColor3 = BrickColor.new("White").Color
      else
        if Dealt >= 3 and Dealt < 20 then
          damgui.TextColor3 = BrickColor.new("Bright yellow").Color
        else
          damgui.TextColor3 = BrickColor.new("Really red").Color
          damgui.Font = "SourceSansBold"
        end
      end
    end
  else
    if Type == "Debuff" then
      damgui.TextColor3 = BrickColor.new("White").Color
    else
      if Type == "Interrupt" then
        damgui.TextColor3 = BrickColor.new("New Yeller").Color
      end
    end
  end
  damgui.TextScaled = true
  ms = Instance.new("CylinderMesh")
  ms.Scale = Vector3.new(0.8, 0.8, 0.8)
  ms.Parent = c
  c.Reflectance = 0
  Instance.new("BodyGyro").Parent = c
  c.Parent = m
  if Char:findFirstChild("Head") ~= nil then
    c.CFrame = cf(Char.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
  else
    if Char.Parent:findFirstChild("Head") ~= nil then
      c.CFrame = cf(Char.Parent.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
    end
  end
  f = Instance.new("BodyPosition")
  f.P = 2000
  f.D = 100
  f.maxForce = Vector3.new(545000, 545000, 545000)
  if Type == "Damage" then
    f.position = c.Position + Vector3.new(0, 3, 0)
  else
    if Type == "Debuff" or Type == "Interrupt" then
      f.position = c.Position + Vector3.new(0, 5, 0)
    end
  end
  f.Parent = c
  game:GetService("Debris"):AddItem(m, 5)
  table.insert(Effects, {m, "showDamage", damgui, f, 10, 1, 15, 50, 100})
  c.CanCollide = false
  m.Parent = workspace
  c.CanCollide = false
end
combo = 0
ob1d = function(mouse)
  if attack == true or equipped == false then
    return 
  end
  hold = true
  if combo == 0 then
    combo = 1
    attackone()
  else
    if combo == 1 then
      combo = 2
      attacktwo()
    else
      if combo == 2 then
        combo = 3
        attackthree()
      else
        if combo == 3 then
          combo = 0
          attackfour()
        end
      end
    end
  end
  coroutine.resume(coroutine.create(function()
    for i = 1, 50 do
      if attack == false then
        swait()
      end
    end
    if attack == false then
      combo = 0
    end
  end))
end
ob1u = function(mouse)
  hold = false
end
buttonhold = false
fenbarmove1.MouseButton1Click:connect(do1)
fenbarmove2.MouseButton1Click:connect(do2)
fenbarmove3.MouseButton1Click:connect(do3)
fenbarmove4.MouseButton1Click:connect(do4)
eul = 0
equipped = false
key = function(key)
  if attack == true then
    return 
  end
  if key == "f" then
    pressedf = true
    fnumb = 0
    attack = true
    if equipped == false then
      equipped = true
      RSH = ch.Torso["Right Shoulder"]
      LSH = ch.Torso["Left Shoulder"]
      RSH.Parent = nil
      LSH.Parent = nil
      RW.Name = "Right Shoulder"
      RW.Part0 = ch.Torso
      RW.C0 = cf(1.5, 0.5, 0)
      RW.C1 = cf(0, 0.5, 0)
      RW.Part1 = ch["Right Arm"]
      RW.Parent = ch.Torso
      LW.Name = "Left Shoulder"
      LW.Part0 = ch.Torso
      LW.C0 = cf(-1.5, 0.5, 0)
      LW.C1 = cf(0, 0.5, 0)
      LW.Part1 = ch["Left Arm"]
      LW.Parent = ch.Torso
      Animate.Parent = nil
      equipanim()
    else
      equipped = false
      hideanim()
      LH.C1 = LHC1
      RH.C1 = RHC1
      Animate.Parent = Humanoid
      swait(0)
      RW.Parent = nil
      LW.Parent = nil
      RSH.Parent = player.Character.Torso
      LSH.Parent = player.Character.Torso
    end
    attack = false
  end
  if equipped == false then
    return 
  end
  if key == "e" and invisnum.Value > 5 then
    Invisibility()
  end
  if key == "z" then
    do1()
  end
  if key == "x" then
    do2()
  end
  if key == "c" then
    do3()
  end
  if key == "v" then
    do4()
  end
end
key2 = function(key)
end
s = function(mouse)
  mouse.Button1Down:connect(function()
    ob1d(mouse)
  end)
  mouse.Button1Up:connect(function()
    ob1u(mouse)
  end)
  mouse.KeyDown:connect(key)
  mouse.KeyUp:connect(key2)
  player = Player
  ch = Character
  MMouse = mouse
end
ds = function(mouse)
end
Bin.Selected:connect(s)
Bin.Deselected:connect(ds)
print("Renegade loaded.")
local mananum = 0
local donum = 0
local stunnum = 0
local staggeranim = false
local stunanim = false
local Point, LastPoint = nil, nil
local passivenum = 100
local pnum2 = 0
local walk = 0
local walkforw = true
local addpassive = 0
local gashnum = 0
while true do
  swait()
  if Humanoid.Health <= 0 then
    attack = true
    for i = 1, #Marked do
      if MarkedGUI[i] ~= nil and MarkedGUI[i][1] ~= nil then
        MarkedGUI[i][1].Parent = nil
      end
      table.remove(MarkedGUI, i)
      table.remove(Marked, i)
    end
    resumeControl()
    modelzorz.Parent = workspace
    game:GetService("Debris"):AddItem(modelzorz, 30)
    for i = 1, #Weapon do
      Weapon[i].Parent = modelzorz
      Weapon[i].CanCollide = true
    end
    for i = 1, #Welds do
      if Welds[i].Part0.Parent == Character or Welds[i].Part1.Parent == Character then
        Welds[i].Parent = nil
      else
        Welds[i].Parent = prt1
      end
    end
  end
  do
    if fnumb < 21 then
      fnumb = fnumb + 1
      if pressedf == false then
        fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency - 0.025
        tellbar.TextTransparency = tellbar.TextTransparency - 0.05
        tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency - 0.05
      else
        if fnumb == 20 then
          fenframe5.Parent = nil
          print("daigui")
        end
        fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency + 0.025
        tellbar.TextTransparency = tellbar.TextTransparency + 0.05
        tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency + 0.05
      end
    end
    if hbwld.Parent == nil then
      hitbox2.Name = "Hitbox"
    else
      hitbox2.Name = "Hitbox2"
    end
    if doing2 == true then
      gashnum = gashnum + 1
      if (gashnum) % 10 == 0 then
        if 0 < mana.Value then
        else
          do2()
        end
      end
      MagicBlock(BrickColor.new("Really black"), prt6.CFrame * euler(-0.3, 0, 0) * cf(0, 0, -2.2) * cf(0, math.random(-100, 100) / 100, math.random(-200, 200) / 100), 0.5, 0.5, 0.5, 0.2, 0.2, 0.2, 0.15, 3)
    end
    hitbox2.Parent = hitbox.Parent
    hitbox2.Size = hitbox.Size
    hitbox2.CFrame = hitboxCF
    hboxpos.position = hitbox2.Position + vt(math.random(-100, 100) / 100, math.random(-100, 100) / 100, math.random(-100, 100) / 100)
    hitbox.Transparency = 1
    hitbox2.Transparency = 1
    for i = 1, #Marked do
      if Marked[i] ~= nil then
        if Marked[i][1].Parent == nil then
          MarkedGUI[i][1].Parent = nil
          table.remove(MarkedGUI, i)
          table.remove(Marked, i)
        else
          if MarkedGUI[i][1].Parent ~= nil then
            MarkedGUI[i][1].Size = UDim2.new(7 + Marked[i][4].Value, 0, 7 + Marked[i][4].Value, 0)
            if 0 < Marked[i][4].Value then
              Marked[i][4].Value = Marked[i][4].Value - 1
            end
            if MarkedGUI[i][2].Parent ~= nil then
              if Marked[i][3].Value == 0 then
                MarkedGUI[i][2].Image = "rbxassetid://258927926"
              else
                if Marked[i][3].Value == 1 then
                  MarkedGUI[i][2].Image = "rbxassetid://258857647"
                else
                  if Marked[i][3].Value == 2 then
                    MarkedGUI[i][2].Image = "rbxassetid://258857606"
                  else
                    if Marked[i][3].Value == 3 then
                      MarkedGUI[i][2].Image = "rbxassetid://258857560"
                    else
                      if Marked[i][3].Value == 4 then
                        MarkedGUI[i][2].Image = "rbxassetid://258857560"
                      else
                        if Marked[i][3].Value == 5 then
                          MarkedGUI[i][2].Image = "rbxassetid://258857513"
                        else
                          if Marked[i][3].Value == 6 then
                            MarkedGUI[i][2].Image = "rbxassetid://258857482"
                          else
                            if Marked[i][3].Value == 7 then
                              MarkedGUI[i][2].Image = "rbxassetid://258857449"
                            else
                              if Marked[i][3].Value == 8 then
                                MarkedGUI[i][2].Image = "rbxassetid://258857415"
                              else
                                if Marked[i][3].Value == 9 then
                                  MarkedGUI[i][2].Image = "rbxassetid://258857385"
                                else
                                  if Marked[i][3].Value == 10 then
                                    MarkedGUI[i][2].Image = "rbxassetid://258857385"
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
          if Marked[i][2] ~= nil then
            Marked[i][2].Value = Marked[i][2].Value - 1
            if Marked[i][2].Value <= 0 then
              Marked[i][1].Parent = nil
              MarkedGUI[i][1].Parent = nil
              table.remove(MarkedGUI, i)
              table.remove(Marked, i)
            end
          end
        end
      end
    end
    scarfp2.CFrame = cf(RootPart.Position, testpart.Position) * cf(0, 0, 0)
    scarfp2.CFrame = scarfp2.CFrame + scarfp2.CFrame.lookVector * 0.5
    scarfp2.CFrame = scarfp2.CFrame * cf(0, 0, 0) * euler(1.57, 0, 0)
    testpart.CFrame = cf(RootPart.Position - RootPart.Velocity) * cf(0, 1, 0)
    if invisible == true then
      addpassive = addpassive + 1
      for i = 1, 1 do
        MagicCircle2(BrickColor.new("Black"), scarfp2.CFrame * euler(0, 0, math.rad(180)) * cf(math.random(-300, 300) / 100, math.random(-200, 200) / 100, math.random(-300, 300) / 100), 1.5, 10, 1.5, -0.2, 1, -0.2, 0.2)
      end
      if 50 <= addpassive then
        addpassive = 0
        for _,c in pairs(workspace:children()) do
          local hum = (c:findFirstChild("Humanoid"))
          if hum ~= nil then
            local head = nil
            for _,d in pairs(c:children()) do
              if d.Name == "HumanoidRootPart" then
                local targ = d.Position - RootPart.Position
                local mag = targ.magnitude
                if mag <= 60 and c.Name ~= Player.Name then
                  mark = d.Parent:findFirstChild("Mark")
                  if mark ~= nil then
                    if (mark:findFirstChild("MarkTime")) ~= nil then
                      mark.MarkTime.Value = 500
                    end
                    if (mark:findFirstChild("MarkValue")) ~= nil then
                      if (mark:findFirstChild("MarkSize")) ~= nil then
                        mark.MarkSize.Value = 5
                      end
                      if mark.MarkValue.Value < 10 then
                        mark.MarkValue.Value = mark.MarkValue.Value + 1
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    do
      pursuitnum = pursuitnum + 1
      if 13 <= passivenum and 150 < pursuitnum and 0 < invisnum.Value then
        invisnum.Value = invisnum.Value - 1
        passivenum = 0
      end
      if 8 <= passivenum and invisible == true then
        invisnum.Value = invisnum.Value - 1
        pursuitnum = 0
        passivenum = 0
      end
      if 100 <= invisnum.Value then
        invisnum.Value = 100
      end
      if invisible == true and invisnum.Value <= 0 then
        Invisibility()
      end
      passivenum = passivenum + 1
      if Stagger.Value == true and staggeranim == false then
        coroutine.resume(coroutine.create(function()
  staggeranim = true
  while attack == true do
    swait()
  end
  StaggerAnim()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end))
      end
      if StaggerHit.Value == true and staggeranim == false then
        coroutine.resume(coroutine.create(function()
  staggeranim = true
  while attack == true do
    swait()
  end
  StaggerHitt()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end))
      end
      if Mvmt.Value < 0 or Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true or Rooted.Value == true then
        Humanoid.WalkSpeed = 0
      else
        Humanoid.WalkSpeed = 16 * Mvmt.Value
      end
      if StunT.Value <= Stun.Value and stunanim == false then
        coroutine.resume(coroutine.create(function()
  stunanim = true
  while attack == true do
    swait()
  end
  StunAnim()
  Stun.Value = 0
  stunanim = false
end))
      end
      local stunnum2 = 30
      if stunnum2 <= stunnum then
        if 0 < Stun.Value then
          Stun.Value = Stun.Value - 1
        end
        stunnum = 0
      end
      stunnum = stunnum + 1
      if 0.5 <= donum then
        handidle = true
      else
        if donum <= 0 then
          handidle = false
        end
      end
      if handidle == false then
        donum = donum + 0.003
      else
        donum = donum - 0.003
      end
      local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
      local velderp = RootPart.Velocity.y
      hitfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
      if equipped == true then
        if attack == false then
          idle = idle + 1
        else
          idle = 0
        end
        if (500 <= idle and attack ~= false) or Anim == "Walk" then
          if walkforw == true then
            RH.C1 = clerp(RH.C1, RHC1 * cf(0.2, -0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
            LH.C1 = clerp(LH.C1, LHC1 * cf(0.1, 0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
          else
            RH.C1 = clerp(RH.C1, RHC1 * cf(-0.1, 0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
            LH.C1 = clerp(LH.C1, LHC1 * cf(-0.2, -0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
          end
        else
          RH.C1 = clerp(RH.C1, RHC1, 0.2)
          LH.C1 = clerp(LH.C1, LHC1, 0.2)
        end
        if 1 < RootPart.Velocity.y and hitfloor == nil then
          Anim = "Jump"
          if attack == false then
            handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.2)
            wld1.C0 = clerp(wld1.C0, cf(0, -2, 0) * euler(0.3, 0, -0.1), 0.2)
            Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0), 0.2)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.5, 0, 0.5), 0.2)
            RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-1, 0, -0.2), 0.2)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
            RH.C0 = clerp(RH.C0, cf(1, -1, -0.3) * euler(-0.5, 1.57, 0) * euler(-0.2, 0, 0), 0.2)
            LH.C0 = clerp(LH.C0, cf(-1, -1, -0.3) * euler(-0.5, -1.57, 0) * euler(-0.2, 0, 0), 0.2)
          end
        else
          if RootPart.Velocity.y < -1 and hitfloor == nil then
            Anim = "Fall"
            if attack == false then
              handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.2)
              wld1.C0 = clerp(wld1.C0, cf(0, -2, 0) * euler(0.3, 0, -0.1), 0.2)
              Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, 0), 0.2)
              RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
              RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 1), 0.2)
              RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
              LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.3, 0, -0.2), 0.2)
              LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
              RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0.4, 1.57, 0), 0.2)
              LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(-0.2, -1.57, 0), 0.2)
            end
          else
            if torvel < 1 and hitfloor ~= nil then
              Anim = "Idle"
              if attack == false then
                handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.2)
                wld1.C0 = clerp(wld1.C0, euler(0, -0.4 - (donum) / 2, 0) * cf(0, -2, 0) * euler(1, 0, 0), 0.2)
                Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1) * euler(0.2, 0, 0), 0.15)
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 1), 0.15)
                RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(2 + (donum) / 3, 0, 0.5 - (donum) / 3) * euler(0, 2.1, 0), 0.15)
                RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.15)
                LW.C0 = clerp(LW.C0, cf(-1.3 - (donum) / 3, 0.5, -0.4 + (donum) / 3) * euler(0.7 + (donum) / 6, 0, 0.4 + (donum) / 6) * euler(0, -1.57, 0), 0.15)
                LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.15)
                RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.3) * euler(0, 1.57, 0) * euler(0, -1, -0.1), 0.2)
                LH.C0 = clerp(LH.C0, cf(-0.8, -1, -0.3) * euler(0, -1.57, 0) * euler(0, -1, 0.3), 0.2)
              end
            else
              if 2 < torvel and torvel < 30 and hitfloor ~= nil then
                Anim = "Walk"
                walk = walk + 1
                if 15 - 5 * Mvmt.Value <= walk then
                  walk = 0
                  if walkforw == true then
                    walkforw = false
                  else
                    if walkforw == false then
                      walkforw = true
                    end
                  end
                end
                if attack == false then
                  handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.2)
                  wld1.C0 = clerp(wld1.C0, cf(0, -2, 0) * euler(0.3, 0, -0.3), 0.2)
                  Neck.C0 = clerp(Neck.C0, necko * euler(0.2 - (donum) / 5, 0, 0), 0.2)
                  RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
                  RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.3 + (donum) / 3, 0, 0.5 - (donum) / 3), 0.2)
                  RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                  LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2 + (donum) / 3, 0, -0.4 + (donum) / 3), 0.2)
                  LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                  RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0), 0.2)
                  LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0), 0.2)
                end
              else
                if 30 <= torvel and hitfloor ~= nil then
                  Anim = "Walk"
                  walk = walk + 1
                  if 15 - 5 * Mvmt.Value <= walk then
                    walk = 0
                    if walkforw == true then
                      walkforw = false
                    else
                      if walkforw == false then
                        walkforw = true
                      end
                    end
                  end
                  if attack == false then
                    handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.2)
                    wld1.C0 = clerp(wld1.C0, cf(0, -2, 0) * euler(0.3, 0, -0.3), 0.2)
                    Neck.C0 = clerp(Neck.C0, necko * euler(0.2 - (donum) / 5, 0, 0), 0.2)
                    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
                    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.3 + (donum) / 3, 0, 0.5 - (donum) / 3), 0.2)
                    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2 + (donum) / 3, 0, -0.4 + (donum) / 3), 0.2)
                    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0), 0.2)
                    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0), 0.2)
                  end
                end
              end
            end
          end
        end
      end
      if 0 < #Effects then
        for e = 1, #Effects do
          if Effects[e] ~= nil then
            local Thing = Effects[e]
            if Thing ~= nil then
              local Part = Thing[1]
              local Mode = Thing[2]
              local Delay = Thing[3]
              local IncX = Thing[4]
              local IncY = Thing[5]
              local IncZ = Thing[6]
              if Thing[2] == "CylinderClang" then
                if Thing[3] <= 1 then
                  Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, 2.5 * Thing[5], 0) * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
                  Thing[7] = Thing[1].CFrame
                  effect("New Yeller", 0, Thing[8], Thing[7])
                  Thing[8] = Thing[7]
                  Thing[3] = Thing[3] + Thing[4]
                else
                  Part.Parent = nil
                  table.remove(Effects, e)
                end
              end
              if Thing[2] == "showDamage" then
                if Thing[6] < Thing[5] then
                  Thing[6] = Thing[6] + 1
                else
                  if Thing[6] < Thing[7] then
                    Thing[4].position = Thing[4].position + vt(0, -0.2, 0)
                    Thing[6] = Thing[6] + 1
                  else
                    if Thing[6] < Thing[8] then
                      Thing[6] = Thing[6] + 1
                    else
                      if Thing[6] < Thing[9] then
                        Thing[6] = Thing[6] + 1
                        Thing[4].position = Thing[4].position + vt(0, 0.2, 0)
                        Thing[3].TextStrokeTransparency = Thing[3].TextStrokeTransparency + 0.1
                        Thing[3].TextTransparency = Thing[3].TextTransparency + 0.1
                      else
                        Thing[1].Parent = nil
                        table.remove(Effects, e)
                      end
                    end
                  end
                end
              end
              if Thing[2] == "PartiEmi" then
                Thing[3] = Thing[3] - 1
                if Thing[3] <= 0 then
                  Thing[1].Enabled = false
                  table.remove(Effects, e)
                end
              end
              if Thing[2] == "AdjuEff" then
                if 0 < Thing[3] then
                  Thing[3] = Thing[3] - 1
                  Thing[1].Size = Thing[1].Size + UDim2.new(0.2, 0, 0.2, 0)
                  Thing[1].StudsOffset = Thing[1].StudsOffset + vt(0, -0.2, 0)
                  Thing[4].ImageTransparency = Thing[4].ImageTransparency + 0.1
                else
                  Thing[1].Parent = nil
                  table.remove(Effects, e)
                end
              end
              if Thing[2] ~= "Shoot" and Thing[2] ~= "DecreaseStat" and Thing[2] ~= "Wave" and Thing[2] ~= "FireWave" and Thing[2] ~= "showDamage" and Thing[2] ~= "PartiEmi" and Thing[2] ~= "AdjuEff" then
                if Thing[1].Transparency <= 1 then
                  if Thing[2] == "Block1" then
                    Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                    Mesh = Thing[7]
                    Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                    Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                  else
                    if Thing[2] == "Block2" then
                      Thing[1].CFrame = Thing[1].CFrame
                      Mesh = Thing[7]
                      Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                      Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                    else
                      if Thing[2] == "Block3" then
                        Thing[9] = Thing[9] + 0.5
                        Thing[1].CFrame = Thing[8] * cf(0, Thing[9], 0)
                        Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                        Mesh = Thing[7]
                        Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                        Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                      else
                        if Thing[2] == "Skull" then
                          Thing[1].CFrame = Thing[1].CFrame * cf(0, Thing[8] / 2, -Thing[8])
                          Mesh = Thing[7]
                          Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                          Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                        else
                          if Thing[2] == "Cylinder" then
                            Mesh = Thing[7]
                            Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                            Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                          else
                            if Thing[2] == "Cylinder2" then
                              Thing[1].CFrame = Thing[1].CFrame * cf(0, Thing[8], 0)
                              Mesh = Thing[7]
                              Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                              Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            else
                              if Thing[2] == "Blood" then
                                Mesh = Thing[7]
                                Thing[1].CFrame = Thing[1].CFrame * cf(0, 0.5, 0)
                                Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                              else
                                if Thing[2] == "Elec" then
                                  Mesh = Thing[10]
                                  Mesh.Scale = Mesh.Scale + vt(Thing[7], Thing[8], Thing[9])
                                  Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                else
                                  if Thing[2] == "Disappear" then
                                    Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                else
                  Part.Parent = nil
                  table.remove(Effects, e)
                end
              end
            end
          end
        end
      end
      do
        fenbarmana2:TweenSize((UDim2.new(0.4, 0, -4 * mana.Value / 100, 0)), nil, 1, 0.4, true)
        fenbarmana4.Text = "Mana(" .. mana.Value .. ")"
        fenbarhp2.BackgroundColor3 = Color3.new(Humanoid.Health / Humanoid.MaxHealth, 0, 0)
        fenbarhp2:TweenSize((UDim2.new(Humanoid.Health / Humanoid.MaxHealth, 0, 1, 0)), nil, 1, 0.4, true)
        fenbarhp3.Text = "(" .. math.floor(Humanoid.Health) .. ")"
        fenbarblock2:TweenSize((UDim2.new(0.4, 0, -4 * invisnum.Value / 100, 0)), nil, 1, 0.4, true)
        fenbarblock3.Text = "Pursuit(" .. invisnum.Value .. ")"
        fenbarmove1b:TweenSize((UDim2.new(1 * cooldowns[1] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
        fenbarmove2b:TweenSize((UDim2.new(1 * cooldowns[2] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
        fenbarmove3b:TweenSize((UDim2.new(1 * cooldowns[3] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
        fenbarmove4b:TweenSize((UDim2.new(1 * cooldowns[4] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
        for _,c in pairs(Decrease:children()) do
          if (c:findFirstChild("Duration")) ~= nil then
            c.Duration.Value = c.Duration.Value - 1
            if c.Duration.Value <= 0 then
              c.Parent = nil
            end
          end
          if c.Name == "DecreaseAtk" then
            decreaseatk = decreaseatk + c.Value
          else
            if c.Name == "DecreaseDef" then
              decreasedef = decreasedef + c.Value
            else
              if c.Name == "DecreaseMvmt" then
                decreasemvmt = decreasemvmt + c.Value
              end
            end
          end
        end
        Atk.Value = 1 - (decreaseatk)
        if Atk.Value <= 0 then
          Atk.Value = 0
        end
        Def.Value = 1 - (decreasedef)
        if Def.Value <= 0 then
          Def.Value = 0.01
        end
        Mvmt.Value = 1 - (decreasemvmt)
        if Mvmt.Value <= 0 then
          Mvmt.Value = 0
        end
        decreaseatk = 0
        decreasedef = 0
        decreasemvmt = 0
        AtkVal = Atk.Value * 100
        AtkVal = math.floor(AtkVal)
        AtkVal = AtkVal / 100
        fenbardamage.Text = "Damage\n(" .. AtkVal .. ")"
        DefVal = Def.Value * 100
        DefVal = math.floor(DefVal)
        DefVal = DefVal / 100
        fenbardef.Text = "Defense\n(" .. DefVal .. ")"
        MvmtVal = Mvmt.Value * 100
        MvmtVal = math.floor(MvmtVal)
        MvmtVal = MvmtVal / 100
        if Rooted.Value == true then
          MvmtVal = 0
        end
        fenbarmove.Text = "Walkspeed\n(" .. MvmtVal .. ")"
        if StunT.Value <= Stun.Value then
          fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4, 0)), nil, 1, 0.4, true)
        else
          fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4 * Stun.Value / StunT.Value, 0)), nil, 1, 0.4, true)
        end
        fenbarstun3.Text = "Stun(" .. Stun.Value .. ")"
        if 100 <= mana.Value then
          mana.Value = 100
        else
          if mananum <= 12 then
            mananum = mananum + 1
          else
            mananum = 0
            mana.Value = mana.Value + 1
          end
        end
        for i = 1, #cooldowns do
          if cooldownmax <= cooldowns[i] then
            cooldowns[i] = cooldownmax
          else
            cooldowns[i] = cooldowns[i] + cooldownsadd[i]
          end
        end
        -- DECOMPILER ERROR at PC6064: LeaveBlock: unexpected jumping out DO_STMT

        -- DECOMPILER ERROR at PC6064: LeaveBlock: unexpected jumping out DO_STMT

        -- DECOMPILER ERROR at PC6064: LeaveBlock: unexpected jumping out DO_STMT

      end
    end
  end
end

]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="HopperBin" referent="RBX6983B530A47941D5B8778A33F0E9C23D">
			<Properties>
				<bool name="Active">false</bool>
				<token name="BinType">0</token>
				<string name="Name">Proto</string>
				<Content name="TextureId"><null></null></Content>
			</Properties>
			<Item class="LocalScript" referent="RBX3FF61EF5D913487F850B0DCD139E0A6F">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LocalScript</string>
					<string name="ScriptGuid">{07BBE466-3C70-4E7E-93E2-C35AF43ECB67}</string>
					<ProtectedString name="Source"><![CDATA[Player = game:GetService("Players").LocalPlayer
Character = Player.Character
PlayerGui = Player.PlayerGui
Backpack = Player.Backpack
Torso = Character.Torso
Head = Character.Head
Humanoid = Character.Humanoid
LeftArm = Character["Left Arm"]
LeftLeg = Character["Left Leg"]
RightArm = Character["Right Arm"]
RightLeg = Character["Right Leg"]
LS = Torso["Left Shoulder"]
LH = Torso["Left Hip"]
RS = Torso["Right Shoulder"]
RH = Torso["Right Hip"]
Neck = Torso.Neck
it = Instance.new
vt = Vector3.new
cf = CFrame.new
euler = CFrame.fromEulerAnglesXYZ
angles = CFrame.Angles
necko = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
necko2 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
LHC0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
LHC1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
RHC0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RHC1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RootPart = Character.HumanoidRootPart
RootJoint = RootPart.RootJoint
RootCF = euler(-1.57, 0, 3.14)
attack = false
attackdebounce = false
MMouse = nil
combo = 0
local hitfloor, posfloor = nil, nil
local idle = 0
local Anim = "Idle"
local Effects = {}
local Weapon = {}
local Welds = {}
local decreaseatk = 0
local decreasedef = 0
local decreasemvmt = 0
local flight = false
local etheral = false
local overheat = 0
local move1 = "(Z)\nPunishment"
local move2 = "(X)\nReaping"
local move3 = "(C)\nCritical Stab"
local move4 = "(V)\nEtheral Blades"
local cooldowns = {}
local cooldown1 = 0
table.insert(cooldowns, cooldown1)
local cooldown2 = 0
table.insert(cooldowns, cooldown2)
local cooldown3 = 0
table.insert(cooldowns, cooldown3)
local cooldown4 = 0
table.insert(cooldowns, cooldown4)
local cooldownsadd = {}
local cooldownadd1 = 0.7
table.insert(cooldownsadd, cooldownadd1)
local cooldownadd2 = 0.3
table.insert(cooldownsadd, cooldownadd2)
local cooldownadd3 = 0.5
table.insert(cooldownsadd, cooldownadd3)
local cooldownadd4 = 0.06
table.insert(cooldownsadd, cooldownadd4)
local cooldownmax = 100
player = nil
RSH = nil
RW = Instance.new("Motor")
RW.Name = "Right Shoulder"
LW = Instance.new("Motor")
LW.Name = "Left Shoulder"
LH = Torso["Left Hip"]
RH = Torso["Right Hip"]
TorsoColor = Torso.BrickColor
TorsoRed = TorsoColor.Color.r
TorsoGreen = TorsoColor.Color.g
TorsoBlue = TorsoColor.Color.b
NewCol = Color3.new(1, 1, 1)
if Player:findFirstChild("Color1") ~= nil then
  NewCol = Player.Color1.Value
end
local mdec = Instance.new("NumberValue", Decrease)
mdec.Name = "DecreaseDef"
mdec.Value = 0.4
local mdec2 = Instance.new("NumberValue", Decrease)
mdec2.Name = "DecreaseMvmt"
mdec2.Value = 0.1
local Animate = Humanoid.Animator
local canjump = true
removeControl = function()
  canjump = false
end

resumeControl = function()
  canjump = true
end

Player.Character.Humanoid.Changed:connect(function()
  if canjump == false then
    Player.Character.Humanoid.Jump = false
  end
end
)
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
    tf = tf + s
    if tf >= frame then
        if allowframeloss then
            script.Heartbeat:Fire()
            lastframe = tick()
        else
            for i = 1, math.floor(tf / frame) do
                script.Heartbeat:Fire()
            end
            lastframe = tick()
        end
        if tossremainder then
            tf = 0
        else
            tf = tf - frame * math.floor(tf / frame)
        end
    end
end)

function swait(num)
    if num == 0 or num == nil then
        ArtificialHB.Event:wait()
    else
        for i = 0, num do
            ArtificialHB.Event:wait()
        end
    end
end

if Character:findFirstChild("Astray Unit", true) ~= nil then
  Character:findFirstChild("Astray Unit", true).Parent = nil
end
if Player.PlayerGui:findFirstChild("WeaponGUI", true) ~= nil then
  Player.PlayerGui:findFirstChild("WeaponGUI", true).Parent = nil
end
if Character:findFirstChild("Stats", true) ~= nil then
  Character:findFirstChild("Stats", true).Parent = nil
end
local Stats = Instance.new("BoolValue")
Stats.Name = "Stats"
Stats.Parent = Character
local Atk = Instance.new("NumberValue")
Atk.Name = "Damage"
Atk.Parent = Stats
Atk.Value = 1
local Def = Instance.new("NumberValue")
Def.Name = "Defense"
Def.Parent = Stats
Def.Value = 1
local Mvmt = Instance.new("NumberValue")
Mvmt.Name = "Movement"
Mvmt.Parent = Stats
Mvmt.Value = 1
local Block = Instance.new("BoolValue")
Block.Name = "Block"
Block.Parent = Stats
Block.Value = false
local Stun = Instance.new("NumberValue")
Stun.Name = "Stun"
Stun.Parent = Stats
Stun.Value = 0
local StunT = Instance.new("NumberValue")
StunT.Name = "StunThreshold"
StunT.Parent = Stats
StunT.Value = 100
local Rooted = Instance.new("BoolValue")
Rooted.Name = "Rooted"
Rooted.Parent = Stats
Rooted.Value = false
local Stunned = Instance.new("BoolValue")
Stunned.Name = "Stunned"
Stunned.Parent = Stats
Stunned.Value = false
local Stagger = Instance.new("BoolValue")
Stagger.Name = "Stagger"
Stagger.Parent = Stats
Stagger.Value = false
local StaggerHit = Instance.new("BoolValue")
StaggerHit.Name = "StaggerHit"
StaggerHit.Parent = Stats
StaggerHit.Value = false
local RecentEnemy = Instance.new("ObjectValue")
RecentEnemy.Name = "RecentEnemy"
RecentEnemy.Parent = Stats
RecentEnemy.Value = nil
local Decrease = Instance.new("BoolValue")
Decrease.Name = "Decrease"
Decrease.Parent = Stats
Decrease.Value = false
local mana = Instance.new("NumberValue")
mana.Name = "Mana"
mana.Parent = Stats
mana.Value = 0
local passive = Instance.new("NumberValue", Decrease)
passive.Name = "DecreaseAtk"
passive.Value = 0

NoOutline = function(Part)
Part.TopSurface = 10
Part.BottomSurface = 10
Part.RightSurface = 10
Part.LeftSurface = 10
Part.FrontSurface = 10
Part.BackSurface = 10
end

part = function(formfactor, parent, reflectance, transparency, brickcolor, name, size)
  local fp = it("Part")
  fp.formFactor = formfactor
  fp.Parent = parent
  fp.Reflectance = reflectance
  fp.Transparency = transparency
  fp.CanCollide = false
  fp.Locked = true
  fp.BrickColor = brickcolor
  fp.Name = name
  fp.Size = size
  fp.Position = Torso.Position
  NoOutline(fp)
  fp.Material = "SmoothPlastic"
  fp:BreakJoints()
  return fp
end

mesh = function(Mesh, part, meshtype, meshid, offset, scale)
  local mesh = it(Mesh)
  mesh.Parent = part
  if Mesh == "SpecialMesh" then
    mesh.MeshType = meshtype
    if meshid ~= "nil" then
      mesh.MeshId = "http://www.roblox.com/asset/?id=" .. meshid
    end
  end
  mesh.Offset = offset
  mesh.Scale = scale
  return mesh
end

weld = function(parent, part0, part1, c0)
  local weld = it("Motor")
  weld.Parent = parent
  weld.Part0 = part0
  weld.Part1 = part1
  weld.C0 = c0
  return weld
end

gui = function(GuiType, parent, text, backtrans, backcol, pos, size)
  local gui = it(GuiType)
  gui.Parent = parent
  gui.Text = text
  gui.BackgroundTransparency = backtrans
  gui.BackgroundColor3 = backcol
  gui.SizeConstraint = "RelativeXY"
  gui.TextXAlignment = "Center"
  gui.TextYAlignment = "Center"
  gui.Position = pos
  gui.Size = size
  gui.Font = "SourceSans"
  gui.FontSize = "Size14"
  gui.TextWrapped = false
  gui.TextStrokeTransparency = 0
  gui.TextColor = BrickColor.new("White")
  return gui
end

local Color1 = Torso.BrickColor
local fengui = it("GuiMain")
fengui.Parent = Player.PlayerGui
fengui.Name = "WeaponGUI"
local fenframe = it("Frame")
fenframe.Parent = fengui
fenframe.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe.BackgroundTransparency = 1
fenframe.BorderColor3 = Color3.new(17, 17, 17)
fenframe.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe.Position = UDim2.new(0.95, 0, 0.7, 0)
local fenframe2 = it("Frame")
fenframe2.Parent = fengui
fenframe2.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe2.BackgroundTransparency = 1
fenframe2.BorderColor3 = Color3.new(17, 17, 17)
fenframe2.Size = UDim2.new(0.2, 0, 0.1, 0)
fenframe2.Position = UDim2.new(0.4, 0, 0.85, 0)
local fenframe3 = it("Frame")
fenframe3.Parent = fengui
fenframe3.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe3.BackgroundTransparency = 1
fenframe3.BorderColor3 = Color3.new(17, 17, 17)
fenframe3.Size = UDim2.new(0.2, 0, 0.2, 0)
fenframe3.Position = UDim2.new(0.8, 0, 0.8, 0)
fenframe3.Name = "MoveFrame"
local fenframe4 = it("Frame")
fenframe4.Parent = fengui
fenframe4.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe4.BackgroundTransparency = 1
fenframe4.BorderColor3 = Color3.new(17, 17, 17)
fenframe4.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe4.Position = UDim2.new(0, 0, 0.7, 0)
local pressedf = false
local fenframe5 = it("Frame")
fenframe5.Parent = fengui
fenframe5.BackgroundColor3 = Color3.new(0, 0, 0)
fenframe5.BackgroundTransparency = 1
fenframe5.BorderColor3 = Color3.new(0, 0, 0)
fenframe5.Size = UDim2.new(1, 0, 1, 0)
fenframe5.Position = UDim2.new(0, 0, 0, 0)
fenframe5.ZIndex = 2
local tellbar = gui("TextLabel", fenframe5, "Press \'F\' to equip your weapon.", 1, Color3.new(0, 0, 0), UDim2.new(0.25, 0, 0.25, 0), UDim2.new(0.5, 0, 0.5, 0))
tellbar.Font = "Arial"
tellbar.TextScaled = true
tellbar.TextTransparency = 1
tellbar.TextStrokeTransparency = 1
tellbar.ZIndex = 2
local fnumb = 0
local fenbarmana1 = gui("TextLabel", fenframe, "", 0, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarmana2 = gui("TextLabel", fenframe, "", 0, BrickColor.new("Bright yellow").Color, UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarmana4 = gui("TextLabel", fenframe, "Mana(" .. mana.Value .. ")", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbarblock1 = gui("TextLabel", fenframe, "", 0, Color3.new(0, 0, 0), UDim2.new(-0.6, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarblock2 = gui("TextLabel", fenframe, "", 0, BrickColor.new("Bright red").Color, UDim2.new(-0.6, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarblock3 = gui("TextLabel", fenframe, "Overheat(" .. overheat .. ")", 1, Color3.new(0, 0, 0), UDim2.new(-0.6, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbardamage = gui("TextLabel", fenframe2, "Damage", 0.55, Color3.new(0.6078431372549, 0, 0), UDim2.new(-0.23, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbardef = gui("TextLabel", fenframe2, "Defense", 0.55, Color3.new(0, 0, 0.6078431372549), UDim2.new(-0.46, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarmove = gui("TextLabel", fenframe2, "Walkspeed", 0.55, Color3.new(0, 0.6078431372549, 0), UDim2.new(1.03, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarhp1 = gui("TextLabel", fenframe2, "", 0, Color3.new(0, 0, 0), UDim2.new(-0.46, 0, 1, 0), UDim2.new(1.92, 0, 0.4, 0))
local fenbarhp2 = gui("TextLabel", fenbarhp1, "", 0, Color3.new(1, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarhp3 = gui("TextLabel", fenbarhp1, "(100)", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
local fenbarstun1 = gui("TextLabel", fenframe4, "", 0, Color3.new(0, 0, 0), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarstun2 = gui("TextLabel", fenframe4, "", 0, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarstun3 = gui("TextLabel", fenframe4, "Stun(" .. Stun.Value .. ")", 1, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbarmove1 = gui("TextButton", fenframe3, move1, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove1.ZIndex = 2
local fenbarmove1b = gui("TextLabel", fenbarmove1, "", 0.55, BrickColor.new("Bright yellow").Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove2 = gui("TextButton", fenframe3, move2, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove2.ZIndex = 2
local fenbarmove2b = gui("TextLabel", fenbarmove2, "", 0.55, BrickColor.new("Bright yellow").Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove3 = gui("TextButton", fenframe3, move3, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove3.ZIndex = 2
local fenbarmove3b = gui("TextLabel", fenbarmove3, "", 0.55, BrickColor.new("Bright yellow").Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove4 = gui("TextButton", fenframe3, move4, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove4.ZIndex = 2
local fenbarmove4b = gui("TextLabel", fenbarmove4, "", 0.55, BrickColor.new("Bright yellow").Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local modelzorz = Instance.new("Model")
modelzorz.Parent = Character
modelzorz.Name = "Astray Unit"
rprt1 = part(3, modelzorz, 0, 0, TorsoColor, "Right Part01", vt())
rprt2 = part(3, modelzorz, 0, 0, TorsoColor, "Right Part02", vt())
rprt3 = part(3, modelzorz, 0, 0, TorsoColor, "Right Part03", vt())
rprt4 = part(3, modelzorz, 0, 0, TorsoColor, "Right Part04", vt())
rprt5 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right Part05", vt())
rprt6 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right Part06", vt())
rprt7 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right Part07", vt())
rprt8 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right Part08", vt())
rprt9 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right Part09", vt())
rprt10 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right Part10", vt())
rprt11 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right Part11", vt())
rprt12 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right Part12", vt())
rprt13 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right Part13", vt())
rprt14 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right Part14", vt())
rprt15 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right Part15", vt())
rprt16 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Right Part16", vt())
rprt17 = part(3, modelzorz, 0, 0, TorsoColor, "Right Part17", vt())
rprt18 = part(3, modelzorz, 0.7, 1, BrickColor.new("New Yeller"), "Right Part18", vt())
rprt19 = part(3, modelzorz, 0.7, 1, BrickColor.new("New Yeller"), "Right Part19", vt())
rprt20 = part(3, modelzorz, 0.7, 1, BrickColor.new("New Yeller"), "Right Part20", vt())
rprt21 = part(3, modelzorz, 0.7, 1, BrickColor.new("New Yeller"), "Right Part21", vt())
rprt22 = part(3, modelzorz, 0.7, 1, BrickColor.new("New Yeller"), "Right Part22", vt())
lprt1 = part(3, modelzorz, 0, 0, TorsoColor, "Left Part01", vt())
lprt2 = part(3, modelzorz, 0, 0, TorsoColor, "Left Part02", vt())
lprt3 = part(3, modelzorz, 0, 0, TorsoColor, "Left Part03", vt())
lprt4 = part(3, modelzorz, 0, 0, TorsoColor, "Left Part04", vt())
lprt5 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left Part05", vt())
lprt6 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left Part06", vt())
lprt7 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left Part07", vt())
lprt8 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left Part08", vt())
lprt9 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left Part09", vt())
lprt10 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left Part10", vt())
lprt11 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left Part11", vt())
lprt12 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left Part12", vt())
lprt13 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left Part13", vt())
lprt14 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left Part14", vt())
lprt15 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left Part15", vt())
lprt16 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Left Part16", vt())
lprt17 = part(3, modelzorz, 0, 0, TorsoColor, "Left Part17", vt())
lprt18 = part(3, modelzorz, 0.7, 1, BrickColor.new("New Yeller"), "Left Part18", vt())
lprt19 = part(3, modelzorz, 0.7, 1, BrickColor.new("New Yeller"), "Left Part19", vt())
lprt20 = part(3, modelzorz, 0.7, 1, BrickColor.new("New Yeller"), "Left Part20", vt())
lprt21 = part(3, modelzorz, 0.7, 1, BrickColor.new("New Yeller"), "Left Part21", vt())
lprt22 = part(3, modelzorz, 0.7, 1, BrickColor.new("New Yeller"), "Left Part22", vt())
bprt1 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Booster Part01", vt())
bprt2 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Booster Part02", vt())
bprt3 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Booster Part03", vt())
bprt4 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Booster Part04", vt())
bprt5 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Booster Part05", vt())
bprt6 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Booster Part06", vt())
bprt7 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Booster Part07", vt())
bprt8 = part(3, modelzorz, 0.5, 0, BrickColor.new("Bright yellow"), "Booster Part08", vt())
bprt9 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Booster Part09", vt())
bprt10 = part(3, modelzorz, 0.5, 0, BrickColor.new("Bright yellow"), "Booster Part10", vt())
rmsh1 = mesh("BlockMesh", rprt1, "", "", vt(0, 0, 0), vt(6, 2, 2))
rmsh2 = mesh("SpecialMesh", rprt2, "Torso", "nil", vt(0, 0, 0), vt(2, 2, 6))
rmsh3 = mesh("BlockMesh", rprt3, "", "", vt(0, 0, 0), vt(6, 2, 2))
rmsh4 = mesh("SpecialMesh", rprt4, "Torso", "nil", vt(0, 0, 0), vt(2, 2, 6))
rmsh5 = mesh("BlockMesh", rprt5, "", "", vt(0, 0, 0), vt(3, 4, 4))
rmsh6 = mesh("BlockMesh", rprt6, "", "", vt(0, 0, 0), vt(1.5, 6, 2))
rmsh7 = mesh("BlockMesh", rprt7, "", "", vt(0, 0, 0), vt(2.5, 4, 2))
rmsh8 = mesh("SpecialMesh", rprt8, "Torso", "nil", vt(0, 0, 0), vt(2, 2, 2.5))
rmsh9 = mesh("BlockMesh", rprt9, "", "", vt(0, 0, 0), vt(2.51, 3, 2))
rmsh10 = mesh("BlockMesh", rprt10, "", "", vt(0, 0, 0), vt(3, 4, 3))
rmsh11 = mesh("SpecialMesh", rprt11, "Wedge", "nil", vt(0, 0, 0), vt(3, 1.5, 2))
rmsh12 = mesh("SpecialMesh", rprt12, "Wedge", "nil", vt(0, 0, 0), vt(3, 1.5, 2))
rmsh13 = mesh("BlockMesh", rprt13, "", "", vt(0, 0, 0), vt(3, 2, 2))
rmsh14 = mesh("SpecialMesh", rprt14, "Wedge", "nil", vt(0, 0, 0), vt(3, 2, 2))
rmsh15 = mesh("SpecialMesh", rprt15, "Wedge", "nil", vt(0, 0, 0), vt(2.5, 3, 5))
rmsh16 = mesh("BlockMesh", rprt16, "", "", vt(0, 0, 0), vt(2, 2, 8))
rmsh17 = mesh("SpecialMesh", rprt17, "Head", "nil", vt(0, 0, 0), vt(3, 6, 3))
rmsh18 = mesh("SpecialMesh", rprt18, "Wedge", "nil", vt(0, 0, 0), vt(1, 2, 16))
rmsh19 = mesh("SpecialMesh", rprt19, "Wedge", "nil", vt(0, 0, 0), vt(1, 4, 19))
rmsh20 = mesh("SpecialMesh", rprt20, "Wedge", "nil", vt(0, 0, 0), vt(1, 2, 7))
rmsh21 = mesh("SpecialMesh", rprt21, "Wedge", "nil", vt(0, 0, 0), vt(1, 3, 8))
rmsh22 = mesh("SpecialMesh", rprt22, "Wedge", "nil", vt(0, 0, 0), vt(1, 2, 8))
lmsh1 = mesh("BlockMesh", lprt1, "", "", vt(0, 0, 0), vt(6, 2, 2))
lmsh2 = mesh("SpecialMesh", lprt2, "Torso", "nil", vt(0, 0, 0), vt(2, 2, 6))
lmsh3 = mesh("BlockMesh", lprt3, "", "", vt(0, 0, 0), vt(6, 2, 2))
lmsh4 = mesh("SpecialMesh", lprt4, "Torso", "nil", vt(0, 0, 0), vt(2, 2, 6))
lmsh5 = mesh("BlockMesh", lprt5, "", "", vt(0, 0, 0), vt(3, 4, 4))
lmsh6 = mesh("BlockMesh", lprt6, "", "", vt(0, 0, 0), vt(1.5, 6, 2))
lmsh7 = mesh("BlockMesh", lprt7, "", "", vt(0, 0, 0), vt(2.5, 4, 2))
lmsh8 = mesh("SpecialMesh", lprt8, "Torso", "nil", vt(0, 0, 0), vt(2, 2, 2.5))
lmsh9 = mesh("BlockMesh", lprt9, "", "", vt(0, 0, 0), vt(2.51, 3, 2))
lmsh10 = mesh("BlockMesh", lprt10, "", "", vt(0, 0, 0), vt(3, 4, 3))
lmsh11 = mesh("SpecialMesh", lprt11, "Wedge", "nil", vt(0, 0, 0), vt(3, 1.5, 2))
lmsh12 = mesh("SpecialMesh", lprt12, "Wedge", "nil", vt(0, 0, 0), vt(3, 1.5, 2))
lmsh13 = mesh("BlockMesh", lprt13, "", "", vt(0, 0, 0), vt(3, 2, 2))
lmsh14 = mesh("SpecialMesh", lprt14, "Wedge", "nil", vt(0, 0, 0), vt(3, 2, 2))
lmsh15 = mesh("SpecialMesh", lprt15, "Wedge", "nil", vt(0, 0, 0), vt(2.5, 3, 5))
lmsh16 = mesh("BlockMesh", lprt16, "", "", vt(0, 0, 0), vt(2, 2, 8))
lmsh17 = mesh("SpecialMesh", lprt17, "Head", "nil", vt(0, 0, 0), vt(3, 6, 3))
lmsh18 = mesh("SpecialMesh", lprt18, "Wedge", "nil", vt(0, 0, 0), vt(1, 2, 16))
lmsh19 = mesh("SpecialMesh", lprt19, "Wedge", "nil", vt(0, 0, 0), vt(1, 4, 19))
lmsh20 = mesh("SpecialMesh", lprt20, "Wedge", "nil", vt(0, 0, 0), vt(1, 2, 7))
lmsh21 = mesh("SpecialMesh", lprt21, "Wedge", "nil", vt(0, 0, 0), vt(1, 3, 8))
lmsh22 = mesh("SpecialMesh", lprt22, "Wedge", "nil", vt(0, 0, 0), vt(1, 2, 8))
bmsh1 = mesh("BlockMesh", bprt1, "", "", vt(0, 0, 0), vt(7, 5, 5))
bmsh2 = mesh("BlockMesh", bprt2, "", "", vt(0, 0, 0), vt(2, 1, 9))
bmsh3 = mesh("BlockMesh", bprt3, "", "", vt(0, 0, 0), vt(2, 1, 9))
bmsh4 = mesh("BlockMesh", bprt4, "", "", vt(0, 0, 0), vt(1, 2, 9))
bmsh5 = mesh("SpecialMesh", bprt5, "Wedge", "nil", vt(0, 0, 0), vt(1, 2, 2))
bmsh6 = mesh("SpecialMesh", bprt6, "Wedge", "nil", vt(0, 0, 0), vt(1, 2, 5))
bmsh7 = mesh("BlockMesh", bprt7, "", "", vt(0, 0, 0), vt(15, 0.5, 2))
bmsh8 = mesh("SpecialMesh", bprt8, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 15, 3))
bmsh9 = mesh("BlockMesh", bprt9, "", "", vt(0, 0, 0), vt(15, 0.5, 2))
bmsh10 = mesh("SpecialMesh", bprt10, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 15, 3))
rwld1 = weld(RightArm, rprt1, RightArm, euler(0, 0, 0) * cf(0, -0.4, -0.5))
rwld2 = weld(rprt1, rprt2, rprt1, euler(1.57, 0, 1.57) * cf(0, 0, 0.4))
rwld3 = weld(rprt1, rprt3, RightArm, euler(0, 0, 0) * cf(0, 0.2, -0.5))
rwld4 = weld(rprt1, rprt4, rprt3, euler(1.57, 0, 1.57) * cf(0, 0, 0.4))
rwld5 = weld(rprt1, rprt5, RightArm, euler(0, 0, 0) * cf(0, -0.2, -1.1))
rwld6 = weld(rprt1, rprt6, rprt5, euler(0, 0, 0) * cf(0, -1, 0.2))
rwld7 = weld(rprt1, rprt7, rprt6, euler(0, 0, 0) * cf(0, -0.3, -0.2))
rwld8 = weld(rprt1, rprt8, rprt7, euler(0, 1.57, 0) * cf(0, -0.6, 0))
rwld9 = weld(rprt1, rprt9, rprt7, euler(-0.6, 0, 0) * cf(0, 0.4, -0.1))
rwld10 = weld(rprt1, rprt10, rprt5, euler(0, 0, 0) * cf(0, 0.8, 0.1))
rwld11 = weld(rprt1, rprt11, rprt10, euler(1.57, 0, 0) * cf(0, 0.6, 0.15))
rwld12 = weld(rprt1, rprt12, rprt10, euler(1.57, 3.14, 0) * cf(0, 0.6, -0.15))
rwld13 = weld(rprt1, rprt13, rprt10, euler(0, 0, 0) * cf(0, -0.2, -0.5))
rwld14 = weld(rprt1, rprt14, rprt13, euler(3.14, 0, 0) * cf(0, 0.4, 0))
rwld15 = weld(rprt1, rprt15, rprt13, euler(3.14, 0, 0) * cf(0, 0.3, -0.3))
rwld16 = weld(rprt1, rprt16, rprt13, euler(0, 0, 0) * cf(0, 0.6, 1.4))
rwld17 = weld(rprt1, rprt17, rprt16, euler(1.57, 0, 0) * cf(0, 0, 0.1))
rwld18 = weld(rprt1, rprt18, rprt10, euler(1.57, 0, 0) * cf(0, 2.01, 0.2))
rwld19 = weld(rprt1, rprt19, rprt10, euler(1.57, 3.14, 0) * cf(0, 1.71, -0.4))
rwld20 = weld(rprt1, rprt20, rprt10, euler(-2.8, 0, 0) * cf(0, -0.2, -1.2))
rwld21 = weld(rprt1, rprt21, rprt10, euler(-2.4, 0, 0) * cf(0, -1.4, -0.8))
rwld22 = weld(rprt1, rprt22, rprt7, euler(-1.57, 0, 0) * cf(0, -0.5, -0.2))
lwld1 = weld(lprt1, lprt1, LeftArm, euler(0, 0, 0) * cf(0, -0.4, -0.5))
lwld2 = weld(rprt1, lprt2, lprt1, euler(1.57, 0, 1.57) * cf(0, 0, 0.4))
lwld3 = weld(rprt1, lprt3, LeftArm, euler(0, 0, 0) * cf(0, 0.2, -0.5))
lwld4 = weld(rprt1, lprt4, lprt3, euler(1.57, 0, 1.57) * cf(0, 0, 0.4))
lwld5 = weld(rprt1, lprt5, LeftArm, euler(0, 0, 0) * cf(0, -0.2, -1.1))
lwld6 = weld(rprt1, lprt6, lprt5, euler(0, 0, 0) * cf(0, -1, 0.2))
lwld7 = weld(rprt1, lprt7, lprt6, euler(0, 0, 0) * cf(0, -0.3, -0.2))
lwld8 = weld(rprt1, lprt8, lprt7, euler(0, 1.57, 0) * cf(0, -0.6, 0))
lwld9 = weld(rprt1, lprt9, lprt7, euler(-0.6, 0, 0) * cf(0, 0.4, -0.1))
lwld10 = weld(rprt1, lprt10, lprt5, euler(0, 0, 0) * cf(0, 0.8, 0.1))
lwld11 = weld(rprt1, lprt11, lprt10, euler(1.57, 0, 0) * cf(0, 0.6, 0.15))
lwld12 = weld(rprt1, lprt12, lprt10, euler(1.57, 3.14, 0) * cf(0, 0.6, -0.15))
lwld13 = weld(rprt1, lprt13, lprt10, euler(0, 0, 0) * cf(0, -0.2, -0.5))
lwld14 = weld(rprt1, lprt14, lprt13, euler(3.14, 0, 0) * cf(0, 0.4, 0))
lwld15 = weld(rprt1, lprt15, lprt13, euler(3.14, 0, 0) * cf(0, 0.3, -0.3))
lwld16 = weld(rprt1, lprt16, lprt13, euler(0, 0, 0) * cf(0, 0.6, 1.4))
lwld17 = weld(rprt1, lprt17, lprt16, euler(1.57, 0, 0) * cf(0, 0, 0.1))
lwld18 = weld(rprt1, lprt18, lprt10, euler(1.57, 0, 0) * cf(0, 2.01, 0.2))
lwld19 = weld(rprt1, lprt19, lprt10, euler(1.57, 3.14, 0) * cf(0, 1.71, -0.4))
lwld20 = weld(rprt1, lprt20, lprt10, euler(-2.8, 0, 0) * cf(0, -0.2, -1.2))
lwld21 = weld(rprt1, lprt21, lprt10, euler(-2.4, 0, 0) * cf(0, -1.4, -0.8))
lwld22 = weld(rprt1, lprt22, lprt7, euler(-1.57, 0, 0) * cf(0, -0.5, -0.2))
bwld1 = weld(bprt1, bprt1, Torso, euler(0, 0, 0) * cf(0, -0.4, -0.8))
bwld2 = weld(rprt1, bprt2, bprt1, euler(0, -0.2, 0) * cf(0.5, -0.6, 0.4))
bwld3 = weld(rprt1, bprt3, bprt1, euler(0, 0.2, 0) * cf(-0.5, -0.6, 0.4))
bwld4 = weld(rprt1, bprt4, bprt1, euler(0, 0, 0) * cf(0, -0.6, -1))
bwld5 = weld(rprt1, bprt5, bprt4, euler(0, 0, 0) * cf(0, 0, 1.1))
bwld6 = weld(rprt1, bprt6, bprt4, euler(3.14, 0, 0) * cf(0, 0, -1.4))
bwld7 = weld(rprt1, bprt7, bprt1, euler(0.1, -0.2, 0.2) * cf(2, -0.6, -0.5))
bwld8 = weld(rprt1, bprt8, bprt7, euler(0, 0, -1.57) * cf(0, 0, 0.5))
bwld9 = weld(rprt1, bprt9, bprt1, euler(-0.1, -0.2, 2.94) * cf(-2, -0.6, -0.5))
bwld10 = weld(rprt1, bprt10, bprt9, euler(0, 0, -1.57) * cf(0, 0, 0.5))
numd = 0.4
numd2 = 0.1
numul = 0.2
local Boost = {}
for i = 1, 2 do
  bprt11 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Booster Part11", vt())
  bprt12 = part(3, modelzorz, 0.5, 0, BrickColor.new("Bright yellow"), "Booster Part12", vt())
  bprt13 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Booster Part13", vt())
  bprt14 = part(3, modelzorz, 0, 0, BrickColor.new("Really black"), "Booster Part14", vt())
  bmsh11 = mesh("BlockMesh", bprt11, "", "", vt(0, 0, 0), vt(3, 3, 5))
  bmsh12 = mesh("BlockMesh", bprt12, "", "", vt(0, 0, 0), vt(3.1, 3.1, 2))
  bmsh13 = mesh("CylinderMesh", bprt13, "", "", vt(0, 0, 0), vt(2.5, 2, 2.5))
  bmsh14 = mesh("CylinderMesh", bprt14, "", "", vt(0, 0, 0), vt(2, 2, 2))
  bwld11 = weld(rprt1, bprt11, bprt1, euler(-0.4, numul, numd2) * cf(numd, 0, -0.6))
  bwld12 = weld(rprt1, bprt12, bprt11, euler(0, 0, 0) * cf(0, 0, -0.5))
  bwld13 = weld(rprt1, bprt13, bprt12, euler(1.57, 0, 0) * cf(0, 0, -0.05))
  bwld14 = weld(rprt1, bprt14, bprt12, euler(1.57, 0, 0) * cf(0, 0, -0.06))
  numd = numd - 0.8
  numul = numul - 0.4
  numd2 = numd2 - 0.2
  num1 = -0.4
  eul = 0
  table.insert(Boost, bprt14)
  for i = 1, 2 do
    bprt15 = part(3, modelzorz, 0.5, 0, BrickColor.new("Bright yellow"), "Booster Part15", vt())
    bprt16 = part(3, modelzorz, 0.5, 0, BrickColor.new("Bright yellow"), "Booster Part16", vt())
    bprt17 = part(3, modelzorz, 0.5, 0, BrickColor.new("Bright yellow"), "Booster Part17", vt())
    bmsh15 = mesh("SpecialMesh", bprt15, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 5))
    bmsh16 = mesh("SpecialMesh", bprt16, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 3))
    bmsh17 = mesh("SpecialMesh", bprt17, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 4))
    bwld15 = weld(rprt1, bprt15, bprt11, euler(0, 0, eul) * cf(0, num1, -0.4))
    bwld16 = weld(rprt1, bprt16, bprt15, euler(0, 3.14, 0) * cf(0, 0, -0.8))
    bwld17 = weld(rprt1, bprt17, bprt16, euler(0, 0, 3.14) * cf(0, 0.2, -0.1))
    eul = eul + 3.14
    num1 = num1 + 0.8
  end
end
for _,c in pairs(modelzorz:children()) do
  table.insert(Weapon, c)
end
for _,c in pairs(rprt1:children()) do
  if c.className == "Motor" then
    table.insert(Welds, c)
  end
end
local hitbox = part(3, modelzorz, 0, 1, BrickColor.new("Black"), "Hitbox2", vt())
hitbox.Anchored = false
local hbwld = weld(hitbox, hitbox, RootPart, euler(0, 0, 0) * cf(0, 0, 0))
local hitbox2 = part(3, nil, 0, 1, BrickColor.new("Black"), "Hitbox", vt(1, 1, 1))
hitbox2.Anchored = true
local hitboxCF = cf(0, 0, 0)
hboxpos = Instance.new("BodyPosition", nil)
hboxpos.P = 2000
hboxpos.D = 100
hboxpos.maxForce = Vector3.new(545000, 545000, 545000)
hitboxweld = function()
  hbwld.Parent = modelzorz
  hbwld.Part0 = hitbox
  hbwld.Part1 = rprt5
end

local nr = NumberRange.new
local ns = NumberSequence.new
local cs = ColorSequence.new
local parti = it("ParticleEmitter")
parti.Color = cs(Color3.new(1, 1, 0), Color3.new(1, 1, 0.3921568627451))
parti.LightEmission = 0.5
parti.Size = ns(0.2)
parti.Texture = "http://www.roblox.com/asset/?id=243728166"
sizeseq = ns({NumberSequenceKeypoint.new(0, 0.5), NumberSequenceKeypoint.new(1, 0.2)})
transseq = ns({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.1, 0.5), NumberSequenceKeypoint.new(0.8, 0.5), NumberSequenceKeypoint.new(1, 1)})
parti.Transparency = transseq
parti.Size = sizeseq
parti.Acceleration = vt(0, 0, 0)
parti.Lifetime = nr(1, 3)
parti.Rate = 40
parti.RotSpeed = nr(90)
parti.Speed = nr(-2)
parti.VelocitySpread = 45
parti.Parent = hitbox
parti.Enabled = false
parti2 = parti:Clone()
parti2.Color = cs(Color3.new(255, 0, 0), Color3.new(255, 255, 0))
parti2.Size = ns(1)
parti2.Acceleration = vt(0, 5, 0)
parti2.Texture = "http://www.roblox.com/asset/?id=242596567"
parti2.Rate = 20
parti2.Speed = nr(-10)
parti2.VelocitySpread = 20
parti2.Parent = Boost[1]
parti3 = parti2:Clone()
parti3.Parent = Boost[2]
parti4 = parti2:Clone()
parti4.Color = cs(Color3.new(255, 255, 0), Color3.new(255, 0, 0))
parti4.LightEmission = 1
parti4.Size = ns(1)
parti4.Acceleration = vt(0, -1, 0)
parti4.Rate = 5
parti4.Speed = nr(2)
parti4.VelocitySpread = 10
parti4.Parent = bprt1
bloodsplat = function(cf, size)
  local prt = part(3, workspace, 0, 1, BrickColor.new("White"), "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cf
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  ggui = Instance.new("BillboardGui")
  ggui.Parent = prt
  ggui.Size = UDim2.new(size, 0, size, 0)
  img = Instance.new("ImageLabel")
  img.Parent = ggui
  img.BackgroundTransparency = 1
  img.Size = UDim2.new(1, 0, 1, 0)
  img.Image = "rbxassetid://179462422"
  img.ImageColor3 = prt.BrickColor.Color
  img.Rotation = math.random(-50, 50)
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Blood", 10, img})
end

if script.Parent.className ~= "HopperBin" then
  Tool = Instance.new("HopperBin")
  Tool.Parent = Backpack
  Tool.Name = "Astray Unit"
  script.Parent = Tool
end
Bin = script.Parent
if Bin.Name == "Proto" then
  Bin.Name = "Astray Unit"
end
local bodvel = Instance.new("BodyVelocity")
local bg = Instance.new("BodyGyro")
so = function(id, par, vol, pit)
  local sou = Instance.new("Sound", par or workspace)
  sou.Volume = vol
  sou.Pitch = pit or 1
  if id == "RandSlash" then
    num = math.random(1, 4)
    if num == 1 then
      id = "200633108"
    else
      if num == 2 then
        id = "200633148"
      else
        if num == 3 then
          id = "200633196"
        else
          if num == 4 then
            id = "200633281"
          end
        end
      end
    end
  end
  sou.SoundId = "http://www.roblox.com/asset/?id=" .. id
  coroutine.resume(coroutine.create(function(Sound)
    swait()
    Sound:play()
  end
), sou)
  game:GetService("Debris"):AddItem(sou, 6)
end

function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

hideanim = function()
  equipped = false
  mdec2.Parent = nil
  mdec.Parent = Decrease
  for i = 0.2, 1, 0.1 do
    swait()
    rprt18.Transparency = i
    rprt19.Transparency = i
    rprt20.Transparency = i
    rprt21.Transparency = i
    rprt22.Transparency = i
    lprt18.Transparency = i
    lprt19.Transparency = i
    lprt20.Transparency = i
    lprt21.Transparency = i
    lprt22.Transparency = i
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, RHC0, 0.2)
    LH.C0 = clerp(LH.C0, LHC0, 0.2)
  end
end

mdec.Parent = Decrease
equipanim = function()
  equipped = true
  mdec.Parent = nil
  for i = 1, 0.2, -0.05 do
    swait()
    rprt18.Transparency = i
    rprt19.Transparency = i
    rprt20.Transparency = i
    rprt21.Transparency = i
    rprt22.Transparency = i
    lprt18.Transparency = i
    lprt19.Transparency = i
    lprt20.Transparency = i
    lprt21.Transparency = i
    lprt22.Transparency = i
    Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 1), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
  end
  mdec2.Parent = Decrease
end

StaggerAnim = function()
  attack = true
  removeControl()
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.35 do
    swait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -40
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.1, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 1) * euler(0, 1, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1, 0, -1) * euler(0, -1, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.3), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, -0.3), 0.3)
  end
  for i = 1, 0, -0.05 do
    swait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -(40 * i)
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.15)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.2, 0, 0), 0.15)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 1.5) * euler(0, 1, 0), 0.15)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.15)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1, 0, -1.5) * euler(0, -1, 0), 0.15)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.15)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0, 0.3), 0.15)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(-0.3, 0, -0.3), 0.15)
  end
  resumeControl()
  combo = 0
  attack = false
end

StaggerHitt = function()
  attack = true
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.2 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.9), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.6), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, -0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  attack = false
end

StunAnim = function()
  attack = true
  removeControl()
  Stunned.Value = true
  showDamage(Character, "Stunned", "Interrupt")
  local dec = Instance.new("NumberValue", Decrease)
  dec.Name = "DecreaseMvmt"
  dec.Value = 10
  for i = 0, 1, 0.3 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.2, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1, 0, 0.4) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.3), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, 0), 0.25)
  end
  for i = 0, 1, 0.3 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0.8, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1.2, 0, 0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(0.1, 0, 0.7), 0.25)
  end
  for i = 0, 1, 0.3 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -1), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1.57, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, -0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.1, 0, 0.3), 0.25)
  end
  local gairost = Instance.new("BodyGyro")
  gairost.Parent = RootPart
  gairost.maxTorque = Vector3.new(400000, 0, 400000) * math.huge
  gairost.P = 20000
  gairost.cframe = cf(0, 0, 0)
  for i = 0, 1, 0.06 do
    swait()
    if hitfloor ~= nil then
      Torso.Velocity = vt(0, 0, 0)
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2.5) * euler(1.57, 0, -3.14), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1.5) * euler(0.2, 3.14, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.5, 0, -1.57) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 0), 0.3)
  end
  for i = 1, 50 do
    swait()
    gairost.cframe = RootPart.CFrame
    if hitfloor ~= nil then
      Torso.Velocity = vt(0, 0, 0)
    end
  end
  for i = 0, 1, 0.2 do
    swait()
    Stun.Value = 0
    gairost.cframe = RootPart.CFrame
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1, 0, -4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1) * euler(0.2, -1, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, 0.2) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, -1) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 1), 0.3)
  end
  resumeControl()
  gairost.Parent = nil
  dec.Parent = nil
  Stun.Value = 0
  combo = 0
  Stunned.Value = false
  attack = false
  for i = 1, 10 do
    swait()
    Stun.Value = 0
  end
end

attackone = function()
  attack = true
  for i = 0, 1, 0.065 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1), 0.3)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(2, 0, -1) * euler(0, 0.8, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.8, 0, -0.2) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.5, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, -0.5, 0), 0.3)
    if StunT.Value <= Stun.Value then
      break
    end
  end
  do
    so("RandSlash", rprt5, 1, math.random(80, 120) / 100)
    hbwld.Parent = nil
    hboxpos.Parent = hitbox
    hitbox.Parent = modelzorz
    hitbox.Size = vt(0.5, 6, 2)
    hitboxCF = rprt5.CFrame * cf(0, -1.5, 0)
    hitbox.CFrame = hitboxCF
    for i = 0, 1, 0.2 do
      swait()
      hitboxCF = rprt5.CFrame * cf(0, -1.5, 0)
      hitbox.CFrame = hitboxCF
      MagniDamage(hitbox, 6, 4, 7, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(2, 5)), nil, true)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.8) * euler(0.2, 0, 0), 0.45)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.8), 0.45)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.5, 0, 1) * euler(0, 0.8, 0), 0.45)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.2, 0, -0.6), 0.45)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
      RH.C0 = clerp(RH.C0, cf(0.7, -1, -0.2) * euler(0, 1.57, 0) * euler(0, 0.8, 0), 0.45)
      LH.C0 = clerp(LH.C0, cf(-0.7, -1, 0.2) * euler(0, -1.57, 0) * euler(0, 0.8, 0), 0.45)
      if StunT.Value <= Stun.Value then
        break
      end
    end
    do
      hitbox.Parent = modelzorz
      hitbox.Size = vt()
      hitboxweld()
      hboxpos.Parent = nil
      attack = false
    end
  end
end

attacktwo = function()
  attack = true
  for i = 0, 1, 0.065 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, -0.6), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.6), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 1), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(0.4, 0, 0.6) * euler(0, -1, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.6, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, -0.6, 0), 0.4)
    if StunT.Value <= Stun.Value then
      break
    end
  end
  do
    so("RandSlash", lprt5, 1, math.random(80, 120) / 100)
    hbwld.Parent = nil
    hboxpos.Parent = hitbox
    hitbox.Parent = modelzorz
    hitbox.Size = vt(0.5, 6, 2)
    hitboxCF = lprt5.CFrame * cf(0, -1.5, 0)
    hitbox.CFrame = hitboxCF
    for i = 0, 1, 0.2 do
      swait()
      hitboxCF = lprt5.CFrame * cf(0, -1.5, 0)
      hitbox.CFrame = hitboxCF
      MagniDamage(hitbox, 6, 4, 7, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(2, 5)), nil, true)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.57), 0.45)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * euler(0, 0, -1.57), 0.45)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 1.57) * euler(0, 0, -1), 0.45)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.5, -0.6, -1.6) * euler(0, 0, 0), 0.45)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
      RH.C0 = clerp(RH.C0, cf(0.5, -1, -0.2) * euler(0, 1.57, 0) * euler(-0.4, 1.57, 0), 0.45)
      LH.C0 = clerp(LH.C0, cf(-0.5, -1, 0.2) * euler(0, -1.57, 0) * euler(0.2, 1.57, 0), 0.45)
      if StunT.Value <= Stun.Value then
        break
      end
    end
    do
      hitbox.Parent = modelzorz
      hitbox.Size = vt()
      hitboxweld()
      hboxpos.Parent = nil
      attack = false
    end
  end
end

attackthree = function()
  attack = true
  for i = 0, 1, 0.065 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1.57), 0.3)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.5, 0, -1) * euler(0, 1.57, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.6, 0, -0.4) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.7, -1, 0.4) * euler(0, 1.57, 0) * euler(0, -1.2, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-0.7, -1, -0.4) * euler(0, -1.57, 0) * euler(0, -1.2, 0), 0.3)
    if StunT.Value <= Stun.Value then
      break
    end
  end
  do
    so("RandSlash", rprt5, 1, math.random(80, 120) / 100)
    hbwld.Parent = nil
    hboxpos.Parent = hitbox
    hitbox.Parent = modelzorz
    hitbox.Size = vt(0.5, 6, 2)
    hitboxCF = rprt5.CFrame * cf(0, -1.5, 0)
    hitbox.CFrame = hitboxCF
    for i = 0, 1, 0.2 do
      swait()
      hitboxCF = rprt5.CFrame * cf(0, -1.5, 0)
      hitbox.CFrame = hitboxCF
      MagniDamage(hitbox, 6, 4, 7, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(2, 5)), nil, true)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1), 0.45)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -1), 0.45)
      RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.5, 0, 1.5) * euler(0, 1.57, 0), 0.45)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.8) * euler(0, 0, 0), 0.45)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
      RH.C0 = clerp(RH.C0, cf(0.6, -1, -0.4) * euler(0, 1.57, 0) * euler(0, 1.57, 0), 0.45)
      LH.C0 = clerp(LH.C0, cf(-0.6, -1, 0.4) * euler(0, -1.57, 0) * euler(0, 1.57, 0), 0.45)
      if StunT.Value <= Stun.Value then
        break
      end
    end
    do
      hitbox.Parent = modelzorz
      hitbox.Size = vt()
      hitboxweld()
      hboxpos.Parent = nil
      attack = false
    end
  end
end

attackfour = function()
  attack = true
  for i = 0, 1, 0.065 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.5), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.4, 0, 0.2), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-0.5, 0.5, -0.5) * euler(1.57, 0, 1) * euler(0, -1.57, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.5, 0), 0.3)
    if StunT.Value <= Stun.Value then
      break
    end
  end
  do
    so("RandSlash", lprt5, 1, math.random(80, 120) / 100)
    hbwld.Parent = nil
    hboxpos.Parent = hitbox
    hitbox.Parent = modelzorz
    hitbox.Size = vt(0.5, 6, 2)
    hitboxCF = lprt5.CFrame * cf(0, -1.5, 0)
    hitbox.CFrame = hitboxCF
    for i = 0, 1, 0.2 do
      swait()
      hitboxCF = lprt5.CFrame * cf(0, -1.5, 0)
      hitbox.CFrame = hitboxCF
      MagniDamage(hitbox, 6, 4, 7, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(2, 5)), nil, true)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.3)
      RootJoint.C0 = RootCF * euler(0, 0, -0.5 + 6.28 * i)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 1), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, -1.57) * euler(0, -1.57, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.3)
      if StunT.Value <= Stun.Value then
        break
      end
    end
    do
      for i = 0, 1, 0.2 do
        swait()
        hitboxCF = lprt5.CFrame * cf(0, -1.5, 0)
        hitbox.CFrame = hitboxCF
        MagniDamage(hitbox, 6, 4, 7, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(2, 5)), nil, true)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 1), 0.3)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.3, 0, -1.57) * euler(0, -1.57, 0), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        if StunT.Value <= Stun.Value then
          break
        end
      end
      do
        hitbox.Parent = modelzorz
        hitbox.Size = vt()
        hitboxweld()
        hboxpos.Parent = nil
        attack = false
      end
    end
  end
end

Flight = function()
  if StunT.Value <= Stun.Value then
    return 
  end
  Vel = Torso.Velocity * 4
  ex = Torso.Velocity.x * 4
  why = Torso.Velocity.y * 4
  ze = Torso.Velocity.z * 4
  if overheat > 60 then
    jetmax = 35
  else
    jetmax = 50
  end
  if why <= 0 then
    why = 0
  else
    if jetmax <= why then
      why = jetmax
    end
  end
  if jetmax <= ex then
    ex = jetmax
  else
    if ex <= -jetmax then
      ex = -jetmax
    end
  end
  if jetmax <= ze then
    ze = jetmax
  else
    if ze <= -jetmax then
      ze = -jetmax
    end
  end
  Vel = vt(ex, why, ze)
  local mananum = 0
  while overheat <= 100 and flight == true and mana.Value > 1 and overheat <= 100 do
    swait()
    if overheat > 100 then
      jetmax = 100
    else
      jetmax = 100
    end
    overheat = overheat + 1
    if mananum >= 0 then
      mananum = 0
      mana.Value = mana.Value - 0
      parti2.Enabled = true
      parti3.Enabled = true
    else
      mananum = mananum + 1
    end
    if Rooted.Value == false then
      Torso.Velocity = Vel
    end
  end
  parti2.Enabled = false
  parti3.Enabled = false
  if overheat >= 100 then
    MagicBlock(BrickColor.new("Bright red"), bprt1.CFrame, 5, 5, 5, 4, 4, 4, 0.1, 1)
    MagicBlock(BrickColor.new("Bright red"), bprt1.CFrame, 3, 3, 3, 4, 4, 4, 0.1, 1)
    Stun.Value = Stun.Value + 100
    Humanoid:TakeDamage(25)
    showDamage(Character, 25, "Damage")
    so("206049428", RootPart, 0.5, math.random(5, 6) / 10)
    MagniDamage(RootPart, 7, 7, 10, math.random(5, 10), "Normal", RootPart, 0.15, 2, math.random(7, 10), true, true, false, "Defense", 0.1, 400)
    local dec = Instance.new("NumberValue")
    dec.Name = "DecreaseMvmt"
    dec.Value = 0.25
    dec.Parent = Decrease
    showDamage(Character, "-Movement", "Debuff")
    game:GetService("Debris"):AddItem(dec, 8)
    local dec = Instance.new("NumberValue")
    dec.Name = "DecreaseDef"
    dec.Value = 0.15
    dec.Parent = Decrease
    showDamage(Character, "-Defense", "Debuff")
    game:GetService("Debris"):AddItem(dec, 6)
    local dec = Instance.new("NumberValue")
    dec.Name = "DecreaseAtk"
    dec.Value = 0.25
    dec.Parent = Decrease
    showDamage(Character, "-Damage", "Debuff")
    game:GetService("Debris"):AddItem(dec, 12)
  end
  do
    flight = false
  end
end

do1 = function()
  if attack == true then
    return 
  end
  if StunT.Value <= Stun.Value then
    return 
  end
  if cooldownmax <= cooldowns[1] and mana.Value >= 15 then
    attack = true
    cooldowns[1] = 0
    mana.Value = mana.Value - 15
    for i = 0, 1, 0.065 do
      swait()
      Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, -0.6), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.8) * euler(0, 0, 1), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 1), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(0.4, 0, 0.6) * euler(0, -1, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.6, 0), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, -0.6, 0), 0.4)
      if StunT.Value <= Stun.Value then
        break
      end
    end
    do
      so("RandSlash", lprt5, 1, math.random(80, 120) / 100)
      hbwld.Parent = nil
      hboxpos.Parent = hitbox
      hitbox.Parent = modelzorz
      hitbox.Size = vt(0.5, 6, 2)
      hitboxCF = lprt5.CFrame * cf(0, -1.5, 0)
      hitbox.CFrame = hitboxCF
      for i = 0, 1, 0.06 do
        swait()
        hitboxCF = lprt5.CFrame * cf(0, -1.5, 0)
        hitbox.CFrame = hitboxCF
        MagniDamage(hitbox, 6, 8, 10, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(2, 5)), nil, false)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(-0.2, 0, 0), 0.45)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -1), 0.45)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 1.57) * euler(0, 0, -1), 0.45)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(2.4, 0, -0.8) * euler(0, -1.2, 0), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
        RH.C0 = clerp(RH.C0, cf(0.8, -1, -0.4) * euler(0, 1.57, 0) * euler(0, 1, 0), 0.45)
        LH.C0 = clerp(LH.C0, cf(-0.8, -1, 0.4) * euler(0, -1.57, 0) * euler(0, 1, 0), 0.45)
        if StunT.Value <= Stun.Value then
          break
        end
      end
      do
        if etheral == true then
          coroutine.resume(coroutine.create(function(EthCF)
    for i = 1, 3 do
      for i = 1, 2 do
        EtheralSlash(EthCF * cf(math.random(-600, 600) / 100, math.random(-600, 600) / 100, math.random(-1200, -400) / 100))
      end
      swait(2)
    end
  end
), RootPart.CFrame)
        end
        hitbox.Parent = modelzorz
        hitbox.Size = vt()
        hitboxweld()
        hboxpos.Parent = nil
        for i = 0, 1, 0.3 do
          swait()
          Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.45)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.4, 0.4, 0.5), 0.45)
          RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 1.57) * euler(0, 3.14, 0), 0.45)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
          LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1.57) * euler(0, 0, 0), 0.45)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
          RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0), 0.45)
          LH.C0 = clerp(LH.C0, cf(-1, -0.6, 0) * euler(0, -1.57, 0) * euler(-0.5, 0, 0.1), 0.45)
          if StunT.Value <= Stun.Value then
            break
          end
          if etheral == true then
            EtheralSlash(RootPart.CFrame * cf(math.random(-600, 600) / 100, math.random(-600, 600) / 100, math.random(-1200, -400) / 100))
          end
        end
        do
          hbwld.Parent = nil
          hboxpos.Parent = hitbox
          hitbox.Parent = modelzorz
          hitbox.Size = vt(0.5, 6, 2)
          hitboxCF = lprt5.CFrame * cf(0, -1.5, 0)
          hitbox.CFrame = hitboxCF
          so("RandSlash", lprt5, 1, math.random(80, 120) / 100)
          for i = 0, 1, 0.2 do
            swait()
            hitboxCF = lprt5.CFrame * cf(0, -1.5, 0)
            hitbox.CFrame = hitboxCF
            MagniDamage(hitbox, 6, 7, 10, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(1, 4)), nil, false)
            hitboxCF = rprt5.CFrame * cf(0, -1.5, 0)
            hitbox.CFrame = hitboxCF
            MagniDamage(hitbox, 6, 7, 10, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(1, 4)), nil, false)
            Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.45)
            RootJoint.C0 = RootCF * cf(0, 0, 2 * i) * euler(-0.4 + 0.4 * i, 0.4 + 0.6 * i, 0.5 + 2.5 * i)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 1.57) * euler(0, 3.14, 0), 0.45)
            RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1.57) * euler(0, 0, 0), 0.45)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
            RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0), 0.45)
            LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, 0), 0.45)
            if StunT.Value <= Stun.Value then
              break
            end
            if etheral == true then
              EtheralSlash(RootPart.CFrame * cf(math.random(-600, 600) / 100, math.random(-600, 600) / 100, math.random(-1200, -400) / 100))
            end
          end
          do
            so("RandSlash", lprt5, 1, math.random(80, 120) / 100)
            for i = 0, 1, 0.2 do
              swait()
              hitboxCF = lprt5.CFrame * cf(0, -1.5, 0)
              hitbox.CFrame = hitboxCF
              MagniDamage(hitbox, 6, 7, 10, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(1, 4)), nil, false)
              hitboxCF = rprt5.CFrame * cf(0, -1.5, 0)
              hitbox.CFrame = hitboxCF
              MagniDamage(hitbox, 6, 7, 10, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(1, 4)), nil, false)
              Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.45)
              RootJoint.C0 = RootCF * cf(0, 0, 2 + 0.5 * i) * euler(0, 1, 3 + 3 * i)
              RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 1.57) * euler(0, 3.14, 0), 0.45)
              RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
              LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1.57) * euler(0, 0, 0), 0.45)
              LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
              RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0), 0.45)
              LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, 0), 0.45)
              if StunT.Value <= Stun.Value then
                break
              end
              if etheral == true then
                EtheralSlash(RootPart.CFrame * cf(math.random(-600, 600) / 100, math.random(-600, 600) / 100, math.random(-1200, -400) / 100))
              end
            end
            do
              so("RandSlash", lprt5, 1, math.random(80, 120) / 100)
              for i = 0, 1, 0.2 do
                swait()
                hitboxCF = lprt5.CFrame * cf(0, -1.5, 0)
                hitbox.CFrame = hitboxCF
                MagniDamage(hitbox, 6, 7, 10, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(1, 4)), nil, false)
                hitboxCF = rprt5.CFrame * cf(0, -1.5, 0)
                hitbox.CFrame = hitboxCF
                MagniDamage(hitbox, 6, 7, 10, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(1, 4)), nil, false)
                Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.45)
                RootJoint.C0 = RootCF * cf(0, 0, 2.5 - 0.5 * i) * euler(0, 1, 6 + 3 * i)
                RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 1.57) * euler(0, 3.14, 0), 0.45)
                RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
                LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1.57) * euler(0, 0, 0), 0.45)
                LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
                RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0), 0.45)
                LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, 0), 0.45)
                if StunT.Value <= Stun.Value then
                  break
                end
                if etheral == true then
                  EtheralSlash(RootPart.CFrame * cf(math.random(-600, 600) / 100, math.random(-600, 600) / 100, math.random(-1200, -400) / 100))
                end
              end
              do
                so("RandSlash", lprt5, 1, math.random(80, 120) / 100)
                for i = 0, 1, 0.2 do
                  swait()
                  hitboxCF = lprt5.CFrame * cf(0, -1.5, 0)
                  hitbox.CFrame = hitboxCF
                  MagniDamage(hitbox, 6, 7, 10, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(1, 4)), nil, false)
                  hitboxCF = rprt5.CFrame * cf(0, -1.5, 0)
                  hitbox.CFrame = hitboxCF
                  MagniDamage(hitbox, 6, 7, 10, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(1, 4)), nil, false)
                  Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.45)
                  RootJoint.C0 = RootCF * cf(0, 0, 2 - 0.5 * i) * euler(0, 1, 9 + 3 * i)
                  RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 1.57) * euler(0, 3.14, 0), 0.45)
                  RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
                  LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1.57) * euler(0, 0, 0), 0.45)
                  LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
                  RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0), 0.45)
                  LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, 0), 0.45)
                  if StunT.Value <= Stun.Value then
                    break
                  end
                  if etheral == true then
                    EtheralSlash(RootPart.CFrame * cf(math.random(-600, 600) / 100, math.random(-600, 600) / 100, math.random(-1200, -400) / 100))
                  end
                end
                do
                  hitbox.Parent = modelzorz
                  hitbox.Size = vt()
                  hitboxweld()
                  hboxpos.Parent = nil
                  attack = false
                end
              end
            end
          end
        end
      end
    end
  end
end

do2 = function()
  if attack == true then
    return 
  end
  if StunT.Value <= Stun.Value then
    return 
  end
  if cooldownmax <= cooldowns[2] and mana.Value >= 40 then
    attack = true
    cooldowns[2] = 0
    mana.Value = mana.Value - 40
    for i = 0, 1, 0.06 do
      swait()
      Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.57) * euler(0, 1.57, 0), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, -1.57) * euler(0, -1.57, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.3)
      if StunT.Value <= Stun.Value then
        break
      end
    end
    do
      hbwld.Parent = nil
      hboxpos.Parent = hitbox
      hitbox.Parent = modelzorz
      hitbox.Size = vt(0.5, 6, 2)
      hitboxCF = rprt5.CFrame * cf(0, -1.5, 0)
      hitbox.CFrame = hitboxCF
      for i = 1, 3 do
        so("RandSlash", lprt5, 1, math.random(80, 120) / 100)
        for i = 0, 1, 0.2 do
          swait()
          hitboxCF = lprt5.CFrame * cf(0, -1.5, 0)
          hitbox.CFrame = hitboxCF
          MagniDamage(hitbox, 6, 5, 10, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(2, 5)), nil, true, false, "Defense", 0.02, 100)
          Neck.C0 = clerp(Neck.C0, necko * euler(0.3, 0, 0.5), 0.45)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.5), 0.45)
          RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 1, 1.4) * euler(0, 1.57, 0), 0.45)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
          LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(0.2, 0, 1.4) * euler(0, -3, 0), 0.45)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
          if StunT.Value <= Stun.Value then
            break
          end
          if etheral == true then
            EtheralSlash(RootPart.CFrame * cf(math.random(-600, 600) / 100, math.random(-600, 600) / 100, math.random(-1200, -400) / 100))
          end
        end
        do
          blcf = nil
          scfr = nil
          so("RandSlash", rprt5, 1, math.random(80, 120) / 100)
          for i = 0, 1, 0.2 do
            swait()
            hitboxCF = rprt5.CFrame * cf(0, -1.5, 0)
            hitbox.CFrame = hitboxCF
            MagniDamage(hitbox, 6, 5, 10, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(2, 5)), nil, true, false, "Defense", 0.02, 100)
            Neck.C0 = clerp(Neck.C0, necko * euler(0.3, 0, -0.5), 0.45)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.5), 0.45)
            RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(0.5, 0, -1) * euler(0, 2.5, 0), 0.45)
            RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.1, 0, -1) * euler(0, 0, 0), 0.45)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
            if StunT.Value <= Stun.Value then
              break
            end
            if etheral == true then
              EtheralSlash(RootPart.CFrame * cf(math.random(-600, 600) / 100, math.random(-600, 600) / 100, math.random(-1200, -400) / 100))
            end
          end
          do
            blcf = nil
            scfr = nil
            so("RandSlash", lprt5, 1, math.random(80, 120) / 100)
            for i = 0, 1, 0.2 do
              swait()
              hitboxCF = lprt5.CFrame * cf(0, -1.5, 0)
              hitbox.CFrame = hitboxCF
              MagniDamage(hitbox, 6, 5, 10, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(2, 5)), nil, true, false, "Defense", 0.02, 100)
              Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0.5), 0.45)
              RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.5), 0.45)
              RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.1, 0, 1) * euler(0, 0, 0), 0.45)
              RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
              LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(2, 0, 1) * euler(0, -1.5, 0), 0.45)
              LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
              if StunT.Value <= Stun.Value then
                break
              end
              if etheral == true then
                EtheralSlash(RootPart.CFrame * cf(math.random(-600, 600) / 100, math.random(-600, 600) / 100, math.random(-800, -400) / 100))
              end
            end
            do
              blcf = nil
              scfr = nil
              so("RandSlash", rprt5, 1, math.random(80, 120) / 100)
              for i = 0, 1, 0.2 do
                swait()
                hitboxCF = rprt5.CFrame * cf(0, -1.5, 0)
                hitbox.CFrame = hitboxCF
                MagniDamage(hitbox, 6, 5, 10, math.random(5, 10), "Normal", RootPart, 0.3, 2, (math.random(2, 5)), nil, true, false, "Defense", 0.02, 100)
                Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.5), 0.45)
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.5), 0.45)
                RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(2, 0, -1) * euler(0, 1.5, 0), 0.45)
                RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
                LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, -1.57) * euler(0, -1.57, 0), 0.45)
                LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.45)
                if StunT.Value <= Stun.Value then
                  break
                end
                if etheral == true then
                  EtheralSlash(RootPart.CFrame * cf(math.random(-600, 600) / 100, math.random(-600, 600) / 100, math.random(-1200, -400) / 100))
                end
              end
              do
                do
                  if StunT.Value <= Stun.Value then
                    break
                  end
                end
              end
            end
          end
        end
      end
      hitbox.Parent = modelzorz
      hitbox.Size = vt()
      hitboxweld()
      hboxpos.Parent = nil
      attack = false
    end
  end
end

do3 = function()
  if attack == true then
    return 
  end
  if StunT.Value <= Stun.Value then
    return 
  end
  if cooldownmax <= cooldowns[3] and mana.Value >= 20 then
    attack = true
    cooldowns[3] = 0
    mana.Value = mana.Value - 20
    for i = 0, 1, 0.06 do
      swait()
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(0, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1), 0.3)
      RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -1.2), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1, 0, -0.1), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(0.8, -1, -0.4) * euler(0, 1.57, 0) * euler(0, 1, -0.1), 0.4)
      LH.C0 = clerp(LH.C0, cf(-0.8, -0.9, 0.4) * euler(0, -1.57, 0) * euler(0, 1, 0.06), 0.4)
      if StunT.Value <= Stun.Value then
        break
      end
    end
    do
      so("RandSlash", rprt5, 1, math.random(80, 120) / 100)
      hbwld.Parent = nil
      hboxpos.Parent = hitbox
      hitbox.Parent = modelzorz
      hitbox.Size = vt(0.5, 6, 2)
      hitboxCF = rprt5.CFrame * cf(0, -1.5, 0)
      hitbox.CFrame = hitboxCF
      for i = 0, 1, 0.06 do
        swait()
        hitboxCF = rprt5.CFrame * cf(0, -1.5, 0)
        hitbox.CFrame = hitboxCF
        MagniDamage(hitbox, 6, 8, 12, math.random(5, 10), "Normal", RootPart, 1, 2, (math.random(2, 5)), nil, true, false, "Stab", 0.1, 200)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57) * euler(0, 0, 0), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 1.57), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1) * euler(0, 1.57, 0), 0.3)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.5, 0, -1), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.4) * euler(0, 1.57, 0) * euler(0.2, -1.57, 0), 0.2)
        LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.4) * euler(0, -1.57, 0) * euler(-0.4, -1.57, 0), 0.2)
        if StunT.Value <= Stun.Value then
          break
        end
      end
      do
        hitbox.Parent = modelzorz
        hitbox.Size = vt()
        hitboxweld()
        hboxpos.Parent = nil
        attack = false
      end
    end
  end
end

do4 = function()
  if attack == true then
    return 
  end
  if StunT.Value <= Stun.Value then
    return 
  end
  if cooldownmax <= cooldowns[4] then
    cooldowns[4] = 0
    etheral = true
    so("200633029", RootPart, 1, 1)
    so("200633077", RootPart, 1, 1)
    swait(500)
    etheral = false
  end
end

DecreaseStat = function(Model, Stat, Amount, Duration)
  if Model:findFirstChild("Stats") ~= nil and Model.Stats[Stat] ~= nil then
    Model.Stats[Stat].Value = Model.Stats[Stat].Value - Amount
    d = Instance.new("NumberValue", Model.Stats.Decrease)
    dur = Instance.new("NumberValue", d)
    dur.Name = "Duration"
    dur.Value = Duration
    game:GetService("Debris"):AddItem(d, 20)
    if Stat == "Damage" then
      d.Name = "DecreaseAtk"
    else
      if Stat == "Defense" then
        d.Name = "DecreaseDef"
      else
        if Stat == "Movement" then
          d.Name = "DecreaseMvmt"
        end
      end
    end
    if Model:findFirstChild("Torso") ~= nil then
      display = ""
      if Stat == "Damage" then
        if Amount > 0 then
          display = "-Damage"
        else
          display = "+Damage"
        end
      else
        if Stat == "Defense" then
          if Amount > 0 then
            display = "-Defense"
          else
            display = "+Defense"
          end
        else
          if Stat == "Movement" then
            if Amount > 0 then
              display = "-Movement"
            else
              display = "+Movement"
            end
          end
        end
      end
      showDamage(Model, display, "Debuff")
    end
    d.Value = Amount
  end
end

GetDist = function(Part1, Part2, magni)
  local targ = Part1.Position - Part2.Position
  local mag = targ.magnitude
  if mag <= magni then
    return true
  else
    return false
  end
end

MagniDamage = function(Part, magni, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
  for _,c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = nil
      for _,d in pairs(c:children()) do
        if d.className == "Model" and ranged ~= true then
          head = d:findFirstChild("Hitbox")
          if d.Parent == Character then
            break
          end
          if head ~= nil then
            local targ = head.Position - Part.Position
            local mag = targ.magnitude
            if mag <= magni and c.Name ~= Player.Name then
              if StaggerHit.Value == false then
                ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
                ref.Anchored = true
                ref.CFrame = cf(head.Position)
                game:GetService("Debris"):AddItem(ref, 1)
                hitnum = math.random(1, 5)
                if hitnum == 1 then
                  so("199148971", ref, 1, 1)
                else
                  if hitnum == 2 then
                    so("199149025", ref, 1, 1)
                  else
                    if hitnum == 3 then
                      so("199149072", ref, 1, 1)
                    else
                      if hitnum == 4 then
                        so("199149109", ref, 1, 1)
                      else
                        if hitnum == 5 then
                          so("199149119", ref, 1, 1)
                        end
                      end
                    end
                  end
                end
              end
              StaggerHit.Value = true
            end
          end
        end
        do
          if d.className == "Part" then
            head = d
            if head ~= nil then
              local targ = head.Position - Part.Position
              local mag = targ.magnitude
              if mag <= magni and c.Name ~= Player.Name then
                if stun == nil then
                  stun = math.random(5, 10)
                end
                local Rang = nil
                if Ranged == false then
                  Rang = true
                end
                local stag = nil
                if shbash == true then
                  stag = true
                end
                Damagefunc(head, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
              end
            end
          end
          do
          end
        end
      end
    end
  end
end

rayCast = function(Pos, Dir, Max, Ignore)
  return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
end

local Point = Torso.CFrame * cf(0, Torso.Size.Y, 0)
LastPoint = Point
effect = function(Color, Ref, LP, P1, returnn)
  if LP == nil or P1 == nil then
    return 
  end
  local effectsmsh = Instance.new("CylinderMesh")
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  effectsmsh.Name = "Mesh"
  local effectsg = Instance.new("Part")
  NoOutline(effectsg)
  effectsg.formFactor = 3
  effectsg.CanCollide = false
  effectsg.Name = "Eff"
  effectsg.Locked = true
  effectsg.Anchored = true
  effectsg.Size = Vector3.new(0.5, 1, 0.5)
  effectsg.Parent = workspace
  effectsmsh.Parent = effectsg
  effectsg.BrickColor = BrickColor.new(Color)
  effectsg.Reflectance = Ref
  local point1 = P1
  local mg = (LP.p - point1.p).magnitude
  effectsg.Size = Vector3.new(0.5, mg, 0.5)
  effectsg.CFrame = cf((LP.p + point1.p) / 2, point1.p) * CFrame.Angles(math.rad(90), 0, 0)
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  game:GetService("Debris"):AddItem(effectsg, 2)
  if returnn then
    return effectsg
  end
  if not returnn then
    table.insert(Effects, {effectsg, "Cylinder", 0.2, 0.01, 0, 0.01, effectsmsh})
  end
end

local CFrameFromTopBack = function(at, top, back)
  local right = top:Cross(back)
  return CFrame.new(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

MagicBlock = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type, parent)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  if Type == 1 or Type == nil then
    table.insert(Effects, {prt, "Block1", delay, x3, y3, z3, msh})
  else
    if Type == 2 then
      table.insert(Effects, {prt, "Block2", delay, x3, y3, z3, msh})
    end
  end
end

MagicCircle = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end

MagicCylinder = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end

MagicHead = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Head", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end

ClangEffect = function(brickcolor, cframe, duration, decrease, size, power)
  local prt = part(3, workspace, 0, 1, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(5, 5, 5))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "CylinderClang", duration, decrease, size, power, prt.CFrame, nil})
end

MagicWave = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "FileMesh", "20329976", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end

MagicFire = function(brickcolor, cframe, x1, y1, z1, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Fire", delay, 1, 1, 1, msh})
end

EtheralSlash = function(CF)
  ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
  ref.Anchored = true
  ref.CFrame = CF
  so("200632992", ref, 1, math.random(100, 130) / 100)
  MagicCircle(BrickColor.new("New Yeller"), cf(ref.Position) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 0.1, 1, 0.1, 0.2, 8, 0.2, 0.05)
  game:GetService("Debris"):AddItem(ref, 5)
  MagniDamage(ref, 5, 4, 7, 0, "Normal", ref, 0.3, 1, 1, nil, false, false)
end

Clone = function()
  d = lprt18
  local c = part(3, workspace, 0, 0.5, d.BrickColor, "Effect", d.Size)
  c.Anchored = true
  c.CFrame = d.CFrame
  game:GetService("Debris"):AddItem(c, 5)
  m = d.Mesh:Clone()
  m.Parent = c
  table.insert(Effects, {c, "Disappear", 0.05})
  d = lprt19
  local c = part(3, workspace, 0, 0.5, d.BrickColor, "Effect", d.Size)
  c.Anchored = true
  c.CFrame = d.CFrame
  game:GetService("Debris"):AddItem(c, 5)
  m = d.Mesh:Clone()
  m.Parent = c
  table.insert(Effects, {c, "Disappear", 0.05})
  d = rprt18
  local c = part(3, workspace, 0, 0.5, d.BrickColor, "Effect", d.Size)
  c.Anchored = true
  c.CFrame = d.CFrame
  game:GetService("Debris"):AddItem(c, 5)
  m = d.Mesh:Clone()
  m.Parent = c
  table.insert(Effects, {c, "Disappear", 0.05})
  d = rprt19
  local c = part(3, workspace, 0, 0.5, d.BrickColor, "Effect", d.Size)
  c.Anchored = true
  c.CFrame = d.CFrame
  game:GetService("Debris"):AddItem(c, 5)
  m = d.Mesh:Clone()
  m.Parent = c
  table.insert(Effects, {c, "Disappear", 0.05})
end

ElecEffect = function(cff, x, y, z)
  local prt = part(3, workspace, 0, 0, BrickColor.new("Bright red"), "Part", vt(1, 1, 1))
  prt.Anchored = true
  prt.CFrame = cff * cf(math.random(-x, x), math.random(-y, y), math.random(-z, z))
  prt.CFrame = cf(prt.Position)
  game:GetService("Debris"):AddItem(prt, 10)
  xval = math.random() / 3
  yval = math.random() / 3
  zval = math.random() / 3
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(xval, yval, zval))
  Effects[#Effects + 1] = {prt, "Elec", 0.2, x, y, z, xval, yval, zval, msh}
end

  Damagefunc = function(hit, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
  if hit.Parent == nil then
    return 
  end
  if hit.Name == "Hitbox" and hit.Parent ~= modelzorz and ranged ~= true then
    ref = part(3, effects, 0, 1, BrickColor.new("Black"), "Reference", vt())
    ref.Anchored = true
    ref.CFrame = cf(hit.Position)
    game:GetService("Debris"):AddItem(ref, 1)
    hitnum = math.random(1, 5)
    if hitnum == 1 then
      so("199148971", ref, 1, 1)
    else
      if hitnum == 2 then
        so("199149025", ref, 1, 1)
      else
        if hitnum == 3 then
          so("199149072", ref, 1, 1)
        else
          if hitnum == 4 then
            so("199149109", ref, 1, 1)
          else
            if hitnum == 5 then
              so("199149119", ref, 1, 1)
            end
          end
        end
      end
    end
    StaggerHit.Value = true
  end
  h = hit.Parent:FindFirstChild("Humanoid")
  if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
    if hit.Parent:findFirstChild("DebounceHit") ~= nil then
      return 
    end
    c = Instance.new("ObjectValue")
    c.Name = "creator"
    c.Value = game:service("Players").LocalPlayer
    c.Parent = h
    RecentEnemy.Value = hit.Parent
    game:GetService("Debris"):AddItem(c, 0.5)
    minim = minim * Atk.Value
    maxim = maxim * Atk.Value
    Damage = 0
    if minim == maxim then
      Damage = maxim
    else
      Damage = math.random(minim, maxim)
    end
    blocked = false
    enblock = nil
    local EStats = hit.Parent:findFirstChild("Stats")
    if EStats ~= nil then
      invis = EStats:findFirstChild("Invisibility")
      isinvis = EStats:findFirstChild("IsInvisible")
      if (ranged == false or ranged == nil) and invis ~= nil and isinvis.Value == true then
        invis.Value = 0
      end
      enblock = EStats:findFirstChild("Block")
      if enblock ~= nil and enblock.Value == true then
        blocked = true
      end
      if EStats:findFirstChild("Defense") ~= nil then
        Damage = Damage / EStats.Defense.Value
        if Damage <= 3 and (ranged == false or ranged == nil) and blocked ~= true then
          hitnum = math.random(1, 5)
          if hitnum == 1 then
            so("199149321", hit, 1, 1)
          else
            if hitnum == 2 then
              so("199149338", hit, 1, 1)
            else
              if hitnum == 3 then
                so("199149367", hit, 1, 1)
              else
                if hitnum == 4 then
                  so("199149409", hit, 1, 1)
                else
                  if hitnum == 5 then
                    so("199149452", hit, 1, 1)
                  end
                end
              end
            end
          end
        else
          if ranged == false or ranged == nil and blocked ~= true then
            hitnum = math.random(1, 6)
            if hitnum == 1 then
              so("199149137", hit, 1, 1)
            else
              if hitnum == 2 then
                so("199149186", hit, 1, 1)
              else
                if hitnum == 3 then
                  so("199149221", hit, 1, 1)
                else
                  if hitnum == 4 then
                    so("199149235", hit, 1, 1)
                  else
                    if hitnum == 5 then
                      so("199149269", hit, 1, 1)
                    else
                      if hitnum == 6 then
                        so("199149297", hit, 1, 1)
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if Damage <= 3 and staghit == true and ranged ~= true then
          StaggerHit.Value = true
        end
      end
      if EStats:findFirstChild("Stun") ~= nil then
        if blocked == true then
          incstun = incstun / 2
        end
        if EStats.Stun.Value < EStats.StunThreshold.Value then
          EStats.Stun.Value = EStats.Stun.Value + incstun
        end
      end
      if EStats:findFirstChild("Stagger") ~= nil and stagger == true then
        EStats.Stagger.Value = true
      end
    end
    if blocked == true then
      showDamage(hit.Parent, "Block", "Damage")
      if ranged ~= true then
        enblock.Value = false
        Stagger.Value = true
        hitnum = math.random(1, 2)
        if hitnum == 1 then
          so("199148933", hit, 1, 1)
        else
          if hitnum == 2 then
            so("199148947", hit, 1, 1)
          end
        end
      end
    else
      Damage = math.floor(Damage)
      coroutine.resume(coroutine.create(function(Hum, Dam)
	hit.Parent.Humanoid:TakeDamage(Damage)
  end
), h, Damage)
      showDamage(hit.Parent, Damage, "Damage")
      if DecreaseState ~= nil then
        if DecreaseState == "Temporal" then
          DecreaseStat(hit.Parent, "Damage", DecreaseAmount, Duration)
          DecreaseStat(hit.Parent, "Defense", DecreaseAmount, Duration)
        else
          if DecreaseState == "Temporal2" then
            DecreaseStat(hit.Parent, "Damage", DecreaseAmount, Duration)
            DecreaseStat(hit.Parent, "Movement", DecreaseAmount, Duration)
          else
            DecreaseStat(hit.Parent, DecreaseState, DecreaseAmount, Duration)
          end
        end
      end
      if Type == "NormalDecreaseMvmt1" then
        DecreaseStat(hit.Parent, "Movement", 0.1, 200)
      end
      if Type == "Knockdown" then
        hum = hit.Parent.Humanoid
        hum.PlatformStand = true
        coroutine.resume(coroutine.create(function(HHumanoid)
    swait(1)
    HHumanoid.PlatformStand = false
  end
), hum)
        local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
        local bodvol = Instance.new("BodyVelocity")
        bodvol.velocity = angle * knockback
        bodvol.P = 5000
        bodvol.maxForce = Vector3.new(8000, 8000, 8000)
        bodvol.Parent = hit
        rl = Instance.new("BodyAngularVelocity")
        rl.P = 3000
        rl.maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000
        rl.angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10))
        rl.Parent = hit
        game:GetService("Debris"):AddItem(bodvol, 0.5)
        game:GetService("Debris"):AddItem(rl, 0.5)
      else
        do
          if Type == "Knockdown2" then
            hum = hit.Parent.Humanoid
            local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
            local bodvol = Instance.new("BodyVelocity")
            bodvol.velocity = angle * knockback
            bodvol.P = 5000
            bodvol.maxForce = Vector3.new(8000, 8000, 8000)
            bodvol.Parent = hit
            game:GetService("Debris"):AddItem(bodvol, 0.5)
          else
            do
              if Type == "Normal" or Type == "NormalDecreaseMvmt1" then
                vp = Instance.new("BodyVelocity")
                vp.P = 500
                vp.maxForce = Vector3.new(math.huge, 0, math.huge)
                if KnockbackType == 1 then
                  vp.velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
                else
                  if KnockbackType == 2 then
                    vp.velocity = Property.CFrame.lookVector * knockback
                  end
                end
                game:GetService("Debris"):AddItem(vp, 0.5)
                if knockback > 0 then
                  vp.Parent = hit.Parent.Torso
                end
              end
              debounce = Instance.new("BoolValue")
              debounce.Name = "DebounceHit"
              debounce.Parent = hit.Parent
              debounce.Value = true
              game:GetService("Debris"):AddItem(debounce, Delay)
              c = Instance.new("ObjectValue")
              c.Name = "creator"
              c.Value = Player
              c.Parent = h
              game:GetService("Debris"):AddItem(c, 0.5)
              CRIT = false
            end
          end
        end
      end
    end
  end
end

  showDamage = function(Char, Dealt, Type)
  m = Instance.new("Model")
  m.Name = "Effect"
  c = Instance.new("Part")
  c.Transparency = 1
  c.Name = "Head"
  c.TopSurface = 0
  c.BottomSurface = 0
  c.formFactor = "Plate"
  c.Size = Vector3.new(1, 0.4, 1)
  b = Instance.new("BillboardGui", c)
  b.Size = UDim2.new(5, 0, 5, 0)
  b.AlwaysOnTop = true
  damgui = gui("TextLabel", b, tostring(Dealt), 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
  if Type == "Damage" then
    damgui.Font = "SourceSans"
    if Dealt == "Block" then
      damgui.TextColor3 = BrickColor.new("Bright blue").Color
    else
      if Dealt < 3 then
        damgui.TextColor3 = BrickColor.new("White").Color
      else
        if Dealt >= 3 and Dealt < 20 then
          damgui.TextColor3 = BrickColor.new("Bright yellow").Color
        else
          damgui.TextColor3 = BrickColor.new("Really red").Color
          damgui.Font = "SourceSansBold"
        end
      end
    end
  else
    if Type == "Debuff" then
      damgui.TextColor3 = BrickColor.new("White").Color
    else
      if Type == "Interrupt" then
        damgui.TextColor3 = BrickColor.new("New Yeller").Color
      end
    end
  end
  damgui.TextScaled = true
  ms = Instance.new("CylinderMesh")
  ms.Scale = Vector3.new(0.8, 0.8, 0.8)
  ms.Parent = c
  c.Reflectance = 0
  Instance.new("BodyGyro").Parent = c
  c.Parent = m
  if Char:findFirstChild("Head") ~= nil then
    c.CFrame = cf(Char.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
  else
    if Char.Parent:findFirstChild("Head") ~= nil then
      c.CFrame = cf(Char.Parent.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
    end
  end
  f = Instance.new("BodyPosition")
  f.P = 2000
  f.D = 100
  f.maxForce = Vector3.new(545000, 545000, 545000)
  if Type == "Damage" then
    f.position = c.Position + Vector3.new(0, 3, 0)
  else
    if Type == "Debuff" or Type == "Interrupt" then
      f.position = c.Position + Vector3.new(0, 5, 0)
    end
  end
  f.Parent = c
  game:GetService("Debris"):AddItem(m, 5)
  table.insert(Effects, {m, "showDamage", damgui, f, 10, 1, 15, 50, 100})
  c.CanCollide = false
  m.Parent = workspace
  c.CanCollide = false
end

combo = 0
ob1d = function(mouse)
  if attack == true or equipped == false then
    return 
  end
  hold = true
  if combo == 0 then
    combo = 1
    attackone()
    if etheral == true then
      coroutine.resume(coroutine.create(function(EthCF)
    for i = 1, 3 do
      for i = 1, 2 do
        EtheralSlash(EthCF * cf(math.random(-600, 600) / 100, math.random(-600, 600) / 100, math.random(-1200, -400) / 100))
      end
      swait(2)
    end
  end
), RootPart.CFrame)
    end
  else
    if combo == 1 then
      combo = 2
      attacktwo()
      if etheral == true then
        coroutine.resume(coroutine.create(function(EthCF)
    for i = 1, 3 do
      for i = 1, 2 do
        EtheralSlash(EthCF * cf(math.random(-600, 600) / 100, math.random(-600, 600) / 100, math.random(-1200, -400) / 100))
      end
      swait(2)
    end
  end
), RootPart.CFrame)
      end
    else
      if combo == 2 then
        combo = 3
        attackthree()
        if etheral == true then
          coroutine.resume(coroutine.create(function(EthCF)
    for i = 1, 3 do
      for i = 1, 2 do
        EtheralSlash(EthCF * cf(math.random(-600, 600) / 100, math.random(-600, 600) / 100, math.random(-1200, -400) / 100))
      end
      swait(2)
    end
  end
), RootPart.CFrame)
        end
      else
        if combo == 3 then
          combo = 0
          attackfour()
          if etheral == true then
            coroutine.resume(coroutine.create(function(EthCF)
    for i = 1, 3 do
      for i = 1, 2 do
        EtheralSlash(EthCF * cf(math.random(-600, 600) / 100, math.random(-600, 600) / 100, math.random(-1200, -400) / 100))
      end
      swait(2)
    end
  end
), RootPart.CFrame)
          end
        end
      end
    end
  end
  coroutine.resume(coroutine.create(function()
    for i = 1, 50 do
      if attack == false then
        swait()
      end
    end
    if attack == false then
      combo = 0
    end
  end
))
end

ob1u = function(mouse)
  hold = false
end

buttonhold = false
fenbarmove1.MouseButton1Click:connect(do1)
fenbarmove2.MouseButton1Click:connect(do2)
fenbarmove3.MouseButton1Click:connect(do3)
fenbarmove4.MouseButton1Click:connect(do4)
eul = 0
equipped = false
key = function(key)
  if key == "e" and flight == true then
    flight = false
    return 
  end
  if key == "e" and flight == false then
    flight = true
    Flight()
  end
  if attack == true then
    return 
  end
  if key == "f" then
    pressedf = true
    fnumb = 0
    attack = true
    if equipped == false then
      equipped = true
      RSH = ch.Torso["Right Shoulder"]
      LSH = ch.Torso["Left Shoulder"]
      RSH.Parent = nil
      LSH.Parent = nil
      RW.Name = "Right Shoulder"
      RW.Part0 = ch.Torso
      RW.C0 = cf(1.5, 0.5, 0)
      RW.C1 = cf(0, 0.5, 0)
      RW.Part1 = ch["Right Arm"]
      RW.Parent = ch.Torso
      LW.Name = "Left Shoulder"
      LW.Part0 = ch.Torso
      LW.C0 = cf(-1.5, 0.5, 0)
      LW.C1 = cf(0, 0.5, 0)
      LW.Part1 = ch["Left Arm"]
      LW.Parent = ch.Torso
      Animate.Parent = nil
      equipanim()
    else
      equipped = false
      hideanim()
      LH.C1 = LHC1
      RH.C1 = RHC1
      Animate.Parent = Humanoid
      swait(0)
      RW.Parent = nil
      LW.Parent = nil
      RSH.Parent = player.Character.Torso
      LSH.Parent = player.Character.Torso
    end
    attack = false
  end
  if equipped == false then
    return 
  end
  if key == "z" then
    do1()
  end
  if key == "x" then
    do2()
  end
  if key == "c" then
    do3()
  end
  if key == "v" then
    do4()
  end
  if attack == false then
    RecentEnemy.Value = nil
  end
end

key2 = function(key)
end

s = function(mouse)
  mouse.Button1Down:connect(function()
    ob1d(mouse)
  end
)
  mouse.Button1Up:connect(function()
    ob1u(mouse)
  end
)
  mouse.KeyDown:connect(key)
  mouse.KeyUp:connect(key2)
  player = Player
  ch = Character
  MMouse = mouse
end

Player.Chatted:connect(function(chat)
if chat == "music off" then
Character.ShowTime.Volume=0
end
end)

Player.Chatted:connect(function(chat)
if chat == "music on" then
Character.ShowTime.Volume=1
end
end)

ds = function(mouse)
end

Bin.Selected:connect(s)
Bin.Deselected:connect(ds)
print("Proto loaded.")
local mananum = 0
local donum = 0
local stunnum = 0
local etheralnum = 0
local heatnum = 0
local staggeranim = false
local stunanim = false
local Point, LastPoint = nil, nil
local oldhealth = Humanoid.Health
local walk = 0
local walkforw = true
while 1 do
  swait()
  parti4.Rotation = nr(math.random(-50, 50))
  if 50 <= overheat then
    parti4.Enabled = true
  else
    parti4.Enabled = false
  end
  if Humanoid.Health <= 0 then
    attack = true
    resumeControl()
    modelzorz.Parent = workspace
    game:GetService("Debris"):AddItem(modelzorz, 30)
    for i = 1, #Weapon do
      Weapon[i].Parent = modelzorz
      Weapon[i].CanCollide = true
    end
    for i = 1, #Welds do
      if Welds[i].Part0.Parent == Character or Welds[i].Part1.Parent == Character then
        Welds[i].Parent = nil
      else
        Welds[i].Parent = rprt1
      end
    end
  end
  do
    if fnumb < 21 then
      fnumb = fnumb + 1
      if pressedf == false then
        fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency - 0.025
        tellbar.TextTransparency = tellbar.TextTransparency - 0.05
        tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency - 0.05
      else
        if fnumb == 20 then
          fenframe5.Parent = nil
          print("daigui")
        end
        fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency + 0.025
        tellbar.TextTransparency = tellbar.TextTransparency + 0.05
        tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency + 0.05
      end
    end
    if hbwld.Parent == nil then
      hitbox2.Name = "Hitbox"
    else
      hitbox2.Name = "Hitbox2"
    end
    hitbox2.Parent = hitbox.Parent
    hitbox2.Size = hitbox.Size
    hitbox2.CFrame = hitboxCF
    hboxpos.position = hitbox2.Position + vt(math.random(-100, 100) / 100, math.random(-100, 100) / 100, math.random(-100, 100) / 100)
    if hbwld.Parent == nil then
      parti.Enabled = true
    else
      parti.Enabled = false
    end
    if Humanoid.Health < oldhealth and flight == true then
      overheat = overheat + 20
      flight = false
    end
    oldhealth = Humanoid.Health
    if 7 <= heatnum then
      heatnum = 0
      overheat = overheat - 1
    end
    if 100 <= overheat and flight == false then
      overheat = 100
    else
      if overheat <= 0 then
        overheat = 0
      end
    end
    heatnum = heatnum + 1
    if Stagger.Value == true and staggeranim == false then
      coroutine.resume(coroutine.create(function()
  staggeranim = true
  while attack == true do
    swait()
  end
  StaggerAnim()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end
))
    end
    if StaggerHit.Value == true and staggeranim == false then
      coroutine.resume(coroutine.create(function()
  staggeranim = true
  while attack == true do
    swait()
  end
  StaggerHitt()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end
))
    end
    if Mvmt.Value < 0 or StunT.Value <= Stun.Value or Rooted.Value == true then
      Humanoid.WalkSpeed = 0
    else
      Humanoid.WalkSpeed = 16 * Mvmt.Value
    end
    if StunT.Value <= Stun.Value and stunanim == false then
      coroutine.resume(coroutine.create(function()
  stunanim = true
  while attack == true do
    swait()
  end
  StunAnim()
  Stun.Value = 0
  stunanim = false
end
))
    end
    local stunnum2 = 80
    if stunnum2 <= stunnum then
      if 0 < Stun.Value then
        Stun.Value = Stun.Value - 1
      end
      stunnum = 0
    end
    stunnum = stunnum + 1
    if 4 <= etheralnum and etheral == true then
      etheralnum = 0
      Clone()
    else
      etheralnum = etheralnum + 1
    end
    if 0.5 <= donum then
      handidle = true
    else
      if donum <= 0 then
        handidle = false
      end
    end
    if handidle == false then
      donum = donum + 0.003
    else
      donum = donum - 0.003
    end
    local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
    local velderp = RootPart.Velocity.y
    hitfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
    if equipped == true then
      if attack == false then
        idle = idle + 1
      else
        idle = 0
      end
      if (500 <= idle and attack ~= false) or Anim == "Walk" then
        if walkforw == true then
          swait()
          RH.C1 = clerp(RH.C1, RHC1 * cf(0.2, -0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
          LH.C1 = clerp(LH.C1, LHC1 * cf(0.1, 0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
        else
          RH.C1 = clerp(RH.C1, RHC1 * cf(-0.1, 0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
          LH.C1 = clerp(LH.C1, LHC1 * cf(-0.2, -0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
        end
      else
        RH.C1 = clerp(RH.C1, RHC1, 0.2)
        LH.C1 = clerp(LH.C1, LHC1, 0.2)
      end
      if 1 < RootPart.Velocity.y and hitfloor == nil then
        Anim = "Jump"
        if attack == false then
          Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, 0), 0.3)
          RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.5, 0, 1), 0.3)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
          LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.5, 0, -1), 0.3)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
          RH.C0 = clerp(RH.C0, cf(1, -1, -0.3) * euler(-0.5, 1.57, 0) * euler(-0.2, 0, 0), 0.2)
          LH.C0 = clerp(LH.C0, cf(-1, -1, -0.3) * euler(-0.5, -1.57, 0) * euler(-0.2, 0, 0), 0.2)
        end
      else
        if RootPart.Velocity.y < -1 and hitfloor == nil then
          Anim = "Fall"
          if attack == false then
            Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, 0), 0.3)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.2, 0, 0), 0.3)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.3, 0, 0.2), 0.3)
            RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.3, 0, -0.2), 0.3)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
            RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0.4, 1.57, 0), 0.2)
            LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(-0.2, -1.57, 0), 0.2)
          end
        else
          if torvel < 1 and hitfloor ~= nil then
            Anim = "Idle"
            if attack == false then
              Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.3), 0.15)
              RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.3), 0.15)
              RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.6 - (donum) / 3, 0, -0.4) * euler(0, 1.4, 0), 0.15)
              RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.15)
              LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.5 - (donum) / 3, 0, 0.4 - (donum) / 3) * euler(0, -0.4, 0), 0.15)
              LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.15)
              RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.3, 0), 0.15)
              LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, -0.3, 0), 0.15)
            end
          else
            if 2 < torvel and torvel < 30 and hitfloor ~= nil then
              Anim = "Walk"
              walk = walk + 1
              if 15 - 5 * Mvmt.Value <= walk then
                walk = 0
                if walkforw == true then
                  walkforw = false
                else
                  if walkforw == false then
                    walkforw = true
                  end
                end
              end
              if attack == false then
                Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.2)
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
                RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 1) * euler(0, 1, 0), 0.2)
                RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1, 0, -1) * euler(0, -1, 0), 0.2)
                LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.2)
                LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.2)
              end
            else
              if 30 < torvel and hitfloor ~= nil then
                Anim = "Run"
                if attack == false then
                  Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.2)
                  RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
                  RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 1) * euler(0, 1, 0), 0.2)
                  RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                  LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1, 0, -1) * euler(0, -1, 0), 0.2)
                  LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                  RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.2)
                  LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.2)
                end
              end
            end
          end
        end
      end
    end
    if 0 < #Effects then
      for e = 1, #Effects do
        if Effects[e] ~= nil then
          local Thing = Effects[e]
          if Thing ~= nil then
            local Part = Thing[1]
            local Mode = Thing[2]
            local Delay = Thing[3]
            local IncX = Thing[4]
            local IncY = Thing[5]
            local IncZ = Thing[6]
            if Thing[2] == "Shoot" then
              local Look = Thing[1]
              local hit, pos = rayCast(Thing[4], Look, 20, modelzorz)
              local mag = Thing[4] - pos.magnitude
              MagicHead(BrickColor.new("Really red"), CFrame.new((Thing[4] + pos) / 2, pos) * angles(1.57, 0, 0), 1, mag * 5, 1, 0.5, 0, 0.5, 0.1)
              Thing[4] = Thing[4] + Look * 20
              Thing[3] = Thing[3] - 1
              if hit ~= nil then
                Thing[3] = 0
                if Thing[8] == 1 then
                  Damagefunc(hit, Thing[5], Thing[6], Thing[7], "Normal", RootPart, 0, 2, (math.random(1, 5)), nil, nil, true, "Gun")
                else
                  if Thing[8] == 2 then
                    Damagefunc(hit, Thing[5], Thing[6], Thing[7], "NormalDecreaseMvmt1", RootPart, 0, 2, (math.random(1, 5)), nil, nil, true, "Gun")
                  end
                end
                ref = part(3, workspace, 0, 1, BrickColor.new("Really red"), "Reference", vt())
                ref.Anchored = true
                ref.CFrame = cf(pos)
                MagicCircle(BrickColor.new("Really red"), cf(pos), 5, 5, 5, 1, 1, 1, 0.03)
                game:GetService("Debris"):AddItem(ref, 1)
              end
              if Thing[3] <= 0 then
                table.remove(Effects, e)
              end
            end
            do
              do
                if Thing[2] == "CylinderClang" then
                  if Thing[3] <= 1 then
                    Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, 2.5 * Thing[5], 0) * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
                    Thing[7] = Thing[1].CFrame
                    effect("New Yeller", 0, Thing[8], Thing[7])
                    Thing[8] = Thing[7]
                    Thing[3] = Thing[3] + Thing[4]
                  else
                    Part.Parent = nil
                    table.remove(Effects, e)
                  end
                end
                if Thing[2] == "FireWave" then
                  if Thing[3] <= Thing[4] then
                    Thing[1].CFrame = Thing[1].CFrame * euler(0, 1, 0)
                    Thing[3] = Thing[3] + 1
                    Thing[6].Scale = Thing[6].Scale + vt(Thing[5], 0, Thing[5])
                  else
                    Part.Parent = nil
                    table.remove(Effects, e)
                  end
                end
                if Thing[2] == "showDamage" then
                  if Thing[6] < Thing[5] then
                    Thing[6] = Thing[6] + 1
                  else
                    if Thing[6] < Thing[7] then
                      Thing[4].position = Thing[4].position + vt(0, -0.2, 0)
                      Thing[6] = Thing[6] + 1
                    else
                      if Thing[6] < Thing[8] then
                        Thing[6] = Thing[6] + 1
                      else
                        if Thing[6] < Thing[9] then
                          Thing[6] = Thing[6] + 1
                          Thing[4].position = Thing[4].position + vt(0, 0.2, 0)
                          Thing[3].TextStrokeTransparency = Thing[3].TextStrokeTransparency + 0.1
                          Thing[3].TextTransparency = Thing[3].TextTransparency + 0.1
                        else
                          Thing[1].Parent = nil
                          table.remove(Effects, e)
                        end
                      end
                    end
                  end
                end
                if Thing[2] == "Blood" then
                  if 0 <= Thing[3] then
                    Thing[3] = Thing[3] - 1
                  else
                    Thing[1].Parent = nil
                    table.remove(Effects, e)
                  end
                  if Thing[3] == 9 or Thing[3] == 10 then
                    Thing[4].Image = "rbxassetid://179462422"
                  else
                    if Thing[3] == 7 or Thing[3] == 8 then
                      Thing[4].Image = "rbxassetid://179462612"
                    else
                      if Thing[3] == 5 or Thing[3] == 6 then
                        Thing[4].Image = "rbxassetid://179462630"
                      else
                        if Thing[3] == 3 or Thing[3] == 4 then
                          Thing[4].Image = "rbxassetid://179462645"
                        else
                          if Thing[3] == 1 or Thing[3] == 2 then
                            Thing[4].Image = "rbxassetid://179462665"
                          else
                            if Thing[3] == 0 then
                              Thing[4].Image = "rbxassetid://000"
                            end
                          end
                        end
                      end
                    end
                  end
                end
                if Thing[2] ~= "Shoot" and Thing[2] ~= "DecreaseStat" and Thing[2] ~= "Wave" and Thing[2] ~= "FireWave" and Thing[2] ~= "showDamage" and Thing[2] ~= "Blood" then
                  if Thing[1].Transparency <= 1 then
                    if Thing[2] == "Block1" then
                      Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                      Mesh = Thing[7]
                      Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                      Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                    else
                      if Thing[2] == "Block2" then
                        Thing[1].CFrame = Thing[1].CFrame
                        Mesh = Thing[7]
                        Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                        Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                      else
                        if Thing[2] == "Fire" then
                          Thing[1].CFrame = cf(Thing[1].Position) + vt(0, 0.2, 0)
                          Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                          Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                        else
                          if Thing[2] == "Cylinder" then
                            Mesh = Thing[7]
                            Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                            Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                          else
                            if Thing[2] == "Blood" then
                              Mesh = Thing[7]
                              Thing[1].CFrame = Thing[1].CFrame * cf(0, 0.5, 0)
                              Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                              Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            else
                              if Thing[2] == "Elec" then
                                Mesh = Thing[10]
                                Mesh.Scale = Mesh.Scale + vt(Thing[7], Thing[8], Thing[9])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                              else
                                if Thing[2] == "Disappear" then
                                  Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  else
                    Part.Parent = nil
                    table.remove(Effects, e)
                  end
                end
              end
            end
          end
        end
      end
    end
    fenbarmana2:TweenSize((UDim2.new(0.4, 0, -4 * mana.Value / 100, 0)), nil, 1, 0.4, true)
    fenbarmana4.Text = "Mana(" .. mana.Value .. ")"
    fenbarhp2.BackgroundColor3 = Color3.new(Humanoid.Health / Humanoid.MaxHealth, 0, 0)
    fenbarhp2:TweenSize((UDim2.new(Humanoid.Health / Humanoid.MaxHealth, 0, 1, 0)), nil, 1, 0.4, true)
    fenbarhp3.Text = "(" .. math.floor(Humanoid.Health) .. ")"
    fenbarblock2:TweenSize((UDim2.new(0.4, 0, -4 * overheat / 100, 0)), nil, 1, 0.4, true)
    fenbarblock3.Text = "Overheat(" .. math.floor(overheat) .. ")"
    fenbarmove1b:TweenSize((UDim2.new(1 * cooldowns[1] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
    fenbarmove2b:TweenSize((UDim2.new(1 * cooldowns[2] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
    fenbarmove3b:TweenSize((UDim2.new(1 * cooldowns[3] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
    fenbarmove4b:TweenSize((UDim2.new(1 * cooldowns[4] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
    for _,c in pairs(Decrease:children()) do
      if (c:findFirstChild("Duration")) ~= nil then
        c.Duration.Value = c.Duration.Value - 1
        if c.Duration.Value <= 0 then
          c.Parent = nil
        end
      end
      if c.Name == "DecreaseAtk" then
        decreaseatk = decreaseatk + c.Value
      else
        if c.Name == "DecreaseDef" then
          decreasedef = decreasedef + c.Value
        else
          if c.Name == "DecreaseMvmt" then
            decreasemvmt = decreasemvmt + c.Value
          end
        end
      end
    end
    Atk.Value = 1 - (decreaseatk)
    if Atk.Value <= 0 then
      Atk.Value = 0
    end
    Def.Value = 1 - (decreasedef)
    if Def.Value <= 0 then
      Def.Value = 0.01
    end
    Mvmt.Value = 1 - (decreasemvmt)
    if Mvmt.Value <= 0 then
      Mvmt.Value = 0
    end
    decreaseatk = 0
    decreasedef = 0
    decreasemvmt = 0
    AtkVal = Atk.Value * 100
    AtkVal = math.floor(AtkVal)
    AtkVal = AtkVal / 100
    fenbardamage.Text = "Damage\n(" .. AtkVal .. ")"
    DefVal = Def.Value * 100
    DefVal = math.floor(DefVal)
    DefVal = DefVal / 100
    fenbardef.Text = "Defense\n(" .. DefVal .. ")"
    MvmtVal = Mvmt.Value * 100
    MvmtVal = math.floor(MvmtVal)
    MvmtVal = MvmtVal / 100
    if Rooted.Value == true then
      MvmtVal = 0
    end
    fenbarmove.Text = "Walkspeed\n(" .. MvmtVal .. ")"
    if StunT.Value <= Stun.Value then
      fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4, 0)), nil, 1, 0.4, true)
    else
      fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4 * Stun.Value / StunT.Value, 0)), nil, 1, 0.4, true)
    end
    fenbarstun3.Text = "Stun(" .. Stun.Value .. ")"
    if 100 <= mana.Value then
      mana.Value = 100
    else
      if mananum <= 13 and flight == false then
        mananum = mananum + 1
      else
        if flight == false then
          mananum = 0
          mana.Value = mana.Value + 1
        end
      end
    end
    for i = 1, #cooldowns do
      if cooldownmax <= cooldowns[i] then
        cooldowns[i] = cooldownmax
      else
        cooldowns[i] = cooldowns[i] + cooldownsadd[i]
      end
    end
  end
end]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="HopperBin" referent="RBXD9BB7B0AEF8A47F7926BEB06845D0063">
			<Properties>
				<bool name="Active">false</bool>
				<token name="BinType">0</token>
				<string name="Name">Mechanic</string>
				<Content name="TextureId"><null></null></Content>
			</Properties>
			<Item class="LocalScript" referent="RBXCFDD53412C51415D8B38BF93386B6294">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LocalScript</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[wait()
Player = game:GetService("Players").LocalPlayer
Character = Player.Character
PlayerGui = Player.PlayerGui
Backpack = Player.Backpack
Torso = Character.Torso
Head = Character.Head
Humanoid = Character.Humanoid
LeftArm = Character["Left Arm"]
LeftLeg = Character["Left Leg"]
RightArm = Character["Right Arm"]
RightLeg = Character["Right Leg"]
LS = Torso["Left Shoulder"]
LH = Torso["Left Hip"]
RS = Torso["Right Shoulder"]
RH = Torso["Right Hip"]
Neck = Torso.Neck
it = Instance.new
vt = Vector3.new
cf = CFrame.new
euler = CFrame.fromEulerAnglesXYZ
angles = CFrame.Angles
necko = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
necko2 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
LHC0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
LHC1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
RHC0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RHC1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RootPart = Character.HumanoidRootPart
RootJoint = RootPart.RootJoint
RootCF = euler(-1.57, 0, 3.14)
attack = false
attackdebounce = false
MMouse = Player:GetMouse()
combo = 0
local idle = 0
local Anim = "Idle"
local Effects = {}
local Weapon = {}
local Welds = {}
local decreaseatk = 0
local decreasedef = 0
local decreasemvmt = 0
local RailgunTarget, CannonTarget, BladesTarget = nil, nil, nil
local railgunattack = false
local cannonattack = false
local tribladesattack = false
local givingarmor = false
local givingrailgun = false
local givingplasma = false
local givingblades = false
local Target = nil
local move1 = "(Z)\nRailgun Armor"
local move2 = "(X)\nPlasma Cannon Armor"
local move3 = "(C)\nTri-Blades Armor"
local move4 = "(V)\nIon Cannon Strike"
local cooldowns = {}
local cooldown1 = 100
table.insert(cooldowns, cooldown1)
local cooldown2 = 100
table.insert(cooldowns, cooldown2)
local cooldown3 = 100
table.insert(cooldowns, cooldown3)
local cooldown4 = 100
table.insert(cooldowns, cooldown4)
local cooldownsadd = {}
local cooldownadd1 = 0.3
table.insert(cooldownsadd, cooldownadd1)
local cooldownadd2 = 0.4
table.insert(cooldownsadd, cooldownadd2)
local cooldownadd3 = 0.25
table.insert(cooldownsadd, cooldownadd3)
local cooldownadd4 = 0.0475
table.insert(cooldownsadd, cooldownadd4)
local cooldownmax = 100
local manualguardend = false
player = nil
RSH = nil
RW = Instance.new("Motor")
LW = Instance.new("Motor")
RW.Name = "Right Shoulder"
LW.Name = "Left Shoulder"
LH = Torso["Left Hip"]
RH = Torso["Right Hip"]
TorsoColor = Torso.BrickColor
TorsoRed = TorsoColor.Color.r
TorsoGreen = TorsoColor.Color.g
TorsoBlue = TorsoColor.Color.b
NewCol = Color3.new(0.3, TorsoGreen, 0.3)
NewCol2 = Color3.new(TorsoRed, TorsoGreen, TorsoBlue)
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

frame = 1 / 40
tf = 0
allowframeloss = true
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
    tf = tf + s
    if tf >= frame then
        if allowframeloss then
            script.Heartbeat:Fire()
            lastframe = tick()
        else
            for i = 1, math.floor(tf / frame) do
                script.Heartbeat:Fire()
            end
            lastframe = tick()
        end
        if tossremainder then
            tf = 0
        else
            tf = tf - frame * math.floor(tf / frame)
        end
    end
end)

function swait(num)
    if num == 0 or num == nil then
        ArtificialHB.Event:wait()
    else
        for i = 0, num do
            ArtificialHB.Event:wait()
        end
    end
end
if Player:findFirstChild("Color1") ~= nil then
  NewCol = Player.Color1.Value
end
if Player:findFirstChild("Color2") ~= nil then
  NewCol2 = Player.Color2.Value
end
local mdec = Instance.new("NumberValue", Decrease)
mdec.Name = "DecreaseDef"
mdec.Value = 0.4
local mdec2 = Instance.new("NumberValue", Decrease)
mdec2.Name = "DecreaseMvmt"
mdec2.Value = 0.1
local Animate = Character.Animate
local animation = Instance.new("Animation")
animation.AnimationId = "http://www.roblox.com/Asset?ID=180435571"
local animTrack = Humanoid:LoadAnimation(animation)
local canjump = true
removeControl = function()
  canjump = false
end
resumeControl = function()
  canjump = true
end
Player.Character.Humanoid.Changed:connect(function()
  if canjump == false then
    Player.Character.Humanoid.Jump = false
  end
end)
createpassgui = function(parent)
  print("makegui111")
  local g = Instance.new("ScreenGui", parent)
  local f = Instance.new("Frame", g)
  f.Position = UDim2.new(0.3, 0, 0.25, 0)
  f.Size = UDim2.new(0.4, 0, 0.4, 0)
  f.Style = "DropShadow"
  local t = Instance.new("TextBox", f)
  t.BackgroundColor3 = Color3.new(0, 0, 0)
  t.BackgroundTransparency = 0.5
  t.BorderSizePixel = 0
  t.Position = UDim2.new(0.15, 0, 0.2, 0)
  t.Size = UDim2.new(0.7, 0, 0.2, 0)
  t.Font = "SourceSansLight"
  t.Text = "Enter Access Code."
  t.TextScaled = true
  t.TextColor3 = Color3.new(1, 1, 1)
  t.TextStrokeTransparency = 0
  local t2 = Instance.new("TextButton", f)
  t2.BackgroundColor3 = Color3.new(0, 0, 0)
  t2.BackgroundTransparency = 0.5
  t2.BorderSizePixel = 0
  t2.Position = UDim2.new(0.3, 0, 0.5, 0)
  t2.Size = UDim2.new(0.4, 0, 0.15, 0)
  t2.TextScaled = true
  t2.Font = "SourceSansLight"
  t2.Text = "Submit"
  t2.TextColor3 = Color3.new(1, 1, 1)
  t2.TextStrokeTransparency = 0
  print("done1")
  return t2
end

if Character:findFirstChild("Gear Gauntlet", true) ~= nil then
  Character:findFirstChild("Gear Gauntlet", true).Parent = nil
end
if Character:findFirstChild("Railgun", true) ~= nil then
  Character:findFirstChild("Railgun", true).Parent = nil
end
if Character:findFirstChild("Plasma Cannon", true) ~= nil then
  Character:findFirstChild("Plasma Cannon", true).Parent = nil
end
if Character:findFirstChild("Tri-Blades", true) ~= nil then
  Character:findFirstChild("Tri-Blades", true).Parent = nil
end
if Player.PlayerGui:findFirstChild("WeaponGUI", true) ~= nil then
  Player.PlayerGui:findFirstChild("WeaponGUI", true).Parent = nil
end
if Character:findFirstChild("Stats", true) ~= nil then
  Character:findFirstChild("Stats", true).Parent = nil
end
local Stats = Instance.new("BoolValue")
Stats.Name = "Stats"
Stats.Parent = Character
local Atk = Instance.new("NumberValue")
Atk.Name = "Damage"
Atk.Parent = Stats
Atk.Value = 1
local Def = Instance.new("NumberValue")
Def.Name = "Defense"
Def.Parent = Stats
Def.Value = 1
local Mvmt = Instance.new("NumberValue")
Mvmt.Name = "Movement"
Mvmt.Parent = Stats
Mvmt.Value = 1
local Block = Instance.new("BoolValue")
Block.Name = "Block"
Block.Parent = Stats
Block.Value = false
local Stun = Instance.new("NumberValue")
Stun.Name = "Stun"
Stun.Parent = Stats
Stun.Value = 0
local StunT = Instance.new("NumberValue")
StunT.Name = "StunThreshold"
StunT.Parent = Stats
StunT.Value = 100
local Rooted = Instance.new("BoolValue")
Rooted.Name = "Rooted"
Rooted.Parent = Stats
Rooted.Value = false
local Decrease = Instance.new("BoolValue")
Decrease.Name = "Decrease"
Decrease.Parent = Stats
Decrease.Value = false
local Stunned = Instance.new("BoolValue")
Stunned.Name = "Stunned"
Stunned.Parent = Stats
Stunned.Value = false
local Stagger = Instance.new("BoolValue")
Stagger.Name = "Stagger"
Stagger.Parent = Stats
Stagger.Value = false
local StaggerHit = Instance.new("BoolValue")
StaggerHit.Name = "StaggerHit"
StaggerHit.Parent = Stats
StaggerHit.Value = false
local RecentEnemy = Instance.new("ObjectValue")
RecentEnemy.Name = "RecentEnemy"
RecentEnemy.Parent = Stats
RecentEnemy.Value = nil
local mana = Instance.new("NumberValue")
mana.Name = "Mana"
mana.Parent = Stats
mana.Value = 30
NoOutline = function(Part)
Part.TopSurface = 10
Part.BottomSurface = 10
Part.RightSurface = 10
Part.LeftSurface = 10
Part.BackSurface = 10
Part.FrontSurface = 10
end
part = function(formfactor, parent, reflectance, transparency, brickcolor, name, size)
  local fp = it("Part")
  fp.formFactor = formfactor
  fp.Parent = parent
  fp.Reflectance = reflectance
  fp.Transparency = transparency
  fp.CanCollide = false
  fp.Locked = true
  fp.BrickColor = brickcolor
  fp.Name = name
  fp.Size = size
  fp.Position = Torso.Position
  NoOutline(fp)
  fp.Material = "SmoothPlastic"
  fp:BreakJoints()
  return fp
end
mesh = function(Mesh, part, meshtype, meshid, offset, scale)
  local mesh = it(Mesh)
  mesh.Parent = part
  if Mesh == "SpecialMesh" then
    mesh.MeshType = meshtype
    if meshid ~= "nil" then
      mesh.MeshId = "http://www.roblox.com/asset/?id=" .. meshid
    end
  end
  mesh.Offset = offset
  mesh.Scale = scale
  return mesh
end
weld = function(parent, part0, part1, c0)
  local weld = it("Motor")
  weld.Parent = parent
  weld.Part0 = part0
  weld.Part1 = part1
  weld.C0 = c0
  return weld
end
gui = function(GuiType, parent, text, backtrans, backcol, pos, size)
  local gui = it(GuiType)
  gui.Parent = parent
  gui.Text = text
  gui.BackgroundTransparency = backtrans
  gui.BackgroundColor3 = backcol
  gui.SizeConstraint = "RelativeXY"
  gui.TextXAlignment = "Center"
  gui.TextYAlignment = "Center"
  gui.Position = pos
  gui.Size = size
  gui.Font = "SourceSans"
  gui.FontSize = "Size14"
  gui.TextWrapped = false
  gui.TextStrokeTransparency = 0
  gui.TextColor = BrickColor.new("White")
  return gui
end
local Color1 = Torso.BrickColor
local fengui = it("GuiMain")
fengui.Parent = Player.PlayerGui
fengui.Name = "WeaponGUI"
local fenframe = it("Frame")
fenframe.Parent = fengui
fenframe.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe.BackgroundTransparency = 1
fenframe.BorderColor3 = Color3.new(17, 17, 17)
fenframe.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe.Position = UDim2.new(0.95, 0, 0.7, 0)
local fenframe2 = it("Frame")
fenframe2.Parent = fengui
fenframe2.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe2.BackgroundTransparency = 1
fenframe2.BorderColor3 = Color3.new(17, 17, 17)
fenframe2.Size = UDim2.new(0.2, 0, 0.1, 0)
fenframe2.Position = UDim2.new(0.4, 0, 0.85, 0)
local fenframe3 = it("Frame")
fenframe3.Parent = fengui
fenframe3.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe3.BackgroundTransparency = 1
fenframe3.BorderColor3 = Color3.new(17, 17, 17)
fenframe3.Size = UDim2.new(0.2, 0, 0.2, 0)
fenframe3.Position = UDim2.new(0.8, 0, 0.8, 0)
fenframe3.Name = "MoveFrame"
local fenframe4 = it("Frame")
fenframe4.Parent = fengui
fenframe4.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe4.BackgroundTransparency = 1
fenframe4.BorderColor3 = Color3.new(17, 17, 17)
fenframe4.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe4.Position = UDim2.new(0, 0, 0.7, 0)
local pressedf = false
local fenframe5 = it("Frame")
fenframe5.Parent = fengui
fenframe5.BackgroundColor3 = Color3.new(0, 0, 0)
fenframe5.BackgroundTransparency = 1
fenframe5.BorderColor3 = Color3.new(0, 0, 0)
fenframe5.Size = UDim2.new(1, 0, 1, 0)
fenframe5.Position = UDim2.new(0, 0, 0, 0)
fenframe5.ZIndex = 2
local tellbar = gui("TextLabel", fenframe5, "Press \'F\' to equip your weapon.", 1, Color3.new(0, 0, 0), UDim2.new(0.25, 0, 0.25, 0), UDim2.new(0.5, 0, 0.5, 0))
tellbar.Font = "Arial"
tellbar.TextScaled = true
tellbar.TextTransparency = 1
tellbar.TextStrokeTransparency = 1
tellbar.ZIndex = 2
local fnumb = 0
local fenbarmana1 = gui("TextLabel", fenframe, "", 0, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarmana2 = gui("TextLabel", fenframe, "", 0, BrickColor.new("Dark green").Color, UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarmana4 = gui("TextLabel", fenframe, "Mana(" .. mana.Value .. ")", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbardamage = gui("TextLabel", fenframe2, "Damage", 0.55, Color3.new(0.6078431372549, 0, 0), UDim2.new(-0.23, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbardef = gui("TextLabel", fenframe2, "Defense", 0.55, Color3.new(0, 0, 0.6078431372549), UDim2.new(-0.46, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarmove = gui("TextLabel", fenframe2, "Walkspeed", 0.55, Color3.new(0, 0.6078431372549, 0), UDim2.new(1.03, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarhp1 = gui("TextLabel", fenframe2, "", 0, Color3.new(0, 0, 0), UDim2.new(-0.46, 0, 1, 0), UDim2.new(1.92, 0, 0.4, 0))
local fenbarhp2 = gui("TextLabel", fenbarhp1, "", 0, Color3.new(1, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarhp3 = gui("TextLabel", fenbarhp1, "(100)", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
local fenbarstun1 = gui("TextLabel", fenframe4, "", 0, Color3.new(0, 0, 0), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarstun2 = gui("TextLabel", fenframe4, "", 0, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarstun3 = gui("TextLabel", fenframe4, "Stun(" .. Stun.Value .. ")", 1, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbarmove1 = gui("TextButton", fenframe3, move1, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove1.ZIndex = 2
local fenbarmove1b = gui("TextLabel", fenbarmove1, "", 0.55, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove2 = gui("TextButton", fenframe3, move2, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove2.ZIndex = 2
local fenbarmove2b = gui("TextLabel", fenbarmove2, "", 0.55, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove3 = gui("TextButton", fenframe3, move3, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove3.ZIndex = 2
local fenbarmove3b = gui("TextLabel", fenbarmove3, "", 0.55, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove4 = gui("TextButton", fenframe3, move4, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove4.ZIndex = 2
local fenbarmove4b = gui("TextLabel", fenbarmove4, "", 0.55, BrickColor.new("Really red").Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local modelzorz = Instance.new("Model")
modelzorz.Parent = Character
modelzorz.Name = "Gear Gauntlet"
RightArm.Transparency = 1
local handle = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Handle", vt())
local prt1 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Part01", vt())
local prt2 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part02", vt())
local prt3 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part03", vt())
local prt4 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part04", vt())
local prt5 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part05", vt())
local prt6 = part(3, modelzorz, 0, 0, BrickColor.new("Medium stone grey"), "Part06", vt())
local prt7 = part(3, modelzorz, 0, 0, Torso.BrickColor, "Part07", vt())
local prt8 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part08", vt())
local prt9 = part(3, modelzorz, 0, 0, BrickColor.new("Medium stone grey"), "Part09", vt())
local prt10 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Part10", vt())
local prt11 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part11", vt())
local prt12 = part(3, modelzorz, 0, 0, BrickColor.new("Really black"), "Part12", vt())
local prt13 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part13", vt())
local prt14 = part(3, modelzorz, 0, 0, BrickColor.new("Medium stone grey"), "Part14", vt())
local prt15 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Part15", vt())
local prt16 = part(3, modelzorz, 0.4, 0, BrickColor.new(NewCol), "Part16", vt())
hmsh = mesh("BlockMesh", handle, "", "", vt(0, 0, 0), vt(5.1, 10.1, 5.1))
msh1 = mesh("BlockMesh", prt1, "", "", vt(0, 0, 0), vt(6, 3, 6))
msh2 = mesh("BlockMesh", prt2, "", "", vt(0, 0, 0), vt(1, 3.5, 5.25))
msh3 = mesh("BlockMesh", prt3, "", "", vt(0, 0, 0), vt(5.25, 3.5, 1))
msh4 = mesh("BlockMesh", prt4, "", "", vt(0, 0, 0), vt(8, 8.1, 1))
msh5 = mesh("BlockMesh", prt5, "", "", vt(0, 0, 0), vt(8, 8.1, 1))
msh6 = mesh("BlockMesh", prt6, "", "", vt(0, 0, 0), vt(3, 0.5, 3))
msh7 = mesh("SpecialMesh", prt7, "Sphere", "nil", vt(0, 0, 0), vt(2.5, 2.5, 2.5))
msh8 = mesh("CylinderMesh", prt8, "", "", vt(0, 0, 0), vt(3, 0.5, 0.3))
msh9 = mesh("CylinderMesh", prt9, "", "", vt(0, 0, 0), vt(1.5, 0.5, 1.5))
msh10 = mesh("CylinderMesh", prt10, "", "", vt(0, 0, 0), vt(1, 0.5, 1))
msh11 = mesh("BlockMesh", prt11, "", "", vt(0, 0, 0), vt(2, 2, 6))
msh12 = mesh("SpecialMesh", prt12, "Wedge", "nil", vt(0, 0, 0), vt(2, 1, 4))
msh13 = mesh("CylinderMesh", prt13, "", "", vt(0, 0, 0), vt(3, 0.5, 0.3))
msh14 = mesh("CylinderMesh", prt14, "", "", vt(0, 0, 0), vt(1.5, 0.5, 1.5))
msh15 = mesh("CylinderMesh", prt15, "", "", vt(0, 0, 0), vt(1, 0.5, 1))
msh16 = mesh("SpecialMesh", prt16, "FileMesh", "9756362", vt(0, 0, 0), vt(0.2, 1, 0.6))
local hwld = weld(handle, handle, RightArm, euler(0, 0, 0) * cf(0, 0, 0))
local wld1 = weld(prt1, prt1, handle, euler(0, 0, 0) * cf(0, 0.6, 0))
local wld2 = weld(prt1, prt2, prt1, euler(0, 0, 0) * cf(-0.2, 0.1, 0))
local wld3 = weld(prt1, prt3, prt1, euler(0, 0, 0) * cf(0, 0.1, 0))
local wld4 = weld(prt1, prt4, prt1, euler(0, 0.785, 0) * cf(0, -0.81, 0))
local wld5 = weld(prt1, prt5, prt1, euler(0, -0.785, 0) * cf(0, -0.81, 0))
local wld6 = weld(prt1, prt6, prt1, euler(0, 0, 0) * cf(0, -1.6, 0))
local wld7 = weld(prt1, prt7, prt6, euler(0, 0, 0) * cf(0, 0, 0))
local wld8 = weld(prt1, prt8, prt1, euler(1.57, 0, -1.57) * cf(0, 0, -0.55))
local wld9 = weld(prt1, prt9, prt8, euler(0, 0, 0) * cf(0, 0.05, 0))
local wld10 = weld(prt1, prt10, prt9, euler(0, 0, 0) * cf(0, 0.01, 0))
local wld11 = weld(prt1, prt11, handle, euler(0, 0, 0) * cf(-0.4, -0.5, 0))
local wld12 = weld(prt1, prt12, prt11, euler(-0.5, 1.57, 1.57) * cf(-0.3, 0.2, 0))
local wld13 = weld(prt1, prt13, prt1, euler(1.57, 0, -1.57) * cf(0, 0, 0.55))
local wld14 = weld(prt1, prt14, prt13, euler(0, 0, 0) * cf(0, -0.05, 0))
local wld15 = weld(prt1, prt15, prt14, euler(0, 0, 0) * cf(0, -0.01, 0))
local wld16 = weld(prt1, prt16, prt1, euler(0, 0, 0) * cf(-0.6, 0, 0))
numb2 = 0
for i = 1, 4 do
  numb = 0.3
  for i = 1, 3 do
    local prtclaw = part(3, modelzorz, 0, 0, BrickColor.new("Medium stone grey"), "Partclaw", vt())
    mshclaw = mesh("SpecialMesh", prtclaw, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 1.5, 0.5))
    local wldclaw = weld(prt1, prtclaw, prt1, euler(1.57, -1.57, -1.57) * cf(-0.6, 0.3, numb) * euler(0, numb2, 0))
    numb = numb - 0.3
  end
  numb2 = numb2 + 1.57
end
numb = 0
for i = 1, 5 do
  local prtgear = part(3, modelzorz, 0, 0, BrickColor.new("Medium stone grey"), "Partgear", vt())
  mshgear = mesh("BlockMesh", prtgear, "", "", vt(0, 0, 0), vt(2, 0.45, 0.35))
  local wldgear = weld(prt1, prtgear, prt9, euler(0, numb, 0) * cf(0, 0, 0))
  numb = numb + 0.628
end
numb = 0
for i = 1, 5 do
  local prtgear = part(3, modelzorz, 0, 0, BrickColor.new("Medium stone grey"), "Partgear", vt())
  mshgear = mesh("BlockMesh", prtgear, "", "", vt(0, 0, 0), vt(2, 0.45, 0.35))
  local wldgear = weld(prt1, prtgear, prt14, euler(0, numb, 0) * cf(0, 0, 0))
  numb = numb + 0.628
end
num = 0.3
num2 = 0.5
for i = 1, 3 do
  local prtclaw1 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Partclaw1", vt())
  clawmsh1 = mesh("SpecialMesh", prtclaw1, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 2))
  local clawwld1 = weld(prt1, prtclaw1, prt11, euler(0, -1.57 + num2, 1.57) * cf(-0.2, -0.2, num))
  num = num - 0.3
  num2 = num2 - 0.5
end
num1 = 0.5
for i = 1, 2 do
  num = 1.57
  num2 = 0.08
  for i = 1, 2 do
    local prt17 = part(3, modelzorz, 0.5, 0, BrickColor.new("Medium stone grey"), "Part17", vt())
    msh17 = mesh("SpecialMesh", prt17, "Wedge", "nil", vt(0, 0, 0), vt(0.2, 4, 0.8))
    local wld17 = weld(prt1, prt17, handle, euler(3.14, num, 0) * cf(num2, -0.3, num1))
    num = num - 3.14
    num2 = num2 - 0.16
  end
  num1 = num1 - 1
end
for _,c in pairs(modelzorz:children()) do
  table.insert(Weapon, c)
end
for _,c in pairs(prt1:children()) do
  if c.className == "Motor" then
    table.insert(Welds, c)
  end
end
local Color1 = BrickColor.new("Medium stone grey")
local Color2 = BrickColor.new(NewCol)
local Color4 = BrickColor.new("Really black")
local model1 = (Instance.new("Model"))
model1.Parent = nil
model1.Name = "Railgun"
Railgun = {}
RailgunWelds = {}
local model2 = (Instance.new("Model"))
model2.Parent = nil
model2.Name = "Plasma Cannon"
Plasma = {}
PlasmaWelds = {}
local model3 = (Instance.new("Model"))
model3.Parent = nil
model3.Name = "Tri-Blades"
Blades = {}
BladesWelds = {}
rprt1 = part(3, model1, 0, 0, Color1, "Part1", vt())
rprt2 = part(3, model1, 0, 0, Color2, "Part2", vt())
rprt3 = part(3, model1, 0, 0, Color2, "Part3", vt())
rprt4 = part(3, model1, 0, 0, Color2, "Part4", vt())
rprt5 = part(3, model1, 0, 0, Color2, "Part5", vt())
rprt6 = part(3, model1, 0, 0, Color2, "Part6", vt())
rprt7 = part(3, model1, 0, 0, Color1, "Part7", vt())
rprt8 = part(3, model1, 0, 0, Color4, "Part8", vt())
rprt9 = part(3, model1, 0, 0, Color1, "Part9", vt())
rprt10 = part(3, model1, 0, 0, Color1, "Part10", vt())
rprt11 = part(3, model1, 0, 0, Color1, "Part11", vt())
rprt12 = part(3, model1, 0, 0, Color1, "Part12", vt())
rprt13 = part(3, model1, 0, 0, Color1, "Part13", vt())
rprt14 = part(3, model1, 0, 0, Color1, "Part14", vt())
rprt15 = part(3, model1, 0, 0, Color1, "Part15", vt())
rprt16 = part(3, model1, 0, 0, Color1, "Part16", vt())
rprt17 = part(3, model1, 0, 0, Color1, "Part17", vt())
rprt18 = part(3, model1, 0, 0, Color2, "Part18", vt())
rprt19 = part(3, model1, 0, 0, Color2, "Part19", vt())
rprt20 = part(3, model1, 0.2, 0, Color1, "Part20", vt())
rprt21 = part(3, model1, 0.2, 0, Color1, "Part21", vt())
rprt22 = part(3, model1, 0.5, 0, Color1, "Part22", vt())
rprt23 = part(3, model1, 0.5, 0, Color1, "Part23", vt())
rprt24 = part(3, model1, 0, 0, Color2, "Part24", vt())
rprt25 = part(3, model1, 0, 0, Color2, "Part25", vt())
rprt26 = part(3, model1, 0.2, 0, Color1, "Part26", vt())
rprt27 = part(3, model1, 0.2, 0, Color1, "Part27", vt())
rprt28 = part(3, model1, 0.5, 0, Color1, "Part28", vt())
rprt29 = part(3, model1, 0.5, 0, Color1, "Part29", vt())
rprt30 = part(3, model1, 0, 0, Color2, "Part30", vt())
rprt31 = part(3, model1, 0, 0, Color2, "Part31", vt())
rprt32 = part(3, model1, 0.2, 0, Color1, "Part32", vt())
rprt33 = part(3, model1, 0.2, 0, Color1, "Part33", vt())
rprt34 = part(3, model1, 0.5, 0, Color1, "Part34", vt())
rprt35 = part(3, model1, 0.5, 0, Color1, "Part35", vt())
for _,c in pairs(model1:children()) do
  table.insert(Railgun, c)
end
pprt1 = part(3, model2, 0, 0, Color1, "aPart1", vt())
pprt2 = part(3, model2, 0, 0, Color2, "aPart2", vt())
pprt3 = part(3, model2, 0, 0, Color2, "aPart3", vt())
pprt4 = part(3, model2, 0, 0, Color2, "aPart4", vt())
pprt5 = part(3, model2, 0, 0, Color2, "aPart5", vt())
pprt6 = part(3, model2, 0, 0, Color2, "aPart6", vt())
pprt7 = part(3, model2, 0, 0, Color2, "aPart7", vt())
pprt8 = part(3, model2, 0, 0, Color1, "aPart8", vt())
pprt9 = part(3, model2, 0, 0, Color1, "aPart9", vt())
pprt10 = part(3, model2, 0, 0, Color4, "aPart10", vt())
pprt11 = part(3, model2, 0, 0, Color4, "aPart11", vt())
pprt12 = part(3, model2, 0, 0, Color1, "aPart12", vt())
pprt13 = part(3, model2, 0, 0, Color1, "aPart13", vt())
pprt14 = part(3, model2, 0, 0, Color1, "aPart14", vt())
pprt15 = part(3, model2, 0, 0, Color1, "aPart15", vt())
pprt16 = part(3, model2, 0, 0, Color1, "aPart16", vt())
pprt17 = part(3, model2, 0, 0, Color1, "aPart17", vt())
pprt18 = part(3, model2, 0, 0, Color1, "aPart18", vt())
pprt19 = part(3, model2, 0, 0, Color2, "aPart19", vt())
pprt20 = part(3, model2, 0, 0, Color2, "aPart20", vt())
pprt21 = part(3, model2, 0.2, 0, Color1, "aPart21", vt())
pprt22 = part(3, model2, 0.2, 0, Color1, "aPart22", vt())
pprt23 = part(3, model2, 0.5, 0, Color1, "aPart23", vt())
pprt24 = part(3, model2, 0.5, 0, Color1, "aPart24", vt())
pprt25 = part(3, model2, 0, 0, Color2, "aPart25", vt())
pprt26 = part(3, model2, 0, 0, Color2, "aPart26", vt())
pprt27 = part(3, model2, 0.2, 0, Color1, "aPart27", vt())
pprt28 = part(3, model2, 0.2, 0, Color1, "aPart28", vt())
pprt29 = part(3, model2, 0.5, 0, Color1, "aPart29", vt())
pprt30 = part(3, model2, 0.5, 0, Color1, "aPart30", vt())
pprt31 = part(3, model2, 0, 0, Color2, "aPart31", vt())
pprt32 = part(3, model2, 0, 0, Color2, "aPart32", vt())
pprt33 = part(3, model2, 0.2, 0, Color1, "aPart33", vt())
pprt34 = part(3, model2, 0.2, 0, Color1, "aPart34", vt())
pprt35 = part(3, model2, 0.5, 0, Color1, "aPart35", vt())
pprt36 = part(3, model2, 0.5, 0, Color1, "aPart36", vt())
pprt37 = part(3, model2, 0, 0, Color2, "aPart37", vt())
pprt38 = part(3, model1, 0, 0, Color1, "aPart38", vt())
pprt39 = part(3, model1, 0, 0, Color1, "aPart39", vt())
for _,c in pairs(model2:children()) do
  table.insert(Plasma, c)
end
bref = part(3, model3, 0, 1, Color4, "bRef", vt())
bprt1 = part(3, model3, 0, 1, Color1, "bPart1", vt())
bprt2 = part(3, model3, 0, 0, Color1, "bPart2", vt())
bprt3 = part(3, model3, 0, 0, Color2, "bPart3", vt())
bprt4 = part(3, model3, 0.8, 0, Color1, "bPart4", vt())
bprt5 = part(3, model3, 0.8, 0, Color1, "bPart5", vt())
bprt6 = part(3, model3, 0.8, 0, Color1, "bPart6", vt())
bprt7 = part(3, model3, 0, 1, Color1, "bPart7", vt())
bprt8 = part(3, model3, 0, 0, Color1, "bPart8", vt())
bprt9 = part(3, model3, 0, 0, Color2, "bPart9", vt())
bprt10 = part(3, model3, 0.8, 0, Color1, "bPart10", vt())
bprt11 = part(3, model3, 0.8, 0, Color1, "bPart11", vt())
bprt12 = part(3, model3, 0.8, 0, Color1, "bPart12", vt())
bprt13 = part(3, model3, 0, 1, Color1, "bPart13", vt())
bprt14 = part(3, model3, 0, 0, Color1, "bPart14", vt())
bprt15 = part(3, model3, 0, 0, Color2, "bPart15", vt())
bprt16 = part(3, model3, 0.8, 0, Color1, "bPart16", vt())
bprt17 = part(3, model3, 0.8, 0, Color1, "bPart17", vt())
bprt18 = part(3, model3, 0.8, 0, Color1, "bPart18", vt())
for _,c in pairs(model3:children()) do
  table.insert(Blades, c)
end
msh1 = mesh("BlockMesh", rprt1, "", "", vt(0, 0, 0), vt(1, 1, 1))
msh2 = mesh("BlockMesh", rprt2, "", "", vt(0, 0, 0), vt(1.3, 2.5, 10))
msh3 = mesh("BlockMesh", rprt3, "", "", vt(0, 0, 0), vt(1.49, 2.5, 5))
msh4 = mesh("BlockMesh", rprt4, "", "", vt(0, 0, 0), vt(1.51, 2.5, 3))
msh5 = mesh("CylinderMesh", rprt5, "", "", vt(0, 0, 0), vt(2.5, 1, 2.5))
msh6 = mesh("CylinderMesh", rprt6, "", "", vt(0, 0, 0), vt(1.5, 16, 1.5))
msh7 = mesh("CylinderMesh", rprt7, "", "", vt(0, 0, 0), vt(1.6, 1, 1.6))
msh8 = mesh("CylinderMesh", rprt8, "", "", vt(0, 0, 0), vt(1.4, 1.01, 1.4))
msh9 = mesh("BlockMesh", rprt9, "", "", vt(0, 0, 0), vt(1.4, 14, 2))
msh10 = mesh("SpecialMesh", rprt10, "Wedge", "nil", vt(0, 0, 0), vt(1.3, 4, 3))
msh11 = mesh("SpecialMesh", rprt11, "Wedge", "nil", vt(0, 0, 0), vt(1.3, 2, 3))
msh12 = mesh("SpecialMesh", rprt12, "Wedge", "nil", vt(0, 0, 0), vt(1.7, 3, 3.5))
msh13 = mesh("BlockMesh", rprt13, "", "", vt(0, 0, 0), vt(1.5, 1.5, 1.5))
msh14 = mesh("BlockMesh", rprt14, "", "", vt(0, 0, 0), vt(1.6, 4.5, 2))
msh15 = mesh("BlockMesh", rprt15, "", "", vt(0, 0, 0), vt(1.6, 3.6, 2))
msh16 = mesh("SpecialMesh", rprt16, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 3, 3.5))
msh17 = mesh("SpecialMesh", rprt17, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 2, 4))
msh19 = mesh("SpecialMesh", rprt19, "Sphere", "nil", vt(0, 0, 0), vt(1.5, 1.5, 1.5))
msh20 = mesh("SpecialMesh", rprt20, "Wedge", "nil", vt(0, 0, 0), vt(0.2, 8, 0.5))
msh21 = mesh("SpecialMesh", rprt21, "Wedge", "nil", vt(0, 0, 0), vt(0.2, 8, 0.5))
msh22 = mesh("SpecialMesh", rprt22, "Wedge", "nil", vt(0, 0, 0), vt(0.3, 7, 0.7))
msh23 = mesh("SpecialMesh", rprt23, "Wedge", "nil", vt(0, 0, 0), vt(0.3, 7, 0.7))
msh25 = mesh("SpecialMesh", rprt25, "Sphere", "nil", vt(0, 0, 0), vt(1.5, 1.5, 1.5))
msh26 = mesh("SpecialMesh", rprt26, "Wedge", "nil", vt(0, 0, 0), vt(0.2, 8, 0.5))
msh27 = mesh("SpecialMesh", rprt27, "Wedge", "nil", vt(0, 0, 0), vt(0.2, 8, 0.5))
msh28 = mesh("SpecialMesh", rprt28, "Wedge", "nil", vt(0, 0, 0), vt(0.3, 7, 0.7))
msh29 = mesh("SpecialMesh", rprt29, "Wedge", "nil", vt(0, 0, 0), vt(0.3, 7, 0.7))
msh31 = mesh("SpecialMesh", rprt31, "Sphere", "nil", vt(0, 0, 0), vt(1.5, 1.5, 1.5))
msh32 = mesh("SpecialMesh", rprt32, "Wedge", "nil", vt(0, 0, 0), vt(0.2, 8, 0.5))
msh33 = mesh("SpecialMesh", rprt33, "Wedge", "nil", vt(0, 0, 0), vt(0.2, 8, 0.5))
msh34 = mesh("SpecialMesh", rprt34, "Wedge", "nil", vt(0, 0, 0), vt(0.3, 7, 0.7))
msh35 = mesh("SpecialMesh", rprt35, "Wedge", "nil", vt(0, 0, 0), vt(0.3, 7, 0.7))
msh1 = mesh("BlockMesh", pprt1, "", "", vt(0, 0, 0), vt(1, 1, 1))
msh2 = mesh("BlockMesh", pprt2, "", "", vt(0, 0, 0), vt(2, 1.3, 5))
msh3 = mesh("SpecialMesh", pprt3, "Wedge", "nil", vt(0, 0, 0), vt(2, 2, 1))
msh4 = mesh("BlockMesh", pprt4, "", "", vt(0, 0, 0), vt(2, 2, 6))
msh5 = mesh("BlockMesh", pprt5, "", "", vt(0, 0, 0), vt(2, 2, 2))
msh6 = mesh("CylinderMesh", pprt6, "", "", vt(0, 0, 0), vt(2, 5, 2))
msh7 = mesh("CylinderMesh", pprt7, "", "", vt(0, 0, 0), vt(2, 5, 2))
msh8 = mesh("CylinderMesh", pprt8, "", "", vt(0, 0, 0), vt(2.1, 1, 2.1))
msh9 = mesh("CylinderMesh", pprt9, "", "", vt(0, 0, 0), vt(2.1, 1, 2.1))
msh10 = mesh("CylinderMesh", pprt10, "", "", vt(0, 0, 0), vt(1.9, 1.01, 1.9))
msh11 = mesh("CylinderMesh", pprt11, "", "", vt(0, 0, 0), vt(1.9, 1.01, 1.9))
msh12 = mesh("CylinderMesh", pprt12, "", "", vt(0, 0, 0), vt(2.2, 5.5, 2.2))
msh13 = mesh("SpecialMesh", pprt13, "Wedge", "nil", vt(0, 0, 0), vt(1.7, 3, 3.5))
msh14 = mesh("BlockMesh", pprt14, "", "", vt(0, 0, 0), vt(1.5, 1.5, 1.5))
msh15 = mesh("BlockMesh", pprt15, "", "", vt(0, 0, 0), vt(1.6, 4.5, 2))
msh16 = mesh("BlockMesh", pprt16, "", "", vt(0, 0, 0), vt(1.6, 3.6, 2))
msh17 = mesh("SpecialMesh", pprt17, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 3, 3.5))
msh18 = mesh("SpecialMesh", pprt18, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 2, 4))
msh20 = mesh("SpecialMesh", pprt20, "Sphere", "nil", vt(0, 0, 0), vt(1.5, 1.5, 1.5))
msh21 = mesh("SpecialMesh", pprt21, "Wedge", "nil", vt(0, 0, 0), vt(0.2, 8, 0.5))
msh22 = mesh("SpecialMesh", pprt22, "Wedge", "nil", vt(0, 0, 0), vt(0.2, 8, 0.5))
msh23 = mesh("SpecialMesh", pprt23, "Wedge", "nil", vt(0, 0, 0), vt(0.3, 7, 0.7))
msh24 = mesh("SpecialMesh", pprt24, "Wedge", "nil", vt(0, 0, 0), vt(0.3, 7, 0.7))
msh26 = mesh("SpecialMesh", pprt26, "Sphere", "nil", vt(0, 0, 0), vt(1.5, 1.5, 1.5))
msh27 = mesh("SpecialMesh", pprt27, "Wedge", "nil", vt(0, 0, 0), vt(0.2, 8, 0.5))
msh28 = mesh("SpecialMesh", pprt28, "Wedge", "nil", vt(0, 0, 0), vt(0.2, 8, 0.5))
msh29 = mesh("SpecialMesh", pprt29, "Wedge", "nil", vt(0, 0, 0), vt(0.3, 7, 0.7))
msh30 = mesh("SpecialMesh", pprt30, "Wedge", "nil", vt(0, 0, 0), vt(0.3, 7, 0.7))
msh32 = mesh("SpecialMesh", pprt32, "Sphere", "nil", vt(0, 0, 0), vt(1.5, 1.5, 1.5))
msh33 = mesh("SpecialMesh", pprt33, "Wedge", "nil", vt(0, 0, 0), vt(0.2, 8, 0.5))
msh34 = mesh("SpecialMesh", pprt34, "Wedge", "nil", vt(0, 0, 0), vt(0.2, 8, 0.5))
msh35 = mesh("SpecialMesh", pprt35, "Wedge", "nil", vt(0, 0, 0), vt(0.3, 7, 0.7))
msh36 = mesh("SpecialMesh", pprt36, "Wedge", "nil", vt(0, 0, 0), vt(0.3, 7, 0.7))
msh37 = mesh("BlockMesh", pprt37, "", "", vt(0, 0, 0), vt(1.51, 2.5, 3))
msh38 = mesh("SpecialMesh", pprt38, "Wedge", "nil", vt(0, 0, 0), vt(1.3, 4, 3))
msh39 = mesh("SpecialMesh", pprt39, "Wedge", "nil", vt(0, 0, 0), vt(1.3, 2, 3))
msh2 = mesh("CylinderMesh", bprt2, "", "", vt(0, 0, 0), vt(3, 1, 3))
msh3 = mesh("CylinderMesh", bprt3, "", "", vt(0, 0, 0), vt(2.5, 1.01, 2.5))
msh4 = mesh("BlockMesh", bprt4, "", "", vt(0, 0, 0), vt(7, 0.5, 1.5))
msh5 = mesh("SpecialMesh", bprt5, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 1.5, 10))
msh6 = mesh("SpecialMesh", bprt6, "Wedge", "nil", vt(0, 0, 0), vt(0.3, 3, 4))
msh8 = mesh("CylinderMesh", bprt8, "", "", vt(0, 0, 0), vt(3, 1, 3))
msh9 = mesh("CylinderMesh", bprt9, "", "", vt(0, 0, 0), vt(2.5, 1.01, 2.5))
msh10 = mesh("BlockMesh", bprt10, "", "", vt(0, 0, 0), vt(7, 0.5, 1.5))
msh11 = mesh("SpecialMesh", bprt11, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 1.5, 10))
msh12 = mesh("SpecialMesh", bprt12, "Wedge", "nil", vt(0, 0, 0), vt(0.3, 3, 4))
msh14 = mesh("CylinderMesh", bprt14, "", "", vt(0, 0, 0), vt(3, 1, 3))
msh15 = mesh("CylinderMesh", bprt15, "", "", vt(0, 0, 0), vt(2.5, 1.01, 2.5))
msh16 = mesh("BlockMesh", bprt16, "", "", vt(0, 0, 0), vt(7, 0.5, 1.5))
msh17 = mesh("SpecialMesh", bprt17, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 1.5, 10))
msh18 = mesh("SpecialMesh", bprt18, "Wedge", "nil", vt(0, 0, 0), vt(0.3, 3, 4))
rwld1 = weld(rprt1, rprt1, RootPart, euler(-0.2, 0, 0) * cf(3, -1, -0.2))
rwld2 = weld(rprt1, rprt2, rprt1, euler(0, 0, 0) * cf(0, 0, 0))
rwld3 = weld(rprt1, rprt3, rprt2, euler(-0.3, 0, 0) * cf(0, 0.05, -1))
rwld4 = weld(rprt1, rprt4, rprt2, euler(-0.5, 0, 0) * cf(0, 0.1, -0.3))
rwld5 = weld(rprt1, rprt5, rprt4, euler(2.07, 0, 0) * cf(0, -0.2, 0))
rwld6 = weld(rprt1, rprt6, rprt2, euler(1.57, 0, 0) * cf(0, -0.11, 1.1))
rwld7 = weld(rprt1, rprt7, rprt6, euler(0, 0, 0) * cf(0, -1.6, 0))
rwld8 = weld(rprt1, rprt8, rprt7, euler(0, 0, 0) * cf(0, 0, 0))
rwld9 = weld(rprt1, rprt9, rprt6, euler(0, 0, 0) * cf(0, -0.3, 0.2))
rwld10 = weld(rprt1, rprt10, rprt9, euler(0, 0, 0) * cf(0, 1.2, 0.4))
rwld11 = weld(rprt1, rprt11, rprt10, euler(0, 0, 3.14) * cf(0, 0.6, 0))
rwld12 = weld(rprt1, rprt12, rprt5, euler(3.14, 0, 0) * cf(0, -0.2, -0.55))
rwld13 = weld(rprt1, rprt13, rprt12, euler(0.785, 0, 0) * cf(0, 0.2, -0.4))
rwld14 = weld(rprt1, rprt14, rprt12, euler(0, 0, 0) * cf(0, -0.4, -0.2))
rwld15 = weld(rprt1, rprt15, rprt14, euler(-0.8, 0, 0) * cf(0, -0.55, -0.2))
rwld16 = weld(rprt1, rprt16, rprt14, euler(0, 0, 3.14) * cf(0, -0.15, 0.5))
rwld17 = weld(rprt1, rprt17, rprt16, euler(0, 0, 3.14) * cf(0, 0.5, -0.3))
rwld18 = weld(rprt1, rprt18, rprt2, euler(0, 0, 0) * cf(0.2, 0, 0))
rwld19 = weld(rprt1, rprt19, rprt18, euler(0, 0, 0.5) * cf(0, 0, 0))
rwld20 = weld(rprt1, rprt20, rprt19, euler(3.14, 3.14, 0) * cf(0, 0.8, 0.05))
rwld21 = weld(rprt1, rprt21, rprt19, euler(3.14, 0, 0) * cf(0, 0.8, -0.05))
rwld22 = weld(rprt1, rprt22, rprt20, euler(0, 0, 0) * cf(0, -0.5, 0.02))
rwld23 = weld(rprt1, rprt23, rprt21, euler(0, 0, 0) * cf(0, -0.5, 0.02))
rwld24 = weld(rprt1, rprt24, rprt2, euler(0, 0, 0) * cf(0.2, -0.1, -0.3))
rwld25 = weld(rprt1, rprt25, rprt24, euler(0.3, 0, 0.6) * cf(0, 0, 0))
rwld26 = weld(rprt1, rprt26, rprt25, euler(3.14, 3.14, 0) * cf(0, 0.8, 0.05))
rwld27 = weld(rprt1, rprt27, rprt25, euler(3.14, 0, 0) * cf(0, 0.8, -0.05))
rwld28 = weld(rprt1, rprt28, rprt26, euler(0, 0, 0) * cf(0, -0.5, 0.02))
rwld29 = weld(rprt1, rprt29, rprt27, euler(0, 0, 0) * cf(0, -0.5, 0.02))
rwld30 = weld(rprt1, rprt30, rprt2, euler(0, 0, 0) * cf(0.2, -0.2, -0.6))
rwld31 = weld(rprt1, rprt31, rprt30, euler(0.6, 0, 0.7) * cf(0, 0, 0))
rwld32 = weld(rprt1, rprt32, rprt31, euler(3.14, 3.14, 0) * cf(0, 0.8, 0.05))
rwld33 = weld(rprt1, rprt33, rprt31, euler(3.14, 0, 0) * cf(0, 0.8, -0.05))
rwld34 = weld(rprt1, rprt34, rprt32, euler(0, 0, 0) * cf(0, -0.5, 0.02))
rwld35 = weld(rprt1, rprt35, rprt33, euler(0, 0, 0) * cf(0, -0.5, 0.02))
for _,c in pairs(rprt1:children()) do
  if c.className == "Motor" then
    table.insert(RailgunWelds, c)
  end
end
pwld1 = weld(pprt1, pprt1, RootPart, euler(-0.2, 0, 0) * cf(-3, -1, -0.2))
pwld2 = weld(pprt1, pprt2, pprt1, euler(0, 0, 0) * cf(0, 0, 0))
pwld3 = weld(pprt1, pprt3, pprt2, euler(0, 3.14, 0) * cf(0, -0.3, -0.4))
pwld4 = weld(pprt1, pprt4, pprt2, euler(0, 0, 0) * cf(0, -0.3, 0.3))
pwld5 = weld(pprt1, pprt5, pprt4, euler(0, 0, 0) * cf(0, -0.3, 0.2))
pwld6 = weld(pprt1, pprt6, pprt4, euler(1.57, 0, 0) * cf(0, -0.02, 0.7))
pwld7 = weld(pprt1, pprt7, pprt4, euler(1.57, 0, 0) * cf(0, 0.02, 0.7))
pwld8 = weld(pprt1, pprt8, pprt6, euler(0, 0, 0) * cf(0, -0.5, 0))
pwld9 = weld(pprt1, pprt9, pprt7, euler(0, 0, 0) * cf(0, -0.5, 0))
pwld10 = weld(pprt1, pprt10, pprt8, euler(0, 0, 0) * cf(0, 0, 0))
pwld11 = weld(pprt1, pprt11, pprt9, euler(0, 0, 0) * cf(0, 0, 0))
pwld12 = weld(pprt1, pprt12, pprt4, euler(1.57, 0, 0) * cf(0, 0.2, 0.75))
pwld13 = weld(pprt1, pprt13, pprt5, euler(-1.57, 0, 0) * cf(0, -0.3, 0))
pwld14 = weld(pprt1, pprt14, pprt13, euler(0.785, 0, 0) * cf(0, 0.2, -0.4))
pwld15 = weld(pprt1, pprt15, pprt13, euler(0, 0, 0) * cf(0, -0.4, -0.2))
pwld16 = weld(pprt1, pprt16, pprt15, euler(-0.8, 0, 0) * cf(0, -0.55, -0.2))
pwld17 = weld(pprt1, pprt17, pprt15, euler(0, 0, 3.14) * cf(0, -0.15, 0.5))
pwld18 = weld(pprt1, pprt18, pprt17, euler(0, 0, 3.14) * cf(0, 0.5, -0.3))
pwld19 = weld(pprt1, pprt19, pprt2, euler(0, 0, 0) * cf(-0.2, -0.2, 0.7))
pwld20 = weld(pprt1, pprt20, pprt19, euler(0, 0, -0.5) * cf(0, 0, 0))
pwld21 = weld(pprt1, pprt21, pprt20, euler(3.14, 3.14, 0) * cf(0, 0.8, 0.05))
pwld22 = weld(pprt1, pprt22, pprt20, euler(3.14, 0, 0) * cf(0, 0.8, -0.05))
pwld23 = weld(pprt1, pprt23, pprt21, euler(0, 0, 0) * cf(0, -0.5, 0.02))
pwld24 = weld(pprt1, pprt24, pprt22, euler(0, 0, 0) * cf(0, -0.5, 0.02))
pwld25 = weld(pprt1, pprt25, pprt2, euler(0, 0, 0) * cf(-0.2, -0.3, 0.4))
pwld26 = weld(pprt1, pprt26, pprt25, euler(0.3, 0, -0.6) * cf(0, 0, 0))
pwld27 = weld(pprt1, pprt27, pprt26, euler(3.14, 3.14, 0) * cf(0, 0.8, 0.05))
pwld28 = weld(pprt1, pprt28, pprt26, euler(3.14, 0, 0) * cf(0, 0.8, -0.05))
pwld29 = weld(pprt1, pprt29, pprt27, euler(0, 0, 0) * cf(0, -0.5, 0.02))
pwld30 = weld(pprt1, pprt30, pprt28, euler(0, 0, 0) * cf(0, -0.5, 0.02))
pwld31 = weld(pprt1, pprt31, pprt2, euler(0, 0, 0) * cf(-0.2, -0.4, 0.1))
pwld32 = weld(pprt1, pprt32, pprt31, euler(0.6, 0, -0.7) * cf(0, 0, 0))
pwld33 = weld(pprt1, pprt33, pprt32, euler(3.14, 3.14, 0) * cf(0, 0.8, 0.05))
pwld34 = weld(pprt1, pprt34, pprt32, euler(3.14, 0, 0) * cf(0, 0.8, -0.05))
pwld35 = weld(pprt1, pprt35, pprt33, euler(0, 0, 0) * cf(0, -0.5, 0.02))
pwld36 = weld(pprt1, pprt36, pprt34, euler(0, 0, 0) * cf(0, -0.5, 0.02))
pwld37 = weld(pprt1, pprt37, pprt2, euler(-0.5, 0, 0) * cf(0, -0.05, -0.1))
pwld38 = weld(pprt1, pprt38, pprt37, euler(-1.57, 3.14, 0) * cf(0, 0.2, 0.15))
pwld39 = weld(pprt1, pprt339, pprt39, euler(0, 0, 3.14) * cf(0, 0.6, 0))
for _,c in pairs(pprt1:children()) do
  if c.className == "Motor" then
    table.insert(PlasmaWelds, c)
  end
end
brefwld = weld(bprt1, bref, RootPart, euler(0, 0, 0) * cf(0, -2, 0))
bwld1 = weld(bprt1, bprt1, bref, euler(0, 0, 0) * cf(2, -0.6, -2))
bwld2 = weld(bprt1, bprt2, bprt1, euler(3.14, -2, 1.17) * cf(0, 0, 0))
bwld3 = weld(bprt1, bprt3, bprt2, euler(0, 0, 0) * cf(0, 0, 0))
bwld4 = weld(bprt1, bprt4, bprt2, euler(0, 0, 0) * cf(-0.8, 0, 0))
bwld5 = weld(bprt1, bprt5, bprt2, euler(-1.57, 0, 1.57) * cf(-0.8, 0, -0.35))
bwld6 = weld(bprt1, bprt6, bprt4, euler(-1.57, 0, 1.57) * cf(-1.1, 0, -0.15))
bwld7 = weld(bprt1, bprt7, bref, euler(0, 0, 0) * cf(0, -0.6, -2))
bwld8 = weld(bprt1, bprt8, bprt7, euler(3.14, -2, 1.57) * cf(0, 0, 0))
bwld9 = weld(bprt1, bprt9, bprt8, euler(0, 0, 0) * cf(0, 0, 0))
bwld10 = weld(bprt1, bprt10, bprt8, euler(0, 0, 0) * cf(-0.8, 0, 0))
bwld11 = weld(bprt1, bprt11, bprt8, euler(-1.57, 0, 1.57) * cf(-0.8, 0, -0.35))
bwld12 = weld(bprt1, bprt12, bprt10, euler(-1.57, 0, 1.57) * cf(-1.1, 0, -0.15))
bwld13 = weld(bprt1, bprt13, bref, euler(0, 0, 0) * cf(-2, -0.6, -2))
bwld14 = weld(bprt1, bprt14, bprt13, euler(3.14, -2, 1.97) * cf(0, 0, 0))
bwld15 = weld(bprt1, bprt15, bprt14, euler(0, 0, 0) * cf(0, 0, 0))
bwld16 = weld(bprt1, bprt16, bprt14, euler(0, 0, 0) * cf(-0.8, 0, 0))
bwld17 = weld(bprt1, bprt17, bprt14, euler(-1.57, 0, 1.57) * cf(-0.8, 0, -0.35))
bwld18 = weld(bprt1, bprt18, bprt16, euler(-1.57, 0, 1.57) * cf(-1.1, 0, -0.15))
for _,c in pairs(bprt1:children()) do
  if c.className == "Motor" then
    table.insert(BladesWelds, c)
  end
end
local hitbox = part(3, modelzorz, 0, 1, BrickColor.new("Black"), "Hitbox2", vt())
hitbox.Anchored = false
local hbwld = weld(hitbox, hitbox, RootPart, euler(0, 0, 0) * cf(0, 0, 0))
local hitbox2 = part(3, nil, 0, 1, BrickColor.new("Black"), "Hitbox", vt(1, 1, 1))
hitbox2.Anchored = true
local hitboxCF = cf(0, 0, 0)
local hitboxb1 = part(3, nil, 0, 1, BrickColor.new("Black"), "Hitboxb", vt(1, 1, 1))
hitboxb1.Anchored = false
local hitboxb2 = part(3, nil, 0, 1, BrickColor.new("Black"), "Hitboxb", vt(1, 1, 1))
hitboxb2.Anchored = false
local hitboxb3 = part(3, nil, 0, 1, BrickColor.new("Black"), "Hitboxb", vt(1, 1, 1))
hitboxb3.Anchored = false
hboxpos = Instance.new("BodyPosition", nil)
hboxpos.P = 2000
hboxpos.D = 100
hboxpos.maxForce = Vector3.new(math.huge, math.huge, math.huge)
hitboxweld = function()
  hbwld.Parent = modelzorz
  hbwld.Part0 = hitbox
  hbwld.Part1 = handle
end
Bin = script.Parent
if Bin.Name == "Mechanic" then
  Bin.Name = "Gear Gauntlet"
end
local bodvel = Instance.new("BodyVelocity")
local bg = Instance.new("BodyGyro")
so = function(id, par, vol, pit)
  local sou = Instance.new("Sound", par or workspace)
  sou.Volume = vol
  sou.Pitch = pit or 1
  sou.SoundId = "http://www.roblox.com/asset/?id=" .. id
  coroutine.resume(coroutine.create(function(Sound)
    fwait()
    Sound:play()
  end), sou)
  game:GetService("Debris"):AddItem(sou, 6)
end
function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end
hideanim = function()
  equipped = false
  for i = 0, 1, 0.1 do
    fwait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, RHC0, 0.4)
    LH.C0 = clerp(LH.C0, LHC0, 0.4)
  end
  mdec2.Parent = nil
  mdec.Parent = Decrease
end
mdec.Parent = Decrease
equipanim = function()
  equipped = true
  mdec.Parent = nil
  mdec2.Parent = Decrease
end
StaggerAnim = function()
  attack = true
  removeControl()
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.35 do
    fwait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -40
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, -0.4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.7) * euler(0, -0.7, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  for i = 0, 1, 0.2 do
    fwait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -40
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(-0.5, 0, -0.4), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.7) * euler(0, -0.7, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.5), 0.4)
  end
  for i = 0, 1, 0.1 do
    fwait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(0.5, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.8) * euler(-0.2, 0, -0.4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.5, 0, 0.8) * euler(0, -0.4, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.5, 0, -0.2) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 1.2), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, 0, -1) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  for i = 1, 40 do
    fwait()
    if StunT.Value <= Stun.Value then
      break
    end
  end
  do
    resumeControl()
    combo = 0
    attack = false
  end
end
StaggerHitt = function()
  attack = true
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.1 do
    fwait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.9), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.6), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, -0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  attack = false
end
StunAnim = function()
  attack = true
  removeControl()
  Stunned.Value = true
  showDamage(Character, "Stunned", "Interrupt")
  local dec = Instance.new("NumberValue", Decrease)
  dec.Name = "DecreaseMvmt"
  dec.Value = 10
  for i = 0, 1, 0.3 do
    fwait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.2, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1, 0, 0.4) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.3), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, 0), 0.25)
  end
  for i = 0, 1, 0.3 do
    fwait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0.8, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1.2, 0, 0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(0.1, 0, 0.7), 0.25)
  end
  for i = 0, 1, 0.3 do
    fwait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -1), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1.57, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, -0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.1, 0, 0.3), 0.25)
  end
  local gairost = Instance.new("BodyGyro")
  gairost.Parent = RootPart
  gairost.maxTorque = Vector3.new(400000, 0, 400000) * math.huge
  gairost.P = 20000
  gairost.cframe = cf(0, 0, 0)
  for i = 0, 1, 0.1 do
    fwait()
    if hitfloor ~= nil then
      Torso.Velocity = vt(0, 0, 0)
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2.5) * euler(1.57, 0, -3.14), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1.5) * euler(0.2, 0, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.5, 0, -1.57) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 0), 0.3)
  end
  for i = 1, 70 do
    fwait()
    gairost.cframe = RootPart.CFrame
    if hitfloor ~= nil then
      Torso.Velocity = vt(0, 0, 0)
    end
  end
  for i = 0, 1, 0.2 do
    fwait()
    Stun.Value = 0
    gairost.cframe = RootPart.CFrame
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1, 0, -4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1) * euler(0.2, -1, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, 0.2) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, -1) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 1), 0.3)
  end
  resumeControl()
  gairost.Parent = nil
  dec.Parent = nil
  Stun.Value = 0
  combo = 0
  Stunned.Value = false
  attack = false
  for i = 1, 10 do
    fwait()
    Stun.Value = 0
  end
end
attackone = function()
  attack = true
  for i = 0, 1, 0.12 do
    fwait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 1) * euler(0, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1), 0.3)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.4, 0, -1), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.6, 0, -1) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, -0.4) * euler(0, 1.57, 0) * euler(0, 1, -0.1), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.8, -0.9, 0.4) * euler(0, -1.57, 0) * euler(0, 1, 0.1), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC189: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC189: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("199145095", handle, 1, 1.1)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(2, 3, 2)
  hitboxCF = handle.CFrame
  hitbox.CFrame = hitboxCF
  for i = 0, 1, 0.35 do
    fwait()
    hitboxCF = handle.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 3, 6, 7, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(4, 8)), nil, true)
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, -1.57) * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 1.57), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.8, 0, 1.2), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.4, 0, -0.1), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.4) * euler(0, 1.57, 0) * euler(0.2, -1.57, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.4) * euler(0, -1.57, 0) * euler(-0.4, -1.57, 0), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC426: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC426: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  for i = 0, 1, 0.1 do
    fwait()
    hitboxCF = handle.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 3, 6, 7, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(4, 8)), nil, true)
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, -1.57) * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 1.57), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 0) * euler(-0.5, 0, 0.5), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.4, 0, -0.1), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.4) * euler(0, 1.57, 0) * euler(0.2, -1.57, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.4) * euler(0, -1.57, 0) * euler(-0.4, -1.57, 0), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC642: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC642: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
attacktwo = function()
  attack = true
  for i = 0, 1, 0.2 do
    fwait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.3), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -1.3), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 1.3), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(0, -2.5, -1.57), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, -0.4) * euler(0, 1.57, 0) * euler(0, 1.3, -0.1), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.8, -0.9, 0.4) * euler(0, -1.57, 0) * euler(0, 1.3, 0.1), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC171: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC171: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("199145146", handle, 1, 1.3)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(2, 3, 2)
  hitboxCF = handle.CFrame
  hitbox.CFrame = hitboxCF
  for i = 0, 1, 0.3 do
    fwait()
    hitboxCF = handle.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 3, 6, 7, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(4, 8)), nil, true)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.5) * euler(0.1, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1.6), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 1, 1.3) * euler(0, -1.57, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1.2), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.4) * euler(0, 1.57, 0) * euler(0.2, -1.57, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.4) * euler(0, -1.57, 0) * euler(-0.4, -1.57, 0), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC408: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC408: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  for i = 0, 1, 0.15 do
    fwait()
    hitboxCF = handle.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 3, 6, 7, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(4, 8)), nil, true)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.5) * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1.6), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 1, 1.3) * euler(0, -1.57, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1.2), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.4) * euler(0, 1.57, 0) * euler(0.2, -1.57, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.4) * euler(0, -1.57, 0) * euler(-0.4, -1.57, 0), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC618: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC618: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
attackthree = function()
  attack = true
  for i = 0, 1, 0.2 do
    fwait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.2) * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1.2), 0.3)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(0, 2.5, 1.5) * euler(0, -1.57, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1.2), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.4) * euler(0, 1.57, 0) * euler(0.2, -1.2, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.4) * euler(0, -1.57, 0) * euler(-0.4, -1.2, 0), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC183: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC183: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("199145204", handle, 1, 1.2)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(2, 3, 2)
  hitboxCF = handle.CFrame
  hitbox.CFrame = hitboxCF
  for i = 0, 1, 0.1 do
    fwait()
    hitboxCF = handle.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 3, 6, 7, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(4, 8)), nil, true)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.2) * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.2), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 1.2) * euler(0, -1.57, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.5, 0, -1.4), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC420: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC420: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
attackfour = function()
  attack = true
  for i = 0, 1, 0.15 do
    fwait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1), 0.4)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -1.2), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1, 0, -0.1), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, -0.4) * euler(0, 1.57, 0) * euler(0, 1, -0.1), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.8, -0.9, 0.4) * euler(0, -1.57, 0) * euler(0, 1, 0.1), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC183: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC183: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("200632211", handle, 1, 0.8)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(2, 3, 2)
  hitboxCF = handle.CFrame
  hitbox.CFrame = hitboxCF
  for i = 0, 1, 0.1 do
    fwait()
    hitboxCF = handle.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 3, 6, 7, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(4, 8)), nil, true)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57) * euler(0, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 1.57), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.57) * euler(0, 1.57, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.5, 0, -1), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.4) * euler(0, 1.57, 0) * euler(0.2, -1.57, 0), 0.2)
    LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.4) * euler(0, -1.57, 0) * euler(-0.4, -1.57, 0), 0.2)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC426: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC426: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
ShootRailGun = function()
  if railgunattack == true then
    return 
  end
  ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
  ref.Anchored = true
  ref.CFrame = cf(rprt8.Position)
  game:GetService("Debris"):AddItem(ref, 1)
  so("169380505", ref, 0.5, 1)
  local MouseLook = cf((rprt8.Position + MMouse.Hit.p) / 2, MMouse.Hit.p)
  local hit, pos = rayCast(rprt8.Position, MouseLook.lookVector, 999, RailgunTarget.Parent)
  local mag = (rprt8.Position - pos).magnitude
  MagicCylinder(Color2, CFrame.new((rprt8.Position + pos) / 2, pos) * angles(1.57, 0, 0), 1, mag * 5, 1, 1.2, 0, 1.2, 0.1)
  if hit ~= nil then
    ref = part(3, workspace, 0, 1, Color2, "Reference", vt())
    ref.Anchored = true
    ref.CFrame = cf(pos)
    game:GetService("Debris"):AddItem(ref, 1)
    so("153092334", ref, 0.5, 1.5)
    so("169380505", ref, 0.5, 1.5)
    MagicCircle(Color2, cf(pos), 10, 10, 10, 1, 1, 1, 0.07)
    Damagefunc(hit, 6, 8, 0, "Normal", RootPart, 0, 2, math.random(1, 5), false, false, true, "Movement", 0.05, 100)
  end
  coroutine.resume(coroutine.create(function()
    railgunattack = true
    for i = 0, 1, 0.2 do
      fwait()
      rwld2.C1 = clerp(rwld2.C1, cf(0, 0, -1), 0.5)
    end
    for i = 0, 1, 0.1 do
      fwait()
      rwld2.C1 = clerp(rwld2.C1, cf(0, 0, 0), 0.4)
    end
    railgunattack = false
  end))
end
ShootCannon = function()
  if cannonattack == true then
    return 
  end
  ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
  ref.Anchored = true
  ref.CFrame = cf(pprt8.Position)
  game:GetService("Debris"):AddItem(ref, 1)
  so("169380505", ref, 0.5, 1)
  table.insert(Effects, {pprt8.Position, "Shoot", 30, MMouse.Hit.p})
  coroutine.resume(coroutine.create(function()
    cannonattack = true
    for i = 0, 1, 0.05 do
      fwait()
      pwld2.C1 = clerp(pwld2.C1, cf(0, 0, -1.5), 0.5)
    end
    for i = 0, 1, 0.05 do
      fwait()
      pwld2.C1 = clerp(pwld2.C1, cf(0, 0, 0), 0.3)
    end
    cannonattack = false
  end))
end
bladesattackone = function()
  while tribladesattack == true do
    fwait()
  end
  tribladesattack = true
  for i = 0, 1, 0.2 do
    fwait()
    brefwld.C0 = clerp(brefwld.C0, euler(0, 0, 0) * cf(0, -2.5, 2), 0.4)
    bwld1.C0 = clerp(bwld1.C0, euler(0, 0, 0) * cf(3, -0.6, -2), 0.4)
    bwld7.C0 = clerp(bwld7.C0, euler(0, 0, 0) * cf(0, -0.6, -2), 0.4)
    bwld13.C0 = clerp(bwld13.C0, euler(0, 0, 0) * cf(-3, -0.6, -2), 0.4)
    bwld2.C0 = clerp(bwld2.C0, euler(3.14, -1.5, 1) * cf(0, 0, 0), 0.4)
    bwld8.C0 = clerp(bwld8.C0, euler(3.14, -1.5, 1.57) * cf(0, 0, 0), 0.4)
    bwld14.C0 = clerp(bwld14.C0, euler(3.14, -1.5, 2) * cf(0, 0, 0), 0.4)
  end
  so("161006195", bprt1, 0.6, math.random(100, 200) / 100)
  so("161006195", bprt7, 0.6, math.random(100, 200) / 100)
  so("161006195", bprt13, 0.6, math.random(100, 200) / 100)
  hitboxb1.Parent = Character
  hitboxb1.Size = vt(1, 2, 1)
  hitboxb1.CFrame = bprt4.CFrame * euler(0, 0, 1.57)
  hitboxb1.Transparency = 1
  hitboxb2.Parent = Character
  hitboxb2.Size = vt(1, 2, 1)
  hitboxb2.CFrame = bprt10.CFrame * euler(0, 0, 1.57)
  hitboxb3.Parent = Character
  hitboxb3.Size = vt(1, 2, 1)
  hitboxb3.CFrame = bprt16.CFrame * euler(0, 0, 1.57)
  for i = 0, 1, 0.3 do
    fwait()
    brefwld.C0 = clerp(brefwld.C0, euler(1.57, 0, 0) * cf(0, 1.5, 3), i)
    bwld2.C0 = clerp(bwld2.C0, euler(3.14, -1.5, 1.57) * cf(0, 0, 0), i)
    bwld8.C0 = clerp(bwld8.C0, euler(3.14, -1.5, 1.57) * cf(0, 0, 0), i)
    bwld14.C0 = clerp(bwld14.C0, euler(3.14, -1.5, 1.57) * cf(0, 0, 0), i)
    hitboxb1.CFrame = bprt4.CFrame * euler(0, 0, 1.57)
    hitboxb2.CFrame = bprt10.CFrame
    hitboxb3.CFrame = bprt16.CFrame
    MagniDamage(hitboxb1, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    MagniDamage(hitboxb2, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    MagniDamage(hitboxb3, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
  end
  for i = 0, 1, 0.2 do
    fwait()
    brefwld.C0 = clerp(brefwld.C0, euler(1.7, 0, 0) * cf(0, 2, 3), 0.4)
    hitboxb1.CFrame = bprt4.CFrame * euler(0, 0, 1.57)
    hitboxb2.CFrame = bprt10.CFrame
    hitboxb3.CFrame = bprt16.CFrame
    MagniDamage(hitboxb1, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    MagniDamage(hitboxb2, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    MagniDamage(hitboxb3, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
  end
  hitboxb1.Parent = nil
  hitboxb2.Parent = nil
  hitboxb3.Parent = nil
  tribladesattack = false
end
bladesattacktwo = function()
  while tribladesattack == true do
    fwait()
  end
  tribladesattack = true
  for i = 0, 1, 0.2 do
    fwait()
    brefwld.C0 = clerp(brefwld.C0, euler(0, -1, 0) * cf(6, 1, 3), 0.4)
    bwld1.C0 = clerp(bwld1.C0, euler(0, -0.5, 0) * cf(2, -0.6, -2), 0.4)
    bwld7.C0 = clerp(bwld7.C0, euler(0, 0, 0) * cf(0, -0.6, -2), 0.4)
    bwld13.C0 = clerp(bwld13.C0, euler(0, 0.5, 0) * cf(-2, -0.6, -2), 0.4)
    bwld2.C0 = clerp(bwld2.C0, euler(4.71, -1.57, 1.57) * cf(0, 0, 0), 0.4)
    bwld8.C0 = clerp(bwld8.C0, euler(4.71, -1.57, 1.57) * cf(0, 0, 0), 0.4)
    bwld14.C0 = clerp(bwld14.C0, euler(4.71, -1.57, 1.57) * cf(0, 0, 0), 0.4)
  end
  so("161006195", bprt1, 0.6, math.random(80, 150) / 100)
  so("161006195", bprt7, 0.6, math.random(80, 150) / 100)
  so("161006195", bprt13, 0.6, math.random(80, 150) / 100)
  hitboxb1.Parent = Character
  hitboxb1.Size = vt(1, 2, 1)
  hitboxb1.CFrame = bprt4.CFrame * euler(0, 0, 1.57)
  hitboxb1.Transparency = 1
  hitboxb2.Parent = Character
  hitboxb2.Size = vt(1, 2, 1)
  hitboxb2.CFrame = bprt10.CFrame * euler(0, 0, 1.57)
  hitboxb3.Parent = Character
  hitboxb3.Size = vt(1, 2, 1)
  hitboxb3.CFrame = bprt16.CFrame * euler(0, 0, 1.57)
  for i = 0, 1, 0.4 do
    fwait()
    brefwld.C0 = clerp(brefwld.C0, euler(0, 1, 0) * cf(-6, 1, 3), i)
    hitboxb1.CFrame = bprt4.CFrame * euler(0, 0, 1.57)
    hitboxb2.CFrame = bprt10.CFrame
    hitboxb3.CFrame = bprt16.CFrame
    MagniDamage(hitboxb1, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    MagniDamage(hitboxb2, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    MagniDamage(hitboxb3, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
  end
  for i = 0, 1, 0.2 do
    fwait()
    brefwld.C0 = clerp(brefwld.C0, euler(0, 1.7, 0) * cf(-6, 1, -1), 0.4)
    hitboxb1.CFrame = bprt4.CFrame * euler(0, 0, 1.57)
    hitboxb2.CFrame = bprt10.CFrame
    hitboxb3.CFrame = bprt16.CFrame
    MagniDamage(hitboxb1, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    MagniDamage(hitboxb2, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    MagniDamage(hitboxb3, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
  end
  hitboxb1.Parent = nil
  hitboxb2.Parent = nil
  hitboxb3.Parent = nil
  tribladesattack = false
end
bladesattackthree = function()
  while tribladesattack == true do
    fwait()
  end
  tribladesattack = true
  for i = 0, 1, 0.3 do
    fwait()
    bwld1.C0 = clerp(bwld1.C0, cf(0, -4, -2) * euler(0, 0, 2.09), 0.4)
    bwld7.C0 = clerp(bwld7.C0, cf(0, -4, -2) * euler(0, 0, 4.18), 0.4)
    bwld13.C0 = clerp(bwld13.C0, cf(0, -4, -2) * euler(0, 0, 6.27), 0.4)
    bwld2.C0 = clerp(bwld2.C0, euler(3.14, -1.3, 1.57) * cf(0, 0, 0), 0.4)
    bwld8.C0 = clerp(bwld8.C0, euler(3.14, -1.3, 1.57) * cf(0, 0, 0), 0.4)
    bwld14.C0 = clerp(bwld14.C0, euler(3.14, -1.3, 1.57) * cf(0, 0, 0), 0.4)
    brefwld.C0 = clerp(brefwld.C0, euler(0, 0, 0) * cf(0, 0, -2), 0.4)
  end
  so("161006195", bprt1, 0.6, math.random(100, 200) / 100)
  so("161006195", bprt7, 0.6, math.random(100, 200) / 100)
  so("161006195", bprt13, 0.6, math.random(100, 200) / 100)
  hitboxb1.Parent = Character
  hitboxb1.Size = vt(1, 2, 1)
  hitboxb1.CFrame = bprt4.CFrame * euler(0, 0, 1.57)
  hitboxb1.Transparency = 1
  hitboxb2.Parent = Character
  hitboxb2.Size = vt(1, 2, 1)
  hitboxb2.CFrame = bprt10.CFrame * euler(0, 0, 1.57)
  hitboxb3.Parent = Character
  hitboxb3.Size = vt(1, 2, 1)
  hitboxb3.CFrame = bprt16.CFrame * euler(0, 0, 1.57)
  n = math.random(-50, 50)
  for i = 0, 1, 0.4 do
    fwait()
    bwld1.C0 = clerp(bwld1.C0, cf(0, -1.2, -2) * euler(0, 0, 2.09), 0.4)
    bwld7.C0 = clerp(bwld7.C0, cf(0, -1.2, -2) * euler(0, 0, 4.18), 0.4)
    bwld13.C0 = clerp(bwld13.C0, cf(0, -1.2, -2) * euler(0, 0, 6.27), 0.4)
    bwld2.C0 = clerp(bwld2.C0, euler(3.14, -1.3, 1.57) * cf(0, 0, 0), 0.4)
    bwld8.C0 = clerp(bwld8.C0, euler(3.14, -1.3, 1.57) * cf(0, 0, 0), 0.4)
    bwld14.C0 = clerp(bwld14.C0, euler(3.14, -1.3, 1.57) * cf(0, 0, 0), 0.4)
    brefwld.C0 = clerp(brefwld.C0, euler(0, 0, n) * cf(0, 0, 6), 0.4)
    hitboxb1.CFrame = bprt4.CFrame * euler(0, 0, 1.57)
    hitboxb2.CFrame = bprt10.CFrame
    hitboxb3.CFrame = bprt16.CFrame
    MagniDamage(hitboxb1, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    MagniDamage(hitboxb2, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    MagniDamage(hitboxb3, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
  end
  n = math.random(-50, 50)
  for i = 0, 1, 0.3 do
    fwait()
    bwld1.C0 = clerp(bwld1.C0, cf(0, -1, -2) * euler(0, 0, 2.09), 0.4)
    bwld7.C0 = clerp(bwld7.C0, cf(0, -1, -2) * euler(0, 0, 4.18), 0.4)
    bwld13.C0 = clerp(bwld13.C0, cf(0, -1, -2) * euler(0, 0, 6.27), 0.4)
    brefwld.C0 = clerp(brefwld.C0, euler(0, 0, n) * cf(0, 0, 7), 0.4)
    hitboxb1.CFrame = bprt4.CFrame * euler(0, 0, 1.57)
    hitboxb2.CFrame = bprt10.CFrame
    hitboxb3.CFrame = bprt16.CFrame
    MagniDamage(hitboxb1, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    MagniDamage(hitboxb2, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    MagniDamage(hitboxb3, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
  end
  hitboxb1.Parent = nil
  hitboxb2.Parent = nil
  hitboxb3.Parent = nil
  tribladesattack = false
end
bladesattackfour = function()
  while tribladesattack == true do
    fwait()
  end
  tribladesattack = true
  for i = 0, 1, 0.2 do
    fwait()
    bwld1.C0 = clerp(bwld1.C0, cf(0, -1, 0) * euler(0, 0, 2.09), 0.4)
    bwld7.C0 = clerp(bwld7.C0, cf(0, -1, 0) * euler(0, 0, 4.18), 0.4)
    bwld13.C0 = clerp(bwld13.C0, cf(0, -1, 0) * euler(0, 0, 6.27), 0.4)
    bwld2.C0 = clerp(bwld2.C0, euler(1.57, 0, -1.57) * cf(0, 0, 0), 0.4)
    bwld8.C0 = clerp(bwld8.C0, euler(1.57, 0, -1.57) * cf(0, 0, 0), 0.4)
    bwld14.C0 = clerp(bwld14.C0, euler(1.57, 0, -1.57) * cf(0, 0, 0), 0.4)
    brefwld.C0 = clerp(brefwld.C0, euler(-1.57, 0, 0) * cf(-5, -0.5, 0), 0.4)
  end
  so("161006195", bprt1, 0.6, math.random(40, 80) / 100)
  so("161006195", bprt7, 0.6, math.random(40, 80) / 100)
  so("161006195", bprt13, 0.6, math.random(40, 80) / 100)
  hitboxb1.Parent = Character
  hitboxb1.Size = vt(1, 2, 1)
  hitboxb1.CFrame = bprt4.CFrame * euler(0, 0, 1.57)
  hitboxb1.Transparency = 1
  hitboxb2.Parent = Character
  hitboxb2.Size = vt(1, 2, 1)
  hitboxb2.CFrame = bprt10.CFrame * euler(0, 0, 1.57)
  hitboxb3.Parent = Character
  hitboxb3.Size = vt(1, 2, 1)
  hitboxb3.CFrame = bprt16.CFrame * euler(0, 0, 1.57)
  for i = 0, 1, 0.6 do
    fwait()
    bwld1.C0 = clerp(bwld1.C0, cf(0, -1, 0) * euler(0, 0, 5.19), 0.5)
    bwld7.C0 = clerp(bwld7.C0, cf(0, -1, 0) * euler(0, 0, 7.28), 0.5)
    bwld13.C0 = clerp(bwld13.C0, cf(0, -1, 0) * euler(0, 0, 9.37), 0.5)
    brefwld.C0 = clerp(brefwld.C0, euler(-1.57, 0, 0) * cf(0, -0.5, 8), 0.5)
    hitboxb1.CFrame = bprt4.CFrame * euler(0, 0, 1.57)
    hitboxb2.CFrame = bprt10.CFrame
    hitboxb3.CFrame = bprt16.CFrame
    MagniDamage(hitboxb1, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    MagniDamage(hitboxb2, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    MagniDamage(hitboxb3, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
  end
  for i = 0, 1, 0.4 do
    fwait()
    bwld1.C0 = clerp(bwld1.C0, cf(0, -1, 0) * euler(0, 0, 7.09), 0.5)
    bwld7.C0 = clerp(bwld7.C0, cf(0, -1, 0) * euler(0, 0, 9.18), 0.5)
    bwld13.C0 = clerp(bwld13.C0, cf(0, -1, 0) * euler(0, 0, 11.27), 0.5)
    brefwld.C0 = clerp(brefwld.C0, euler(-1.57, 0, 0) * cf(0, -0.5, 20), 0.5)
    hitboxb1.CFrame = bprt4.CFrame * euler(0, 0, 1.57)
    hitboxb2.CFrame = bprt10.CFrame
    hitboxb3.CFrame = bprt16.CFrame
    MagniDamage(hitboxb1, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    MagniDamage(hitboxb2, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    MagniDamage(hitboxb3, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
  end
  for i = 0, 1, 0.4 do
    fwait()
    brefwld.C0 = clerp(brefwld.C0, euler(-1.57, 0, 0) * cf(0, -2, 0), 0.5)
    bwld1.C0 = clerp(bwld1.C0, cf(0, -1, 0) * euler(0, 0, 2.09), 0.4)
    bwld7.C0 = clerp(bwld7.C0, cf(0, -1, 0) * euler(0, 0, 4.18), 0.4)
    bwld13.C0 = clerp(bwld13.C0, cf(0, -1, 0) * euler(0, 0, 6.27), 0.4)
    hitboxb1.CFrame = bprt4.CFrame * euler(0, 0, 1.57)
    hitboxb2.CFrame = bprt10.CFrame
    hitboxb3.CFrame = bprt16.CFrame
    MagniDamage(hitboxb1, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    MagniDamage(hitboxb2, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    MagniDamage(hitboxb3, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
  end
  hitboxb1.Parent = nil
  hitboxb2.Parent = nil
  hitboxb3.Parent = nil
  tribladesattack = false
end
BladesDamage = function(pitch)
  so("161006195", bprt1, 0.6, pitch)
  so("161006195", bprt7, 0.6, pitch)
  so("161006195", bprt13, 0.6, pitch)
  hitboxb1.Parent = Character
  hitboxb1.Size = vt(1, 2, 1)
  hitboxb1.CFrame = bprt4.CFrame * euler(0, 0, 1.57)
  hitboxb1.Transparency = 1
  hitboxb2.Parent = Character
  hitboxb2.Size = vt(1, 2, 1)
  hitboxb2.CFrame = bprt10.CFrame * euler(0, 0, 1.57)
  hitboxb3.Parent = Character
  hitboxb3.Size = vt(1, 2, 1)
  hitboxb3.CFrame = bprt16.CFrame * euler(0, 0, 1.57)
  coroutine.resume(coroutine.create(function(Con1, Con2, Con3)
    while attack == true do
      fwait()
      hitboxb1.CFrame = bprt4.CFrame * euler(0, 0, 1.57)
      hitboxb2.CFrame = bprt10.CFrame
      hitboxb3.CFrame = bprt16.CFrame
      MagniDamage(hitboxb1, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
      MagniDamage(hitboxb2, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
      MagniDamage(hitboxb3, 2, 5, 7, math.random(1, 5), "Normal", BladesTarget, 0.4, 1, math.random(1, 3), false, true, true, nil, nil, nil, "Slash")
    end
    hitboxb1.Parent = nil
    hitboxb2.Parent = nil
    hitboxb3.Parent = nil
  end), con1, con2, con3)
end
StatConvert = function()
  attack = true
  for i = 0, 1, 0.1 do
    fwait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.2, 0.5, -0.5) * euler(1.5, 0, -1.5) * euler(0, 0, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.5) * euler(1.5, 0, 1.5) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC189: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC189: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  for _,i in pairs(Decrease:children()) do
    if i.Name == "DecreaseDef" then
      i.Name = "DecreaseAtk"
      i.Value = i.Value * 0.5
    else
      if i.Name == "DecreaseAtk" then
        i.Name = "DecreaseDef"
        i.Value = i.Value * 2
      end
    end
  end
  attack = false
  for i = 1, 30 do
    fwait()
    for i = 1, 2 do
      ElecEffect(cf(RootPart.Position), 2, 3, 1)
    end
  end
end
do1 = function()
  if givingarmor == true then
    givingarmor = false
    cooldowns[1] = 0
    RailgunTarget = RootPart
  end
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[1] and mana.Value >= 30 then
    givingrailgun = true
    attack = true
    mana.Value = mana.Value - 30
    MagicSpecial(BrickColor.new(NewCol), RightArm.CFrame * cf(0, -1, 0) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 0.2, 0.2, 0.2, 0.5, 0.5, 0.5, 0.1)
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = 0.4
    for i = 0, 1, 0.2 do
      fwait()
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1) * euler(0.2, 0, 0), 0.5)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1), 0.5)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.7, 0, 0) * euler(0, 0, -0.5), 0.5)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
      LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.3, 0, 0) * euler(0, 0, 0.8), 0.5)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
      RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.5) * euler(0, 1.57, 0) * euler(0, -1, -0.1), 0.5)
      LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.5) * euler(0, -1.57, 0) * euler(0, -1, 0.4), 0.5)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC279: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC279: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    givingarmor = true
    while givingarmor == true do
      if givingarmor == true then
        fwait()
        ElecEffect(RightArm.CFrame, 1, 2, 1)
      end
      if Stagger.Value ~= true and StunT.Value > Stun.Value and StaggerHit.Value == true then
        break
      end
    end
    givingrailgun = false
    DecreaseStat(Character, "Defense", -0.1, 400)
    DecreaseStat(Character, "Movement", 0.1, 400)
    cooldowns[1] = 0
    givingarmor = false
    dec.Parent = nil
    if RailgunTarget ~= nil then
      for i = 0, 1, 0.2 do
        fwait()
        Neck.C0 = clerp(Neck.C0, necko * euler(-0.4, 0, -0.2), 0.4)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.5) * euler(0.8, 0, 0.5), 0.4)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.4, 0, 0.5), 0.4)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4), 0.4)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
        RH.C0 = clerp(RH.C0, RHC0 * cf(0, 0, 0) * euler(0, -0.5, -0.5), 0.4)
        LH.C0 = clerp(LH.C0, LHC0 * cf(-0.5, 1, 0) * euler(0.5, 0, -0.5), 0.4)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC499: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC499: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      DecreaseStat(RailgunTarget.Parent, "Defense", -0.2, 280)
      rwld1.Part1 = RailgunTarget
      model1.Parent = RailgunTarget.Parent
      MagicSpecial(BrickColor.new(NewCol), rprt1.CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 0.5, 0.5, 0.5, 0.05)
      ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
      ref.Anchored = true
      ref.CFrame = cf(rprt1.Position)
      game:GetService("Debris"):AddItem(ref, 1)
      so("203691326", ref, 1, 1)
      for i = 1, 5 do
        ElecEffect(cf(rprt1.Position), 3, 3, 3)
      end
      for i = 1, #Railgun do
        Railgun[i].Parent = model1
        RailgunWelds[i].Parent = Railgun[1]
      end
      elecnum = 0
      attack = false
      for i = 1, 50 do
        fwait()
        ElecEffect(cf(rprt1.Position), 2, 2, 2)
      end
    else
      do
        attack = false
      end
    end
  end
end
do2 = function()
  if givingarmor == true then
    givingarmor = false
    cooldowns[2] = 0
    CannonTarget = RootPart
  end
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[2] and mana.Value >= 30 then
    attack = true
    mana.Value = mana.Value - 30
    givingplasma = true
    MagicSpecial(BrickColor.new(NewCol), RightArm.CFrame * cf(0, -1, 0) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 0.2, 0.2, 0.2, 0.5, 0.5, 0.5, 0.1)
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = 0.4
    for i = 0, 1, 0.2 do
      fwait()
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1) * euler(0.2, 0, 0), 0.5)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1), 0.5)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.7, 0, 0) * euler(0, 0, -0.5), 0.5)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
      LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.3, 0, 0) * euler(0, 0, 0.8), 0.5)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
      RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.5) * euler(0, 1.57, 0) * euler(0, -1, -0.1), 0.5)
      LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.5) * euler(0, -1.57, 0) * euler(0, -1, 0.4), 0.5)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC279: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC279: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    givingarmor = true
    while givingarmor == true do
      if givingarmor == true then
        fwait()
        ElecEffect(RightArm.CFrame, 1, 2, 1)
      end
      if Stagger.Value ~= true and StunT.Value > Stun.Value and StaggerHit.Value == true then
        break
      end
    end
    givingplasma = false
    DecreaseStat(Character, "Defense", -0.1, 400)
    DecreaseStat(Character, "Movement", 0.1, 400)
    cooldowns[2] = 0
    givingarmor = false
    dec.Parent = nil
    if CannonTarget ~= nil then
      for i = 0, 1, 0.2 do
        fwait()
        Neck.C0 = clerp(Neck.C0, necko * euler(-0.4, 0, -0.2), 0.4)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.5) * euler(0.8, 0, 0.5), 0.4)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.4, 0, 0.5), 0.4)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4), 0.4)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
        RH.C0 = clerp(RH.C0, RHC0 * cf(0, 0, 0) * euler(0, -0.5, -0.5), 0.4)
        LH.C0 = clerp(LH.C0, LHC0 * cf(-0.5, 1, 0) * euler(0.5, 0, -0.5), 0.4)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC499: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC499: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      DecreaseStat(CannonTarget.Parent, "Defense", -0.2, 300)
      pwld1.Part1 = CannonTarget
      model2.Parent = CannonTarget.Parent
      MagicSpecial(BrickColor.new(NewCol), pprt1.CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 0.5, 0.5, 0.5, 0.05)
      ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
      ref.Anchored = true
      ref.CFrame = cf(pprt1.Position)
      game:GetService("Debris"):AddItem(ref, 1)
      so("203691326", ref, 1, 1)
      for i = 1, 5 do
        ElecEffect(cf(pprt1.Position), 3, 3, 3)
      end
      for i = 1, #Plasma do
        Plasma[i].Parent = model2
        PlasmaWelds[i].Parent = Plasma[1]
      end
      elecnum = 0
      attack = false
      for i = 1, 50 do
        fwait()
        ElecEffect(cf(pprt1.Position), 2, 2, 2)
      end
    else
      do
        attack = false
      end
    end
  end
end
do3 = function()
  if givingarmor == true then
    givingarmor = false
    cooldowns[3] = 0
    BladesTarget = RootPart
  end
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[3] and mana.Value >= 30 then
    attack = true
    mana.Value = mana.Value - 30
    givingblades = true
    MagicSpecial(BrickColor.new(NewCol), RightArm.CFrame * cf(0, -1, 0) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 0.2, 0.2, 0.2, 0.5, 0.5, 0.5, 0.1)
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = 0.4
    for i = 0, 1, 0.2 do
      fwait()
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1) * euler(0.2, 0, 0), 0.5)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1), 0.5)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.7, 0, 0) * euler(0, 0, -0.5), 0.5)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
      LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.3, 0, 0) * euler(0, 0, 0.8), 0.5)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
      RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.5) * euler(0, 1.57, 0) * euler(0, -1, -0.1), 0.5)
      LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.5) * euler(0, -1.57, 0) * euler(0, -1, 0.4), 0.5)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC279: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC279: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    givingarmor = true
    while givingarmor == true do
      if givingarmor == true then
        fwait()
        ElecEffect(RightArm.CFrame, 1, 2, 1)
      end
      if Stagger.Value ~= true and StunT.Value > Stun.Value and StaggerHit.Value == true then
        break
      end
    end
    givingblades = false
    DecreaseStat(Character, "Defense", -0.1, 400)
    DecreaseStat(Character, "Movement", 0.1, 400)
    cooldowns[3] = 0
    givingarmor = false
    dec.Parent = nil
    if BladesTarget ~= nil then
      for i = 0, 1, 0.2 do
        fwait()
        Neck.C0 = clerp(Neck.C0, necko * euler(-0.4, 0, -0.2), 0.4)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.5) * euler(0.8, 0, 0.5), 0.4)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.4, 0, 0.5), 0.4)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4), 0.4)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
        RH.C0 = clerp(RH.C0, RHC0 * cf(0, 0, 0) * euler(0, -0.5, -0.5), 0.4)
        LH.C0 = clerp(LH.C0, LHC0 * cf(-0.5, 1, 0) * euler(0.5, 0, -0.5), 0.4)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC499: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC499: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      DecreaseStat(BladesTarget.Parent, "Damage", -0.2, 300)
      brefwld.Part1 = BladesTarget
      model3.Parent = BladesTarget.Parent
      MagicSpecial(BrickColor.new(NewCol), bprt1.CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 0.3, 0.3, 0.3, 0.05)
      MagicSpecial(BrickColor.new(NewCol), bprt7.CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 0.3, 0.3, 0.3, 0.05)
      MagicSpecial(BrickColor.new(NewCol), bprt13.CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 0.3, 0.3, 0.3, 0.05)
      ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
      ref.Anchored = true
      ref.CFrame = cf(bprt1.Position)
      game:GetService("Debris"):AddItem(ref, 1)
      so("203691326", ref, 1, 1)
      for i = 1, 5 do
        ElecEffect(cf(bref.Position), 3, 3, 3)
      end
      for i = 1, #Blades do
        Blades[i].Parent = model3
        BladesWelds[i].Parent = Blades[1]
      end
      attack = false
      for i = 1, 50 do
        fwait()
        ElecEffect(cf(bref.Position), 2, 2, 2)
      end
    else
      do
        attack = false
      end
    end
  end
end
ignoretab2 = {}
NewPart = function(size, cframe, color, meshtype, meshscale)
  local par = Instance.new("Part")
  par.TopSurface = 0
  par.BottomSurface = 0
  par.Size = size
  par.CFrame = cframe
  par.BrickColor = color
  par.Anchored = true
  par.CanCollide = false
  do
    if meshtype then
      local m = Instance.new(meshtype, par)
      m.Scale = meshscale
    end
    table.insert(ignoretab2, par)
    return par
  end
end
vPlayer = game.Players.LocalPlayer
GetTeamFromColor = function(color)
  for _,v in pairs(game:GetService("Teams"):children()) do
    if color == v.TeamColor then
      return v.Name
    end
  end
end
drawline = function(pos, pos2)
  local par, loc, normal = nil, nil, nil
  for i = 1, 100 do
    par = workspace:FindPartOnRayWithIgnoreList(Ray.new(pos, -(pos - pos2)), ignoretab2)
    if par then
      -- DECOMPILER ERROR at PC45: Unhandled construct in 'MakeBoolean' P3

      -- DECOMPILER ERROR at PC45: Unhandled construct in 'MakeBoolean' P3

      if (par.CanCollide == false and par.Parent:FindFirstChild("Humanoid") == nil) or par:IsDescendantOf(vPlayer) then
        table.insert(ignoretab2, par)
      else
        local ok = true
        do
          do
            do
              if par.Parent:FindFirstChild("Humanoid") then
                local vp = game.Players:GetPlayerFromCharacter(par.Parent)
                -- DECOMPILER ERROR at PC81: Unhandled construct in 'MakeBoolean' P1

                if vp ~= nil and vp.Neutral ~= true and vPlayer.Neutral ~= true and GetTeamFromColor(vp.TeamColor) == GetTeamFromColor(vPlayer.TeamColor) then
                  table.insert(ignoretab2, par)
                  ok = false
                end
              end
              if vPlayer.Neutral ~= true and par.Parent:FindFirstChild("Alignment") ~= nil and vPlayer.TeamColor.Color == par.Parent.Alignment.Value then
                table.insert(ignoretab2, par)
                ok = false
              end
              if ok then
                return par, loc, normal
              end
              do return par, loc, normal end
              -- DECOMPILER ERROR at PC119: LeaveBlock: unexpected jumping out DO_STMT

              -- DECOMPILER ERROR at PC119: LeaveBlock: unexpected jumping out DO_STMT

              -- DECOMPILER ERROR at PC119: LeaveBlock: unexpected jumping out IF_ELSE_STMT

              -- DECOMPILER ERROR at PC119: LeaveBlock: unexpected jumping out IF_STMT

              -- DECOMPILER ERROR at PC119: LeaveBlock: unexpected jumping out IF_THEN_STMT

              -- DECOMPILER ERROR at PC119: LeaveBlock: unexpected jumping out IF_STMT

            end
          end
        end
      end
    end
  end
  print("oops")
  return nil, Vector3.new(0, 0, 0), Vector3.new(0, 0, 0)
end
lasersounds = {412755503, 412755564, 412755598, 412755669, 412756057, 412756123, 412756170, 412756199}
GetNubs = function()
  Nubs = {}
  for _,v in pairs(workspace:children()) do
    if v:FindFirstChild("Humanoid") ~= nil and v:FindFirstChild("Torso") ~= nil and v.Name ~= game.Players.LocalPlayer.Name and v.Name ~= vPlayer.Name .. "Subunit" and (v.Torso.Position - vPlayer.Character.HumanoidRootPart.Position).magnitude <= 600 and v.Humanoid.Health > 0 then
      local vp = game.Players:GetPlayerFromCharacter(v)
      if vp == nil then
        table.insert(Nubs, v)
      else
        if vp.Neutral == true and vPlayer.Neutral == true then
          table.insert(Nubs, v)
        else
          if GetTeamFromColor(vp.TeamColor) ~= GetTeamFromColor(vPlayer.TeamColor) then
            table.insert(Nubs, v)
          end
        end
      end
    end
  end
end
Nubs = {}
GetNubsInRadius = function(pos, radius)
  local radius = radius
  local filtered = {}
  for _,v in pairs(Nubs) do
    if v:FindFirstChild("Torso") ~= nil and v:FindFirstChild("Humanoid") ~= nil then
      local cpos = pos
      do
        do
          if v.Humanoid:GetState() == Enum.HumanoidStateType.Jumping or v.Humanoid:GetState() == Enum.HumanoidStateType.Freefall then
            local ydiff = (v.Torso.Position.y - vPlayer.Character.Torso.Position.y) / 1
            if ydiff > 5 then
              ydiff = 5
            end
            cpos = pos + Vector3.new(0, ydiff, 0)
          end
          if v.Name == "Siegmund" then
            cpos = cpos - Vector3.new(0, 5, 0)
          end
          if v.Torso.Position - (cpos).magnitude <= radius then
            table.insert(filtered, v)
          end
          -- DECOMPILER ERROR at PC74: LeaveBlock: unexpected jumping out DO_STMT

          -- DECOMPILER ERROR at PC74: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC74: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
  end
  return filtered
end

fwait = function(t)
  if t == nil then
    t = 0.033333333333333
  else
    if t == 0 then
      t = 0.033333333333333
    end
  end
  local s = 0
  repeat
    s = s + 0.033333333333333
    ArtificialHB.Event:wait()
  until t <= s
  return s, workspace.DistributedGameTime
end
do4 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[4] and mana.Value >= 40 then
    attack = true
    cooldowns[4] = 0
    mana.Value = mana.Value - 40
    GetNubs()
    table.insert(Nubs, vPlayer.Character)
    local ppos = vPlayer:GetMouse().Hit.p
    do
      local h, p, k = drawline(ppos + Vector3.new(0, 450, 0), ppos - Vector3.new(0, 450, 0))
      local r, g, b = nil, nil, nil
      local Col1 = BrickColor.new(NewCol)
      r = Col1.Color.r + 0.3
      g = Col1.Color.g + 0.3
      b = Col1.Color.b + 0.3
      if r > 1 then
        r = 1
      end
      if g > 1 then
        g = 1
      end
      if b > 1 then
        b = 1
      end
      local Col1C = (Color3.new(r, g, b))
      local pro, blolb, r, psl, par, loc, nor = nil, nil, nil, nil, nil, nil, nil
      local x = {}
      local joj, kd = false, false
      for i = 1, 10 do
        x[i] = i
      end
      local m = Instance.new("Model", workspace)
      m.Name = "IONCANNON_EFFECTS"
      game:GetService("Debris"):AddItem(m, 20)
      local kt = tick()
      local soloc = Instance.new("Part", workspace)
      soloc.Transparency = 1
      soloc.CanCollide = false
      soloc.Anchored = true
      soloc.Name = "Effect"
      soloc.Size = Vector3.new(0.2, 0.2, 0.2)
      soloc.CFrame = CFrame.new(ppos + Vector3.new(0, 450, 0), ppos - Vector3.new(0, 450, 0)) --(p)
      game:GetService("Debris"):AddItem(soloc, 25)
      local so = Instance.new("Sound", vPlayer.Character.Head)
      so.Volume = 0.35
      so.Pitch = 1
      so.SoundId = "http://www.roblox.com/asset/?id=412756347"
      coroutine.resume(coroutine.create(function(so)
    wait()
    so:Play()
  end), so)
      for i = 0, 1, 0.1 do
        fwait()
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1) * euler(0, 0, 0), 0.5)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.5)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.7, 0, 0) * euler(0, 0, 0), 0.4)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
        LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(0, 0, 0) * euler(0, 0, 0), 0.4)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      end
      fwait(0.5)
      local so = Instance.new("Sound", vPlayer.Character.Head)
      so.Volume = 0.4
      so.Pitch = 1.1
      so.SoundId = "http://www.roblox.com/asset/?id=412756417"
      coroutine.resume(coroutine.create(function(so)
    wait()
    so:Play()
  end), so)
      attack = false
      local so = Instance.new("Sound", soloc)
      so.Volume = 0.8
      so.Pitch = 1.2
      so.SoundId = "http://www.roblox.com/asset/?id=412756315"
      coroutine.resume(coroutine.create(function(so)
    wait()
    so:Play()
  end), so)
      local kuck = false
      local lasparts = {}
      coroutine.resume(coroutine.create(function()
    local ksl, mdist, mpl = 0, 0, 0
    repeat
      fwait(0.12)
      ksl = ksl + 1
      if ksl == 50 then
        GetNubs()
        table.insert(Nubs, vPlayer.Character)
        ksl = 0
      end
      mdist = (lasparts[1].Position - p).magnitude
      print(mdist)
      for _,v in pairs(Nubs) do
        if v and v.Parent and v:FindFirstChild("Torso") and v:FindFirstChild("Humanoid") and v.Humanoid.Health > 0 then
          mpl = Vector3.new(v.Torso.Position.x, 0, v.Torso.Position.z) - Vector3.new(p.x, 0, p.z).magnitude
          if mdist - 4.5 < mpl and mpl < mdist + 4.5 then
            print("!!!!", time())
            for __,vv in pairs(lasparts) do
              if vv.Position - v.Torso.Position.magnitude <= 10 and vv.Position.y - 4 <= v.Torso.Position.y then
                if v ~= vPlayer.Character then
                  Damagefunc(v.Torso, 1, 1, 0, "Normal", RootPart, 0, 1, 1, nil, false)
                  DecreaseStat(v.Parent, "Movement", 0.06, 200)
                  break
                end
                vPlayer.Character.Humanoid:TakeDamage(1 / vPlayer.Character.Stats.Defense.Value)
                DecreaseStat(vPlayer.Character, "Movement", 0.06, 200)
                showDamage(vPlayer.Character, math.floor(1 / vPlayer.Character.Stats.Defense.Value), "Damage")
                break
              end
            end
          end
        end
      end
    until kuck == true
  end))
      for i = 1, 10 do
        r = math.random(1, #x)
        if #x > 1 then
          blolb = x[r]
        else
          blolb = x[1]
        end
        psl = ppos + Vector3.new(0, 450, 0), ppos - Vector3.new(0, 450, 0) + Vector3.new(math.cos(math.rad(36 * blolb)) * 35, 0, math.sin(math.rad(36 * blolb)) * 35) --p + Vector3.new(math.cos(math.rad(36 * blolb)) * 35, 0, math.sin(math.rad(36 * blolb)) * 35)
        par = drawline(psl + Vector3.new(0, 480, 0), psl - Vector3.new(0, 480, 0))
        local pc = NewPart(Vector3.new(1, 1, 1), CFrame.new(ppos) * CFrame.Angles(math.random(-30, 30) / 50, math.random(-30, 30) / 50, math.random(-30, 30) / 50), Col1, "SpecialMesh", Vector3.new(2, 2, 2))
        pc.Parent = workspace
        pc.Anchored = true
        pc.CanCollide = false
        pc.Mesh.MeshType = "Sphere"
        pc.Transparency = 1
        pc.Material = "Neon"
        game:GetService("Debris"):AddItem(pc, 15)
        coroutine.resume(coroutine.create(function(p, V, x)
    for i = 1, 12 do
      p.Mesh.Scale = p.Mesh.Scale + Vector3.new(1.6, 1.6, 1.6) / (1 + i / 6.5)
      p.Transparency = 0.25 + i / 16
      p.CFrame = p.CFrame * V
      fwait()
    end
    p:Remove()
  end), pc, CFrame.Angles(math.rad(math.random(-6, 6)), math.rad(math.random(-16, 16)), math.rad(math.random(-6, 6))))
        table.insert(ignoretab2, pc)
        local pc = NewPart(Vector3.new(1, 1, 1), CFrame.new(ppos + Vector3.new(0, 1.25, 0)) * CFrame.Angles(0, math.random(-180, 180) * math.rad(1), 0), Col1, "SpecialMesh", Vector3.new(4, 4, 4))
        pc.Mesh.MeshType = "FileMesh"
        pc.Anchored = true
        pc.CanCollide = false
        pc.Parent = workspace
        pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
        pc.Name = "Shockwave"
        pc.Material = "Neon"
        game:GetService("Debris"):AddItem(pc, 5)
        coroutine.resume(coroutine.create(function(p)
    for i = 1, 12 do
      p.Transparency = 0.25 + i / 16
      p.CFrame = p.CFrame * CFrame.Angles(0, math.rad(5 + i / 20), 0) + Vector3.new(0, -0.11666666666667, 0)
      p.Mesh.Scale = p.Mesh.Scale + Vector3.new(i / 10, -0.25, i / 10)
      fwait()
    end
    p:Remove()
  end), pc)
        local so = Instance.new("Sound", pc)
        so.Volume = 1
        so.Pitch = 1
        so.SoundId = "http://www.roblox.com/asset/?id=" .. lasersounds[math.random(1, 8)]
        coroutine.resume(coroutine.create(function(so)
    wait()
    so:Play()
  end), so)
        for kek = 1, 3 do
          pro = NewPart(Vector3.new(1, 1, 1), CFrame.new(ppos), Col1, "CylinderMesh", Vector3.new(1.7 - kek * 0.1, 1600, 1.7 - kek * 0.1) - Vector3.new(0.25, 0, 0.25) * 1.95 ^ (kek - 1))
          pro.Anchored = true
          pro.Mesh.Offset = Vector3.new(0, 799, 0)
          pro.Material = "Neon"
          pro.Name = "Las" .. i .. kek
          pro.Parent = m
          pro.Transparency = 1 - 0.2 * 1.7 ^ (kek - 1)
          game:GetService("Debris"):AddItem(pro, 10)
          if kek == 1 then
            table.insert(lasparts, pro)
            coroutine.resume(coroutine.create(function(k, l)
    repeat
      fwait()
    until joj == true
    local j, c, h, psl, pc = nil, nil, nil, nil, nil
    local klr, i, lj = 0, 0, 0
    repeat
      if lj < 0.008 then
        lj = lj + 0.001
      else
        lj = 0.008
      end
      klr = klr + i * lj
      if klr > 34.75 then
        klr = 34.75
      end
      psl = ppos
      j = drawline(psl + Vector3.new(0, 480, 0), psl - Vector3.new(0, 480, 0))
      k.CFrame = CFrame.new(ppos)
      i = i + 1
      m["Las" .. l .. "2"].CFrame = k.CFrame
      m["Las" .. l .. "3"].CFrame = k.CFrame
      fwait()
    until klr >= 34.75
    psl = ppos
    -- DECOMPILER ERROR at PC144: Overwrote pending register: R4 in 'AssignReg'

    -- DECOMPILER ERROR at PC145: Overwrote pending register: R3 in 'AssignReg'

    j = drawline(psl + Vector3.new(0, 480, 0), psl - Vector3.new(0, 480, 0))
    k.CFrame = CFrame.new(ppos)
    kd = true
  end), pro, i)
            local sizeseq = NumberSequence.new({NumberSequenceKeypoint.new(0, 1.8), NumberSequenceKeypoint.new(1, 0)})
            local transseq = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.66), NumberSequenceKeypoint.new(1, 1)})
            local sus1 = Instance.new("ParticleEmitter", pro)
            sus1.Color = ColorSequence.new(Col1.Color, Col1C)
            sus1.Transparency = transseq
            sus1.Size = sizeseq
            sus1.LightEmission = 0.33
            sus1.Rotation = NumberRange.new(-180, 180)
            sus1.Lifetime = NumberRange.new(0.8, 0.8)
            sus1.RotSpeed = NumberRange.new(-10, 10)
            sus1.Texture = "http://www.roblox.com/asset/?id=242911609"
            sus1.Speed = NumberRange.new(5, 8)
            sus1.VelocitySpread = 3
            sus1.Rate = 125
            sus1.ZOffset = 0
            sus1.Name = "ParticleEmitter1"
            local sizeseq = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.6), NumberSequenceKeypoint.new(1, 0)})
            local transseq = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)})
            local sus1 = Instance.new("ParticleEmitter", pro)
            sus1.Color = ColorSequence.new(Col1C, Col1C)
            sus1.Transparency = transseq
            sus1.Size = sizeseq
            sus1.LightEmission = 0.33
            sus1.Rotation = NumberRange.new(-180, 180)
            sus1.Lifetime = NumberRange.new(0.4, 0.8)
            sus1.RotSpeed = NumberRange.new(-10, 10)
            sus1.Texture = "http://www.roblox.com/asset/?id=242292318"
            sus1.Speed = NumberRange.new(10, 12)
            sus1.VelocitySpread = 60
            sus1.Rate = 50
            sus1.ZOffset = 0
            sus1.Name = "ParticleEmitter2"
          end
        end
        table.remove(x, r)
        fwait(0.15)
      end
      fwait()
      joj = true
      fwait(2)
      local so = Instance.new("Sound", soloc)
      so.Volume = 0.9
      so.Pitch = 1
      so.SoundId = "http://www.roblox.com/asset/?id=412756262"
      coroutine.resume(coroutine.create(function(so)
    wait()
    so:Play()
  end), so)
      repeat
        fwait(0.06)
        pro = NewPart(Vector3.new(0.2, 0.2, 0.2), CFrame.new(ppos) * CFrame.Angles(0, math.rad(math.random(-180, 180)), 0) * CFrame.new(math.random(3, 50), 0, 0), Col1, "SpecialMesh", Vector3.new(2, 25, 2))
        pro.Mesh.MeshType = "Sphere"
        pro.Anchored = true
        pro.Material = "Neon"
        pro.Name = "LasEffect"
        pro.Parent = m
        pro.Transparency = 1
        game:GetService("Debris"):AddItem(pro, 10)
        table.insert(ignoretab2, pro)
        coroutine.resume(coroutine.create(function(p, k)
    for i = 1, 50 do
      if i <= 5 then
        p.Transparency = p.Transparency - 0.1
      else
        if i >= 45 then
          p.Transparency = p.Transparency + 0.1
        end
      end
      p.CFrame = p.CFrame + Vector3.new(0, k, 0)
      fwait()
    end
    p:Destroy()
  end), pro, math.random(15, 30) / 10)
      until kd == true
      for kek = 1, 4 do
        pro = NewPart(Vector3.new(3, 1, 3), CFrame.new(ppos), Col1, "CylinderMesh", Vector3.new(0.7, 1600, 0.7) - Vector3.new(0.175, 0, 0.175) * (kek - 1))
        pro.Anchored = true
        pro.Mesh.Offset = Vector3.new(0, 799, 0)
        pro.Material = "Neon"
        pro.Name = "LasBig"
        pro.Parent = m
        pro.Transparency = 1 - 0.2 * 1.7 ^ (kek - 1)
        game:GetService("Debris"):AddItem(pro, 10)
        local sizeseq = NumberSequence.new({NumberSequenceKeypoint.new(0, 1.8), NumberSequenceKeypoint.new(1, 0)})
        local transseq = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.66), NumberSequenceKeypoint.new(1, 1)})
        local sus1 = Instance.new("ParticleEmitter", pro)
        sus1.Color = ColorSequence.new(Col1.Color, Col1C)
        sus1.Transparency = transseq
        sus1.Size = sizeseq
        sus1.LightEmission = 0.33
        sus1.Rotation = NumberRange.new(-180, 180)
        sus1.Lifetime = NumberRange.new(0.8, 0.8)
        sus1.RotSpeed = NumberRange.new(-10, 10)
        sus1.Texture = "http://www.roblox.com/asset/?id=242911609"
        sus1.Speed = NumberRange.new(5, 8)
        sus1.VelocitySpread = 3
        sus1.Rate = 125
        sus1.ZOffset = 5
        sus1.Name = "ParticleEmitter1"
        local sizeseq = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.6), NumberSequenceKeypoint.new(1, 0)})
        local transseq = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)})
        local sus1 = Instance.new("ParticleEmitter", pro)
        sus1.Color = ColorSequence.new(Col1C, Col1C)
        sus1.Transparency = transseq
        sus1.Size = sizeseq
        sus1.LightEmission = 0.33
        sus1.Rotation = NumberRange.new(-180, 180)
        sus1.Lifetime = NumberRange.new(0.4, 0.8)
        sus1.RotSpeed = NumberRange.new(-10, 10)
        sus1.Texture = "http://www.roblox.com/asset/?id=242292318"
        sus1.Speed = NumberRange.new(10, 12)
        sus1.VelocitySpread = 60
        sus1.Rate = 50
        sus1.ZOffset = 5
        sus1.Name = "ParticleEmitter2"
        coroutine.resume(coroutine.create(function(k)
    for i = 1, 70 do
      if k.Parent == nil then
        break
      end
      fwait()
      k.Mesh.Scale = k.Mesh.Scale * 1.028
      k.ParticleEmitter1.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 2 + i * 0.1), NumberSequenceKeypoint.new(1, 0)})
      k.ParticleEmitter1.Speed = NumberRange.new(10 + i / 8, 12 + i / 8)
      k.ParticleEmitter2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 1 + i * 0.03), NumberSequenceKeypoint.new(1, 0)})
      k.ParticleEmitter2.Speed = NumberRange.new(15 + i / 8, 18 + i / 8)
    end
  end), pro)
      end
      print(tick() - kt)
      print("JOJ")
      for i = 1, 22.5 do
        fwait(0.066666666666667)
        pro = NewPart(Vector3.new(0.2, 0.2, 0.2), CFrame.new(ppos) * CFrame.Angles(0, math.rad(math.random(-180, 180)), 0) * CFrame.new(math.random(3, 50), 0, 0), Col1, "SpecialMesh", Vector3.new(2, 25, 2))
        pro.Mesh.MeshType = "Sphere"
        pro.Anchored = true
        pro.Material = "Neon"
        pro.Name = "LasEffect"
        pro.Parent = m
        pro.Transparency = 1
        game:GetService("Debris"):AddItem(pro, 10)
        table.insert(ignoretab2, pro)
        coroutine.resume(coroutine.create(function(p, k)
    for i = 1, 50 do
      if i <= 5 then
        p.Transparency = p.Transparency - 0.1
      else
        if i >= 45 then
          p.Transparency = p.Transparency + 0.1
        end
      end
      p.CFrame = p.CFrame + Vector3.new(0, k, 0)
      fwait()
    end
    p:Destroy()
  end), pro, math.random(15, 30) / 10)
      end
      local so = Instance.new("Sound", soloc)
      so.Volume = 1
      so.Pitch = 1
      so.SoundId = "http://www.roblox.com/asset/?id=266243673"
      so:Play()
      local pros = NewPart(Vector3.new(1, 1, 1), CFrame.new(ppos), Col1, "CylinderMesh", Vector3.new(24, 1600, 24))
      pros.Anchored = true
      pros.Mesh.Offset = Vector3.new(0, 799, 0) * 4
      pros.Material = "Neon"
      pros.Name = "LasBerryBig"
      pros.Parent = m
      game:GetService("Debris"):AddItem(pros, 10)
      coroutine.resume(coroutine.create(function(k)
    for i = 1, 30 do
      k.Mesh.Offset = k.Mesh.Offset - Vector3.new(0, 79.9, 0)
      fwait()
    end
    kuck = true
    for i = 1, 30 do
      if k.Parent == nil then
        break
      end
      k.Mesh.Offset = k.Mesh.Offset - Vector3.new(0, 799, 0) / 30
      k.Mesh.Scale = k.Mesh.Scale - Vector3.new(22, 1600, 22) / 30
      fwait()
    end
    do
      k:Destroy()
    end
  end), pros)
      for i = 1, 32.5 do
        if kuck == true then
          break
        end
        fwait()
        pro = NewPart(Vector3.new(0.2, 0.2, 0.2), CFrame.new(ppos) * CFrame.Angles(0, math.rad(math.random(-180, 180)), 0) * CFrame.new(math.random(3, 50), 0, 0), Col1, "SpecialMesh", Vector3.new(2, 25, 2))
        pro.Mesh.MeshType = "Sphere"
        pro.Anchored = true
        pro.Material = "Neon"
        pro.Name = "LasEffect"
        pro.Parent = m
        pro.Transparency = 1
        game:GetService("Debris"):AddItem(pro, 10)
        table.insert(ignoretab2, pro)
        coroutine.resume(coroutine.create(function(p, k)
    for i = 1, 50 do
      if i <= 5 then
        p.Transparency = p.Transparency - 0.1
      else
        if i >= 45 then
          p.Transparency = p.Transparency + 0.1
        end
      end
      p.CFrame = p.CFrame + Vector3.new(0, k, 0)
      fwait()
    end
    p:Destroy()
  end), pro, math.random(15, 30) / 10)
        if kuck == true then
          break
        end
        fwait()
      end
      do
        local so = Instance.new("Sound", soloc)
        so.Volume = 1
        so.Pitch = 1.2
        so.SoundId = "http://www.roblox.com/asset/?id=266243712"
        so:Play()
        local so = Instance.new("Sound", soloc)
        so.Volume = 1
        so.Pitch = 1.2
        so.SoundId = "http://www.roblox.com/asset/?id=385545047"
        so:Play()
        local pc = NewPart(Vector3.new(1, 1, 1), CFrame.new(ppos + Vector3.new(0, 6.75, 0)) * CFrame.Angles(0, math.random(-10, 10), 0), Col1, "SpecialMesh", Vector3.new(47.5, 15, 47.5))
        pc.Mesh.MeshType = "FileMesh"
        pc.Anchored = true
        pc.CanCollide = false
        pc.Parent = workspace
        pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
        pc.Name = "Shockwave"
        game:GetService("Debris"):AddItem(pc, 5)
        pc.Material = "Neon"
        coroutine.resume(coroutine.create(function(p)
    for i = 1, 30 do
      p.Transparency = 0.25 + i / 40
      p.CFrame = p.CFrame * CFrame.Angles(0, math.rad(3 + i / 30), 0) - Vector3.new(0, 0.24166666666667, 0)
      p.Mesh.Scale = p.Mesh.Scale + Vector3.new(i / 11, -0.48333333333333, i / 11)
      fwait()
    end
    p:Remove()
  end), pc)
        local pc = NewPart(Vector3.new(1, 1, 1), CFrame.new(ppos + Vector3.new(0, 4.25, 0)) * CFrame.Angles(0, math.random(-10, 10), 0), Col1, "SpecialMesh", Vector3.new(57.5, 10, 57.5))
        pc.Mesh.MeshType = "FileMesh"
        pc.Anchored = true
        pc.CanCollide = false
        pc.Parent = workspace
        pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
        pc.Name = "Shockwave"
        game:GetService("Debris"):AddItem(pc, 5)
        pc.Material = "Neon"
        coroutine.resume(coroutine.create(function(p)
    for i = 1, 30 do
      p.Transparency = 0.25 + i / 40
      p.CFrame = p.CFrame * CFrame.Angles(0, -math.rad(3 + i / 30), 0) - Vector3.new(0, 0.15833333333333, 0)
      p.Mesh.Scale = p.Mesh.Scale + Vector3.new(i / 9, -0.31666666666667, i / 9)
      fwait()
    end
    p:Remove()
  end), pc)
        local pc = NewPart(Vector3.new(1, 1, 1), CFrame.new(ppos + Vector3.new(0, 1.75, 0)) * CFrame.Angles(0, math.random(-10, 10), 0), Col1, "SpecialMesh", Vector3.new(73.5, 5, 73.5))
        pc.Mesh.MeshType = "FileMesh"
        pc.Anchored = true
        pc.CanCollide = false
        pc.Parent = workspace
        pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
        pc.Name = "Shockwave"
        game:GetService("Debris"):AddItem(pc, 5)
        pc.Material = "Neon"
        coroutine.resume(coroutine.create(function(p)
    for i = 1, 30 do
      p.Transparency = 0.25 + i / 40
      p.CFrame = p.CFrame * CFrame.Angles(0, math.rad(3 + i / 30), 0) - Vector3.new(0, 0.075, 0)
      p.Mesh.Scale = p.Mesh.Scale + Vector3.new(i / 7, -0.15, i / 7)
      fwait()
    end
    p:Remove()
  end), pc)
        local pc = NewPart(Vector3.new(1, 1, 1), CFrame.new(ppos + Vector3.new(0, 1.5, 0)) * CFrame.Angles(0, math.random(-10, 10), 0), BrickColor.new("Institutional white"), "SpecialMesh", Vector3.new(30, 5, 30))
        pc.Mesh.MeshType = "FileMesh"
        pc.Anchored = true
        pc.CanCollide = false
        pc.Parent = workspace
        pc.Mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
        pc.Name = "Shockwave"
        pc.Material = "Neon"
        game:GetService("Debris"):AddItem(pc, 5)
        coroutine.resume(coroutine.create(function(p)
    for i = 1, 20 do
      p.Transparency = 0.5 + i / 40
      p.CFrame = p.CFrame * CFrame.Angles(0, math.rad(5 + i / 10), 0)
      p.Mesh.Scale = p.Mesh.Scale + Vector3.new(i / 6 + 8, 0, i / 6 + 8)
      fwait()
    end
    p:Remove()
  end), pc)
        for LEL = 1, 3 do
          local pc = NewPart(Vector3.new(1, 1, 1), CFrame.new(ppos + Vector3.new(0, 0, 0)), Col1, "SpecialMesh", Vector3.new(18, 18, 18) * LEL)
          pc.Parent = workspace
          pc.Mesh.MeshType = "Sphere"
          pc.Anchored = true
          pc.CanCollide = false
          pc.Transparency = 1
          game:GetService("Debris"):AddItem(pc, 15)
          pc.Material = "Neon"
          coroutine.resume(coroutine.create(function(p, V, x)
    for i = 1, 20 do
      p.Mesh.Scale = p.Mesh.Scale * 1.05 + Vector3.new(1.5, 1.5, 1.5)
      p.Transparency = 0.25 + i / 26.666666666667
      p.CFrame = p.CFrame * V
      fwait()
    end
    p:Remove()
  end), pc, CFrame.fromEulerAnglesXYZ(0, math.rad(5), 0))
        end
        for LEL = 1, 3 do
          local pc = NewPart(Vector3.new(1, 1, 1), CFrame.new(ppos) * CFrame.fromEulerAnglesXYZ(math.random(-180, 180), math.random(-180, 180), math.random(-180, 180)), Col1, "BlockMesh", Vector3.new(15, 15, 15) * LEL)
          pc.Parent = workspace
          pc.Anchored = true
          pc.CanCollide = false
          pc.Transparency = 1
          game:GetService("Debris"):AddItem(pc, 15)
          pc.Material = "Neon"
          coroutine.resume(coroutine.create(function(p, V, x)
    for i = 1, 12 do
      p.Mesh.Scale = p.Mesh.Scale * 1.02 + Vector3.new(3.5, 3.5, 3.5)
      p.Transparency = 0.1 + i / 13.333333333333
      p.CFrame = p.CFrame * V
      fwait()
    end
    p:Remove()
  end), pc, CFrame.fromEulerAnglesXYZ(0, math.rad(5), 0))
        end
        for LEL = 1, 6 do
          local pc = NewPart(Vector3.new(1, 1, 1), CFrame.new(ppos + Vector3.new(math.random(-50, 50) / 3, 0, math.random(-50, 50) / 3)), Col1, "SpecialMesh", Vector3.new(7, 9, 7))
          pc.Parent = workspace
          pc.Mesh.MeshType = "Sphere"
          pc.Anchored = true
          pc.CanCollide = false
          pc.Transparency = 1
          game:GetService("Debris"):AddItem(pc, 15)
          pc.Material = "Neon"
          coroutine.resume(coroutine.create(function(p, V, x)
    for i = 1, 40 do
      p.Mesh.Scale = Vector3.new(25 - i / 2, 30 * i, 25 - i / 2)
      p.Transparency = 0.25 + i / 53.333333333333
      p.CFrame = p.CFrame * V
      fwait()
    end
    p:Remove()
  end), pc, CFrame.fromEulerAnglesXYZ(0, math.rad(5), 0))
          do
            if LEL % 2 == 0 then
              local pc = NewPart(Vector3.new(1, 1, 1), CFrame.new(ppos), Col1, "SpecialMesh", Vector3.new(10, 15, 10) + Vector3.new(2, 3, 2) * LEL)
              pc.Parent = workspace
              pc.Mesh.MeshType = "Sphere"
              pc.Anchored = true
              pc.CanCollide = false
              pc.Transparency = 1
              game:GetService("Debris"):AddItem(pc, 15)
              pc.Material = "Neon"
              coroutine.resume(coroutine.create(function(p, V, x)
    for i = 1, 40 do
      p.Mesh.Scale = p.Mesh.Scale * 1.04 + Vector3.new(3.5 - i * 0.27, i, 3.5 - i * 0.27)
      p.Transparency = 0.33 + i / 59.701492537313
      p.CFrame = p.CFrame * V
      fwait()
    end
    p:Remove()
  end), pc, CFrame.fromEulerAnglesXYZ(0, math.rad(5), 0))
            end
            do
              local pc = NewPart(Vector3.new(1, 1, 1), CFrame.new(ppos + Vector3.new(0, 0, 0)) * CFrame.fromEulerAnglesXYZ(math.random(-180, 180), math.random(-180, 180), math.random(-180, 180)), Col1, "BlockMesh", Vector3.new(20, 20, 20))
              pc.Parent = workspace
              pc.Anchored = true
              pc.CanCollide = false
              pc.Transparency = 1
              game:GetService("Debris"):AddItem(pc, 15)
              pc.Material = "Neon"
              coroutine.resume(coroutine.create(function(p, V, x)
    for i = 1, 60 do
      p.Mesh.Scale = p.Mesh.Scale * 1.01 + Vector3.new(0.6, 0.6, 0.6)
      p.Transparency = 0.4 + i / 100
      p.CFrame = p.CFrame * V
      fwait()
    end
    p:Remove()
  end), pc, CFrame.fromEulerAnglesXYZ(math.rad(math.random(-50, 50) / 15), math.rad(math.random(-50, 50) / 15), math.rad(math.random(-50, 50) / 15)))
              if LEL == 2 then
                MagniDamage(soloc, 50, 38, 42, 45, "Normal", soloc, 0, 1, 80, false, false, true, nil, nil, nil, nil)
                if vPlayer.Character.Torso.Position - ppos.magnitude <= 50 then
                  vPlayer.Character.Humanoid:TakeDamage(40 / vPlayer.Character.Stats.Defense.Value)
                  showDamage(vPlayer.Character, math.floor(40 / vPlayer.Character.Stats.Defense.Value), "Damage")
                  vPlayer.Character.Stats.Stun.Value = 100
                end
              end
              fwait(0.066666666666667)
              -- DECOMPILER ERROR at PC2114: LeaveBlock: unexpected jumping out DO_STMT

            end
          end
        end
        fwait()
        for _,v in pairs(m:children()) do
          if v.Name ~= "LasBerryBig" then
            v:Remove()
          end
        end
      end
    end
  end
end
DecreaseStat = function(Model, Stat, Amount, Duration)
  if Model:findFirstChild("Stats") ~= nil and Model.Stats[Stat] ~= nil then
    Model.Stats[Stat].Value = Model.Stats[Stat].Value - Amount
    d = Instance.new("NumberValue", Model.Stats.Decrease)
    dur = Instance.new("NumberValue", d)
    dur.Name = "Duration"
    dur.Value = Duration
    game:GetService("Debris"):AddItem(d, 20)
    if Stat == "Damage" then
      d.Name = "DecreaseAtk"
    else
      if Stat == "Defense" then
        d.Name = "DecreaseDef"
      else
        if Stat == "Movement" then
          d.Name = "DecreaseMvmt"
        end
      end
    end
    if Model:findFirstChild("Torso") ~= nil then
      display = ""
      if Stat == "Damage" then
        if Amount > 0 then
          display = "-Damage"
        else
          display = "+Damage"
        end
      else
        if Stat == "Defense" then
          if Amount > 0 then
            display = "-Defense"
          else
            display = "+Defense"
          end
        else
          if Stat == "Movement" then
            if Amount > 0 then
              display = "-Movement"
            else
              display = "+Movement"
            end
          end
        end
      end
      showDamage(Model, display, "Debuff")
    end
    d.Value = Amount
  end
end
GetDist = function(Part1, Part2, magni)
  local targ = Part1.Position - Part2.Position
  local mag = targ.magnitude
  if mag <= magni then
    return true
  else
    return false
  end
end
MagniDamage = function(Part, magni, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration, Sound)
  for _,c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = nil
      for _,d in pairs(c:children()) do
        if d.className == "Model" and ranged ~= true then
          head = d:findFirstChild("Hitbox")
          if d.Parent == Character then
            break
          end
          if head ~= nil then
            local targ = head.Position - Part.Position
            local mag = targ.magnitude
            if mag <= magni and c.Name ~= Player.Name then
              ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
              ref.Anchored = true
              ref.CFrame = cf(head.Position)
              game:GetService("Debris"):AddItem(ref, 1)
              hitnum = math.random(1, 5)
              if hitnum == 1 then
                so("199148971", ref, 1, 1)
              else
                if hitnum == 2 then
                  so("199149025", ref, 1, 1)
                else
                  if hitnum == 3 then
                    so("199149072", ref, 1, 1)
                  else
                    if hitnum == 4 then
                      so("199149109", ref, 1, 1)
                    else
                      if hitnum == 5 then
                        so("199149119", ref, 1, 1)
                      end
                    end
                  end
                end
              end
              StaggerHit.Value = true
            end
          end
        end
        do
          if d.className == "Part" then
            head = d
            if head ~= nil then
              local targ = head.Position - Part.Position
              local mag = targ.magnitude
              if mag <= magni and c.Name ~= Player.Name then
                if stun == nil then
                  stun = math.random(5, 10)
                end
                local Rang = nil
                if Ranged == false then
                  Rang = true
                end
                local stag = nil
                if shbash == true then
                  stag = true
                end
                Damagefunc(head, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration, Sound)
              end
            end
          end
          do
            -- DECOMPILER ERROR at PC184: LeaveBlock: unexpected jumping out DO_STMT

          end
        end
      end
    end
  end
end
rayCast = function(Pos, Dir, Max, Ignore)
  return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
end
local Point = Torso.CFrame * cf(0, Torso.Size.Y, 0)
LastPoint = Point
effect = function(Color, Ref, LP, P1, returnn)
  if LP == nil or P1 == nil then
    return 
  end
  local effectsmsh = Instance.new("CylinderMesh")
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  effectsmsh.Name = "Mesh"
  local effectsg = Instance.new("Part")
  NoOutline(effectsg)
  effectsg.formFactor = 3
  effectsg.CanCollide = false
  effectsg.Name = "Eff"
  effectsg.Locked = true
  effectsg.Anchored = true
  effectsg.Size = Vector3.new(0.5, 1, 0.5)
  effectsg.Parent = workspace
  effectsmsh.Parent = effectsg
  effectsg.BrickColor = BrickColor.new(Color)
  effectsg.Reflectance = Ref
  local point1 = P1
  local mg = LP.p - point1.p.magnitude
  effectsg.Size = Vector3.new(0.5, mg, 0.5)
  effectsg.CFrame = cf((LP.p + point1.p) / 2, point1.p) * CFrame.Angles(math.rad(90), 0, 0)
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  game:GetService("Debris"):AddItem(effectsg, 2)
  if returnn then
    return effectsg
  end
  if not returnn then
    table.insert(Effects, {effectsg, "Cylinder", 0.2, 0.01, 0, 0.01, effectsmsh})
  end
end
MagicBlock = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  if Type == 1 or Type == nil then
    table.insert(Effects, {prt, "Block1", delay, x3, y3, z3, msh})
  else
    if Type == 2 then
      table.insert(Effects, {prt, "Block2", delay, x3, y3, z3, msh})
    end
  end
end
MagicCircle = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicRing = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
  prt.Anchored = true
  prt.CFrame = cframe * cf(x2, y2, z2)
  local msh = mesh("SpecialMesh", prt, "FileMesh", "3270017", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicCylinder = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicCylinder2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt(0.2, 0.2, 0.2))
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 5)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
ClangEffect = function(brickcolor, cframe, duration, decrease, size, power)
  local prt = part(3, workspace, 0, 1, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(5, 5, 5))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "CylinderClang", duration, decrease, size, power, prt.CFrame, nil})
end
MagicWave = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "FileMesh", "20329976", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicSpecial = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "FileMesh", "24388358", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
ElecEffect = function(cff, x, y, z)
  local prt = part(3, workspace, 0, 0, BrickColor.new("Dark stone grey"), "Part", vt(1, 1, 1))
  prt.Anchored = true
  prt.CFrame = cff * cf(math.random(-x, x), math.random(-y, y), math.random(-z, z))
  prt.CFrame = cf(prt.Position)
  game:GetService("Debris"):AddItem(prt, 10)
  xval = math.random() / 3
  yval = math.random() / 3
  zval = math.random() / 3
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(xval, yval, zval))
  Effects[#Effects + 1] = {prt, "Elec", 0.2, x, y, z, xval, yval, zval, msh}
end
  Damagefunc = function(hit, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
  if hit.Parent == nil then
    return 
  end
  if hit.Name == "Hitbox" and hit.Parent ~= modelzorz and ranged ~= true then
    ref = part(3, effects, 0, 1, BrickColor.new("Black"), "Reference", vt())
    ref.Anchored = true
    ref.CFrame = cf(hit.Position)
    game:GetService("Debris"):AddItem(ref, 1)
    hitnum = math.random(1, 5)
    if hitnum == 1 then
      so("199148971", ref, 1, 1)
    else
      if hitnum == 2 then
        so("199149025", ref, 1, 1)
      else
        if hitnum == 3 then
          so("199149072", ref, 1, 1)
        else
          if hitnum == 4 then
            so("199149109", ref, 1, 1)
          else
            if hitnum == 5 then
              so("199149119", ref, 1, 1)
            end
          end
        end
      end
    end
    StaggerHit.Value = true
  end
  h = hit.Parent:FindFirstChild("Humanoid")
  if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
    if hit.Parent:findFirstChild("DebounceHit") ~= nil then
      return 
    end
    c = Instance.new("ObjectValue")
    c.Name = "creator"
    c.Value = game:service("Players").LocalPlayer
    c.Parent = h
    RecentEnemy.Value = hit.Parent
    game:GetService("Debris"):AddItem(c, 0.5)
    minim = minim * Atk.Value
    maxim = maxim * Atk.Value
    Damage = 0
    if minim == maxim then
      Damage = maxim
    else
      Damage = math.random(minim, maxim)
    end
    blocked = false
    enblock = nil
    local EStats = hit.Parent:findFirstChild("Stats")
    if EStats ~= nil then
      invis = EStats:findFirstChild("Invisibility")
      isinvis = EStats:findFirstChild("IsInvisible")
      if (ranged == false or ranged == nil) and invis ~= nil and isinvis.Value == true then
        invis.Value = 0
      end
      enblock = EStats:findFirstChild("Block")
      if enblock ~= nil and enblock.Value == true then
        blocked = true
      end
      if EStats:findFirstChild("Defense") ~= nil then
        Damage = Damage / EStats.Defense.Value
        if Damage <= 3 and (ranged == false or ranged == nil) and blocked ~= true then
          hitnum = math.random(1, 5)
          if hitnum == 1 then
            so("199149321", hit, 1, 1)
          else
            if hitnum == 2 then
              so("199149338", hit, 1, 1)
            else
              if hitnum == 3 then
                so("199149367", hit, 1, 1)
              else
                if hitnum == 4 then
                  so("199149409", hit, 1, 1)
                else
                  if hitnum == 5 then
                    so("199149452", hit, 1, 1)
                  end
                end
              end
            end
          end
        else
          if ranged == false or ranged == nil and blocked ~= true then
            hitnum = math.random(1, 6)
            if hitnum == 1 then
              so("199149137", hit, 1, 1)
            else
              if hitnum == 2 then
                so("199149186", hit, 1, 1)
              else
                if hitnum == 3 then
                  so("199149221", hit, 1, 1)
                else
                  if hitnum == 4 then
                    so("199149235", hit, 1, 1)
                  else
                    if hitnum == 5 then
                      so("199149269", hit, 1, 1)
                    else
                      if hitnum == 6 then
                        so("199149297", hit, 1, 1)
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if Damage <= 3 and staghit == true and ranged ~= true then
          StaggerHit.Value = true
        end
      end
      if EStats:findFirstChild("Stun") ~= nil then
        if blocked == true then
          incstun = incstun / 2
        end
        if EStats.Stun.Value < EStats.StunThreshold.Value then
          EStats.Stun.Value = EStats.Stun.Value + incstun
        end
      end
      if EStats:findFirstChild("Stagger") ~= nil and stagger == true then
        EStats.Stagger.Value = true
      end
    end
    if blocked == true then
      showDamage(hit.Parent, "Block", "Damage")
      if ranged ~= true then
        enblock.Value = false
        Stagger.Value = true
        hitnum = math.random(1, 2)
        if hitnum == 1 then
          so("199148933", hit, 1, 1)
        else
          if hitnum == 2 then
            so("199148947", hit, 1, 1)
          end
        end
      end
    else
      Damage = math.floor(Damage)
      coroutine.resume(coroutine.create(function(Hum, Dam)
	hit.Parent.Humanoid:TakeDamage(Damage)
  end
), h, Damage)
      showDamage(hit.Parent, Damage, "Damage")
      if DecreaseState ~= nil then
        if DecreaseState == "Temporal" then
          DecreaseStat(hit.Parent, "Damage", DecreaseAmount, Duration)
          DecreaseStat(hit.Parent, "Defense", DecreaseAmount, Duration)
        else
          if DecreaseState == "Temporal2" then
            DecreaseStat(hit.Parent, "Damage", DecreaseAmount, Duration)
            DecreaseStat(hit.Parent, "Movement", DecreaseAmount, Duration)
          else
            DecreaseStat(hit.Parent, DecreaseState, DecreaseAmount, Duration)
          end
        end
      end
      if Type == "NormalDecreaseMvmt1" then
        DecreaseStat(hit.Parent, "Movement", 0.1, 200)
      end
      if Type == "Knockdown" then
        hum = hit.Parent.Humanoid
        hum.PlatformStand = true
        coroutine.resume(coroutine.create(function(HHumanoid)
    swait(1)
    HHumanoid.PlatformStand = false
  end
), hum)
        local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
        local bodvol = Instance.new("BodyVelocity")
        bodvol.velocity = angle * knockback
        bodvol.P = 5000
        bodvol.maxForce = Vector3.new(8000, 8000, 8000)
        bodvol.Parent = hit
        rl = Instance.new("BodyAngularVelocity")
        rl.P = 3000
        rl.maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000
        rl.angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10))
        rl.Parent = hit
        game:GetService("Debris"):AddItem(bodvol, 0.5)
        game:GetService("Debris"):AddItem(rl, 0.5)
      else
        do
          if Type == "Knockdown2" then
            hum = hit.Parent.Humanoid
            local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
            local bodvol = Instance.new("BodyVelocity")
            bodvol.velocity = angle * knockback
            bodvol.P = 5000
            bodvol.maxForce = Vector3.new(8000, 8000, 8000)
            bodvol.Parent = hit
            game:GetService("Debris"):AddItem(bodvol, 0.5)
          else
            do
              if Type == "Normal" or Type == "NormalDecreaseMvmt1" then
                vp = Instance.new("BodyVelocity")
                vp.P = 500
                vp.maxForce = Vector3.new(math.huge, 0, math.huge)
                if KnockbackType == 1 then
                  vp.velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
                else
                  if KnockbackType == 2 then
                    vp.velocity = Property.CFrame.lookVector * knockback
                  end
                end
                game:GetService("Debris"):AddItem(vp, 0.5)
                if knockback > 0 then
                  vp.Parent = hit.Parent.Torso
                end
              end
              debounce = Instance.new("BoolValue")
              debounce.Name = "DebounceHit"
              debounce.Parent = hit.Parent
              debounce.Value = true
              game:GetService("Debris"):AddItem(debounce, Delay)
              c = Instance.new("ObjectValue")
              c.Name = "creator"
              c.Value = Player
              c.Parent = h
              game:GetService("Debris"):AddItem(c, 0.5)
              CRIT = false
            end
          end
        end
      end
    end
  end
end
showDamage = function(Char, Dealt, Type)
  m = Instance.new("Model")
  m.Name = "Effect"
  c = Instance.new("Part")
  c.Transparency = 1
  c.Name = "Head"
  c.TopSurface = 0
  c.BottomSurface = 0
  c.formFactor = "Plate"
  c.Size = Vector3.new(1, 0.4, 1)
  local b = Instance.new("BillboardGui", c)
  b.Size = UDim2.new(5, 0, 5, 0)
  b.AlwaysOnTop = true
  damgui = gui("TextLabel", b, tostring(Dealt), 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
  if Type == "Damage" then
    damgui.Font = "SourceSans"
    if Dealt == "Block" then
      damgui.TextColor3 = BrickColor.new("Bright blue").Color
    else
      if Dealt < 3 then
        damgui.TextColor3 = BrickColor.new("White").Color
      else
        if Dealt >= 3 and Dealt < 20 then
          damgui.TextColor3 = BrickColor.new("Bright yellow").Color
        else
          damgui.TextColor3 = BrickColor.new("Really red").Color
          damgui.Font = "SourceSansBold"
        end
      end
    end
  else
    if Type == "Debuff" then
      damgui.TextColor3 = BrickColor.new("White").Color
    else
      if Type == "Interrupt" then
        damgui.TextColor3 = BrickColor.new("New Yeller").Color
      end
    end
  end
  damgui.TextScaled = true
  ms = Instance.new("CylinderMesh")
  ms.Scale = Vector3.new(0.8, 0.8, 0.8)
  ms.Parent = c
  c.Reflectance = 0
  Instance.new("BodyGyro").Parent = c
  c.Parent = m
  if Char:findFirstChild("Head") ~= nil then
    c.CFrame = cf(Char.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
  else
    if Char.Parent:findFirstChild("Head") ~= nil then
      c.CFrame = cf(Char.Parent.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
    end
  end
  f = Instance.new("BodyPosition")
  f.P = 2000
  f.D = 100
  f.maxForce = Vector3.new(math.huge, math.huge, math.huge)
  if Type == "Damage" then
    f.position = c.Position + Vector3.new(0, 3, 0)
  else
    if Type == "Debuff" or Type == "Interrupt" then
      f.position = c.Position + Vector3.new(0, 5, 0)
    end
  end
  f.Parent = c
  game:GetService("Debris"):AddItem(m, 5)
  table.insert(Effects, {m, "showDamage", damgui, f, 10, 1, 15, 50, 100})
  c.CanCollide = false
  m.Parent = workspace
  c.CanCollide = false
end
combo = 0
ob1d = function(mouse)
  if MMouse.Target ~= nil and MMouse.Target.Parent:findFirstChild("Humanoid") ~= nil and game.Players:GetPlayerFromCharacter(MMouse.Target.Parent) ~= nil and Player.Neutral == false and game.Players:GetPlayerFromCharacter(MMouse.Target.Parent).TeamColor == Player.TeamColor then
    if givingrailgun == true then
      RailgunTarget = MMouse.Target.Parent.HumanoidRootPart
      givingarmor = false
    end
    if givingplasma == true then
      CannonTarget = MMouse.Target.Parent.HumanoidRootPart
      givingarmor = false
    end
    if givingblades == true then
      BladesTarget = MMouse.Target.Parent.HumanoidRootPart
      givingarmor = false
    end
  end
  if attack == true or equipped == false then
    return 
  end
  hold = true
  if BladesTarget ~= nil then
    coroutine.resume(coroutine.create(function()
    if combo == 0 then
      bladesattackone()
    else
      if combo == 1 then
        bladesattackthree()
      else
        if combo == 2 then
          bladesattacktwo()
        else
          if combo == 3 then
            bladesattackfour()
          end
        end
      end
    end
  end))
  end
  if combo == 0 then
    combo = 1
    attackone()
  else
    if combo == 1 then
      combo = 2
      attacktwo()
    else
      if combo == 2 then
        combo = 3
        attackthree()
      else
        if combo == 3 then
          combo = 0
          attackfour()
        end
      end
    end
  end
  if RailgunTarget ~= nil then
    ShootRailGun()
  end
  if CannonTarget ~= nil then
    ShootCannon()
  end
  coroutine.resume(coroutine.create(function()
    for i = 1, 50 do
      if attack == false then
        fwait()
      end
    end
    if attack == false then
      combo = 0
    end
  end))
end
ob1u = function(mouse)
  hold = false
end
buttonhold = false
fenbarmove1.MouseButton1Click:connect(do1)
fenbarmove2.MouseButton1Click:connect(do2)
fenbarmove3.MouseButton1Click:connect(do3)
fenbarmove4.MouseButton1Click:connect(do4)
eul = 0
equipped = false
key = function(key)
  if key == "z" and givingarmor == true then
    do1()
  end
  if key == "x" and givingarmor == true then
    do2()
  end
  if key == "c" and givingarmor == true then
    do3()
  end
  if attack == true then
    return 
  end
  if key == "f" then
    pressedf = true
    fnumb = 0
    attack = true
    if equipped == false then
      equipped = true
      RSH = ch.Torso["Right Shoulder"]
      LSH = ch.Torso["Left Shoulder"]
      RSH.Parent = nil
      LSH.Parent = nil
      RW.Name = "Right Shoulder"
      RW.Part0 = ch.Torso
      RW.C0 = cf(1.5, 0.5, 0)
      RW.C1 = cf(0, 0.5, 0)
      RW.Part1 = ch["Right Arm"]
      RW.Parent = ch.Torso
      LW.Name = "Left Shoulder"
      LW.Part0 = ch.Torso
      LW.C0 = cf(-1.5, 0.5, 0)
      LW.C1 = cf(0, 0.5, 0)
      LW.Part1 = ch["Left Arm"]
      LW.Parent = ch.Torso
      Animate.Parent = nil
      animTrack:Play()
      equipanim()
    else
      equipped = false
      hideanim()
      LH.C1 = LHC1
      RH.C1 = RHC1
      animTrack:Stop()
      Animate.Parent = Character
      fwait(0)
      RW.Parent = nil
      LW.Parent = nil
      RSH.Parent = player.Character.Torso
      LSH.Parent = player.Character.Torso
    end
    attack = false
  end
  if equipped == false then
    return 
  end
  if key == "e" then
    StatConvert()
  end
  if key == "z" then
    do1()
  end
  if key == "x" then
    do2()
  end
  if key == "c" then
    do3()
  end
  if key == "v" then
    do4()
  end
end
key2 = function(key)
end
s = function(mouse)
  mouse.Button1Down:connect(function()
    ob1d(mouse)
  end)
  mouse.Button1Up:connect(function()
    ob1u(mouse)
  end)
  mouse.KeyDown:connect(key)
  mouse.KeyUp:connect(key2)
  player = Player
  ch = Character
end
ds = function(mouse)
end
Bin.Selected:connect(s)
Bin.Deselected:connect(ds)
print("Mechanic loaded.")
local mananum = 0
local blocknum2 = 0
local donum = 0
local stunnum = 0
local staggeranim = false
local stunanim = false
local Point, LastPoint = nil, nil
local walk = 0
local walkforw = true
while 1 do
  fwait()
  if Humanoid.Health <= 0 then
    attack = true
    resumeControl()
    modelzorz.Parent = workspace
    game:GetService("Debris"):AddItem(modelzorz, 30)
    for i = 1, #Weapon do
      Weapon[i].Parent = modelzorz
      Weapon[i].CanCollide = true
    end
    for i = 1, #Welds do
      if Welds[i].Part0.Parent == Character or Welds[i].Part1.Parent == Character then
        Welds[i].Parent = nil
      else
        Welds[i].Parent = prt1
      end
    end
  end
  do
    if fnumb < 21 then
      fnumb = fnumb + 1
      if pressedf == false then
        fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency - 0.025
        tellbar.TextTransparency = tellbar.TextTransparency - 0.05
        tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency - 0.05
      else
        if fnumb == 20 then
          fenframe5.Parent = nil
          print("daigui")
        end
        fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency + 0.025
        tellbar.TextTransparency = tellbar.TextTransparency + 0.05
        tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency + 0.05
      end
    end
    if hbwld.Parent == nil then
      hitbox2.Name = "Hitbox"
    else
      hitbox2.Name = "Hitbox2"
    end
    hitbox2.Parent = hitbox.Parent
    hitbox2.Size = hitbox.Size
    hitbox2.CFrame = hitboxCF
    hboxpos.position = hitbox2.Position + vt(math.random(-100, 100) / 100, math.random(-100, 100) / 100, math.random(-100, 100) / 100)
    if cooldownmax <= cooldowns[1] and RailgunTarget ~= nil then
      MagicSpecial(BrickColor.new(NewCol), rprt1.CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 0.5, 0.5, 0.5, 0.05)
      for i = 1, 5 do
        ElecEffect(cf(rprt1.Position), 3, 3, 3)
      end
      RailgunTarget = nil
      model1.Parent = nil
    end
    if cooldownmax <= cooldowns[2] and CannonTarget ~= nil then
      print("daicannon")
      print(cooldowns[2])
      print(CannonTarget)
      MagicSpecial(BrickColor.new(NewCol), pprt1.CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 0.5, 0.5, 0.5, 0.05)
      for i = 1, 5 do
        ElecEffect(cf(pprt1.Position), 3, 3, 3)
      end
      CannonTarget = nil
      model2.Parent = nil
    end
    if cooldownmax <= cooldowns[3] and BladesTarget ~= nil then
      print("daiblades")
      print(cooldowns[3])
      print(BladesTarget)
      MagicSpecial(BrickColor.new(NewCol), bprt1.CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 0.3, 0.3, 0.3, 0.05)
      MagicSpecial(BrickColor.new(NewCol), bprt7.CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 0.3, 0.3, 0.3, 0.05)
      MagicSpecial(BrickColor.new(NewCol), bprt13.CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 0.3, 0.3, 0.3, 0.05)
      for i = 1, 5 do
        ElecEffect(cf(bref.Position), 3, 3, 3)
      end
      BladesTarget = nil
      model3.Parent = nil
    end
    if MMouse ~= nil then
      if model1.Parent ~= nil then
        local mpos = rprt1.CFrame * euler(0, 0, 0)
        local cff = CFrame.new(mpos.p, MMouse.Hit.p) * CFrame.Angles(math.pi / 2, 0, 0)
        local x, y, z = rprt1.CFrame:toObjectSpace(cff):toEulerAnglesXYZ()
        rwld1.Part1 = RailgunTarget
        rwld1.C0 = euler(0, 0, 0) * cf(3, -1, -0.2)
        rwld2.Part0 = rprt1
        rwld2.Part1 = rprt2
        rwld2.C0 = clerp(rwld2.C0, CFrame.Angles(x, y, z) * euler(-1.57, 0, 0), 0.3)
      end
      do
        if model2.Parent ~= nil then
          local mpos = pprt1.CFrame * euler(0, 0, 0)
          local cff = CFrame.new(mpos.p, MMouse.Hit.p) * CFrame.Angles(math.pi / 2, 0, 0)
          local x, y, z = pprt1.CFrame:toObjectSpace(cff):toEulerAnglesXYZ()
          pwld1.Part1 = CannonTarget
          pwld1.C0 = euler(0, 0, 0) * cf(-3, -1, -0.2)
          pwld2.Part0 = pprt1
          pwld2.Part1 = pprt2
          pwld2.C0 = clerp(pwld2.C0, CFrame.Angles(x, y, z) * euler(-1.57, 0, 0), 0.3)
        end
        do
          pwld1.C0 = clerp(pwld1.C0, euler(-0.2, 0, 0) * cf(-3, -1, -0.2), 0.5)
          pwld2.C0 = clerp(pwld2.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.5)
          rwld1.C0 = clerp(rwld1.C0, euler(-0.2, 0, 0) * cf(3, -1, -0.2), 0.5)
          rwld2.C0 = clerp(rwld2.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.5)
          if Stagger.Value == true and staggeranim == false then
            coroutine.resume(coroutine.create(function()
  staggeranim = true
  while attack == true do
    fwait()
  end
  StaggerAnim()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end))
          end
          if StaggerHit.Value == true and staggeranim == false then
            coroutine.resume(coroutine.create(function()
  staggeranim = true
  while attack == true do
    fwait()
  end
  StaggerHitt()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end))
          end
          if Mvmt.Value < 0 or Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true or Rooted.Value == true then
            Humanoid.WalkSpeed = 0
          else
            Humanoid.WalkSpeed = 16 * Mvmt.Value
          end
          if StunT.Value <= Stun.Value and stunanim == false then
            coroutine.resume(coroutine.create(function()
  stunanim = true
  while attack == true do
    fwait()
  end
  StunAnim()
  Stun.Value = 0
  stunanim = false
end))
          end
          local stunnum2 = 30
          if stunnum2 <= stunnum then
            if 0 < Stun.Value then
              Stun.Value = Stun.Value - 1
            end
            stunnum = 0
          end
          stunnum = stunnum + 1
          if 0.5 <= donum then
            handidle = true
          else
            if donum <= 0 then
              handidle = false
            end
          end
          if handidle == false then
            donum = donum + 0.006
          else
            donum = donum - 0.006
          end
          local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
          local velderp = RootPart.Velocity.y
          hitfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
          if equipped == true then
            if attack == false then
              idle = idle + 1
            else
              idle = 0
            end
            if (500 <= idle and attack ~= false) or Anim == "Walk" then
              if walkforw == true then
                RH.C1 = clerp(RH.C1, RHC1 * cf(0.2, -0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
                LH.C1 = clerp(LH.C1, LHC1 * cf(0.1, 0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
              else
                RH.C1 = clerp(RH.C1, RHC1 * cf(-0.1, 0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
                LH.C1 = clerp(LH.C1, LHC1 * cf(-0.2, -0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
              end
            else
              RH.C1 = clerp(RH.C1, RHC1, 0.2)
              LH.C1 = clerp(LH.C1, LHC1, 0.2)
            end
            if tribladesattack == false then
              bwld1.C0 = clerp(bwld1.C0, euler(0, 0, 0) * cf(2, -0.6, -2), 0.4)
              bwld7.C0 = clerp(bwld7.C0, euler(0, 0, 0) * cf(0, -0.6, -2), 0.4)
              bwld13.C0 = clerp(bwld13.C0, euler(0, 0, 0) * cf(-2, -0.6, -2), 0.4)
              bwld2.C0 = clerp(bwld2.C0, euler(3.14, -2, 1.17) * cf(0, 0, 0), 0.4)
              bwld8.C0 = clerp(bwld8.C0, euler(3.14, -2, 1.57) * cf(0, 0, 0), 0.4)
              bwld14.C0 = clerp(bwld14.C0, euler(3.14, -2, 1.97) * cf(0, 0, 0), 0.4)
              brefwld.C0 = clerp(brefwld.C0, euler(0, 0, 0) * cf(0, -2, 0), 0.4)
            end
            if 1 < RootPart.Velocity.y and hitfloor == nil then
              Anim = "Jump"
              if attack == false then
                Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0), 0.2)
                Neck.C1 = clerp(Neck.C1, necko2 * euler(0, 0, 0), 0.2)
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.1, 0, 0), 0.2)
                RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.5, 0, 0.5), 0.2)
                RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(2, 0, 1.2), 0.2)
                LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                RH.C0 = clerp(RH.C0, cf(1, -1, -0.3) * euler(-0.5, 1.57, 0) * euler(-0.2, 0, 0), 0.2)
                LH.C0 = clerp(LH.C0, cf(-1, -1, -0.3) * euler(-0.5, -1.57, 0) * euler(-0.2, 0, 0), 0.2)
              end
            else
              if RootPart.Velocity.y < -1 and hitfloor == nil then
                Anim = "Fall"
                if attack == false then
                  Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, 0), 0.2)
                  Neck.C1 = clerp(Neck.C1, necko2 * euler(0, 0, 0), 0.2)
                  RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.1, 0, 0), 0.2)
                  RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.3, 0, 0.2), 0.2)
                  RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                  LW.C0 = clerp(LW.C0, cf(-1.3, 0.5, -0.2) * euler(-0.3, 0, -0.2), 0.2)
                  LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                  RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0.4, 1.57, 0), 0.2)
                  LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(-0.2, -1.57, 0), 0.2)
                end
              else
                if torvel < 1 and hitfloor ~= nil then
                  Anim = "Idle"
                  if attack == false then
                    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.15)
                    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.5), 0.15)
                    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.3, 0, 0.2) * euler(0, -1.57, 0), 0.15)
                    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.15)
                    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -0.4 + (donum) / 3), 0.15)
                    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.15)
                    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, -0.1), 0.2)
                    LH.C0 = clerp(LH.C0, cf(-0.8, -1, 0.2) * euler(0, -1.57, 0) * euler(0, 0.5, 0.05), 0.2)
                  end
                else
                  if 2 < torvel and torvel < 30 and hitfloor ~= nil then
                    Anim = "Walk"
                    walk = walk + 1
                    if 15 - 5 * Mvmt.Value <= walk then
                      walk = 0
                      if walkforw == true then
                        walkforw = false
                      else
                        if walkforw == false then
                          walkforw = true
                        end
                      end
                    end
                    if attack == false then
                      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.3)
                      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
                      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.2), 0.3)
                      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
                      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.2), 0.3)
                      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
                      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0), 0.2)
                      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0), 0.2)
                    end
                  else
                    if 30 <= torvel and hitfloor ~= nil then
                      Anim = "Run"
                      if attack == false then
                        Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, -0.2), 0.4)
                        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.5) * euler(0.8, 0, 0.2), 0.4)
                        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 0.2), 0.4)
                        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
                        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4), 0.4)
                        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
                        RH.C0 = clerp(RH.C0, RHC0 * cf(1, 1, 0.2) * euler(0, -0.2, -0.5), 0.4)
                        LH.C0 = clerp(LH.C0, LHC0 * cf(-0.5, 1, 0) * euler(0.2, 0, -0.5), 0.4)
                      end
                    end
                  end
                end
              end
            end
          end
          if 0 < #Effects then
            for e = 1, #Effects do
              if Effects[e] ~= nil then
                local Thing = Effects[e]
                if Thing ~= nil then
                  local Part = Thing[1]
                  local Mode = Thing[2]
                  local Delay = Thing[3]
                  local IncX = Thing[4]
                  local IncY = Thing[5]
                  local IncZ = Thing[6]
                  if Thing[2] == "CylinderClang" then
                    if Thing[3] <= 1 then
                      Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, 2.5 * Thing[5], 0) * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
                      Thing[7] = Thing[1].CFrame
                      effect("New Yeller", 0, Thing[8], Thing[7])
                      Thing[8] = Thing[7]
                      Thing[3] = Thing[3] + Thing[4]
                    else
                      Part.Parent = nil
                      table.remove(Effects, e)
                    end
                  end
                  if Thing[2] == "showDamage" then
                    if Thing[6] < Thing[5] then
                      Thing[6] = Thing[6] + 1
                    else
                      if Thing[6] < Thing[7] then
                        Thing[4].position = Thing[4].position + vt(0, -0.2, 0)
                        Thing[6] = Thing[6] + 1
                      else
                        if Thing[6] < Thing[8] then
                          Thing[6] = Thing[6] + 1
                        else
                          if Thing[6] < Thing[9] then
                            Thing[6] = Thing[6] + 1
                            Thing[4].position = Thing[4].position + vt(0, 0.2, 0)
                            Thing[3].TextStrokeTransparency = Thing[3].TextStrokeTransparency + 0.1
                            Thing[3].TextTransparency = Thing[3].TextTransparency + 0.1
                          else
                            Thing[1].Parent = nil
                            table.remove(Effects, e)
                          end
                        end
                      end
                    end
                  end
                  if Thing[2] == "Shoot" then
                    if CannonTarget == nil then
                      table.remove(Effects, e)
                    else
                      local MainPos = Thing[1]
                      local MainPos2 = Thing[4]
                      local MouseLook = cf((MainPos + MainPos2) / 2, MainPos2)
                      local hit, pos = rayCast(MainPos, MouseLook.lookVector, 10, CannonTarget.Parent)
                      local mag = (Thing[1] - pos).magnitude
                      MagicCylinder2(Color2, CFrame.new((Thing[1] + pos) / 2, pos) * angles(1.57, 0, 0), 3, mag * 5, 3, 1.5, 0, 1.5, 0.1)
                      Thing[1] = Thing[1] + MouseLook.lookVector * 10
                      Thing[3] = Thing[3] - 1
                      if hit ~= nil then
                        Thing[3] = 0
                        Damagefunc(hit, 8, 10, 0, "Normal", RootPart, 0, 2, math.random(1, 5), false, false, true, "Damage", 0.1, 200)
                        ref = part(3, workspace, 0, 1, Color2, "Reference", vt())
                        ref.Anchored = true
                        ref.CFrame = cf(pos)
                        so("169445602", ref, 1, 0.8)
                        so("153092334", ref, 1, 0.8)
                        MagicBlock(Color2, cf(pos), 20, 20, 20, 5, 5, 5, 0.05)
                        game:GetService("Debris"):AddItem(ref, 1)
                        MagniDamage(ref, 10, 6, 9, 0, "Normal", ref, 0, 1, (math.random(1, 5)), nil, nil, true, "Damage", 0.05, 200)
                      end
                      if Thing[3] <= 0 then
                        table.remove(Effects, e)
                      end
                    end
                  end
                  do
                    do
                      if Thing[2] ~= "DecreaseStat" and Thing[2] ~= "showDamage" and Thing[2] ~= "Shoot" then
                        if Thing[1].Transparency <= 1 then
                          if Thing[2] == "Block1" then
                            Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                            Mesh = Thing[7]
                            Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                            Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                          else
                            if Thing[2] == "Ice" then
                              if Thing[6] <= Thing[5] then
                                Thing[6] = Thing[6] + 0.3
                                Thing[1].CFrame = Thing[1].CFrame * cf(0, 1, 0)
                              else
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                              end
                            else
                              if Thing[2] == "Shatter" then
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                Thing[4] = Thing[4] * cf(0, Thing[7], 0)
                                Thing[1].CFrame = Thing[4] * euler(Thing[6], 0, 0)
                                Thing[6] = Thing[6] + Thing[5]
                              else
                                if Thing[2] == "Block2" then
                                  Thing[1].CFrame = Thing[1].CFrame
                                  Mesh = Thing[7]
                                  Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                  Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                else
                                  if Thing[2] == "Cylinder" then
                                    Mesh = Thing[7]
                                    Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                    Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                  else
                                    if Thing[2] == "Blood" then
                                      Mesh = Thing[7]
                                      Thing[1].CFrame = Thing[1].CFrame * cf(0, 0.5, 0)
                                      Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                      Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                    else
                                      if Thing[2] == "Elec" then
                                        Mesh = Thing[10]
                                        Mesh.Scale = Mesh.Scale + vt(Thing[7], Thing[8], Thing[9])
                                        Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                      else
                                        if Thing[2] == "Disappear" then
                                          Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        else
                          Part.Parent = nil
                          table.remove(Effects, e)
                        end
                      end
                      -- DECOMPILER ERROR at PC9980: LeaveBlock: unexpected jumping out DO_STMT

                      -- DECOMPILER ERROR at PC9980: LeaveBlock: unexpected jumping out IF_THEN_STMT

                      -- DECOMPILER ERROR at PC9980: LeaveBlock: unexpected jumping out IF_STMT

                      -- DECOMPILER ERROR at PC9980: LeaveBlock: unexpected jumping out IF_THEN_STMT

                      -- DECOMPILER ERROR at PC9980: LeaveBlock: unexpected jumping out IF_STMT

                    end
                  end
                end
              end
            end
          end
          fenbarmana2:TweenSize((UDim2.new(0.4, 0, -4 * mana.Value / 100, 0)), nil, 1, 0.4, true)
          fenbarmana4.Text = "Mana(" .. mana.Value .. ")"
          fenbarhp2.BackgroundColor3 = Color3.new(Humanoid.Health / Humanoid.MaxHealth, 0, 0)
          fenbarhp2:TweenSize((UDim2.new(Humanoid.Health / Humanoid.MaxHealth, 0, 1, 0)), nil, 1, 0.4, true)
          fenbarhp3.Text = "(" .. math.floor(Humanoid.Health) .. ")"
          fenbarmove1b:TweenSize((UDim2.new(1 * cooldowns[1] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
          fenbarmove2b:TweenSize((UDim2.new(1 * cooldowns[2] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
          fenbarmove3b:TweenSize((UDim2.new(1 * cooldowns[3] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
          fenbarmove4b:TweenSize((UDim2.new(1 * cooldowns[4] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
          for _,c in pairs(Decrease:children()) do
            if (c:findFirstChild("Duration")) ~= nil then
              c.Duration.Value = c.Duration.Value - 1
              if c.Duration.Value <= 0 then
                c.Parent = nil
              end
            end
            if c.Name == "DecreaseAtk" then
              decreaseatk = decreaseatk + c.Value
            else
              if c.Name == "DecreaseDef" then
                decreasedef = decreasedef + c.Value
              else
                if c.Name == "DecreaseMvmt" then
                  decreasemvmt = decreasemvmt + c.Value
                end
              end
            end
          end
          Atk.Value = 1 - (decreaseatk)
          if Atk.Value <= 0 then
            Atk.Value = 0
          end
          Def.Value = 1 - (decreasedef)
          if Def.Value <= 0 then
            Def.Value = 0.01
          end
          Mvmt.Value = 1 - (decreasemvmt)
          if Mvmt.Value <= 0 then
            Mvmt.Value = 0
          end
          decreaseatk = 0
          decreasedef = 0
          decreasemvmt = 0
          AtkVal = Atk.Value * 100
          AtkVal = math.floor(AtkVal)
          AtkVal = AtkVal / 100
          fenbardamage.Text = "Damage\n(" .. AtkVal .. ")"
          DefVal = Def.Value * 100
          DefVal = math.floor(DefVal)
          DefVal = DefVal / 100
          fenbardef.Text = "Defense\n(" .. DefVal .. ")"
          MvmtVal = Mvmt.Value * 100
          MvmtVal = math.floor(MvmtVal)
          MvmtVal = MvmtVal / 100
          if Rooted.Value == true then
            MvmtVal = 0
          end
          fenbarmove.Text = "Walkspeed\n(" .. MvmtVal .. ")"
          if StunT.Value <= Stun.Value then
            fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4, 0)), nil, 1, 0.4, true)
          else
            fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4 * Stun.Value / StunT.Value, 0)), nil, 1, 0.4, true)
          end
          fenbarstun3.Text = "Stun(" .. Stun.Value .. ")"
          if 100 <= mana.Value then
            mana.Value = 100
          else
            if mananum <= 11 then
              mananum = mananum + 1
            else
              if 8 <= mananum then
                mananum = 0
                mana.Value = mana.Value + 1
              end
            end
          end
          for i = 1, #cooldowns do
            if cooldownmax <= cooldowns[i] then
              cooldowns[i] = cooldownmax
            else
              cooldowns[i] = cooldowns[i] + cooldownsadd[i]
            end
          end
          -- DECOMPILER ERROR at PC10344: LeaveBlock: unexpected jumping out DO_STMT

          -- DECOMPILER ERROR at PC10344: LeaveBlock: unexpected jumping out DO_STMT

          -- DECOMPILER ERROR at PC10344: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC10344: LeaveBlock: unexpected jumping out IF_STMT

          -- DECOMPILER ERROR at PC10344: LeaveBlock: unexpected jumping out DO_STMT

        end
      end
    end
  end
end
]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="HopperBin" referent="RBX17B4B58AF1F84179A3B03EC26BD17473">
			<Properties>
				<bool name="Active">true</bool>
				<token name="BinType">0</token>
				<string name="Name">Dynamence</string>
				<Content name="TextureId"><null></null></Content>
			</Properties>
			<Item class="LocalScript" referent="RBXE8AA822067A54E33831F85E5DF459800">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Dynamence</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[Player = game:GetService("Players").LocalPlayer
Character = Player.Character
PlayerGui = Player.PlayerGui
Backpack = Player.Backpack
Torso = Character.Torso
Head = Character.Head
Humanoid = Character.Humanoid
Face = Head.face
LeftArm = Character["Left Arm"]
LeftLeg = Character["Left Leg"]
RightArm = Character["Right Arm"]
RightLeg = Character["Right Leg"]
LS = Torso["Left Shoulder"]
LH = Torso["Left Hip"]
RS = Torso["Right Shoulder"]
RH = Torso["Right Hip"]
Neck = Torso.Neck
it = Instance.new
vt = Vector3.new
cf = CFrame.new
euler = CFrame.fromEulerAnglesXYZ
angles = CFrame.Angles
necko = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
necko2 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
LHC0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
LHC1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
RHC0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RHC1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RootPart = Character.HumanoidRootPart
RootJoint = RootPart.RootJoint
RootCF = euler(-1.57, 0, 3.14)
attack = false
attackdebounce = false
MMouse = nil
combo = 0
local hitfloor, posfloor = nil, nil
local idle = 0
local Anim = "Idle"
local Effects = {}
local decreaseatk = 0
local decreasedef = 0
local decreasemvmt = 0
local equipped = false
local manainc = 9
local triangparent = workspace
local dynamomove = true
local Mode = "Classic"
local overload = 0
local defending = false
local choosemode = false
local move1 = "(Z)\n[MORPH SHIELD]\nVital Stab"
local move2 = "(X)\n[DYNAMIC BLADE]\nKinetic Strike"
local move3 = "(C)\n[ENERGY REACTOR]\nLaser Barrage"
local move4 = "(V)\n"
local cooldowns = {}
local cooldown1 = 0
table.insert(cooldowns, cooldown1)
local cooldown2 = 0
table.insert(cooldowns, cooldown2)
local cooldown3 = 0
table.insert(cooldowns, cooldown3)
local cooldown4 = 0
table.insert(cooldowns, cooldown4)
local cooldownsadd = {}
local cooldownadd1 = 0.48
table.insert(cooldownsadd, cooldownadd1)
local cooldownadd2 = 0.34
table.insert(cooldownsadd, cooldownadd2)
local cooldownadd3 = 0.45
table.insert(cooldownsadd, cooldownadd3)
local cooldownadd4 = 0.1
table.insert(cooldownsadd, cooldownadd4)
local cooldownmax = 100
player = nil
RSH,LSH = nil,nil
RW,LW = Instance.new("Motor"),Instance.new("Motor")
RW.Name = "Right Shoulder"
LW.Name = "Left Shoulder"
LH = Torso["Left Hip"]
RH = Torso["Right Hip"]
TorsoColor = Torso.BrickColor
TorsoRed = TorsoColor.Color.r
TorsoGreen = TorsoColor.Color.g
TorsoBlue = TorsoColor.Color.b
NewCol = BrickColor.new("Institutional white").Color
NewCol2 = BrickColor.new("Institutional white").Color
NewCol3 = BrickColor.new("Grey").Color
if Player:findFirstChild("Color1") ~= nil then
  NewCol = Player.Color1.Value
end
if Player:findFirstChild("Color2") ~= nil then
  NewCol2 = Player.Color2.Value
end
print(BrickColor.new(NewCol))
local mdec = Instance.new("NumberValue", Decrease)
mdec.Name = "DecreaseDef"
mdec.Value = 0.4
local mdec2 = Instance.new("NumberValue", Decrease)
mdec2.Name = "DecreaseMvmt"
mdec2.Value = 0.1
local Animate = Humanoid.Animator
local canjump = true

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

frame = 1 / 40
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
    tf = tf + s
    if tf >= frame then
        if allowframeloss then
            script.Heartbeat:Fire()
            lastframe = tick()
        else
            for i = 1, math.floor(tf / frame) do
                script.Heartbeat:Fire()
            end
            lastframe = tick()
        end
        if tossremainder then
            tf = 0
        else
            tf = tf - frame * math.floor(tf / frame)
        end
    end
end)

function swait(num)
    if num == 0 or num == nil then
        ArtificialHB.Event:wait()
    else
        for i = 0, num do
            ArtificialHB.Event:wait()
        end
    end
end

createpassgui = function(parent)
  print("makegui111")
  local g = Instance.new("ScreenGui", parent)
  local f = Instance.new("Frame", g)
  f.Position = UDim2.new(0.3, 0, 0.25, 0)
  f.Size = UDim2.new(0.4, 0, 0.4, 0)
  f.Style = "DropShadow"
  local t = Instance.new("TextBox", f)
  t.BackgroundColor3 = Color3.new(0, 0, 0)
  t.BackgroundTransparency = 0.5
  t.BorderSizePixel = 0
  t.Position = UDim2.new(0.15, 0, 0.2, 0)
  t.Size = UDim2.new(0.7, 0, 0.2, 0)
  t.Font = "SourceSansLight"
  t.Text = "Enter Access Code."
  t.TextScaled = true
  t.TextColor3 = Color3.new(1, 1, 1)
  t.TextStrokeTransparency = 0
  local t2 = Instance.new("TextButton", f)
  t2.BackgroundColor3 = Color3.new(0, 0, 0)
  t2.BackgroundTransparency = 0.5
  t2.BorderSizePixel = 0
  t2.Position = UDim2.new(0.3, 0, 0.5, 0)
  t2.Size = UDim2.new(0.4, 0, 0.15, 0)
  t2.TextScaled = true
  t2.Font = "SourceSansLight"
  t2.Text = "Submit"
  t2.TextColor3 = Color3.new(1, 1, 1)
  t2.TextStrokeTransparency = 0
  print("done1")
  return t2
end

if Character:findFirstChild("Permanence", true) ~= nil then
  Character:findFirstChild("Permanence", true).Parent = nil
end
if Character:findFirstChild("Dynamo", true) ~= nil then
  Character:findFirstChild("Dynamo", true).Parent = nil
end
if Player.PlayerGui:findFirstChild("WeaponGUI", true) ~= nil then
  Player.PlayerGui:findFirstChild("WeaponGUI", true).Parent = nil
end
if Character:findFirstChild("Stats", true) ~= nil then
  Character:findFirstChild("Stats", true).Parent = nil
end
local Stats = Instance.new("BoolValue")
Stats.Name = "Stats"
Stats.Parent = Character
local Atk = Instance.new("NumberValue")
Atk.Name = "Damage"
Atk.Parent = Stats
Atk.Value = 1
local Def = Instance.new("NumberValue")
Def.Name = "Defense"
Def.Parent = Stats
Def.Value = 1
local Mvmt = Instance.new("NumberValue")
Mvmt.Name = "Movement"
Mvmt.Parent = Stats
Mvmt.Value = 1
local Block = Instance.new("BoolValue")
Block.Name = "Block"
Block.Parent = Stats
Block.Value = false
local Stun = Instance.new("NumberValue")
Stun.Name = "Stun"
Stun.Parent = Stats
Stun.Value = 0
local StunT = Instance.new("NumberValue")
StunT.Name = "StunThreshold"
StunT.Parent = Stats
StunT.Value = 100
local Rooted = Instance.new("BoolValue")
Rooted.Name = "Rooted"
Rooted.Parent = Stats
Rooted.Value = false
local Stunned = Instance.new("BoolValue")
Stunned.Name = "Stunned"
Stunned.Parent = Stats
Stunned.Value = false
local Stagger = Instance.new("BoolValue")
Stagger.Name = "Stagger"
Stagger.Parent = Stats
Stagger.Value = false
local StaggerHit = Instance.new("BoolValue")
StaggerHit.Name = "StaggerHit"
StaggerHit.Parent = Stats
StaggerHit.Value = false
local RecentEnemy = Instance.new("ObjectValue")
RecentEnemy.Name = "RecentEnemy"
RecentEnemy.Parent = Stats
RecentEnemy.Value = nil
local Decrease = Instance.new("BoolValue")
Decrease.Name = "Decrease"
Decrease.Parent = Stats
Decrease.Value = false
local mana = Instance.new("NumberValue")
mana.Name = "Mana"
mana.Parent = Stats
mana.Value = 0
local passive1 = Instance.new("NumberValue", Decrease)
passive1.Name = "DecreaseAtk"
passive1.Value = 0
local passive2 = Instance.new("NumberValue", Decrease)
passive2.Name = "DecreaseDef"
passive2.Value = 0
local passive3 = Instance.new("NumberValue", Decrease)
passive3.Name = "DecreaseMvmt"
passive3.Value = 0
passive1.Value = 0.1
passive2.Value = -0.05
passive3.Value = -0.1
local passive4 = Instance.new("NumberValue", nil)
passive4.Name = "DecreaseDef"
passive4.Value = -0.4
local passive5 = Instance.new("NumberValue", nil)
passive5.Name = "DecreaseMvmt"
passive5.Value = 0.6
NoOutline = function(Part)
  Part.TopSurface = 10
end

part = function(formfactor, parent, reflectance, transparency, brickcolor, name, size)
  local fp = it("Part")
  fp.formFactor = formfactor
  fp.Parent = parent
  fp.Reflectance = reflectance
  fp.Transparency = transparency
  fp.CanCollide = false
  fp.Locked = true
  fp.BrickColor = brickcolor
  fp.Name = name
  fp.Size = size
  fp.Position = Torso.Position
  NoOutline(fp)
  fp.Material = "SmoothPlastic"
  fp:BreakJoints()
  return fp
end

mesh = function(Mesh, part, meshtype, meshid, offset, scale)
  local mesh = it(Mesh)
  mesh.Parent = part
  if Mesh == "SpecialMesh" then
    mesh.MeshType = meshtype
    if meshid ~= "nil" then
      mesh.MeshId = "http://www.roblox.com/asset/?id=" .. meshid
    end
  end
  mesh.Offset = offset
  mesh.Scale = scale
  return mesh
end

weld = function(parent, part0, part1, c0)
  local weld = it("Motor")
  weld.Parent = parent
  weld.Part0 = part0
  weld.Part1 = part1
  weld.C0 = c0
  return weld
end

gui = function(GuiType, parent, text, backtrans, backcol, pos, size)
  local gui = it(GuiType)
  gui.Parent = parent
  gui.Text = text
  gui.BackgroundTransparency = backtrans
  gui.BackgroundColor3 = backcol
  gui.SizeConstraint = "RelativeXY"
  gui.TextXAlignment = "Center"
  gui.TextYAlignment = "Center"
  gui.Position = pos
  gui.Size = size
  gui.Font = "SourceSans"
  gui.FontSize = "Size14"
  gui.TextWrapped = false
  gui.TextStrokeTransparency = 0
  gui.TextColor = BrickColor.new("White")
  return gui
end

local Color1 = Torso.BrickColor
local fengui = it("GuiMain")
fengui.Parent = Player.PlayerGui
fengui.Name = "WeaponGUI"
local fenframe = it("Frame")
fenframe.Parent = fengui
fenframe.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe.BackgroundTransparency = 1
fenframe.BorderColor3 = Color3.new(17, 17, 17)
fenframe.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe.Position = UDim2.new(0.95, 0, 0.7, 0)
local fenframe2 = it("Frame")
fenframe2.Parent = fengui
fenframe2.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe2.BackgroundTransparency = 1
fenframe2.BorderColor3 = Color3.new(17, 17, 17)
fenframe2.Size = UDim2.new(0.2, 0, 0.1, 0)
fenframe2.Position = UDim2.new(0.4, 0, 0.85, 0)
local fenframe3 = it("Frame")
fenframe3.Parent = fengui
fenframe3.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe3.BackgroundTransparency = 1
fenframe3.BorderColor3 = Color3.new(17, 17, 17)
fenframe3.Size = UDim2.new(0.2, 0, 0.2, 0)
fenframe3.Position = UDim2.new(0.8, 0, 0.8, 0)
fenframe3.Name = "MoveFrame"
local fenframe4 = it("Frame")
fenframe4.Parent = fengui
fenframe4.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe4.BackgroundTransparency = 1
fenframe4.BorderColor3 = Color3.new(17, 17, 17)
fenframe4.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe4.Position = UDim2.new(0, 0, 0.7, 0)
local pressedf = false
local fenframe5 = it("Frame")
fenframe5.Parent = fengui
fenframe5.BackgroundColor3 = Color3.new(0, 0, 0)
fenframe5.BackgroundTransparency = 1
fenframe5.BorderColor3 = Color3.new(0, 0, 0)
fenframe5.Size = UDim2.new(1, 0, 1, 0)
fenframe5.Position = UDim2.new(0, 0, 0, 0)
fenframe5.ZIndex = 2
local tellbar = gui("TextLabel", fenframe5, "Press 'F' to equip.", 1, Color3.new(0, 0, 0), UDim2.new(0.25, 0, 0.25, 0), UDim2.new(0.5, 0, 0.5, 0))
tellbar.Font = "Arial"
tellbar.TextScaled = true
tellbar.TextTransparency = 1
tellbar.TextStrokeTransparency = 1
tellbar.ZIndex = 2
local fnumb = 0
local fenbarmana1 = gui("TextLabel", fenframe, "", 0, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarmana2 = gui("TextLabel", fenframe, "", 0, BrickColor.new(NewCol3).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarmana4 = gui("TextLabel", fenframe, "Mana(" .. mana.Value .. ")", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbarblock1 = gui("TextLabel", fenframe, "", 0, Color3.new(0, 0, 0), UDim2.new(-0.7, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarblock2 = gui("TextLabel", fenframe, "", 0, BrickColor.new("White").Color, UDim2.new(-0.7, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarblock3 = gui("TextLabel", fenframe, "Overload(" .. overload .. ")", 1, Color3.new(0, 0, 0), UDim2.new(-0.7, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbardamage = gui("TextLabel", fenframe2, "Damage", 0.55, Color3.new(0.6078431372549, 0, 0), UDim2.new(-0.23, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbardef = gui("TextLabel", fenframe2, "Defense", 0.55, Color3.new(0, 0, 0.6078431372549), UDim2.new(-0.46, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarmove = gui("TextLabel", fenframe2, "Walkspeed", 0.55, Color3.new(0, 0.6078431372549, 0), UDim2.new(1.03, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarhp1 = gui("TextLabel", fenframe2, "", 0, Color3.new(0, 0, 0), UDim2.new(-0.46, 0, 1, 0), UDim2.new(1.92, 0, 0.4, 0))
local fenbarhp2 = gui("TextLabel", fenbarhp1, "", 0, Color3.new(1, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarhp3 = gui("TextLabel", fenbarhp1, "(100)", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
local fenbarstun1 = gui("TextLabel", fenframe4, "", 0, Color3.new(0, 0, 0), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarstun2 = gui("TextLabel", fenframe4, "", 0, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarstun3 = gui("TextLabel", fenframe4, "Stun(" .. Stun.Value .. ")", 1, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbarmove1 = gui("TextButton", fenframe3, move1, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove1.ZIndex = 2
local fenbarmove1b = gui("TextLabel", fenbarmove1, "", 0.55, BrickColor.new(NewCol3).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove2 = gui("TextButton", fenframe3, move2, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove2.ZIndex = 2
local fenbarmove2b = gui("TextLabel", fenbarmove2, "", 0.55, BrickColor.new(NewCol3).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove3 = gui("TextButton", fenframe3, move3, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove3.ZIndex = 2
local fenbarmove3b = gui("TextLabel", fenbarmove3, "", 0.55, BrickColor.new(NewCol3).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove4 = gui("TextButton", fenframe3, move4, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove4.ZIndex = 2
local fenbarmove4b = gui("TextLabel", fenbarmove4, "", 0.55, BrickColor.new(NewCol3).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local modelzorz = Instance.new("Model")
modelzorz.Parent = Character
modelzorz.Name = "Permanence"
local modelzorz2 = Instance.new("Model")
modelzorz2.Parent = Character
modelzorz2.Name = "Dynamo"
prt1 = part(3, modelzorz, 0, 0, BrickColor.new("Medium stone grey"), "Part01", vt())
prt2 = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Part02", vt())
prt3 = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Part03", vt())
prt4 = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Part04", vt())
prt5 = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Part05", vt())
prt6 = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Part06", vt())
prt7 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Part07", vt())
prt8 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Part08", vt())
prt9 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part09", vt())
prt10 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part10", vt())
prt11 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part11", vt())
prt13 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part13", vt())
prt14 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part14", vt())
prt15 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part15", vt())
prt16 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part16", vt())
prt17 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part17", vt())
prt18 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part18", vt())
prt19 = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Part19", vt())
prt20 = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Part20", vt())
prt21 = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Part21", vt())
prt23 = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Part23", vt())
prt29 = part(3, modelzorz, 0.3, 0.05, BrickColor.new(NewCol2), "Part29", vt())
prt31 = part(3, modelzorz, 0.2, 0.5, BrickColor.new(NewCol2), "Part31", vt())
msh1 = mesh("BlockMesh", prt1, "", "", vt(0, 0, 0), vt(1, 4.99, 1))
msh2 = mesh("SpecialMesh", prt2, "Wedge", "nil", vt(0, 0, 0), vt(1.1, 2, 1.1))
msh3 = mesh("BlockMesh", prt3, "", "", vt(0, 0, 0), vt(1.1, 1, 1.1))
msh4 = mesh("SpecialMesh", prt4, "Wedge", "nil", vt(0, 0, 0), vt(1.1, 1, 1.1))
msh5 = mesh("BlockMesh", prt5, "", "", vt(0, 0, 0), vt(1.1, 1, 1.1))
msh6 = mesh("BlockMesh", prt6, "", "", vt(0, 0, 0), vt(1.1, 1, 2))
msh7 = mesh("SpecialMesh", prt7, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 2, 2))
msh8 = mesh("SpecialMesh", prt8, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 2, 2))
msh9 = mesh("CylinderMesh", prt9, "", "", vt(0, 0, 0), vt(3, 2, 3))
msh10 = mesh("BlockMesh", prt10, "", "", vt(0, 0, 0), vt(2, 4, 2))
msh11 = mesh("CylinderMesh", prt11, "", "", vt(0, 0, 0), vt(2, 2, 2))
msh13 = mesh("BlockMesh", prt13, "", "", vt(0, 0, 0), vt(2, 2, 2))
msh14 = mesh("CylinderMesh", prt14, "", "", vt(0, 0, 0), vt(2, 1.99, 2))
msh15 = mesh("BlockMesh", prt15, "", "", vt(0, 0, 0), vt(0.5, 1, 3))
msh16 = mesh("SpecialMesh", prt16, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 1, 2))
msh17 = mesh("BlockMesh", prt17, "", "", vt(0, 0, 0), vt(0.5, 1, 3))
msh18 = mesh("SpecialMesh", prt18, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 1, 2))
msh19 = mesh("BlockMesh", prt19, "", "", vt(0, 0, 0), vt(1.5, 2, 1.5))
msh20 = mesh("SpecialMesh", prt20, "FileMesh", "1778999", vt(0, 0, 0), vt(0.3, 0.3, 0.3))
msh21 = mesh("CylinderMesh", prt21, "", "", vt(0, 0, 0), vt(2.5, 3, 2.5))
msh23 = mesh("SpecialMesh", prt23, "FileMesh", "1778999", vt(0, 0, 0), vt(0.375, 0.4, 0.375))
msh29 = mesh("BlockMesh", prt29, "", "", vt(0, 0, 0), vt(0.5, 15, 2))
msh31 = mesh("BlockMesh", prt31, "", "", vt(0, 0, 0), vt(0.2, 16, 3))
local wld1 = weld(prt1, prt1, Torso, euler(-1.2, 0, -0.5) * euler(0, 0, 3.14) * cf(-0.8, 1, 1.5))
local wld2 = weld(prt2, prt2, prt1, euler(0, 0, 0) * cf(0, 0.1, 0))
local wld3 = weld(prt3, prt3, prt2, euler(0, 0, 0) * cf(0, 0.3, 0))
local wld4 = weld(prt4, prt4, prt1, euler(0, 0, 3.14) * cf(0, -0.2, 0))
local wld5 = weld(prt5, prt5, prt4, euler(0, 0, 0) * cf(0, 0.2, 0))
local wld6 = weld(prt6, prt6, prt1, euler(0, 0, 0) * cf(0, -0.6, 0))
local wld7 = weld(prt7, prt7, prt6, euler(1.1, 0, 0) * cf(0, 0.08, 0.2))
local wld8 = weld(prt8, prt8, prt6, euler(1.1, 0, 0) * cf(0, 0.08, 0.2) * euler(0, 3.14, 0))
local wld9 = weld(prt9, prt9, prt6, euler(0, 0, 1.57) * cf(0, -0.3, 0))
local wld10 = weld(prt10, prt10, prt9, euler(0, 0, 1.57) * cf(0.6, 0, 0) * euler(0, -1.6, 0))
local wld11 = weld(prt11, prt11, prt10, euler(0, 0, 1.57) * cf(0, 0.4, 0))
local wld13 = weld(prt13, prt13, prt9, euler(0, 0, 1.57) * cf(0.4, 0, 0) * euler(0, 2.4, 0))
local wld14 = weld(prt14, prt14, prt13, euler(0, 0, 1.57) * cf(0, 0.2, 0))
local wld15 = weld(prt15, prt15, prt14, euler(0, 0, 1.57) * cf(0, 0.1, 0.4) * euler(0, 1, 0))
local wld16 = weld(prt16, prt16, prt15, euler(0, 0, 0) * cf(0, 0, 0.5))
local wld17 = weld(prt17, prt17, prt14, euler(0, 0, 1.57) * cf(0, -0.1, 0.4) * euler(0, 1, 0))
local wld18 = weld(prt18, prt18, prt17, euler(0, 0, 0) * cf(0, 0, 0.5))
local wld19 = weld(prt19, prt19, prt9, euler(0, 0, 1.57) * cf(0.3, 0, 0))
local wld20 = weld(prt20, prt20, prt19, euler(0, 0, 0) * cf(0, 0, 0))
local wld21 = weld(prt21, prt21, prt19, euler(0, 0, 0) * cf(0, 0.5, 0))
local wld23 = weld(prt23, prt23, prt21, euler(3.14, 0, 0) * cf(0, 0.62, 0))
local wld29 = weld(prt29, prt29, prt23, euler(0, 0, 0) * cf(0, -1.2, 0))
local wld31 = weld(prt31, prt31, prt23, euler(0, 0, 0) * cf(0, -1.3, 0))
for i = -0.2, 0.2, 0.4 do
  local prt12 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part12", vt())
  msh12 = mesh("SpecialMesh", prt12, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 1))
  local wld12 = weld(prt12, prt12, prt10, euler(0, 0, 0) * cf(0, i, 0.3))
end
for i = 1.57, 6.28 do
  local prt22 = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Part22", vt())
  msh22 = mesh("SpecialMesh", prt22, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 2, 1))
  local wld22 = weld(prt22, prt22, prt19, euler(0.2, 0, 0) * cf(0, 0.1, 0.22) * euler(0, i, 0))
end
for i = 0, 3.14, 3.14 do
  local prt24 = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Part24", vt())
  local prt25 = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Part25", vt())
  local prt26 = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Part26", vt())
  local prt27 = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Part27", vt())
  local prt28 = part(3, modelzorz, 0, 0, BrickColor.new("Dark stone grey"), "Part28", vt())
  msh24 = mesh("BlockMesh", prt24, "", "", vt(0, 0, 0), vt(1, 2, 0.5))
  msh25 = mesh("BlockMesh", prt25, "", "", vt(0, 0, 0), vt(1, 7, 0.5))
  msh26 = mesh("SpecialMesh", prt26, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 1))
  msh27 = mesh("SpecialMesh", prt27, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 0.5))
  msh28 = mesh("SpecialMesh", prt28, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 0.5))
  local wld24 = weld(prt24, prt24, prt21, euler(0, 0, 0) * cf(0, 0.1, 0.25) * euler(0, i, 0))
  local wld25 = weld(prt25, prt25, prt24, euler(0, 0, 0) * cf(0, 0.5, 0.1))
  local wld26 = weld(prt26, prt26, prt24, euler(0, 0, 0) * cf(0, -0.3, 0.05))
  local wld27 = weld(prt27, prt27, prt24, euler(3.14, 0, 0) * cf(0, 0.3, 0))
  local wld28 = weld(prt28, prt28, prt25, euler(3.14, 3.14, 0) * cf(0, 0.8, 0))
end
local prt30 = part(3, modelzorz, 0.3, 0.05, BrickColor.new(NewCol2), "Part30", vt())
msh30 = mesh("SpecialMesh", prt30, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 3, 1))
local wld30 = weld(prt30, prt30, prt29, euler(0, 0, 0) * cf(0, -1.8, 0.1) * euler(0, 0, 0))
local prt30b = part(3, modelzorz, 0.3, 0.05, BrickColor.new(NewCol2), "Part30B", vt())
msh30b = mesh("SpecialMesh", prt30b, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 3, 1))
local wld30b = weld(prt30b, prt30b, prt29, euler(0, 0, 0) * cf(0, -1.8, 0.1) * euler(0, 3.14, 0))
local prt32 = part(3, modelzorz, 0.2, 0.5, BrickColor.new(NewCol2), "Part32", vt())
msh32 = mesh("SpecialMesh", prt32, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 5, 1.5))
local wld32 = weld(prt32, prt32, prt31, euler(0, 0, 0) * cf(0, -2.1, 0.15) * euler(0, 0, 0))
local prt32b = part(3, modelzorz, 0.2, 0.5, BrickColor.new(NewCol2), "Part32B", vt())
msh32b = mesh("SpecialMesh", prt32b, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 5, 1.5))
local wld32b = weld(prt32b, prt32b, prt31, euler(0, 0, 0) * cf(0, -2.1, 0.15) * euler(0, 3.14, 0))
local prt33 = part(3, modelzorz, 0.3, 1.1, BrickColor.new(NewCol2), "Part33", vt())
local prt34 = part(3, modelzorz, 0.3, 1.1, BrickColor.new(NewCol2), "Part34", vt())
local prt35 = part(3, modelzorz, 0.3, 1.1, BrickColor.new(NewCol2), "Part35", vt())
local prt36 = part(3, modelzorz, 0.5, 1.5, BrickColor.new(NewCol2), "Part36", vt())
local prt37 = part(3, modelzorz, 0.5, 1.5, BrickColor.new(NewCol2), "Part37", vt())
local prt38 = part(3, modelzorz, 0.5, 1.5, BrickColor.new(NewCol2), "Part38", vt())
local prt39 = part(3, modelzorz, 0.5, 1.5, BrickColor.new(NewCol2), "Part39", vt())
msh33 = mesh("BlockMesh", prt33, "", "", vt(0, 0, 0), vt(0.5, 23, 3))
msh34 = mesh("SpecialMesh", prt34, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 5, 1.5))
msh35 = mesh("SpecialMesh", prt35, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 5, 1.5))
msh36 = mesh("SpecialMesh", prt36, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 30, 9))
msh37 = mesh("SpecialMesh", prt37, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 30, 9))
msh38 = mesh("SpecialMesh", prt38, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 2, 9))
msh39 = mesh("SpecialMesh", prt39, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 2, 9))
local wld33 = weld(prt33, prt33, prt23, euler(0, 0, 0) * cf(0, -2, 0))
local wld34 = weld(prt34, prt34, prt33, euler(0, 0, 0) * cf(0, -2.8, 0.15) * euler(0, 0, 0))
local wld35 = weld(prt35, prt35, prt33, euler(0, 0, 0) * cf(0, -2.8, 0.15) * euler(0, 3.14, 0))
local wld36 = weld(prt36, prt36, prt23, euler(0, 0, 0) * cf(0, -2.7, 0.9) * euler(0, 0, 0))
local wld37 = weld(prt37, prt37, prt23, euler(0, 0, 0) * cf(0, -2.7, 0.9) * euler(0, 3.14, 0))
local wld38 = weld(prt38, prt38, prt23, euler(0, 0, 3.14) * cf(0, 0.5, 0.9) * euler(0, 0, 0))
local wld39 = weld(prt39, prt39, prt23, euler(0, 0, 3.14) * cf(0, 0.5, 0.9) * euler(0, 3.14, 0))
handle = part(3, modelzorz2, 0, 1, BrickColor.new("Black"), "Handle", vt())
dprt1 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "Part01", vt())
dprt2 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "Part02", vt())
dprt3 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "Part03", vt())
dprt4 = part(3, modelzorz2, 0.4, 0.5, BrickColor.new(NewCol2), "Part04", vt())
dprt5 = part(3, modelzorz2, 0.4, 0.5, BrickColor.new(NewCol2), "Part05", vt())
dprt6 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "Part06", vt())
dprt7 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "Part07", vt())
dprt8 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "Part08", vt())
dprt9 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "Part09", vt())
dprt10 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "Part10", vt())
dprt11 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "Part11", vt())
dprt12 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "Part12", vt())
dprt13 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "Part13", vt())
dprt14 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "Part14", vt())
dprt15 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "Part15", vt())
dprt16 = part(3, modelzorz2, 0.4, 0.5, BrickColor.new(NewCol2), "Part16", vt())
dprt17 = part(3, modelzorz2, 0.4, 0.5, BrickColor.new(NewCol2), "Part17", vt())
dprt18 = part(3, modelzorz2, 0.4, 0.5, BrickColor.new(NewCol2), "Part18", vt())
dprt19 = part(3, modelzorz2, 0.4, 0.5, BrickColor.new(NewCol2), "Part19", vt())
dprt20 = part(3, modelzorz2, 0.4, 0.5, BrickColor.new(NewCol2), "Part20", vt())
dprt21 = part(3, modelzorz2, 0.4, 0.5, BrickColor.new(NewCol2), "Part21", vt())
dprt22 = part(3, modelzorz2, 0.4, 0.5, BrickColor.new(NewCol2), "Part22", vt())
dprtb1 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "PartB01", vt())
dprtb2 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "PartB02", vt())
dprtb3 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "PartB03", vt())
dprtb4 = part(3, modelzorz2, 0.4, 0.5, BrickColor.new(NewCol2), "PartB04", vt())
dprtb5 = part(3, modelzorz2, 0.4, 0.5, BrickColor.new(NewCol2), "PartB05", vt())
dprtb6 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "PartB06", vt())
dprtb7 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "PartB07", vt())
dprtb8 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "PartB08", vt())
dprtb9 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "PartB09", vt())
dprtb10 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "PartB10", vt())
dprtb11 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "PartB11", vt())
dprtb12 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "PartB12", vt())
dprtb13 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "PartB13", vt())
dprtb14 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "PartB14", vt())
dprtb15 = part(3, modelzorz2, 0, 0, BrickColor.new(NewCol), "PartB15", vt())
dprtb16 = part(3, modelzorz2, 0.4, 0.5, BrickColor.new(NewCol2), "PartB16", vt())
dprtb17 = part(3, modelzorz2, 0.4, 0.5, BrickColor.new(NewCol2), "PartB17", vt())
dprtb18 = part(3, modelzorz2, 0.4, 0.5, BrickColor.new(NewCol2), "PartB18", vt())
dprtb19 = part(3, modelzorz2, 0.4, 0.5, BrickColor.new(NewCol2), "PartB19", vt())
dprtb20 = part(3, modelzorz2, 0.4, 0.5, BrickColor.new(NewCol2), "PartB20", vt())
dprtb21 = part(3, modelzorz2, 0.4, 0.5, BrickColor.new(NewCol2), "PartB21", vt())
dprtb22 = part(3, modelzorz2, 0.4, 0.5, BrickColor.new(NewCol2), "PartB22", vt())
dmsh1 = mesh("BlockMesh", dprt1, "", "", vt(0, 0, 0), vt(1.5, 6, 1))
dmsh2 = mesh("SpecialMesh", dprt2, "Wedge", "nil", vt(0, 0, 0), vt(1, 1.5, 1))
dmsh3 = mesh("SpecialMesh", dprt3, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 1.5))
dmsh4 = mesh("SpecialMesh", dprt4, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 10, 3))
dmsh5 = mesh("SpecialMesh", dprt5, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 1.5, 1.5))
dmsh6 = mesh("BlockMesh", dprt6, "", "", vt(0, 0, 0), vt(1.5, 3, 1))
dmsh7 = mesh("SpecialMesh", dprt7, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 1.5))
dmsh8 = mesh("SpecialMesh", dprt8, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 1.5))
dmsh9 = mesh("SpecialMesh", dprt9, "Torso", "nil", vt(0, 0, 0), vt(7, 1, 1))
dmsh10 = mesh("BlockMesh", dprt10, "", "", vt(0, 0, 0), vt(2, 4, 1))
dmsh11 = mesh("SpecialMesh", dprt11, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 1.5))
dmsh12 = mesh("SpecialMesh", dprt12, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 0.5))
dmsh13 = mesh("BlockMesh", dprt13, "", "", vt(0, 0, 0), vt(1, 4, 1))
dmsh14 = mesh("SpecialMesh", dprt14, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 1))
dmsh15 = mesh("SpecialMesh", dprt15, "Wedge", "nil", vt(0, 0, 0), vt(1, 4, 1))
dmsh16 = mesh("BlockMesh", dprt16, "", "", vt(0, 0, 0), vt(0.5, 7, 3))
dmsh17 = mesh("SpecialMesh", dprt17, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 2.5, 3))
dmsh18 = mesh("SpecialMesh", dprt18, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 12, 3))
dmsh19 = mesh("BlockMesh", dprt19, "", "", vt(0, 0, 0), vt(0.5, 5, 1))
dmsh20 = mesh("SpecialMesh", dprt20, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 3, 1))
dmsh21 = mesh("SpecialMesh", dprt21, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 1.5, 1))
dmsh22 = mesh("SpecialMesh", dprt22, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 11, 3))
dmshb1 = mesh("BlockMesh", dprtb1, "", "", vt(0, 0, 0), vt(1.5, 6, 1))
dmshb2 = mesh("SpecialMesh", dprtb2, "Wedge", "nil", vt(0, 0, 0), vt(1, 1.5, 1))
dmshb3 = mesh("SpecialMesh", dprtb3, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 1.5))
dmshb4 = mesh("SpecialMesh", dprtb4, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 10, 3))
dmshb5 = mesh("SpecialMesh", dprtb5, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 1.5, 1.5))
dmshb6 = mesh("BlockMesh", dprtb6, "", "", vt(0, 0, 0), vt(1.5, 3, 1))
dmshb7 = mesh("SpecialMesh", dprtb7, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 1.5))
dmshb8 = mesh("SpecialMesh", dprtb8, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 1.5))
dmshb9 = mesh("SpecialMesh", dprtb9, "Torso", "nil", vt(0, 0, 0), vt(7, 1, 1))
dmshb10 = mesh("BlockMesh", dprtb10, "", "", vt(0, 0, 0), vt(2, 4, 1))
dmshb11 = mesh("SpecialMesh", dprtb11, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 1.5))
dmshb12 = mesh("SpecialMesh", dprtb12, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 0.5))
dmshb13 = mesh("BlockMesh", dprtb13, "", "", vt(0, 0, 0), vt(1, 4, 1))
dmshb14 = mesh("SpecialMesh", dprtb14, "Wedge", "nil", vt(0, 0, 0), vt(1, 1, 1))
dmshb15 = mesh("SpecialMesh", dprtb15, "Wedge", "nil", vt(0, 0, 0), vt(1, 4, 1))
dmshb16 = mesh("BlockMesh", dprtb16, "", "", vt(0, 0, 0), vt(0.5, 7, 3))
dmshb17 = mesh("SpecialMesh", dprtb17, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 2.5, 3))
dmshb18 = mesh("SpecialMesh", dprtb18, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 12, 3))
dmshb19 = mesh("BlockMesh", dprtb19, "", "", vt(0, 0, 0), vt(0.5, 5, 1))
dmshb20 = mesh("SpecialMesh", dprtb20, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 3, 1))
dmshb21 = mesh("SpecialMesh", dprtb21, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 1.5, 1))
dmshb22 = mesh("SpecialMesh", dprtb22, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 11, 3))
hwld = weld(handle, handle, RightArm, euler(0, 0, 0) * cf(0, 0, 0))
dwld1 = weld(dprt1, dprt1, handle, euler(0, 1.57, 0) * cf(-0.6, -1.5, -0.4))
dwld2 = weld(dprt2, dprt2, dprt1, euler(1.57, -1.57, 0) * cf(0, 0.7, 0))
dwld3 = weld(dprt3, dprt3, dprt1, euler(0, 1.57, 0) * cf(0, -0.7, 0))
dwld4 = weld(dprt4, dprt4, dprt1, euler(0, 1.57, 0) * cf(-0.15, -0.5, 0))
dwld5 = weld(dprt5, dprt5, dprt1, euler(0, -1.57, 3.14) * cf(-0.3, 0.65, 0))
dwld6 = weld(dprt6, dprt6, handle, euler(0, 1.57, 0) * cf(-0.6, -0.4, -0.35))
dwld7 = weld(dprt7, dprt7, dprt6, euler(0, 1.57, 0) * cf(0, -0.4, 0))
dwld8 = weld(dprt8, dprt8, dprt6, euler(3.14, -1.57, 0) * cf(0, 0.4, 0))
dwld9 = weld(dprt9, dprt9, dprt6, euler(0, 0, -1.57) * cf(0.25, -0.2, 0))
dwld10 = weld(dprt10, dprt10, handle, euler(0, 1.57, 0) * cf(-0.6, 0.5, -0.45))
dwld11 = weld(dprt11, dprt11, dprt10, euler(0, -1.57, 0) * cf(0.05, -0.5, 0))
dwld12 = weld(dprt12, dprt12, dprt10, euler(0, 1.57, 0) * cf(-0.15, -0.5, 0))
dwld13 = weld(dprt13, dprt13, dprt10, euler(0, 0, 0) * cf(0.1, 0.8, 0))
dwld14 = weld(dprt14, dprt14, dprt10, euler(3.14, -1.57, 0) * cf(-0.1, 0.5, 0))
dwld15 = weld(dprt15, dprt15, dprt13, euler(3.14, -1.57, 0) * cf(0, 0.8, 0))
dwld16 = weld(dprt16, dprt16, dprt10, euler(0, 1.57, 0) * cf(-0.1, -0.3, 0))
dwld17 = weld(dprt17, dprt17, dprt10, euler(0, -1.57, 0) * cf(-0.1, -1.25, 0))
dwld18 = weld(dprt18, dprt18, dprt10, euler(0, -1.57, 3.14) * cf(-0.1, 1.6, 0))
dwld19 = weld(dprt19, dprt19, dprt16, euler(0, 0, 0) * cf(0, -0.1, 0.4))
dwld20 = weld(dprt20, dprt20, dprt19, euler(0, 0, 0) * cf(0, -0.8, 0))
dwld21 = weld(dprt21, dprt21, dprt19, euler(0, 0, 3.14) * cf(0, 0.65, 0))
dwld22 = weld(dprt22, dprt22, dprt9, euler(0, -1.57, 1.57) * cf(-0.4, -0.2, 0))
dwldb1 = weld(dprtb1, dprtb1, handle, euler(0, -1.57, 0) * cf(-0.6, -1.5, 0.4))
dwldb2 = weld(dprtb2, dprtb2, dprtb1, euler(1.57, -1.57, 0) * cf(0, 0.7, 0))
dwldb3 = weld(dprtb3, dprtb3, dprtb1, euler(0, 1.57, 0) * cf(0, -0.7, 0))
dwldb4 = weld(dprtb4, dprtb4, dprtb1, euler(0, 1.57, 0) * cf(-0.15, -0.5, 0))
dwldb5 = weld(dprtb5, dprtb5, dprtb1, euler(0, -1.57, 3.14) * cf(-0.3, 0.65, 0))
dwldb6 = weld(dprtb6, dprtb6, handle, euler(0, -1.57, 0) * cf(-0.6, -0.4, 0.35))
dwldb7 = weld(dprtb7, dprtb7, dprtb6, euler(0, 1.57, 0) * cf(0, -0.4, 0))
dwldb8 = weld(dprtb8, dprtb8, dprtb6, euler(3.14, -1.57, 0) * cf(0, 0.4, 0))
dwldb9 = weld(dprtb9, dprtb9, dprtb6, euler(0, 0, -1.57) * cf(0.25, -0.2, 0))
dwldb10 = weld(dprtb10, dprtb10, handle, euler(0, -1.57, 0) * cf(-0.6, 0.5, 0.45))
dwldb11 = weld(dprtb11, dprtb11, dprtb10, euler(0, -1.57, 0) * cf(0.05, -0.5, 0))
dwldb12 = weld(dprtb12, dprtb12, dprtb10, euler(0, 1.57, 0) * cf(-0.15, -0.5, 0))
dwldb13 = weld(dprtb13, dprtb13, dprtb10, euler(0, 0, 0) * cf(0.1, 0.8, 0))
dwldb14 = weld(dprtb14, dprtb14, dprtb10, euler(3.14, -1.57, 0) * cf(-0.1, 0.5, 0))
dwldb15 = weld(dprtb15, dprtb15, dprtb13, euler(3.14, -1.57, 0) * cf(0, 0.8, 0))
dwldb16 = weld(dprtb16, dprtb16, dprtb10, euler(0, 1.57, 0) * cf(-0.1, -0.3, 0))
dwldb17 = weld(dprtb17, dprtb17, dprtb10, euler(0, -1.57, 0) * cf(-0.1, -1.25, 0))
dwldb18 = weld(dprtb18, dprtb18, dprtb10, euler(0, -1.57, 3.14) * cf(-0.1, 1.6, 0))
dwldb19 = weld(dprtb19, dprtb19, dprtb16, euler(0, 0, 0) * cf(0, -0.1, 0.4))
dwldb20 = weld(dprtb20, dprtb20, dprtb19, euler(0, 0, 0) * cf(0, -0.8, 0))
dwldb21 = weld(dprtb21, dprtb21, dprtb19, euler(0, 0, 3.14) * cf(0, 0.65, 0))
dwldb22 = weld(dprtb22, dprtb22, dprtb9, euler(0, -1.57, 1.57) * cf(-0.4, -0.2, 0))
local hitbox = part(3, modelzorz, 0, 1, BrickColor.new("Black"), "Hitbox2", vt())
hitbox.Anchored = false
local hbwld = weld(hitbox, hitbox, RootPart, euler(0, 0, 0) * cf(0, 0, 0))
local hitbox2 = part(3, nil, 0, 1, BrickColor.new("Black"), "Hitbox", vt(1, 1, 1))
hitbox2.Anchored = true
local hitboxCF = cf(0, 0, 0)
hboxpos = Instance.new("BodyPosition", nil)
hboxpos.P = 2000
hboxpos.D = 100
hboxpos.maxForce = Vector3.new(545000, 545000, 545000)
local DemTable = {}
table.insert(DemTable, {prt29, 0.05})
table.insert(DemTable, {prt30, 0.05})
table.insert(DemTable, {prt30b, 0.05})
table.insert(DemTable, {prt31, 0.5})
table.insert(DemTable, {prt32, 0.5})
table.insert(DemTable, {prt32b, 0.5})
table.insert(DemTable, {dprt4, 0.5})
table.insert(DemTable, {dprt5, 0.5})
table.insert(DemTable, {dprt16, 0.5})
table.insert(DemTable, {dprt17, 0.5})
table.insert(DemTable, {dprt18, 0.5})
table.insert(DemTable, {dprt19, 0.5})
table.insert(DemTable, {dprt20, 0.5})
table.insert(DemTable, {dprt21, 0.5})
table.insert(DemTable, {dprt22, 0.5})
table.insert(DemTable, {dprtb4, 0.5})
table.insert(DemTable, {dprtb5, 0.5})
table.insert(DemTable, {dprtb16, 0.5})
table.insert(DemTable, {dprtb17, 0.5})
table.insert(DemTable, {dprtb18, 0.5})
table.insert(DemTable, {dprtb19, 0.5})
table.insert(DemTable, {dprtb20, 0.5})
table.insert(DemTable, {dprtb21, 0.5})
table.insert(DemTable, {dprtb22, 0.5})
local DynamPrt = {}
table.insert(DynamPrt, dprt1)
table.insert(DynamPrt, dprt6)
table.insert(DynamPrt, dprt10)
table.insert(DynamPrt, dprtb1)
table.insert(DynamPrt, dprtb6)
table.insert(DynamPrt, dprtb10)
hitboxweld = function()
  hbwld.Parent = modelzorz
  hbwld.Part0 = hitbox
  hbwld.Part1 = prt6
end
Bin = script.Parent
if Bin.Name == "Dynamence" then
  Bin.Name = "Dynamo & Permanence"
end
local bodvel = Instance.new("BodyVelocity")
local bg = Instance.new("BodyGyro")
so = function(id, par, vol, pit)
  local sou = Instance.new("Sound", par or workspace)
  sou.Volume = vol
  sou.Pitch = pit or 1
  sou.SoundId = "http://www.roblox.com/asset/?id=" .. id
  coroutine.resume(coroutine.create(function(Sound)
    swait()
    Sound:play()
  end
), sou)
  game:GetService("Debris"):AddItem(sou, 6)
end

so2 = function(id, par, vol, pit)
  local sou = Instance.new("Sound", par or workspace)
  sou.Volume = vol
  sou.Pitch = pit or 1
  sou.SoundId = id
  sou:play()
  game:GetService("Debris"):AddItem(sou, 6)
end

function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

hideanim = function()
  equipped = false
  for i = 0, 1, 0.2 do
    swait()
    if Mode == "Classic" then
      hwld.C0 = clerp(hwld.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.4)
      dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * cf(-0.6, -1.5, -0.4), 0.4)
      dwld6.C0 = clerp(dwld6.C0, euler(0, 1.57, 0) * cf(-0.6, -0.4, -0.35), 0.4)
      dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * cf(-0.6, 0.5, -0.45), 0.4)
      dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * cf(-0.6, -1.5, 0.4), 0.4)
      dwldb6.C0 = clerp(dwldb6.C0, euler(0, -1.57, 0) * cf(-0.6, -0.4, 0.35), 0.4)
      dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * cf(-0.6, 0.5, 0.45), 0.4)
    else
      if Mode == "Dynamic Blade" then
        dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * cf(0.2, -2.5, -0.4), 0.4)
        dwld6.C0 = clerp(dwld6.C0, euler(0, 1.57, 0) * cf(0.2, -1.4, -0.35), 0.4)
        dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * cf(0.2, -0.5, -0.45), 0.4)
        dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * cf(0.2, -2.5, 0.4), 0.4)
        dwldb6.C0 = clerp(dwldb6.C0, euler(0, -1.57, 0) * cf(0.2, -1.4, 0.35), 0.4)
        dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * cf(0.2, -0.5, 0.45), 0.4)
      else
        if Mode == "Energy Reactor" then
          hwld.Part1 = Torso
          hwld.C0 = clerp(hwld.C0, euler(0, 1.57, 1) * cf(0, 0, 0), 0.4)
          dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * cf(-0.6, -1.5, -0.4), 0.4)
          dwld6.C0 = clerp(dwld6.C0, euler(0, 1.57, 0) * cf(-0.6, -0.4, -0.35), 0.4)
          dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * cf(-0.6, 0.5, -0.45), 0.4)
          dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * cf(-0.6, -1.5, 0.4), 0.4)
          dwldb6.C0 = clerp(dwldb6.C0, euler(0, -1.57, 0) * cf(-0.6, -0.4, 0.35), 0.4)
          dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * cf(-0.6, 0.5, 0.45), 0.4)
        end
      end
    end
    wld1.C0 = clerp(wld1.C0, euler(1.7, 0, 0) * cf(0, 1, 0), 0.5)
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, -0.6), 0.5)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.5)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 0.2), 0.5)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
    LW.C0 = clerp(LW.C0, cf(0, 0.2, -1) * euler(0.2, 0, 0.6) * euler(0, -3, 0), 0.5)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
    RH.C0 = clerp(RH.C0, RHC0, 0.4)
    RH.C1 = clerp(RH.C1, RHC1, 0.4)
    LH.C0 = clerp(LH.C0, LHC0, 0.4)
    LH.C1 = clerp(LH.C1, LHC1, 0.4)
  end
  wld1.Part1 = Torso
  wld1.C0 = euler(-1.2, 0, -0.5) * euler(0, 0, 3.14) * cf(-0.8, 1, 1.5)
  mdec2.Parent = nil
  mdec.Parent = Decrease
  for i = 0, 1, 0.1 do
    swait()
    if Mode == "Classic" then
      dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * cf(-0.6, -1.5, -0.4), 0.4)
      dwld6.C0 = clerp(dwld6.C0, euler(0, 1.57, 0) * cf(-0.6, -0.4, -0.35), 0.4)
      dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * cf(-0.6, 0.5, -0.45), 0.4)
      dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * cf(-0.6, -1.5, 0.4), 0.4)
      dwldb6.C0 = clerp(dwldb6.C0, euler(0, -1.57, 0) * cf(-0.6, -0.4, 0.35), 0.4)
      dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * cf(-0.6, 0.5, 0.45), 0.4)
    else
      if Mode == "Dynamic Blade" then
        dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * cf(0.2, -2.5, -0.4), 0.4)
        dwld6.C0 = clerp(dwld6.C0, euler(0, 1.57, 0) * cf(0.2, -1.4, -0.35), 0.4)
        dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * cf(0.2, -0.5, -0.45), 0.4)
        dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * cf(0.2, -2.5, 0.4), 0.4)
        dwldb6.C0 = clerp(dwldb6.C0, euler(0, -1.57, 0) * cf(0.2, -1.4, 0.35), 0.4)
        dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * cf(0.2, -0.5, 0.45), 0.4)
      else
        if Mode == "Energy Reactor" then
          hwld.C0 = clerp(hwld.C0, euler(0, 1.57, 1) * cf(0, 0, 0), 0.4)
          dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * cf(-0.6, -1.5, -0.4), 0.4)
          dwld6.C0 = clerp(dwld6.C0, euler(0, 1.57, 0) * cf(-0.6, -0.4, -0.35), 0.4)
          dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * cf(-0.6, 0.5, -0.45), 0.4)
          dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * cf(-0.6, -1.5, 0.4), 0.4)
          dwldb6.C0 = clerp(dwldb6.C0, euler(0, -1.57, 0) * cf(-0.6, -0.4, 0.35), 0.4)
          dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * cf(-0.6, 0.5, 0.45), 0.4)
        end
      end
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
  end
end

mdec.Parent = Decrease
equipanim = function()
  equipped = true
  mdec.Parent = nil
  for i = 0, 1, 0.2 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, -0.6), 0.5)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.5)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 0.2), 0.5)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
    LW.C0 = clerp(LW.C0, cf(0, 0.2, -1) * euler(0.2, 0, 0.6) * euler(0, -3, 0), 0.5)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
  end
  wld1.Part1 = LeftArm
  wld1.C0 = euler(1.7, 0, 0) * cf(0, 1, 0)
  mdec2.Parent = Decrease
end

StaggerAnim = function()
  attack = true
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.35 do
    swait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -40
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, -0.4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.7) * euler(0, -0.7, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
    if StunT.Value <= Stun.Value then
      break
    end
  end
  do
    for i = 0, 1, 0.2 do
      swait()
      if Rooted.Value == false then
        Torso.Velocity = RootPart.CFrame.lookVector * -40
      end
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(-0.5, 0, -0.4), 0.4)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.7) * euler(0, -0.7, 0), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.5), 0.4)
      if StunT.Value <= Stun.Value then
        break
      end
    end
    do
      for i = 0, 1, 0.1 do
        swait()
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(0.5, 0, 0), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.8) * euler(-0.2, 0, -0.4), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.3, 0, 0.4) * euler(0, -0.4, 0), 0.3)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.3, 0, -0.2) * euler(0, 0.4, 0), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 1.2), 0.3)
        LH.C0 = clerp(LH.C0, cf(-1, 0, -1) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
        if StunT.Value <= Stun.Value then
          break
        end
      end
      do
        for i = 1, 50 do
          swait()
          if StunT.Value <= Stun.Value then
            break
          end
        end
        do
          combo = 0
          attack = false
        end
      end
    end
  end
end

StaggerHitt = function()
  attack = true
  if invisible == true then
    Clone(0.1)
  end
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.1 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.7) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, -0.6), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.9) * euler(0, -0.7, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, -0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  attack = false
end

StunAnim = function()
  attack = true
  Stunned.Value = true
  showDamage(Character, "Stunned", "Interrupt")
  local dec = Instance.new("NumberValue", Decrease)
  dec.Name = "DecreaseMvmt"
  dec.Value = 10
  for i = 0, 1, 0.3 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.2, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1, 0, 0.4) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.3), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, 0), 0.25)
  end
  for i = 0, 1, 0.3 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0.8, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1.2, 0, 0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(0.1, 0, 0.7), 0.25)
  end
  for i = 0, 1, 0.3 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -1), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1.57, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, -0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.1, 0, 0.3), 0.25)
  end
  local gairost = Instance.new("BodyGyro")
  gairost.Parent = RootPart
  gairost.maxTorque = Vector3.new(400000, 0, 400000) * 1000
  gairost.P = 20000
  gairost.cframe = cf(0, 0, 0)
  for i = 0, 1, 0.1 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2.5) * euler(1.57, 0, -3.14), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1.5) * euler(0.2, 0, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.5, 0, -1.57) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 0), 0.3)
  end
  for i = 1, 70 do
    swait()
    gairost.cframe = RootPart.CFrame
  end
  for i = 0, 1, 0.2 do
    swait()
    Stun.Value = 0
    gairost.cframe = RootPart.CFrame
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1, 0, -4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1) * euler(0.2, -1, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, 0.2) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, -1) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 1), 0.3)
  end
  dynamove = true
  gairost.Parent = nil
  dec.Parent = nil
  Stun.Value = 0
  combo = 0
  Stunned.Value = false
  attack = false
  for i = 1, 10 do
    swait()
    Stun.Value = 0
  end
end

attackone = function()
  attack = true
  for i = 0, 1, 0.15 do
    swait()
    if Mode == "Classic" then
      hwld.C0 = clerp(hwld.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.5)
      dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * cf(-0.6, -1.5, -0.4), 0.5)
      dwld6.C0 = clerp(dwld6.C0, euler(0, 1.57, 0) * cf(-0.6, -0.4, -0.35), 0.5)
      dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * cf(-0.6, 0.5, -0.45), 0.5)
      dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * cf(-0.6, -1.5, 0.4), 0.5)
      dwldb6.C0 = clerp(dwldb6.C0, euler(0, -1.57, 0) * cf(-0.6, -0.4, 0.35), 0.5)
      dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * cf(-0.6, 0.5, 0.45), 0.5)
    end
    if Mode == "Dynamic Blade" then
      hwld.C0 = clerp(hwld.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.6)
      dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * euler(0, 0, 0) * cf(0, -6.5, -0.15), 0.6)
      dwld6.C0 = clerp(dwld6.C0, euler(0, -1.57, 0) * euler(0, 0, 0) * cf(0, -5, -0.4), 0.6)
      dwld10.C0 = clerp(dwld10.C0, euler(3.14, 1.57, 0) * cf(0, -4, -0.5), 0.6)
      dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * euler(0, 0, 0) * cf(0, -6.5, 0.15), 0.6)
      dwldb6.C0 = clerp(dwldb6.C0, euler(0, 1.57, 0) * euler(0, 0, 0) * cf(0, -5, 0.4), 0.6)
      dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, -1.57, 0) * cf(0, -4, 0.5), 0.6)
    end
    wld1.C0 = clerp(wld1.C0, euler(1, 0, 0) * cf(0, 1, 0), 0.2)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.5), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.2), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-0.5, 0.5, -0.5) * euler(2, 0, 1) * euler(0, -1, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.5, 0), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC477: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC477: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  num = 1
  dam1 = 6
  dam2 = 8
  knock = math.random(5, 10)
  stun = math.random(5, 7)
  typ = "Normal"
  if Mode == "Dynamic Blade" then
    num = 2
    dam1 = 7
    dam2 = 9
    knock = math.random(10, 15)
    stun = math.random(6, 8)
    typ = "Normal"
  end
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(0.5, 5.4, 1)
  local size = 5
  if Mode == "Dynamic Blade" then
    hitbox.Size = vt(1, 8, 2)
    size = 7
  end
  hitboxCF = prt31.CFrame * cf(0, 0, 0)
  hitbox.CFrame = hitboxCF
  blcf = nil
  scfr = nil
  so("200633281", prt31, 1, 0.9)
  for i = 0, 1, 0.1 do
    swait()
    hitboxCF = prt31.CFrame * cf(0, 0, 0)
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, size, dam1, dam2, knock, typ, RootPart, 0.5, num, stun, nil, true)
    wld1.C0 = clerp(wld1.C0, euler(2.5, 0, 0) * cf(0, 1, 0), 0.2)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.8) * euler(0.2, 0, 0), 0.5)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.8), 0.5)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.6, 0, 0.4), 0.5)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.5, 0, -1) * euler(0, -0.6, 0), 0.5)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.5, 0), 0.5)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, -0.5, 0), 0.5)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC795: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC795: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end

attacktwo = function()
  attack = true
  if Mode == "Classic" then
    for i = 0, 1, 0.1 do
      swait()
      Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0) * euler(0, 0, -0.8), 0.2)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -0.7), 0.2)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 1.4) * euler(0, 0, 0), 0.2)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.3, 0, -0.4) * euler(0, 0, 0), 0.2)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.7, 0) * euler(0, 0, -0.4), 0.2)
      LH.C0 = clerp(LH.C0, cf(-0.9, -0.8, -0.1) * euler(0, -1.57, 0) * euler(0, 0.7, 0) * euler(0, 0, 0.1), 0.2)
      dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * euler(0.24, 3.14, 0) * cf(-0.6, 0, 0.3), 0.3)
      dwld6.C0 = clerp(dwld6.C0, euler(3.14, 1.57, 0) * euler(-0.24, 0, 0) * cf(-0.6, 1.4, 0.3), 0.3)
      dwld10.C0 = clerp(dwld10.C0, euler(0, -1.57, 0) * euler(2.9, 0, 0) * cf(-0.6, 0.6, -0.1), 0.3)
      dwldb1.C0 = clerp(dwldb1.C0, euler(0, 1.57, 0) * euler(0.24, 3.14, 0) * cf(-0.9, 0, 0.3), 0.3)
      dwldb6.C0 = clerp(dwldb6.C0, euler(3.14, 1.57, 0) * euler(-0.24, 0, 0) * cf(-0.9, 1.4, 0.3), 0.3)
      dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * euler(2.9, 0, 0) * cf(-0.9, 0.6, -0.1), 0.3)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC354: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC354: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    hbwld.Parent = nil
    hboxpos.Parent = hitbox
    hitbox.Parent = modelzorz
    hitbox.Size = vt(0.8, 5.4, 1.3)
    size = 5
    hitboxCF = handle.CFrame * euler(0.14, 0, 0) * cf(0.75, -1, 0)
    hitbox.CFrame = hitboxCF
    blcf = nil
    scfr = nil
    so("200633108", handle, 1, 1.1)
    so("200633148", handle, 1, 1.1)
    for i = 0, 1, 0.1 do
      swait()
      hitboxCF = handle.CFrame * euler(0.14, 0, 0) * cf(0.75, -1, 0)
      hitbox.CFrame = hitboxCF
      MagniDamage(hitbox, size, 5, 6, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(10, 12)), nil, true)
      wld1.C0 = clerp(wld1.C0, euler(1, 0, 0) * cf(0, 1, 0), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(0.1, 0, 0) * euler(0, 0, -0.7), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * euler(0, 0, 0.7), 0.4)
      RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.4, 0, -0.6) * euler(0, 1.6, 0), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.6, 0, -0.6) * euler(0, 0, 0), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.7, 0) * euler(0, 0, 0), 0.4)
      LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.1) * euler(0, -1.57, 0) * euler(0, -0.7, 0) * euler(0, 0, 0.2), 0.4)
      dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * euler(0.24, 3.14, 0) * cf(-0.6, 0.4, 0.3), 0.6)
      dwld6.C0 = clerp(dwld6.C0, euler(3.14, 1.57, 0) * euler(-0.24, 0, 0) * cf(-0.6, 1.8, 0.3), 0.6)
      dwld10.C0 = clerp(dwld10.C0, euler(0, -1.57, 0) * euler(2.9, 0, 0) * cf(-0.6, 1, -0.1), 0.6)
      dwldb1.C0 = clerp(dwldb1.C0, euler(0, 1.57, 0) * euler(0.24, 3.14, 0) * cf(-0.9, 0.4, 0.3), 0.6)
      dwldb6.C0 = clerp(dwldb6.C0, euler(3.14, 1.57, 0) * euler(-0.24, 0, 0) * cf(-0.9, 1.8, 0.3), 0.6)
      dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * euler(2.9, 0, 0) * cf(-0.9, 1, -0.1), 0.6)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC813: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC813: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    hitbox.Parent = modelzorz
    hitbox.Size = vt()
    hitboxweld()
    hboxpos.Parent = nil
  else
    for i = 0, 1, 0.15 do
      swait()
      if Mode == "Dynamic Blade" then
        hwld.C0 = clerp(hwld.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.6)
        dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * cf(0, -5.5, -0.2), 0.6)
        dwld6.C0 = clerp(dwld6.C0, euler(0, 1.57, 0) * euler(-3.64, 0, 0) * cf(0, -3.4, -0.7), 0.6)
        dwld10.C0 = clerp(dwld10.C0, euler(3.14, 1.57, 0) * euler(0.2, 0, 0) * cf(0, -5, -0.8), 0.6)
        dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * cf(0, -5.5, 0.2), 0.6)
        dwldb6.C0 = clerp(dwldb6.C0, euler(0, -1.57, 0) * euler(3.64, 0, 0) * cf(0, -3.4, 0.7), 0.6)
        dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, -1.57, 0) * euler(-0.2, 0, 0) * cf(0, -5, 0.8), 0.6)
      end
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.3), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.8), 0.4)
      RW.C0 = clerp(RW.C0, cf(-0.5, 0.7, -0.5) * euler(2.2, 0, -1), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(2, 0, -0.4) * euler(0, 1, 0), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(0.9, -1, 0.2) * euler(0, 1.57, 0) * euler(0, -0.8, 0), 0.4)
      LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.2) * euler(0, -1.57, 0) * euler(0, -0.8, 0), 0.4)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC1154: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC1154: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    num = 1
    dam1 = 6
    dam2 = 8
    knock = math.random(5, 10)
    stun = math.random(5, 7)
    typ = "Normal"
    if Mode == "Dynamic Blade" then
      num = 2
      dam1 = 7
      dam2 = 9
      knock = math.random(15, 20)
      stun = math.random(6, 8)
      typ = "Normal"
    end
    hbwld.Parent = nil
    hboxpos.Parent = hitbox
    hitbox.Parent = modelzorz
    hitbox.Size = vt(0.5, 5.4, 1)
    size = 5
    so("200633148", prt31, 1, 0.9)
    if Mode == "Dynamic Blade" then
      hitbox.Size = vt(1, 8, 2)
      size = 7
    end
    hitboxCF = prt31.CFrame * cf(0, 0, 0)
    hitbox.CFrame = hitboxCF
    blcf = nil
    scfr = nil
    for i = 0, 1, 0.1 do
      swait()
      hitboxCF = prt31.CFrame * cf(0, 0, 0)
      hitbox.CFrame = hitboxCF
      MagniDamage(hitbox, size, dam1, dam2, knock, typ, RootPart, 0.5, num, stun, nil, true)
      wld1.C0 = clerp(wld1.C0, euler(2, 0, 0) * cf(0, 1, 0), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.3) * euler(0.2, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.8), 0.4)
      RW.C0 = clerp(RW.C0, cf(0.5, 0.3, -0.2) * euler(0.2, 0, -0.3), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-0.8, 0.5, -0.2) * euler(0.3, 0, 0.5) * euler(0, 0.5, 0), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(0.9, -1, -0.3) * euler(0, 1.57, 0) * euler(0, 0.8, 0), 0.4)
      LH.C0 = clerp(LH.C0, cf(-0.9, -1, 0.3) * euler(0, -1.57, 0) * euler(0, 0.8, 0), 0.4)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC1474: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC1474: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    hitbox.Parent = modelzorz
    hitbox.Size = vt()
    hitboxweld()
    hboxpos.Parent = nil
  end
  attack = false
end

attackthree = function()
  attack = true
  if Mode == "Energy Reactor" then
    dynamomove = false
    for i = 0, 1, 0.15 do
      swait()
      hwld.Part1 = RootPart
      wld1.C0 = clerp(wld1.C0, euler(1.4, 0, 0) * cf(0, 1, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0.2, 0, -0.5), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.5), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.2, 0.5, -0.3) * euler(1.5, 0, 0.5) * euler(0, 1.57, 0), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.6) * euler(0, 0, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(0, -0.3, 0) * euler(0, 0, -0.1), 0.3)
      LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.1) * euler(0, -1.57, 0) * euler(0, -0.3, 0) * euler(0, 0, 0.4), 0.3)
      hwld.C0 = clerp(hwld.C0, euler(0, 0, -2.5) * cf(0, 0, 2), 0.6)
      dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0.5) * cf(2, -1, 0) * euler(0, 0, 0) * euler(1.57, 0, 0), 0.6)
      dwld6.C0 = clerp(dwld6.C0, euler(0, 4.71, 0.5) * cf(2, -1, 0) * euler(0, 1.046, 0) * euler(1.57, 0, 0), 0.6)
      dwld10.C0 = clerp(dwld10.C0, euler(3.14, 1.57, 0.5) * cf(2, -1, 0) * euler(0, 2.092, 0) * euler(1.57, 0, 0), 0.6)
      dwldb1.C0 = clerp(dwldb1.C0, euler(0, 1.57, 0.5) * cf(2, -1, 0) * euler(0, 3.138, 0) * euler(1.57, 0, 0), 0.6)
      dwldb6.C0 = clerp(dwldb6.C0, euler(0, 4.71, 0.5) * cf(2, -1, 0) * euler(0, 4.184, 0) * euler(1.57, 0, 0), 0.6)
      dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, 1.57, 0.5) * cf(2, -1, 0) * euler(0, 5.23, 0) * euler(1.57, 0, 0), 0.6)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC431: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC431: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    eulmov = 0
    damov = -2
    ai = 4
    for i = 0, 1, 0.1 do
      swait()
      CF = handle.CFrame * cf(0, 0, damov)
      damov = damov - 3
      if ai % 4 == 0 then
        ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
        ref.Anchored = true
        ref.CFrame = CF
        game:GetService("Debris"):AddItem(ref, 1)
        so("300916105", ref, 1, 2)
        MagicCircle(BrickColor.new(NewCol2), CF, 5, 5, 5, 2, 2, 2, 0.1)
        MagicCircle(BrickColor.new(NewCol2), CF, 1, 1, 1, 3, 3, 3, 0.05)
        MagicRing(BrickColor.new(NewCol2), CF, 1, 1, 1, 0.8, 0.8, 0.2, 0.03)
        MagniDamage(ref, 8, 5, 7, 0, "Normal", RootPart, 0, 1, (math.random(3, 5)), nil, true, true)
      end
      ai = ai + 1
      eulmov = eulmov - 0.4
      wld1.C0 = clerp(wld1.C0, euler(1.4, 0, 0) * cf(0, 1, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0.2, 0, -0.5), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.5), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.2, 0.5, -0.3) * euler(1.5, 0, 0.5) * euler(0, 1.57, 0), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.6) * euler(0, 0, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(0, -0.3, 0) * euler(0, 0, -0.1), 0.3)
      LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.1) * euler(0, -1.57, 0) * euler(0, -0.3, 0) * euler(0, 0, 0.4), 0.3)
      hwld.C0 = clerp(hwld.C0, euler(0, 0, -2.5 - eulmov) * cf(0, 0, 0), 0.3)
      dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0.5) * cf(3, -1, 0) * euler(0, 0, 0) * euler(1.57, 0, 0), 0.2)
      dwld6.C0 = clerp(dwld6.C0, euler(0, 4.71, 0.2) * cf(3, -1.5, 0) * euler(0, 1.046, 0) * euler(1.57, 0, 0), 0.2)
      dwld10.C0 = clerp(dwld10.C0, euler(3.14, 1.57, 0.2) * cf(3, -1.5, 0) * euler(0, 2.092, 0) * euler(1.57, 0, 0), 0.2)
      dwldb1.C0 = clerp(dwldb1.C0, euler(0, 1.57, 0.2) * cf(3, -1.5, 0) * euler(0, 3.138, 0) * euler(1.57, 0, 0), 0.2)
      dwldb6.C0 = clerp(dwldb6.C0, euler(0, 4.71, 0.2) * cf(3, -1.5, 0) * euler(0, 4.184, 0) * euler(1.57, 0, 0), 0.2)
      dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, 1.57, 0.2) * cf(3, -1.5, 0) * euler(0, 5.23, 0) * euler(1.57, 0, 0), 0.2)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC976: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC976: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    dynamomove = true
  else
    for i = 0, 1, 0.15 do
      swait()
      if Mode == "Classic" then
        hwld.C0 = clerp(hwld.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.5)
        dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * cf(-0.6, -1.5, -0.4), 0.5)
        dwld6.C0 = clerp(dwld6.C0, euler(0, 1.57, 0) * cf(-0.6, -0.4, -0.35), 0.5)
        dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * cf(-0.6, 0.5, -0.45), 0.5)
        dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * cf(-0.6, -1.5, 0.4), 0.5)
        dwldb6.C0 = clerp(dwldb6.C0, euler(0, -1.57, 0) * cf(-0.6, -0.4, 0.35), 0.5)
        dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * cf(-0.6, 0.5, 0.45), 0.5)
      end
      if Mode == "Dynamic Blade" then
        hwld.C0 = clerp(hwld.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.6)
        dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * euler(0, 0, 0) * cf(0, -6.5, -0.15), 0.6)
        dwld6.C0 = clerp(dwld6.C0, euler(0, -1.57, 0) * euler(0, 0, 0) * cf(0, -5, -0.4), 0.6)
        dwld10.C0 = clerp(dwld10.C0, euler(3.14, 1.57, 0) * cf(0, -4, -0.5), 0.6)
        dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * euler(0, 0, 0) * cf(0, -6.5, 0.15), 0.6)
        dwldb6.C0 = clerp(dwldb6.C0, euler(0, 1.57, 0) * euler(0, 0, 0) * cf(0, -5, 0.4), 0.6)
        dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, -1.57, 0) * cf(0, -4, 0.5), 0.6)
      end
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.5), 0.3)
      wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.4, 0, 0.2), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-0.5, 0.5, -0.5) * euler(1.57, 0, 1) * euler(0, -1.57, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, -0.4), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.5, 0.1), 0.3)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC1455: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC1455: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    num = 1
    dam1 = 4
    dam2 = 6
    knock = math.random(5, 10)
    stun = math.random(5, 7)
    typ = "Normal"
    if Mode == "Dynamic Blade" then
      num = 2
      dam1 = 5
      dam2 = 7
      knock = math.random(10, 15)
      stun = math.random(6, 8)
      typ = "Normal"
    end
    hbwld.Parent = nil
    hboxpos.Parent = hitbox
    hitbox.Parent = modelzorz
    hitbox.Size = vt(0.5, 5.4, 1)
    size = 5
    so("200633108", prt31, 1, 1.1)
    if Mode == "Dynamic Blade" then
      hitbox.Size = vt(1, 8, 2)
      size = 7
    end
    hitboxCF = prt31.CFrame * cf(0, 0, 0)
    hitbox.CFrame = hitboxCF
    blcf = nil
    scfr = nil
    for i = 0, 1, 0.15 do
      swait()
      hitboxCF = prt31.CFrame * cf(0, 0, 0)
      hitbox.CFrame = hitboxCF
      MagniDamage(hitbox, size, dam1, dam2, knock, typ, RootPart, 0.2, num, stun, nil, true)
      wld1.C0 = clerp(wld1.C0, euler(2.5, 0, 0) * cf(0, 1, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.3)
      RootJoint.C0 = RootCF * euler(0, 0, -0.5 + 6.28 * i)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 1), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, -1.57) * euler(0, -1.57, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.3)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC1765: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC1765: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    for i = 0, 1, 0.2 do
      swait()
      hitboxCF = prt31.CFrame * cf(0, 0, 0)
      hitbox.CFrame = hitboxCF
      MagniDamage(hitbox, size, dam1, dam2, knock, typ, RootPart, 0.2, num, stun, nil, true)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.4), 0.3)
      wld1.C0 = clerp(wld1.C0, euler(2.5, 0, 0) * cf(0, 1, 0), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 1), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.3, 0, -1.57) * euler(0, -1.2, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC1937: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC1937: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    hitbox.Parent = modelzorz
    hitbox.Size = vt()
    hitboxweld()
    hboxpos.Parent = nil
  end
  attack = false
end

attackfour = function()
  attack = true
  if Mode == "Energy Reactor" then
    dynamomove = false
    for i = 0, 1, 0.1 do
      swait()
      hwld.Part1 = RootPart
      wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.5) * euler(-0.6, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.5), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.2, 0.5, -0.3) * euler(1.5, 0, 0.5) * euler(0, 1.57, 0) * euler(0, 0, 1), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.6) * euler(0, 0, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(0, -0.3, 0) * euler(0, 0, -0.1), 0.3)
      LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.1) * euler(0, -1.57, 0) * euler(0, -0.3, 0) * euler(0, 0, 0.4), 0.3)
      hwld.C0 = clerp(hwld.C0, euler(0, 0, 1) * euler(1.2, 0, 0) * cf(0, -8, 0), 0.3)
      dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, -1) * cf(1, -0.5, 0) * euler(0, 0, 0) * euler(1.57, 0, 0), 0.3)
      dwld6.C0 = clerp(dwld6.C0, euler(0, 4.71, -1) * cf(1, -0.5, 0) * euler(0, 1.046, 0) * euler(1.57, 0, 0), 0.3)
      dwld10.C0 = clerp(dwld10.C0, euler(3.14, 1.57, -1) * cf(1, -0.5, 0) * euler(0, 2.092, 0) * euler(1.57, 0, 0), 0.3)
      dwldb1.C0 = clerp(dwldb1.C0, euler(0, 1.57, -1) * cf(1, -0.5, 0) * euler(0, 3.138, 0) * euler(1.57, 0, 0), 0.3)
      dwldb6.C0 = clerp(dwldb6.C0, euler(0, 4.71, -1) * cf(1, -0.5, 0) * euler(0, 4.184, 0) * euler(1.57, 0, 0), 0.3)
      dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, 1.57, -1) * cf(1, -0.5, 0) * euler(0, 5.23, 0) * euler(1.57, 0, 0), 0.3)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC443: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC443: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    eul = 0
    dov = 0
    doi = 0
    for i = 0, 1, 0.05 do
      swait()
      eul = eul + 0.4
      dov = dov + 0.05
      doi = doi + 1
      hwld.Part1 = RootPart
      if doi % 2 == 0 then
        lhit,lpos = rayCast(handle.Position, handle.CFrame.lookVector, 100, Character)
        local mag = (handle.Position - lpos).magnitude
        MagicHead2(BrickColor.new(NewCol2), CFrame.new((handle.Position + lpos) / 2, lpos) * angles(1.57, 0, 0), 12, mag * 5, 12, 0.4, 1, 0.4, 0.2)
        if lhit ~= nil then
          so("301031757", handle, 0.6, 1.5)
          ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
          ref.Anchored = true
          ref.CFrame = cf(lpos)
          game:GetService("Debris"):AddItem(ref, 1)
          MagniDamage(ref, 8, 4, 6, 0, "Normal", RootPart, 0.4, 1, (math.random(3, 5)), nil, true, true)
          MagicRing(BrickColor.new(NewCol2), cf(lpos) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 5, 5, 1, 0.8, 0.8, 0.2, 0.1)
          MagicCircle(BrickColor.new(NewCol2), cf(lpos), 20, 20, 20, 3, 3, 3, 0.1)
        end
      end
      do
        wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.5) * euler(0, 0, 0), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.5), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.2, 0.5, -0.3) * euler(1.5, 0, 0.5) * euler(0, 1.57, 0), 0.3)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.6) * euler(0, 0, 0), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(0, -0.3, 0) * euler(0, 0, -0.1), 0.3)
        LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.1) * euler(0, -1.57, 0) * euler(0, -0.3, 0) * euler(0, 0, 0.4), 0.3)
        hwld.C0 = clerp(hwld.C0, euler(1.2 - dov, 0, 0) * cf(0, -8, eul) * euler(0, 0, 0), 0.3)
        dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, -1) * cf(1, -0.5, 0) * euler(0, 0 + eul, 0) * euler(1.57, 0, 0), 0.3)
        dwld6.C0 = clerp(dwld6.C0, euler(0, 4.71, -1) * cf(1, -0.5, 0) * euler(0, 1.046 + eul, 0) * euler(1.57, 0, 0), 0.3)
        dwld10.C0 = clerp(dwld10.C0, euler(3.14, 1.57, -1) * cf(1, -0.5, 0) * euler(0, 2.092 + eul, 0) * euler(1.57, 0, 0), 0.3)
        dwldb1.C0 = clerp(dwldb1.C0, euler(0, 1.57, -1) * cf(1, -0.5, 0) * euler(0, 3.138 + eul, 0) * euler(1.57, 0, 0), 0.3)
        dwldb6.C0 = clerp(dwldb6.C0, euler(0, 4.71, -1) * cf(1, -0.5, 0) * euler(0, 4.184 + eul, 0) * euler(1.57, 0, 0), 0.3)
        dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, 1.57, -1) * cf(1, -0.5, 0) * euler(0, 5.23 + eul, 0) * euler(1.57, 0, 0), 0.3)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC1051: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC1051: LeaveBlock: unexpected jumping out IF_STMT

            -- DECOMPILER ERROR at PC1051: LeaveBlock: unexpected jumping out DO_STMT

          end
        end
      end
    end
    dynamomove = true
  else
    if Mode == "Classic" then
      for i = 0, 1, 0.1 do
        swait()
        Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0) * euler(0, 0, -0.5), 0.2)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -0.3), 0.2)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.4, 0, 0.4) * euler(0, 0, 0), 0.2)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.2, 0, -0.2) * euler(0, 0, 0), 0.2)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
        RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.3, 0) * euler(0, 0, -0.4), 0.2)
        LH.C0 = clerp(LH.C0, cf(-0.9, -0.8, -0.1) * euler(0, -1.57, 0) * euler(0, 0.3, 0) * euler(0, 0, 0.1), 0.2)
        dwld1.C0 = clerp(dwld1.C0, euler(3.14, 1.57, 0) * euler(-0.23, 0, 0) * cf(-0.6, 2.1, -0.5), 0.4)
        dwld6.C0 = clerp(dwld6.C0, euler(0, -1.57, 0) * euler(-1, 0, 0) * cf(-0.6, 0.8, -1.1), 0.4)
        dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * cf(-0.6, 0.6, -0.2), 0.4)
        dwldb1.C0 = clerp(dwldb1.C0, euler(3.14, -1.57, 0) * euler(0.23, 0, 0) * cf(-0.6, 2.1, 0.5), 0.4)
        dwldb6.C0 = clerp(dwldb6.C0, euler(0, 1.57, 0) * euler(1, 0, 0) * cf(-0.6, 0.8, 1.1), 0.4)
        dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * cf(-0.6, 0.6, 0.2), 0.4)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC1395: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC1395: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      hbwld.Parent = nil
      hboxpos.Parent = hitbox
      hitbox.Parent = modelzorz
      hitbox.Size = vt(0.8, 4.5, 2.5)
      hitboxCF = handle.CFrame * cf(0.75, -1.9, 0)
      hitbox.CFrame = hitboxCF
      blcf = nil
      scfr = nil
      so("200633196", handle, 1, 0.8)
      for i = 0, 1, 0.1 do
        swait()
        hitboxCF = handle.CFrame * cf(0.75, -1.9, 0)
        hitbox.CFrame = hitboxCF
        MagniDamage(hitbox, 4, 7, 8, math.random(10, 20), "Normal", RootPart, 0.5, 1, (math.random(10, 12)), nil, true)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0.2, 0, -0.5), 0.4)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.5), 0.4)
        RW.C0 = clerp(RW.C0, cf(1.2, 0.5, -0.3) * euler(1.5, 0, -0.2) * euler(0, 1, 0), 0.4)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.6) * euler(0, 0, 0), 0.4)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
        RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(0, -0.3, 0) * euler(0, 0, -0.1), 0.4)
        LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.1) * euler(0, -1.57, 0) * euler(0, -0.3, 0) * euler(0, 0, 0.4), 0.4)
        dwld1.C0 = clerp(dwld1.C0, euler(3.14, 1.57, 0) * euler(-0.23, 0, 0) * cf(-0.6, 2.5, -0.5), 0.4)
        dwld6.C0 = clerp(dwld6.C0, euler(0, -1.57, 0) * euler(-1, 0, 0) * cf(-0.6, 1.2, -1.1), 0.4)
        dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * cf(-0.6, 1, -0.2), 0.4)
        dwldb1.C0 = clerp(dwldb1.C0, euler(3.14, -1.57, 0) * euler(0.23, 0, 0) * cf(-0.6, 2.5, 0.5), 0.4)
        dwldb6.C0 = clerp(dwldb6.C0, euler(0, 1.57, 0) * euler(1, 0, 0) * cf(-0.6, 1.2, 1.1), 0.4)
        dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * cf(-0.6, 1, 0.2), 0.4)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC1804: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC1804: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      hitbox.Parent = modelzorz
      hitbox.Size = vt()
      hitboxweld()
      hboxpos.Parent = nil
    else
      for i = 0, 1, 0.15 do
        swait()
        if Mode == "Dynamic Blade" then
          hwld.C0 = clerp(hwld.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.6)
          dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * euler(0, 0, 0) * cf(0, -4.5, -0.45), 0.3)
          dwld6.C0 = clerp(dwld6.C0, euler(0, -1.57, 0) * euler(0, 0, 0) * cf(0, -2.2, -0.55), 0.3)
          dwld10.C0 = clerp(dwld10.C0, euler(3.14, 1.57, 0) * cf(0, -7.2, -0.2), 0.3)
          dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * euler(0, 0, 0) * cf(0, -4.5, 0.45), 0.3)
          dwldb6.C0 = clerp(dwldb6.C0, euler(0, 1.57, 0) * euler(0, 0, 0) * cf(0, -2.2, 0.55), 0.3)
          dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, -1.57, 0) * cf(0, -7.2, 0.2), 0.3)
        end
        wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0.8) * cf(0, 1, 0), 0.3)
        Neck.C0 = clerp(Neck.C0, necko * euler(-0.4, 0, 0), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
        RW.C0 = clerp(RW.C0, cf(1, 1, -0.5) * euler(2.8, 0, -0.8) * euler(0, 0, 0), 0.3)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-1, 1, -0.5) * euler(2.8, 0, 0.8), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
        LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.3)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC2163: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC2163: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      num = 1
      dam1 = 6
      dam2 = 8
      knock = math.random(5, 10)
      stun = math.random(5, 7)
      typ = "Normal"
      if Mode == "Dynamic Blade" then
        num = 2
        dam1 = 7
        dam2 = 9
        knock = math.random(15, 20)
        stun = math.random(6, 8)
        typ = "Normal"
      end
      hbwld.Parent = nil
      hboxpos.Parent = hitbox
      hitbox.Parent = modelzorz
      hitbox.Size = vt(0.5, 5.4, 1)
      size = 5
      if Mode == "Dynamic Blade" then
        hitbox.Size = vt(1, 10, 3)
        size = 8
      end
      hitboxCF = prt31.CFrame * cf(0, 0, 0)
      hitbox.CFrame = hitboxCF
      blcf = nil
      scfr = nil
      so("200633196", prt31, 1, 1)
      for i = 0, 1, 0.1 do
        swait()
        if Mode == "Dynamic Blade" then
          hitboxCF = prt31.CFrame * cf(0, 1, 0)
          hitbox.CFrame = hitboxCF
        else
          hitboxCF = prt31.CFrame * cf(0, 1, 0)
          hitbox.CFrame = hitboxCF
        end
        MagniDamage(hitbox, size, dam1, dam2, knock, typ, RootPart, 0.5, num, stun, nil, true)
        if Mode == "Dynamic Blade" then
          hwld.C0 = clerp(hwld.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.6)
          dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * euler(0, 0, 0) * cf(0, -4.5, -0.45), 0.3)
          dwld6.C0 = clerp(dwld6.C0, euler(0, -1.57, 0) * euler(0, 0, 0) * cf(0, -2.2, -0.55), 0.3)
          dwld10.C0 = clerp(dwld10.C0, euler(3.14, 1.57, 0) * cf(0, -7.2, -0.2), 0.3)
          dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * euler(0, 0, 0) * cf(0, -4.5, 0.45), 0.3)
          dwldb6.C0 = clerp(dwldb6.C0, euler(0, 1.57, 0) * euler(0, 0, 0) * cf(0, -2.2, 0.55), 0.3)
          dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, -1.57, 0) * cf(0, -7.2, 0.2), 0.3)
        end
        wld1.C0 = clerp(wld1.C0, euler(2, 0, 0.8) * cf(0, 1, 0), 0.6)
        Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, 0), 0.4)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
        RW.C0 = clerp(RW.C0, cf(1, 0.1, -0.5) * euler(0.2, 0, -0.8) * euler(0, 0, 0), 0.4)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
        LW.C0 = clerp(LW.C0, cf(-1, 0.1, -0.5) * euler(0.2, 0, 0.8), 0.4)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
        RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.4)
        LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.4)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC2646: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC2646: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      hitbox.Parent = modelzorz
      hitbox.Size = vt()
      hitboxweld()
      hboxpos.Parent = nil
    end
  end
  attack = false
  if Mode == "Classic" then
    for i = 0, 1, 0.1 do
      swait()
      dwld1.C0 = clerp(dwld1.C0, euler(3.14, 1.57, 0) * euler(-0.23, 0, 0) * cf(-0.6, 1.6, -0.5), 0.4)
      dwld6.C0 = clerp(dwld6.C0, euler(0, -1.57, 0) * euler(-1, 0, 0) * cf(-0.6, 0.3, -1.1), 0.4)
      dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * cf(-0.6, 0.1, -0.2), 0.4)
      dwldb1.C0 = clerp(dwldb1.C0, euler(3.14, -1.57, 0) * euler(0.23, 0, 0) * cf(-0.6, 1.6, 0.5), 0.4)
      dwldb6.C0 = clerp(dwldb6.C0, euler(0, 1.57, 0) * euler(1, 0, 0) * cf(-0.6, 0.3, 1.1), 0.4)
      dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * cf(-0.6, 0.1, 0.2), 0.4)
      if Mode ~= "Classic" then
        break
      end
    end
  end
end

ModeChange = function()
  attack = true
  Mode = "Changing"
  passive1.Value = 0
  passive2.Value = 0
  passive3.Value = 0
  hwld.Part1 = RootPart
  if Mode == "Classic" then
    hwld.C0 = euler(0, 0, 0) * cf(-2, 0, 0)
  else
    if Mode == "Dynamic Blade" then
      hwld.C0 = euler(1.57, 0, 0) * cf(2, 0, 0)
    end
  end
  randangle = math.random(-50, 50)
  for i = 0, 1, 0.1 do
    swait()
    hwld.C0 = clerp(hwld.C0, euler(0, randangle, 0) * cf(0, 0, 0), 0.3)
    dwld1.C0 = clerp(dwld1.C0, euler(0, 0, -0.5) * cf(4, 1.5, 0) * euler(0, 0, 0), 0.3)
    dwld6.C0 = clerp(dwld6.C0, euler(0, 3.14, -0.5) * cf(4, 1.5, 0) * euler(0, 1.046, 0), 0.3)
    dwld10.C0 = clerp(dwld10.C0, euler(3.14, 0, -0.5) * cf(4, 1.5, 0) * euler(0, 2.092, 0), 0.3)
    dwldb1.C0 = clerp(dwldb1.C0, euler(0, 0, -0.5) * cf(4, 1.5, 0) * euler(0, 3.138, 0), 0.3)
    dwldb6.C0 = clerp(dwldb6.C0, euler(0, 3.14, -0.5) * cf(4, 1.5, 0) * euler(0, 4.184, 0), 0.3)
    dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, 0, -0.5) * cf(4, 1.5, 0) * euler(0, 5.23, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 1.57) * euler(0, 0, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1.57) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC395: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC395: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  round = 0
  choosemode = true
  while choosemode == true do
    swait()
    hwld.C0 = euler(0, randangle, 0) * euler(0, round, 0)
    dwld1.C0 = clerp(dwld1.C0, euler(0, 0, -0.5) * cf(4, 1.5, 0) * euler(0, 0, 0), 0.3)
    dwld6.C0 = clerp(dwld6.C0, euler(0, 3.14, -0.5) * cf(4, 1.5, 0) * euler(0, 1.046, 0), 0.3)
    dwld10.C0 = clerp(dwld10.C0, euler(3.14, 0, -0.5) * cf(4, 1.5, 0) * euler(0, 2.092, 0), 0.3)
    dwldb1.C0 = clerp(dwldb1.C0, euler(0, 0, -0.5) * cf(4, 1.5, 0) * euler(0, 3.138, 0), 0.3)
    dwldb6.C0 = clerp(dwldb6.C0, euler(0, 3.14, -0.5) * cf(4, 1.5, 0) * euler(0, 4.184, 0), 0.3)
    dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, 0, -0.5) * cf(4, 1.5, 0) * euler(0, 5.23, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 1.57) * euler(0, 0, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1.57) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.3)
    round = round + 0.01
    if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
      choosemode = false
      dynamove = false
      Mode = "Classic"
      break
    end
  end
  attack = false
end

Defend = function()
  attack = true
  defending = true
  passive4.Parent = Decrease
  passive5.Parent = Decrease
  local eulmove = 0
      while defending == true do
          swait()
          if Mode == "Classic" then
            hwld.C0 = clerp(hwld.C0, euler(1.57, 0, 0) * cf(0, 0, 0), 0.3)
            dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * cf(-0.6, 1, -0.15), 0.3)
            dwld6.C0 = clerp(dwld6.C0, euler(0, -1.57, 0) * euler(2.2, 0, 0) * cf(-0.6, 0, 1.2), 0.3)
            dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * euler(0, 3.14, 0) * cf(-0.6, -0.8, -0.6), 0.3)
            dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * cf(-0.6, 1, 0.15), 0.3)
            dwldb6.C0 = clerp(dwldb6.C0, euler(0, 1.57, 0) * euler(-2.2, 0, 0) * cf(-0.6, 0, -1.2), 0.3)
            dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * euler(0, 3.14, 0) * cf(-0.6, -0.8, 0.6), 0.3)
            wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
            Neck.C0 = clerp(Neck.C0, necko * euler(0.3, 0, 0) * euler(0, 0, -0.2), 0.3)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.8), 0.3)
            RW.C0 = clerp(RW.C0, cf(1, 0.45, -0.5) * euler(1.57, 0, -0.8) * euler(0, 0, 0), 0.3)
            RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.6) * euler(0, -0.2, 0), 0.3)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
            RH.C0 = clerp(RH.C0, cf(1.2, -1, 0.2) * euler(0, 1.57, 0) * euler(0, -0.8, 0) * euler(0, 0, -0.1), 0.3)
            LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.4) * euler(0, -1.57, 0) * euler(0, -0.5, 0) * euler(0, 0, 0.6), 0.3)
            -- DECOMPILER ERROR at PC371: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC371: LeaveBlock: unexpected jumping out IF_STMT

            -- DECOMPILER ERROR at PC371: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC371: LeaveBlock: unexpected jumping out IF_STMT

          end
      if Mode == "Dynamic Blade" then
        hwld.C0 = clerp(hwld.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.3)
        dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * cf(0, -4.5, -0.45), 0.3)
        dwld6.C0 = clerp(dwld6.C0, euler(0, 1.57, 0) * euler(-3.34, 0, 0) * cf(0, -3.2, -0.6), 0.3)
        dwld10.C0 = clerp(dwld10.C0, euler(3.14, 1.57, 0) * euler(0.3, 0, 0) * cf(0, -4.8, -0.85), 0.3)
        dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * cf(0, -4.5, 0.45), 0.3)
        dwldb6.C0 = clerp(dwldb6.C0, euler(0, -1.57, 0) * euler(3.34, 0, 0) * cf(0, -3.2, 0.6), 0.3)
        dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, -1.57, 0) * euler(-0.3, 0, 0) * cf(0, -4.8, 0.85), 0.3)
        wld1.C0 = clerp(wld1.C0, euler(1.57, 0, -1.57) * euler(-0.8, 0, 0) * euler(0, 0, -0.4) * cf(0, 1.2, -0.2), 0.3)
        Neck.C0 = clerp(Neck.C0, necko * euler(0.3, 0, 0) * euler(0, 0, -0.2), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.8), 0.3)
        RW.C0 = clerp(RW.C0, cf(0.5, 0.6, -0.5) * euler(0, 0, -2.2) * euler(0.2, 0, 0), 0.3)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-1, 0.6, -0.5) * euler(2.5, 0, 0.2) * euler(0, 0, -0.5) * euler(0, -2.2, 0), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(1.2, -1, 0.2) * euler(0, 1.57, 0) * euler(0, -0.8, 0) * euler(0, 0, -0.1), 0.3)
        LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.4) * euler(0, -1.57, 0) * euler(0, -0.5, 0) * euler(0, 0, 0.6), 0.3)
        -- DECOMPILER ERROR at PC745: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC745: LeaveBlock: unexpected jumping out IF_STMT

      end
    if Mode == "Energy Reactor" then
      eulmove = eulmove + 0.2
      dynamomove = false
      hwld.Part1 = RootPart
      wld1.C0 = clerp(wld1.C0, euler(1.8, 0, 0) * cf(0, 1, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0.4, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0), 0.3)
      RW.C0 = clerp(RW.C0, cf(0.5, 0.5, -0.5) * euler(1.4, 0, 0) * euler(0, 0, -1.3), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-0.5, 0.5, -0.5) * euler(2, 0, 0) * euler(0, 0, 1.3) * euler(0, -1.5, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.2) * euler(0, 1.57, 0) * euler(0, 0, 0) * euler(0, 0, -0.1), 0.3)
      LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.1) * euler(0, -1.57, 0) * euler(0, 0, 0) * euler(0, 0, 0.4), 0.3)
      hwld.C0 = clerp(hwld.C0, euler(0, 0, -2.5 - (eulmove)) * cf(0, -0.5, 1), 0.3)
      dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 1.4) * cf(2, -1, 0) * euler(0, 0, 0) * euler(1.57, 0, 0), 0.3)
      dwld6.C0 = clerp(dwld6.C0, euler(0, 4.71, 1.4) * cf(2, -1, 0) * euler(0, 1.046, 0) * euler(1.57, 0, 0), 0.3)
      dwld10.C0 = clerp(dwld10.C0, euler(3.14, 1.57, 1.4) * cf(2, -1, 0) * euler(0, 2.092, 0) * euler(1.57, 0, 0), 0.3)
      dwldb1.C0 = clerp(dwldb1.C0, euler(0, 1.57, 1.4) * cf(2, -1, 0) * euler(0, 3.138, 0) * euler(1.57, 0, 0), 0.3)
      dwldb6.C0 = clerp(dwldb6.C0, euler(0, 4.71, 1.4) * cf(2, -1, 0) * euler(0, 4.184, 0) * euler(1.57, 0, 0), 0.3)
      dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, 1.57, 1.4) * cf(2, -1, 0) * euler(0, 5.23, 0) * euler(1.57, 0, 0), 0.3)
    end
  end
  defending = false
  dynamomove = true
  passive4.Parent = nil
  passive5.Parent = nil
  attack = false
end

do1 = function()
  if attack == true then
    return 
  end
    attack = true
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[1] and mana.Value >= 15 then
    Mode = "Classic"
    manainc = 13
    choosemode = false
    passive1.Value = 0.1
    passive2.Value = -0.05
    passive3.Value = -0.1
    cooldowns[1] = 0
    ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
    ref.Anchored = true
    ref.CFrame = RightArm.CFrame * cf(0.6, 1, 0)
    game:GetService("Debris"):AddItem(ref, 10)
    dul = 0
    dulinc = 0
    so("203691326", handle, 0.6, 1.8)
    for i = 0, 1, 0.1 do
      swait()
      dul = dul + dulinc
      dulinc = dulinc + 0.08
      ref.CFrame = RightArm.CFrame * cf(0.6, -1 - dulinc * 2, 0)
      hwld.Part1 = RightArm
      hwld.C0 = clerp(hwld.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.5)
      dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * euler(0, 1.57, -3.14) * cf(-1.5, 0.5, 0) * euler(0, dul, 0) * cf(-0.6, 0, 0), 0.5)
      dwld6.C0 = clerp(dwld6.C0, euler(0, 1.57, 0) * euler(0, 0, 3.14) * cf(0, 0.5, 1.5) * euler(0, dul, 0) * cf(-0.6, 0, 0), 0.5)
      dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * cf(-0.6, 0, -0.2), 0.5)
      dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * euler(0, 1.57, -3.14) * cf(1.5, 0.5, 0) * euler(0, dul, 0) * cf(-0.6, 0, 0), 0.5)
      dwldb6.C0 = clerp(dwldb6.C0, euler(0, -1.57, 0) * euler(0, 0, 3.14) * cf(0, 0.5, -1.5) * euler(0, dul, 0) * cf(-0.6, 0, 0), 0.5)
      dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * cf(-0.6, 0, 0.2), 0.5)
      wld1.C0 = clerp(wld1.C0, euler(1.4, 0, 0) * cf(0, 1, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0.3, 0, -0.4), 0.2)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.2), 0.2)
      RW.C0 = clerp(RW.C0, cf(1.3, 0.45, 0.2) * euler(1.4, 0, 0.8) * euler(0, 1, 0), 0.2)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.2) * euler(0, 0.5, 0), 0.2)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.2) * euler(0, 1.57, 0) * euler(0, -0.2, 0) * euler(0, 0, 0.1), 0.2)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0.1) * euler(0, -1.57, 0) * euler(0, 0, 0) * euler(0, 0, 0.3), 0.2)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC525: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC525: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    mana.Value = mana.Value - 15
    RecentEnemy.Value = nil
    da = 0
    so("200633281", handle, 0.6, 1.2)
    so("200633108", handle, 0.6, 1)
    for i = 0, 1, 0.1 do
      swait()
      dul = dul + 0.5
      if i <= 0.5 then
        da = da + 0.9
      end
      ref.CFrame = RightArm.CFrame * cf(0.6, -1 - da, 0)
      MagniDamage(ref, 5, 6, 8, math.random(40, 60), "Knockdown2", RootPart, 0.6, 1, (math.random(6, 8)), nil, true, false, "Damage", 0.4, 300)
      hwld.Part1 = RightArm
      hwld.C0 = clerp(hwld.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.5)
      dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * euler(0, 1.57, -2.84) * cf(-1, 6, 0) * euler(0, dul, 0) * cf(-0.6, 0, 0), 0.3)
      dwld6.C0 = clerp(dwld6.C0, euler(0, 1.57, 0) * euler(-0.3, 0, 3.14) * cf(0, 6, 1) * euler(0, dul, 0) * cf(-0.6, 0, 0), 0.3)
      dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * cf(-0.6, 0, -0.35), 0.3)
      dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * euler(0, 1.57, -3.44) * cf(1, 6, 0) * euler(0, dul, 0) * cf(-0.6, 0, 0), 0.3)
      dwldb6.C0 = clerp(dwldb6.C0, euler(0, -1.57, 0) * euler(0.3, 0, 3.14) * cf(0, 6, -1) * euler(0, dul, 0) * cf(-0.6, 0, 0), 0.3)
      dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * cf(-0.6, 0, 0.35), 0.3)
      wld1.C0 = clerp(wld1.C0, euler(1.4, 0, 0) * cf(0, 1, 0), 0.5)
      Neck.C0 = clerp(Neck.C0, necko * euler(0.3, 0, -0.6), 0.5)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.6), 0.5)
      RW.C0 = clerp(RW.C0, cf(1, 0.45, -0.6) * euler(1.4, 0, 0.4) * euler(0, 1, 0), 0.5)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.6, 0, -0.4) * euler(0, 0.5, 0), 0.5)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.4, 0) * euler(0, 0, -0.1), 0.5)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, -0.6, 0) * euler(0, 0, 0.3), 0.5)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC1010: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC1010: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    if overload >= 50 and RecentEnemy.Value ~= nil then
      for i = 0, 1, 0.1 do
        swait()
        hwld.C0 = clerp(hwld.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.4)
        dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * cf(-0.6, -1.5, -0.4), 0.4)
        dwld6.C0 = clerp(dwld6.C0, euler(0, 1.57, 0) * cf(-0.6, -0.4, -0.35), 0.4)
        dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * cf(-0.6, 0.5, -0.45), 0.4)
        dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * cf(-0.6, -1.5, 0.4), 0.4)
        dwldb6.C0 = clerp(dwldb6.C0, euler(0, -1.57, 0) * cf(-0.6, -0.4, 0.35), 0.4)
        dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * cf(-0.6, 0.5, 0.45), 0.4)
        wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0.4, 0, 0), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0), 0.3)
        RW.C0 = clerp(RW.C0, cf(0.5, 0.5, -0.5) * euler(1.4, 0, 0) * euler(0, 0, -1.3) * euler(0, 1.5, 0), 0.3)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-0.5, 0.5, -0.5) * euler(1.2, 0, 0) * euler(0, 0, 1) * euler(0, -1.5, 0), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.2) * euler(0, 1.57, 0) * euler(0, 0, 0) * euler(0, 0, -0.1), 0.3)
        LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.1) * euler(0, -1.57, 0) * euler(0, 0, 0) * euler(0, 0, 0.4), 0.3)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC1379: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC1379: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
          overload = overload - 50
          MagicWave(BrickColor.new(NewCol2), cf(RootPart.Position) * cf(0, -2, 0), 1, 5, 1, 1, -0.2, 1, 0.07)
          --[[dec = Stats:FindFirstChild("Decrease")
          if dec ~= nil then
            for _,c in pairs(dec:children()) do
              if c.className == "NumberValue" and c.Value > 0 and c:findFirstChild("Duration") ~= nil then
                c.Parent = nil
              end
            end
          end--]]
          do
            DecreaseStat(Character, "Damage", -0.4, 350)
            DecreaseStat(Character, "Defense", -0.4, 350)
            for i = 0, 1, 0.1 do
              swait()
              hwld.C0 = clerp(hwld.C0, euler(-0.5, 0, 0) * cf(0, 1, 0), 0.4)
              dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * cf(-0.6, -1.5, -0.4), 0.4)
              dwld6.C0 = clerp(dwld6.C0, euler(0, 1.57, 0) * cf(-0.6, -0.4, -0.35), 0.4)
              dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * cf(-0.6, 0.5, -0.45), 0.4)
              dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * cf(-0.6, -1.5, 0.4), 0.4)
              dwldb6.C0 = clerp(dwldb6.C0, euler(0, -1.57, 0) * cf(-0.6, -0.4, 0.35), 0.4)
              dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * cf(-0.6, 0.5, 0.45), 0.4)
              wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
              Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0.5, 0, 0), 0.3)
              RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0), 0.3)
              RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.57) * euler(0, 1.5, 0), 0.3)
              RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
              LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, -1.57) * euler(0, -1.5, 0), 0.3)
              LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
              RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0) * euler(0, 0, 0), 0.3)
              LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0) * euler(0, 0, 0), 0.3)
              if Stagger.Value ~= true and StunT.Value > Stun.Value then
                do
                  if StaggerHit.Value == true then
                    break
                  end
                  -- DECOMPILER ERROR at PC1810: LeaveBlock: unexpected jumping out IF_THEN_STMT

                  -- DECOMPILER ERROR at PC1810: LeaveBlock: unexpected jumping out IF_STMT

                end
              end
            end
        end
      end
    end
  end
            attack = false
end

do2 = function()
  if attack == true then
    return 
  end
    attack = true
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[2] and mana.Value >= 20 then
    Mode = "Dynamic Blade"
    manainc = 18
    choosemode = false
    passive1.Value = -0.1
    passive2.Value = 0.1
    passive3.Value = 0.1
    cooldowns[2] = 0
    for i = 0, 1, 0.2 do
      swait()
      hwld.Part1 = prt1
      hwld.C0 = clerp(hwld.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.5)
      dwld1.C0 = clerp(dwld1.C0, euler(3.14, 1.57, 0) * euler(-0.28, 0, 0) * euler(0, 0, 3.14) * cf(0, -6, -0.6), 0.7)
      dwld6.C0 = clerp(dwld6.C0, euler(0, -1.57, 0) * euler(0.4, 0, 0) * euler(0, 0, 0) * cf(0, -5, -1.2), 0.7)
      dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * euler(0, 0, 3.14) * cf(0, -4, -0.5), 0.7)
      dwldb1.C0 = clerp(dwldb1.C0, euler(3.14, -1.57, 0) * euler(0.28, 0, 0) * euler(0, 0, 3.14) * cf(0, -6, 0.6), 0.7)
      dwldb6.C0 = clerp(dwldb6.C0, euler(0, 1.57, 0) * euler(-0.4, 0, 0) * euler(0, 0, 0) * cf(0, -5, 1.2), 0.7)
      dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * euler(0, 0, 3.14) * cf(0, -4, 0.5), 0.7)
      wld1.C0 = clerp(wld1.C0, euler(0.6, 0, 0) * cf(0, 1.1, 0.2), 0.7)
      Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, -0.8), 0.5)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.8), 0.5)
      RW.C0 = clerp(RW.C0, cf(-0.1, 0.5, -0.5) * euler(1.5, 0, -1) * euler(0, -1.5, 0), 0.5)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
      LW.C0 = clerp(LW.C0, cf(-0.5, 0.5, -0.5) * euler(1.57, 0, -1.7) * euler(0, -1.57, 0), 0.5)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
      RH.C0 = clerp(RH.C0, cf(0.9, -1, 0.2) * euler(0, 1.57, 0) * euler(0, -0.8, 0), 0.5)
      LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.2) * euler(0, -1.57, 0) * euler(0, -0.8, 0), 0.5)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC432: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC432: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    MagicWave(BrickColor.new(NewCol2), handle.CFrame * euler(3.14, 0, 0) * cf(0, -6, 0), 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.05)
    mana.Value = mana.Value - 20
    hbwld.Parent = nil
    hboxpos.Parent = hitbox
    hitbox.Parent = modelzorz
    hitbox.Size = vt(1, 8, 2)
    RecentEnemy.Value = nil
    da = 0
    so("200633148", handle, 1, 0.8)
    so("199145327", handle, 0.6, 1)
    for i = 0, 1, 0.1 do
      swait()
      da = da + 1
      if da % 3 == 0 then
        MagicWave(BrickColor.new(NewCol2), handle.CFrame * euler(3.14, math.random(-50, 50), 0) * cf(0, -6, 0), 1, 1, 1, 0.5, 0.5, 0.5, 0.2)
      end
      hitboxCF = prt31.CFrame * cf(0, 0, 0)
      hitbox.CFrame = hitboxCF
      MagniDamage(hitbox, 6, 5, 7, math.random(20, 30), "Normal", RootPart, 0.2, 2, (math.random(4, 7)), nil, true)
      if Rooted.Value == false then
        Torso.Velocity = RootPart.CFrame.lookVector * 80
      end
      wld1.C0 = clerp(wld1.C0, euler(2.5, 0, 0) * euler(0, 0, 0.2) * cf(0, 1, -0.2), 0.5)
      Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0) * euler(0, 0, -0.4), 0.5)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.4), 0.5)
      RW.C0 = clerp(RW.C0, cf(0, 0.4, -0.5) * euler(1.45, 0, -0.6) * euler(0, -1.5, 0), 0.5)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
      LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.2) * euler(1.4, 0, 0.1) * euler(0, -1.4, 0), 0.5)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
      RH.C0 = clerp(RH.C0, cf(0.9, -1, 0.2) * euler(0, 1.57, 0) * euler(0, -0.8, 0), 0.5)
      LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.2) * euler(0, -1.57, 0) * euler(0, -0.8, 0), 0.5)
      if Stagger.Value ~= true and StunT.Value > Stun.Value and StaggerHit.Value ~= true then
        do
          if RecentEnemy.Value ~= nil then
            break
          end
          -- DECOMPILER ERROR at PC793: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC793: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    if RecentEnemy.Value ~= nil and hitfloor ~= nil and Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * 120
    end
    if overload >= 50 and RecentEnemy.Value ~= nil then
      for i = 0, 1, 0.15 do
        swait()
        hwld.C0 = clerp(hwld.C0, euler(1.57, 0, 0) * cf(0, 0, 0), 0.6)
        dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * euler(2.34, 0, 0) * cf(0, 1.8, -4), 0.6)
        dwld6.C0 = clerp(dwld6.C0, euler(0, -1.57, 0) * euler(2.94, 3.14, 0) * cf(0, 1.2, -5.4), 0.6)
        dwld10.C0 = clerp(dwld10.C0, euler(3.14, 1.57, 0) * euler(4.64, 0, 0) * cf(0, 0.5, -4), 0.6)
        dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * euler(0.8, 0, 0) * cf(0, -1.8, -4), 0.6)
        dwldb6.C0 = clerp(dwldb6.C0, euler(0, 1.57, 0) * euler(0.2, 3.14, 0) * cf(0, -1.2, -5.4), 0.6)
        dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, -1.57, 0) * euler(-1.5, 0, 0) * cf(0, -0.5, -4), 0.6)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.5), 0.3)
        wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.4, 0, -0.4), 0.3)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-0.5, 0.5, -0.5) * euler(1.57, 0, 1) * euler(0, -1.57, 0), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, -0.4), 0.3)
        LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.5, 0.1), 0.3)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC1173: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC1173: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
          overload = overload - 50
          ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
          ref.Anchored = true
          game:GetService("Debris"):AddItem(ref, 1)
          for i = 0, 1, 0.15 do
            swait()
            for i = 1, 2 do
              so("300916014", prt31, 0.5, 1)
            end
            for i = 1, 3 do
              MagicBlock(BrickColor.new(NewCol2), prt31.CFrame * cf(math.random(-500, 500) / 100, 6 + math.random(-500, 500) / 100, math.random(-500, 500) / 100), 1, 1, 1, 1, 1, 1, 0.08, 1, workspace)
            end
            for i = 2, 6, 2 do
              MagicCircle(BrickColor.new(NewCol2), prt31.CFrame * cf(0, 6, 0), 3, 3, 3, i, i, i, 0.1)
            end
            ref.CFrame = prt31.CFrame * cf(0, 6, 0)
            MagniDamage(ref, 6, 6, 8, math.random(-60, -40), "Knockdown2", RootPart, 0.5, 2, (math.random(5, 8)), nil, true, true)
            wld1.C0 = clerp(wld1.C0, euler(2.5, 0, 0) * cf(0, 1, 0), 0.3)
            Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.3)
            RootJoint.C0 = RootCF * euler(0, 0, -0.2 + 6.28 * i)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 1), 0.3)
            RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, -1.57) * euler(0, -1.57, 0), 0.3)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
            RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
            LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.3)
            if Stagger.Value ~= true and StunT.Value > Stun.Value then
              do
                if StaggerHit.Value == true then
                  break
                end
                -- DECOMPILER ERROR at PC1519: LeaveBlock: unexpected jumping out IF_THEN_STMT

                -- DECOMPILER ERROR at PC1519: LeaveBlock: unexpected jumping out IF_STMT

              end
            end
          end
          ref.Parent = nil
          for i = 0, 1, 0.1 do
            swait()
            Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.3)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.4), 0.3)
            wld1.C0 = clerp(wld1.C0, euler(2.5, 0, 0) * cf(0, 1, 0), 0.3)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 1), 0.3)
            RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.3, 0, -1.57) * euler(0, -1.2, 0), 0.3)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
            if Stagger.Value ~= true and StunT.Value > Stun.Value then
              do
                if StaggerHit.Value == true then
                  break
                end
                -- DECOMPILER ERROR at PC1667: LeaveBlock: unexpected jumping out IF_THEN_STMT

                -- DECOMPILER ERROR at PC1667: LeaveBlock: unexpected jumping out IF_STMT

              end
            end
          end
          hitbox.Parent = modelzorz
          hitbox.Size = vt()
          hitboxweld()
          hboxpos.Parent = nil
      end
    end
  end
          attack = false
end

do3 = function()
  if attack == true then
    return 
  end
    attack = true
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[3] and mana.Value >= 15 then
    doextra = false
    da = 0
    if overload >= 50 then
      doextra = true
    end
    Mode = "Energy Reactor"
    manainc = 10
    choosemode = false
    passive1.Value = 0.1
    passive2.Value = -0.15
    passive3.Value = 0.05
    if Mode == "Classic" then
      for i = 0, 1, 0.2 do
        swait()
        wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.5)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0.2, 0, -0.5), 0.5)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.5), 0.5)
        RW.C0 = clerp(RW.C0, cf(1.2, 0.5, -0.3) * euler(1.5, 0, 0.5) * euler(0, 1.57, 0), 0.5)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.6) * euler(0, 0, 0), 0.5)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
        RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(0, -0.3, 0) * euler(0, 0, -0.1), 0.5)
        LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.1) * euler(0, -1.57, 0) * euler(0, -0.3, 0) * euler(0, 0, 0.4), 0.5)
        dwld1.C0 = clerp(dwld1.C0, euler(3.14, 1.57, 0) * euler(0, 0, 0) * cf(-1, 1, -1), 0.5)
        dwld6.C0 = clerp(dwld6.C0, euler(0, -1.57, 0) * euler(3.14, 0, 0) * cf(0.3, 0.7, -1.5), 0.5)
        dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * cf(-0.5, 0.5, -0.4), 0.5)
        dwldb1.C0 = clerp(dwldb1.C0, euler(3.14, -1.57, 0) * euler(0, 0, 0) * cf(-1, 1, 1), 0.5)
        dwldb6.C0 = clerp(dwldb6.C0, euler(0, 1.57, 0) * euler(3.14, 0, 0) * cf(0.3, 0.7, 1.5), 0.5)
        dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * cf(-0.5, 0.5, 0.4), 0.5)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC409: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC409: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
    else
      if Mode == "Dynamic Blade" then
        for i = 0, 1, 0.2 do
          swait()
          dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * cf(1, -4.5, -1), 0.6)
          dwld6.C0 = clerp(dwld6.C0, euler(0, 1.57, 0) * euler(0, 0, 0) * cf(0, -3.4, -1), 0.6)
          dwld10.C0 = clerp(dwld10.C0, euler(3.14, 1.57, 0) * euler(0, 0, 0) * cf(-1, -3, -1.5), 0.6)
          dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * cf(1, -4.5, 1), 0.6)
          dwldb6.C0 = clerp(dwldb6.C0, euler(0, -1.57, 0) * euler(0, 0, 0) * cf(0, -3.4, 1), 0.6)
          dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, -1.57, 0) * euler(0, 0, 0) * cf(-1, -3, 1.5), 0.6)
          Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, -0.8), 0.5)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.8), 0.5)
          RW.C0 = clerp(RW.C0, cf(-0.8, 0.5, -0.5) * euler(1.8, 0, -1) * euler(0, 1, 0), 0.5)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
          LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, -0.8) * euler(0, -1.57, 0), 0.5)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
          RH.C0 = clerp(RH.C0, cf(0.9, -1, 0.2) * euler(0, 1.57, 0) * euler(0, -0.8, 0), 0.5)
          LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.2) * euler(0, -1.57, 0) * euler(0, -0.8, 0), 0.5)
          if Stagger.Value ~= true and StunT.Value > Stun.Value then
            do
              if StaggerHit.Value == true then
                break
              end
              -- DECOMPILER ERROR at PC727: LeaveBlock: unexpected jumping out IF_THEN_STMT

              -- DECOMPILER ERROR at PC727: LeaveBlock: unexpected jumping out IF_STMT

            end
          end
        end
      else
        if Mode == "Energy Reactor" then
          dynamomove = false
          for i = 0, 1, 0.1 do
            swait()
            if doextra == true then
              da = da + 0.3
            end
            bb = -4
            if doextra == true then
              bb = -6
            end
            hwld.Part1 = RootPart
            wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.5)
            Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0.2, 0, -0.5), 0.5)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.5), 0.5)
            RW.C0 = clerp(RW.C0, cf(1.2, 0.5, -0.3) * euler(1.5, 0, 0.5) * euler(0, 1.57, 0), 0.5)
            RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.6) * euler(0, 0, 0), 0.5)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
            RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(0, -0.3, 0) * euler(0, 0, -0.1), 0.5)
            LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.1) * euler(0, -1.57, 0) * euler(0, -0.3, 0) * euler(0, 0, 0.4), 0.5)
            hwld.C0 = clerp(hwld.C0, euler(0, 0, -2) * euler(0, 0, -da) * cf(0, bb, 0), 0.6)
            dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * cf(2, -1, 0) * euler(0, 0, 0) * euler(1.57, 0, 0), 0.6)
            dwld6.C0 = clerp(dwld6.C0, euler(0, 4.71, 0) * cf(2, -1, 0) * euler(0, 1.046, 0) * euler(1.57, 0, 0), 0.6)
            dwld10.C0 = clerp(dwld10.C0, euler(3.14, 1.57, 0) * cf(2, -1, 0) * euler(0, 2.092, 0) * euler(1.57, 0, 0), 0.6)
            dwldb1.C0 = clerp(dwldb1.C0, euler(0, 1.57, 0) * cf(2, -1, 0) * euler(0, 3.138, 0) * euler(1.57, 0, 0), 0.6)
            dwldb6.C0 = clerp(dwldb6.C0, euler(0, 4.71, 0) * cf(2, -1, 0) * euler(0, 4.184, 0) * euler(1.57, 0, 0), 0.6)
            dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, 1.57, 0) * cf(2, -1, 0) * euler(0, 5.23, 0) * euler(1.57, 0, 0), 0.6)
            if Stagger.Value ~= true and StunT.Value > Stun.Value then
              do
                if StaggerHit.Value == true then
                  break
                end
                -- DECOMPILER ERROR at PC1178: LeaveBlock: unexpected jumping out IF_THEN_STMT

                -- DECOMPILER ERROR at PC1178: LeaveBlock: unexpected jumping out IF_STMT

              end
            end
          end
        end
      end
    end
    mana.Value = mana.Value - 15
    cooldowns[3] = 0
    for i = 1, #DynamPrt do
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          for d = 1, 2 do
            swait()
            da = da + 0.6
            if doextra == true then
              MagicCircle(BrickColor.new(NewCol2), handle.CFrame * cf(0, 0, -3), 1, 1, 1, 3, 3, 3, 0.1)
              dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0.5) * cf(3, -1, 0) * euler(0, 0, 0) * euler(1.57, 0, 0), 0.2)
              dwld6.C0 = clerp(dwld6.C0, euler(0, 4.71, 0.5) * cf(3, -1, 0) * euler(0, 1.046, 0) * euler(1.57, 0, 0), 0.2)
              dwld10.C0 = clerp(dwld10.C0, euler(3.14, 1.57, 0.5) * cf(3, -1, 0) * euler(0, 2.092, 0) * euler(1.57, 0, 0), 0.2)
              dwldb1.C0 = clerp(dwldb1.C0, euler(0, 1.57, 0.5) * cf(3, -1, 0) * euler(0, 3.138, 0) * euler(1.57, 0, 0), 0.2)
              dwldb6.C0 = clerp(dwldb6.C0, euler(0, 4.71, 0.5) * cf(3, -1, 0) * euler(0, 4.184, 0) * euler(1.57, 0, 0), 0.2)
              dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, 1.57, 0.5) * cf(3, -1, 0) * euler(0, 5.23, 0) * euler(1.57, 0, 0), 0.2)
              hwld.C0 = clerp(hwld.C0, euler(0, 0, -2) * euler(0, 0, -da) * cf(0, -6, 0), 0.6)
            end
          end
          so("300916038", DynamPrt[i], 1, 2)
          Shoot(DynamPrt[i].Position)
          -- DECOMPILER ERROR at PC1457: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC1457: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    if doextra == true then
      overload = overload - 50
      so("300916038", handle, 1, 1.5)
      Shoot2(handle.Position)
    end
  end
    attack = false
end

do4 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
end

DecreaseStat = function(Model, Stat, Amount, Duration)
  if Model:findFirstChild("Stats") ~= nil and Model.Stats[Stat] ~= nil then
    Model.Stats[Stat].Value = Model.Stats[Stat].Value - Amount
    d = Instance.new("NumberValue", Model.Stats.Decrease)
    dur = Instance.new("NumberValue", d)
    dur.Name = "Duration"
    dur.Value = Duration
    game:GetService("Debris"):AddItem(d, 20)
    if Stat == "Damage" then
      d.Name = "DecreaseAtk"
    else
      if Stat == "Defense" then
        d.Name = "DecreaseDef"
      else
        if Stat == "Movement" then
          d.Name = "DecreaseMvmt"
        end
      end
    end
    if Model:findFirstChild("Torso") ~= nil then
      display = ""
      if Stat == "Damage" then
        if Amount > 0 then
          display = "-Damage"
        else
          display = "+Damage"
        end
      else
        if Stat == "Defense" then
          if Amount > 0 then
            display = "-Defense"
          else
            display = "+Defense"
          end
        else
          if Stat == "Movement" then
            if Amount > 0 then
              display = "-Movement"
            else
              display = "+Movement"
            end
          end
        end
      end
      showDamage(Model, display, "Debuff")
    end
    d.Value = Amount
  end
end

GetDist = function(Part1, Part2, magni)
  local targ = Part1.Position - Part2.Position
  local mag = targ.magnitude
  if mag <= magni then
    return true
  else
    return false
  end
end

MagniDamage = function(Part, magni, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
  for _,c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = nil
      for _,d in pairs(c:children()) do
        if d.className == "Model" and ranged ~= true then
          head = d:findFirstChild("Hitbox")
          if d.Parent == Character then
            break
          end
          if head ~= nil then
            local targ = head.Position - Part.Position
            local mag = targ.magnitude
            if mag <= magni and c.Name ~= Player.Name then
              ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
              ref.Anchored = true
              ref.CFrame = cf(head.Position)
              game:GetService("Debris"):AddItem(ref, 1)
              hitnum = math.random(1, 5)
              if hitnum == 1 then
                so("199148971", ref, 1, 1)
              else
                if hitnum == 2 then
                  so("199149025", ref, 1, 1)
                else
                  if hitnum == 3 then
                    so("199149072", ref, 1, 1)
                  else
                    if hitnum == 4 then
                      so("199149109", ref, 1, 1)
                    else
                      if hitnum == 5 then
                        so("199149119", ref, 1, 1)
                      end
                    end
                  end
                end
              end
              StaggerHit.Value = true
            end
          end
        end
        do
          if d.className == "Part" and d.Name=="Torso" then
            head = d
            if head ~= nil then
              local targ = head.Position - Part.Position
              local mag = targ.magnitude
              if mag <= magni and c.Name ~= Player.Name then
                if stun == nil then
                  stun = math.random(5, 10)
                end
                local Rang = nil
                if Ranged == false then
                  Rang = true
                end
                local stag = nil
                if shbash == true then
                  stag = true
                end
                Damagefunc(head, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
              end
            end
          end
          do
            -- DECOMPILER ERROR at PC183: LeaveBlock: unexpected jumping out DO_STMT

          end
        end
      end
    end
  end
end

rayCast = function(Pos, Dir, Max, Ignore)
  return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
end

local Point = Torso.CFrame * cf(0, Torso.Size.Y, 0)
LastPoint = Point
effect = function(Color, Ref, LP, P1, returnn)
  if LP == nil or P1 == nil then
    return 
  end
  local effectsmsh = Instance.new("CylinderMesh")
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  effectsmsh.Name = "Mesh"
  local effectsg = Instance.new("Part")
  NoOutline(effectsg)
  effectsg.formFactor = 3
  effectsg.CanCollide = false
  effectsg.Name = "Eff"
  effectsg.Locked = true
  effectsg.Anchored = true
  effectsg.Size = Vector3.new(0.5, 1, 0.5)
  effectsg.Parent = workspace
  effectsmsh.Parent = effectsg
  effectsg.BrickColor = BrickColor.new(Color)
  effectsg.Reflectance = Ref
  local point1 = P1
  local mg = (LP.p - point1.p).magnitude
  effectsg.Size = Vector3.new(0.5, mg, 0.5)
  effectsg.CFrame = cf((LP.p + point1.p) / 2, point1.p) * CFrame.Angles(math.rad(90), 0, 0)
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  game:GetService("Debris"):AddItem(effectsg, 2)
  if returnn then
    return effectsg
  end
  if not returnn then
    table.insert(Effects, {effectsg, "Cylinder", 0.2, 0.01, 0, 0.01, effectsmsh})
  end
end

local CFrameFromTopBack = function(at, top, back)
  local right = top:Cross(back)
  return CFrame.new(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

Triangle = function(a, b, c)
  local edg1 = c - a:Dot(b - a.unit)
  local edg2 = a - b:Dot(c - b.unit)
  local edg3 = b - c:Dot(a - c.unit)
  if edg1 <= (b - a).magnitude and edg1 >= 0 then
    a = a
  else
    -- DECOMPILER ERROR at PC35: Overwrote pending register: R1 in 'AssignReg'

    if edg2 <= (c - b).magnitude and edg2 >= 0 then
      a = b
    else
      -- DECOMPILER ERROR at PC46: Overwrote pending register: R2 in 'AssignReg'

      -- DECOMPILER ERROR at PC47: Overwrote pending register: R1 in 'AssignReg'

      if edg3 <= (a - c).magnitude and edg3 >= 0 then
        a = c
      else
        assert(false, "unreachable")
      end
    end
  end
  local len1 = c - a:Dot(b - a.unit)
  local len2 = (b - a).magnitude - len1
  local width = a + b - a.unit * (len1 - c).magnitude
  local maincf = CFrameFromTopBack(a, b - a:Cross(c - b).unit, -b - a.unit)
  local list = {}
  if len1 > 0.01 then
    local w1 = Instance.new("WedgePart", m)
    game:GetService("Debris"):AddItem(w1, 5)
    w1.Material = "SmoothPlastic"
    w1.FormFactor = "Custom"
    w1.BrickColor = BrickColor.new(NewCol2)
    w1.Transparency = 0
    w1.Reflectance = 0
    w1.Material = "SmoothPlastic"
    w1.CanCollide = false
    NoOutline(w1)
    local sz = Vector3.new(0.2, width, len1)
    w1.Size = sz
    local sp = Instance.new("SpecialMesh", w1)
    sp.MeshType = "Wedge"
    sp.Scale = Vector3.new(0, 1, 1) * sz / w1.Size
    w1:BreakJoints()
    w1.Anchored = true
    w1.Parent = triangparent
    w1.Transparency = 0.7
    table.insert(Effects, {w1, "Disappear", 0.05})
    w1.CFrame = maincf * CFrame.Angles(math.pi, 0, math.pi / 2) * CFrame.new(0, width / 2, len1 / 2)
    table.insert(list, w1)
  end
  do
    if len2 > 0.01 then
      local w2 = Instance.new("WedgePart", m)
      game:GetService("Debris"):AddItem(w2, 5)
      w2.Material = "SmoothPlastic"
      w2.FormFactor = "Custom"
      w2.BrickColor = BrickColor.new(NewCol2)
      w2.Transparency = 0
      w2.Reflectance = 0
      w2.Material = "SmoothPlastic"
      w2.CanCollide = false
      NoOutline(w2)
      local sz = Vector3.new(0.2, width, len2)
      w2.Size = sz
      local sp = Instance.new("SpecialMesh", w2)
      sp.MeshType = "Wedge"
      sp.Scale = Vector3.new(0, 1, 1) * sz / w2.Size
      w2:BreakJoints()
      w2.Anchored = true
      w2.Parent = triangparent
      w2.Transparency = 0.7
      table.insert(Effects, {w2, "Disappear", 0.05})
      w2.CFrame = maincf * CFrame.Angles(math.pi, math.pi, -math.pi / 2) * CFrame.new(0, width / 2, -len1 - len2 / 2)
      table.insert(list, w2)
    end
    do
      return unpack(list)
    end
  end
end

MagicBlock = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type, parent, prt2)
  local prt = (part(3, parent, 0, 0, brickcolor, "Effect", vt()))
  local wld = nil
  prt.CFrame = cframe
  if Type ~= 3 then
    prt.Anchored = true
  else
    prt.Anchored = false
    wld = weld(prt, prt, prt2, cframe)
  end
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  if Type == 1 or Type == nil then
    table.insert(Effects, {prt, "Block1", delay, x3, y3, z3, msh})
  else
    if Type == 2 then
      table.insert(Effects, {prt, "Block2", delay, x3, y3, z3, msh})
    else
      if Type == 3 then
        table.insert(Effects, {prt, "Block3", delay, x3, y3, z3, msh, wld, cframe})
      end
    end
  end
end

MagicSkull = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, goe)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("SpecialMesh", prt, "FileMesh", "4770583", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Skull", delay, x3, y3, z3, msh, goe})
end

MagicCircle = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end

MagicCylinder = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end

MagicCylinder3 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, modelzorz, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Head", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end

MagicCylinder2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, goe)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder2", delay, x3, y3, z3, msh, goe})
end

MagicHead = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, Character, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Head", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end

MagicHead2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, Character, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Head", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end

ClangEffect = function(brickcolor, cframe, duration, decrease, size, power)
  local prt = part(3, workspace, 0, 1, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(5, 5, 5))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "CylinderClang", duration, decrease, size, power, prt.CFrame, nil})
end

MagicWave = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "FileMesh", "20329976", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end

MagicRing = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
  prt.Anchored = true
  prt.CFrame = cframe * cf(x2, y2, z2)
  local msh = mesh("SpecialMesh", prt, "FileMesh", "3270017", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end

MagicRing2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, prt2)
  local prt = part(3, modelzorz, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
  prt.Anchored = false
  wld = weld(prt, prt, prt2, cframe)
  local msh = mesh("SpecialMesh", prt, "FileMesh", "3270017", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Block3", delay, x3, y3, z3, msh, wld, cframe})
end

ElecEffect = function(cff, x, y, z)
  local prt = part(3, workspace, 0, 0, BrickColor.new("Bright red"), "Part", vt(1, 1, 1))
  prt.Anchored = true
  prt.CFrame = cff * cf(math.random(-x, x), math.random(-y, y), math.random(-z, z))
  prt.CFrame = cf(prt.Position)
  game:GetService("Debris"):AddItem(prt, 10)
  xval = math.random() / 3
  yval = math.random() / 3
  zval = math.random() / 3
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(xval, yval, zval))
  Effects[#Effects + 1] = {prt, "Elec", 0.2, x, y, z, xval, yval, zval, msh}
end

Lightning = function(p0, p1, tym, ofs, col, th, tra, last)
  local magz = (p0 - p1).magnitude
  local curpos = p0
  local trz = {-ofs, ofs}
  for i = 1, tym do
    local li = Instance.new("Part", workspace)
    li.TopSurface = 0
    li.BottomSurface = 0
    li.Anchored = true
    li.Transparency = tra or 0.4
    li.BrickColor = BrickColor.new(col)
    li.formFactor = "Custom"
    li.CanCollide = false
    li.Size = Vector3.new(th, th, magz / tym)
    local ofz = Vector3.new(trz[math.random(1, 2)], trz[math.random(1, 2)], trz[math.random(1, 2)])
    local trolpos = CFrame.new(curpos, p1) * CFrame.new(0, 0, magz / tym).p + ofz
    if tym == i then
      local magz2 = (curpos - p1).magnitude
      li.Size = Vector3.new(th, th, magz2)
      li.CFrame = CFrame.new(curpos, p1) * CFrame.new(0, 0, -magz2 / 2)
table.insert(Effects, {li, "Disappear", last})
    else
      do
        do
          li.CFrame = CFrame.new(curpos, trolpos) * CFrame.new(0, 0, magz / tym / 2)
          curpos = li.CFrame * CFrame.new(0, 0, magz / tym / 2).p
          game.Debris:AddItem(li, 10)
          table.insert(Effects, {li, "Disappear", last})
        end
      end
    end
  end
end

Shoot = function(orgpos)
  rand = 1.5
  if Mode == "Energy Reactor" then
    rand = 0
  else
    if Mode == "Dynamic Blade" then
      rand = 2
    end
  end
  spread = vt((math.random(-1, 0) + math.random()) * rand, (math.random(-1, 0) + math.random()) * rand, (math.random(-1, 0) + math.random()) * rand) * (orgpos - MMouse.Hit.p).magnitude / 100
  local MouseLook = cf((orgpos + MMouse.Hit.p) / 2, MMouse.Hit.p + spread)
  MagicCircle(BrickColor.new(NewCol2), cf(orgpos), 5, 5, 5, 1, 1, 1, 0.1)
  table.insert(Effects, {MouseLook.lookVector, "Shoot", 50, orgpos, 5, 7, 0, 1, 2})
end

Shoot2 = function(orgpos)
  local MouseLook = cf((orgpos + MMouse.Hit.p) / 2, MMouse.Hit.p)
  MagicCircle(BrickColor.new(NewCol2), cf(orgpos), 5, 5, 5, 3, 3, 3, 0.1)
  table.insert(Effects, {MouseLook.lookVector, "Shoot2", 50, orgpos, 5, 7, 0, 1, 2})
end

Damagefunc = function(hit, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
  if hit.Parent == nil then
    return 
  end
  if hit == MovePart then
    Fly = false
  end
  if hit.Name == "Hitbox" and hit.Parent ~= modelzorz and ranged ~= true then
    ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
    ref.Anchored = true
    ref.CFrame = cf(hit.Position)
    game:GetService("Debris"):AddItem(ref, 1)
    hitnum = math.random(1, 5)
    if hitnum == 1 then
      so("199148971", ref, 1, 1)
    else
      if hitnum == 2 then
        so("199149025", ref, 1, 1)
      else
        if hitnum == 3 then
          so("199149072", ref, 1, 1)
        else
          if hitnum == 4 then
            so("199149109", ref, 1, 1)
          else
            if hitnum == 5 then
              so("199149119", ref, 1, 1)
            end
          end
        end
      end
    end
    StaggerHit.Value = true
  end
  if hit.Parent.Parent:FindFirstChild("Torso") ~= nil then
    hit = hit.Parent.Parent:findFirstChild("Torso")
    h = hit.Parent.Parent:FindFirstChild("Humanoid")
  end
  if hit.Parent.className == "Hat" then
    hit = hit.Parent.Parent:findFirstChild("Head")
  end
  h = hit.Parent:FindFirstChild("Humanoid")
  if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
    if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
      return 
    end
    if Player.Neutral == false then
      if hit.Parent:findFirstChild("Alignment") ~= nil and hit.Parent.Alignment.Value == Player.TeamColor.Color then
        return 
      end
      if game.Players:GetPlayerFromCharacter(hit.Parent) ~= nil and game.Players:GetPlayerFromCharacter(hit.Parent).TeamColor == Player.TeamColor then
        return 
      end
    end
    c = Instance.new("ObjectValue")
    c.Name = "creator"
    c.Value = game:service("Players").LocalPlayer
    c.Parent = h
    RecentEnemy.Value = hit.Parent
    game:GetService("Debris"):AddItem(c, 0.5)
    minim = minim * Atk.Value
    maxim = maxim * Atk.Value
    Damage = 0
    if minim == maxim then
      Damage = maxim
    else
      Damage = math.random(minim, maxim)
    end
    blocked = false
    enblock = nil
    Stats = hit.Parent:findFirstChild("Stats")
    if Stats ~= nil then
      enblock = Stats:findFirstChild("Block")
      if enblock ~= nil and enblock.Value == true then
        blocked = true
      end
      if Stats:findFirstChild("Defense") ~= nil then
        Damage = Damage / Stats.Defense.Value
        if Damage <= 3 and (ranged == false or ranged == nil) and blocked ~= true then
          hitnum = math.random(1, 5)
          if hitnum == 1 then
            so("199149321", hit, 1, 1)
          else
            if hitnum == 2 then
              so("199149338", hit, 1, 1)
            else
              if hitnum == 3 then
                so("199149367", hit, 1, 1)
              else
                if hitnum == 4 then
                  so("199149409", hit, 1, 1)
                else
                  if hitnum == 5 then
                    so("199149452", hit, 1, 1)
                  end
                end
              end
            end
          end
        else
          if ranged == false or ranged == nil and blocked ~= true then
            hitnum = math.random(1, 6)
            if hitnum == 1 then
              so("199149137", hit, 1, 1)
            else
              if hitnum == 2 then
                so("199149186", hit, 1, 1)
              else
                if hitnum == 3 then
                  so("199149221", hit, 1, 1)
                else
                  if hitnum == 4 then
                    so("199149235", hit, 1, 1)
                  else
                    if hitnum == 5 then
                      so("199149269", hit, 1, 1)
                    else
                      if hitnum == 6 then
                        so("199149297", hit, 1, 1)
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if Damage <= 3 and staghit == true and ranged ~= true then
          StaggerHit.Value = true
        end
      end
      if Stats:findFirstChild("Stun") ~= nil then
        if blocked == true then
          incstun = incstun / 2
        end
        --[[if Stats.Stun.Value < Stats.StunThreshold.Value then
          Stats.Stun.Value = Stats.Stun.Value + incstun
        end--]]
      end
      if Stats:findFirstChild("Stagger") ~= nil and stagger == true then
        Stats.Stagger.Value = true
      end
    end
    if blocked == true then
      showDamage(hit.Parent, "Block", "Damage")
      if ranged ~= true then
        enblock.Value = false
        Stagger.Value = true
        hitnum = math.random(1, 2)
        if hitnum == 1 then
          so("199148933", hit, 1, 1)
        else
          if hitnum == 2 then
            so("199148947", hit, 1, 1)
          end
        end
      end
    else
      Damage = math.floor(Damage)
      coroutine.resume(coroutine.create(function(Hum, Dam)
	hit.Parent.Humanoid:TakeDamage(Damage)
  end
), h, Damage)
      showDamage(hit.Parent, Damage, "Damage")
      if prechit == true then
        eul = euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
        MagicCircle(BrickColor.new("White"), cf(hit.Position) * eul, 5, 5, 5, -0.1, 5, -0.1, 0.02)
        MagicCircle(BrickColor.new("White"), cf(hit.Position) * eul * euler(1.57, 0, 0), 5, 5, 5, -0.1, 5, -0.1, 0.02)
      end
      if DecreaseState ~= nil then
        DecreaseStat(hit.Parent, DecreaseState, DecreaseAmount, Duration)
      end
      if Type == "Knockdown" then
        hum = hit.Parent.Humanoid
        hum.PlatformStand = true
        coroutine.resume(coroutine.create(function(HHumanoid)
    swait(1)
    HHumanoid.PlatformStand = false
  end
), hum)
        local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
        local bodvol = Instance.new("BodyVelocity")
        bodvol.velocity = angle * knockback
        bodvol.P = 5000
        bodvol.maxForce = Vector3.new(8000, 8000, 8000)
        bodvol.Parent = hit
        rl = Instance.new("BodyAngularVelocity")
        rl.P = 3000
        rl.maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000
        rl.angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10))
        rl.Parent = hit
        game:GetService("Debris"):AddItem(bodvol, 0.5)
        game:GetService("Debris"):AddItem(rl, 0.5)
      else
        do
          if Type == "Knockdown2" then
            hum = hit.Parent.Humanoid
            local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
            local bodvol = Instance.new("BodyVelocity")
            bodvol.velocity = angle * knockback
            bodvol.P = 500
            bodvol.maxForce = Vector3.new(3000, 3000, 3000)
            bodvol.Parent = hit
            game:GetService("Debris"):AddItem(bodvol, 0.5)
          else
            do
              if Type == "Normal" or Type == "NormalDecreaseMvmt1" then
                vp = Instance.new("BodyVelocity")
                vp.P = 500
                vp.maxForce = Vector3.new(math.huge, 0, math.huge)
                if KnockbackType == 1 then
                  vp.velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
                else
                  if KnockbackType == 2 then
                    vp.velocity = Property.CFrame.lookVector * knockback
                  end
                end
                game:GetService("Debris"):AddItem(vp, 0.5)
                if knockback > 0 then
                  vp.Parent = hit.Parent.Torso
                end
              end
              debounce = Instance.new("BoolValue")
              debounce.Name = "DebounceHit"
              debounce.Parent = hit.Parent
              debounce.Value = true
              game:GetService("Debris"):AddItem(debounce, Delay)
              c = Instance.new("ObjectValue")
              c.Name = "creator"
              c.Value = Player
              c.Parent = h
              game:GetService("Debris"):AddItem(c, 0.5)
              CRIT = false
            end
          end
        end
      end
    end
  end
end

showDamage = function(Char, Dealt, Type)
  m = Instance.new("Model")
  m.Name = "Effect"
  c = Instance.new("Part")
  c.Transparency = 1
  c.Name = "Head"
  c.TopSurface = 0
  c.BottomSurface = 0
  c.formFactor = "Plate"
  c.Size = Vector3.new(1, 0.4, 1)
  b = Instance.new("BillboardGui", c)
  b.Size = UDim2.new(5, 0, 5, 0)
  b.AlwaysOnTop = true
  damgui = gui("TextLabel", b, tostring(Dealt), 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
  if Type == "Damage" then
    damgui.Font = "SourceSans"
    if Dealt == "Block" then
      damgui.TextColor3 = BrickColor.new("Bright blue").Color
    else
      if Dealt < 3 then
        damgui.TextColor3 = BrickColor.new("White").Color
      else
        if Dealt >= 3 and Dealt < 20 then
          damgui.TextColor3 = BrickColor.new("Bright yellow").Color
        else
          damgui.TextColor3 = BrickColor.new("Really red").Color
          damgui.Font = "SourceSansBold"
        end
      end
    end
  else
    if Type == "Debuff" then
      damgui.TextColor3 = BrickColor.new("White").Color
    else
      if Type == "Interrupt" then
        damgui.TextColor3 = BrickColor.new("New Yeller").Color
      end
    end
  end
  damgui.TextScaled = true
  ms = Instance.new("CylinderMesh")
  ms.Scale = Vector3.new(0.8, 0.8, 0.8)
  ms.Parent = c
  c.Reflectance = 0
  Instance.new("BodyGyro").Parent = c
  c.Parent = m
  if Char:findFirstChild("Head") ~= nil then
    c.CFrame = cf(Char.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
  else
    if Char.Parent:findFirstChild("Head") ~= nil then
      c.CFrame = cf(Char.Parent.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
    end
  end
  f = Instance.new("BodyPosition")
  f.P = 2000
  f.D = 100
  f.maxForce = Vector3.new(545000, 545000, 545000)
  if Type == "Damage" then
    f.position = c.Position + Vector3.new(0, 3, 0)
  else
    if Type == "Debuff" or Type == "Interrupt" then
      f.position = c.Position + Vector3.new(0, 5, 0)
    end
  end
  f.Parent = c
  game:GetService("Debris"):AddItem(m, 5)
  table.insert(Effects, {m, "showDamage", damgui, f, 10, 1, 15, 50, 100})
  c.CanCollide = false
  m.Parent = workspace
  c.CanCollide = false
end

combo = 0
ob1d = function(mouse)
  if attack == true or equipped == false then
    return 
  end
  hold = true
  dynamomove = false
  if Mode == "Energy Reactor" then
    dynamomove = true
  end
  if combo == 0 then
    combo = 1
    attackone()
  else
    if combo == 1 then
      combo = 2
      attacktwo()
    else
      if combo == 2 then
        combo = 3
        attackthree()
      else
        if combo == 3 then
          combo = 0
          attackfour()
        end
      end
    end
  end
  coroutine.resume(coroutine.create(function()
    for i = 1, 50 do
      if attack == false then
        swait()
      end
    end
    if attack == false then
      dynamomove = true
      combo = 0
    end
  end
))
end

ob1u = function(mouse)
  hold = false
end

buttonhold = false
fenbarmove1.MouseButton1Click:connect(do1)
fenbarmove2.MouseButton1Click:connect(do2)
fenbarmove3.MouseButton1Click:connect(do3)
fenbarmove4.MouseButton1Click:connect(do4)
eul = 0
equipped = false
key = function(key)
  if key == "e" and defending == true then
    defending = false
  end
  if key == "z" and choosemode == true then
    Mode = "Classic"
    manainc = 9
    choosemode = false
    passive1.Value = 0.1
    passive2.Value = -0.05
    passive3.Value = -0.1
  else
    if key == "x" and choosemode == true then
      Mode = "Dynamic Blade"
      manainc = 15
      choosemode = false
      passive1.Value = -0.1
      passive2.Value = 0.1
      passive3.Value = 0.1
    else
      if key == "c" and choosemode == true then
        Mode = "Energy Reactor"
        manainc = 5
        choosemode = false
        passive1.Value = 0.1
        passive2.Value = -0.15
        passive3.Value = 0.05
      end
    end
  end
  if attack == true then
    return 
  end
  if key == "f" then
    pressedf = true
    fnumb = 0
    attack = true
    if equipped == false then
      equipped = true
      RSH = ch.Torso["Right Shoulder"]
      LSH = ch.Torso["Left Shoulder"]
      RSH.Parent = nil
      LSH.Parent = nil
      RW.Name = "Right Shoulder"
      RW.Part0 = ch.Torso
      RW.C0 = cf(1.5, 0.5, 0)
      RW.C1 = cf(0, 0.5, 0)
      RW.Part1 = ch["Right Arm"]
      RW.Parent = ch.Torso
      LW.Name = "Left Shoulder"
      LW.Part0 = ch.Torso
      LW.C0 = cf(-1.5, 0.5, 0)
      LW.C1 = cf(0, 0.5, 0)
      LW.Part1 = ch["Left Arm"]
      LW.Parent = ch.Torso
      Animate.Parent = nil
      equipanim()
    else
      equipped = false
      hideanim()
      LH.C1 = LHC1
      RH.C1 = RHC1
      Animate.Parent = Humanoid
      swait(0)
      RW.Parent = nil
      LW.Parent = nil
      RSH.Parent = player.Character.Torso
      LSH.Parent = player.Character.Torso
    end
    attack = false
  end
  if equipped == false then
    return 
  end
  if key == "e" then
    Defend()
  end
  if key == "z" then
    do1()
  end
  if key == "x" then
    do2()
  end
  if key == "c" then
    do3()
  end
  if key == "v" then
    do4()
  end
  if key == "e" or key == "z" or key == "x" or key == "c" or key == "v" then
    dynamomove = true
  end
end

key2 = function(key)
end

s = function(mouse)
  mouse.Button1Down:connect(function()
    ob1d(mouse)
  end
)
  mouse.Button1Up:connect(function()
    ob1u(mouse)
  end
)
  mouse.KeyDown:connect(key)
  mouse.KeyUp:connect(key2)
  player = Player
  ch = Character
  MMouse = mouse
end

ds = function(mouse)
end

Bin.Selected:connect(s)
Bin.Deselected:connect(ds)
print("Dynamo & Permanence loaded.")
local mananum = 0
local donum = 0
local stunnum = 0
local staggeranim = false
local stunanim = false
local Point, LastPoint = nil, nil
local handef = 0
local flick = 0
local reactlightn = 0
local walk = 0
local walkforw = true
local ovloadn = 0
local oldhealth = Humanoid.Health
local oldstun = Stun.Value
while 1 do
  swait()
  if fnumb < 21 then
    fnumb = fnumb + 1
    if pressedf == false then
      fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency - 0.025
      tellbar.TextTransparency = tellbar.TextTransparency - 0.05
      tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency - 0.05
    else
      if fnumb == 20 then
        fenframe5.Parent = nil
        print("daigui")
      end
      fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency + 0.025
      tellbar.TextTransparency = tellbar.TextTransparency + 0.05
      tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency + 0.05
    end
  end
  hitbox2.Parent = hitbox.Parent
  hitbox2.Size = hitbox.Size
  hitbox2.CFrame = hitboxCF
  hboxpos.position = hitbox2.Position + vt(math.random(-100, 100) / 100, math.random(-100, 100) / 100, math.random(-100, 100) / 100)
  if mdec2.Parent == nil then
    for i = 1, #DemTable do
      if DemTable[i][1].Transparency < 1 then
        DemTable[i][1].Transparency = DemTable[i][1].Transparency + 0.1
      end
    end
  else
    do
      for i = 1, #DemTable do
        if DemTable[i][2] < DemTable[i][1].Transparency then
          DemTable[i][1].Transparency = DemTable[i][1].Transparency - 0.05
        end
        if 4 <= flick then
          DemTable[i][1].Transparency = DemTable[i][1].Transparency + 0.1
        end
      end
      do
        if 4 <= flick then
          flick = 0
        end
        flick = flick + 1
        ovloadn = ovloadn + 1
        if 20 <= ovloadn then
          ovloadn = 0
          if overload < 100 then
            overload = overload + 1
          end
        end
        if 100 <= overload then
          overload = 100
        end
        if 50 <= overload then
          prt29.Material = "Neon"
          prt30.Material = "Neon"
          prt30b.Material = "Neon"
          prt31.Material = "Neon"
          prt32.Material = "Neon"
          prt32b.Material = "Neon"
          dprt4.Material = "Neon"
          dprt5.Material = "Neon"
          dprt16.Material = "Neon"
          dprt17.Material = "Neon"
          dprt18.Material = "Neon"
          dprt19.Material = "Neon"
          dprt20.Material = "Neon"
          dprt21.Material = "Neon"
          dprt22.Material = "Neon"
          dprtb4.Material = "Neon"
          dprtb5.Material = "Neon"
          dprtb16.Material = "Neon"
          dprtb17.Material = "Neon"
          dprtb18.Material = "Neon"
          dprtb19.Material = "Neon"
          dprtb20.Material = "Neon"
          dprtb21.Material = "Neon"
          dprtb22.Material = "Neon"
        else
          prt29.Material = "SmoothPlastic"
          prt30.Material = "SmoothPlastic"
          prt30b.Material = "SmoothPlastic"
          prt31.Material = "SmoothPlastic"
          prt32.Material = "SmoothPlastic"
          prt32b.Material = "SmoothPlastic"
          dprt4.Material = "SmoothPlastic"
          dprt5.Material = "SmoothPlastic"
          dprt16.Material = "SmoothPlastic"
          dprt17.Material = "SmoothPlastic"
          dprt18.Material = "SmoothPlastic"
          dprt19.Material = "SmoothPlastic"
          dprt20.Material = "SmoothPlastic"
          dprt21.Material = "SmoothPlastic"
          dprt22.Material = "SmoothPlastic"
          dprtb4.Material = "SmoothPlastic"
          dprtb5.Material = "SmoothPlastic"
          dprtb16.Material = "SmoothPlastic"
          dprtb17.Material = "SmoothPlastic"
          dprtb18.Material = "SmoothPlastic"
          dprtb19.Material = "SmoothPlastic"
          dprtb20.Material = "SmoothPlastic"
          dprtb21.Material = "SmoothPlastic"
          dprtb22.Material = "SmoothPlastic"
        end
        if defending == true and Humanoid.Health < oldhealth then
          overload = overload + (oldhealth - Humanoid.Health)
          if Mode == "Classic" then
            MagicCircle(BrickColor.new(NewCol2), handle.CFrame * cf(0.6, math.random(-100, 100) / 100, math.random(-100, 100) / 100), 1, 1, 1, 0, 5, 5, 0.1)
          else
            if Mode == "Dynamic Blade" then
              MagicCircle(BrickColor.new(NewCol2), prt31.CFrame * cf(0, math.random(-200, 200) / 100, math.random(-90, 90) / 100), 1, 1, 1, 0, 5, 5, 0.1)
            else
              if Mode == "Energy Reactor" then
                MagicCircle(BrickColor.new(NewCol2), handle.CFrame * cf(math.random(-100, 100) / 100, math.random(-100, 100) / 100, -1), 1, 1, 1, 5, 5, 0, 0.1)
              end
            end
          end
        end
        if Stagger.Value == true and staggeranim == false and defending == false then
          coroutine.resume(coroutine.create(function()
  staggeranim = true
  while attack == true do
    swait()
  end
  StaggerAnim()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end
))
        end
        if StaggerHit.Value == true and staggeranim == false and defending == false then
          coroutine.resume(coroutine.create(function()
  staggeranim = true
  while attack == true do
    swait()
  end
  StaggerHitt()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end
))
        end
        oldhealth = Humanoid.Health
        if defending == true then
          if oldstun <= 60 and StunT.Value <= Stun.Value then
            Stun.Value = 60
            defending = false
            if Mode == "Classic" then
              MagicCircle(BrickColor.new(NewCol2), handle.CFrame * cf(0.6, 0, 0), 1, 1, 1, 0, 5, 5, 0.05)
            else
              if Mode == "Dynamic Blade" then
                MagicCircle(BrickColor.new(NewCol2), prt31.CFrame, 1, 1, 1, 0, 5, 5, 0.05)
              else
                if Mode == "Energy Reactor" then
                  MagicCircle(BrickColor.new(NewCol2), handle.CFrame * cf(0, 0, -1), 1, 1, 1, 5, 5, 0, 0.05)
                end
              end
            end
          else
            if StunT.Value <= Stun.Value then
              Stun.Value = 99
              defending = false
            end
          end
          oldstun = tonumber(Stun.Value)
          if Stagger.Value == true then
            Stagger.Value = false
            if Mode == "Classic" then
              MagicCircle(BrickColor.new(NewCol2), handle.CFrame * cf(0.6, 0, 0), 1, 1, 1, 0, 5, 5, 0.05)
            else
              if Mode == "Dynamic Blade" then
                MagicCircle(BrickColor.new(NewCol2), prt31.CFrame, 1, 1, 1, 0, 5, 5, 0.05)
              else
                if Mode == "Energy Reactor" then
                  MagicCircle(BrickColor.new(NewCol2), handle.CFrame * cf(0, 0, -1), 1, 1, 1, 5, 5, 0, 0.05)
                end
              end
            end
          end
          if StaggerHit.Value == true then
            StaggerHit.Value = false
          end
        end
        if Mvmt.Value < 0 or Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true or Rooted.Value == true then
          Humanoid.WalkSpeed = 0
        else
          Humanoid.WalkSpeed = 16 * Mvmt.Value
        end
        if StunT.Value <= Stun.Value and stunanim == false and defending == false then
          coroutine.resume(coroutine.create(function()
  stunanim = true
  while attack == true do
    swait()
  end
  StunAnim()
  Stun.Value = 0
  stunanim = false
end
))
        end
        local stunnum2 = 30
        if stunnum2 <= stunnum then
          if 0 < Stun.Value then
            Stun.Value = Stun.Value - 1
          end
          stunnum = 0
        end
        stunnum = stunnum + 1
        if 0.5 <= donum then
          handidle = true
        else
          if donum <= 0 then
            handidle = false
          end
        end
        if handidle == false then
          donum = donum + 0.003
        else
          donum = donum - 0.003
        end
        local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
        local velderp = RootPart.Velocity.y
        hitfloor,posfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
        if equipped == true then
          if attack == false then
            idle = idle + 1
          else
            idle = 0
          end
          if (500 <= idle and attack ~= false) or Anim == "Walk" then
            if walkforw == true then
              RH.C1 = clerp(RH.C1, RHC1 * cf(0.2, -0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
              LH.C1 = clerp(LH.C1, LHC1 * cf(0.1, 0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
            else
              RH.C1 = clerp(RH.C1, RHC1 * cf(-0.1, 0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
              LH.C1 = clerp(LH.C1, LHC1 * cf(-0.2, -0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
            end
          else
            RH.C1 = clerp(RH.C1, RHC1, 0.2)
            LH.C1 = clerp(LH.C1, LHC1, 0.2)
          end
          if Mode == "Classic" and attack == false and dynamomove == true then
            hwld.Part1 = RightArm
            hwld.C0 = clerp(hwld.C0, euler(0, 0, 0) * cf(0, 0, 0), math.random(30, 200) / 1000)
            dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * cf(-0.6, -1.5, -0.4), math.random(30, 200) / 1000)
            dwld6.C0 = clerp(dwld6.C0, euler(0, 1.57, 0) * cf(-0.6, -0.4, -0.35), math.random(30, 200) / 1000)
            dwld10.C0 = clerp(dwld10.C0, euler(0, 1.57, 0) * cf(-0.6, 0.5, -0.45), math.random(30, 200) / 1000)
            dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * cf(-0.6, -1.5, 0.4), math.random(30, 200) / 1000)
            dwldb6.C0 = clerp(dwldb6.C0, euler(0, -1.57, 0) * cf(-0.6, -0.4, 0.35), math.random(30, 200) / 1000)
            dwldb10.C0 = clerp(dwldb10.C0, euler(0, -1.57, 0) * cf(-0.6, 0.5, 0.45), math.random(30, 200) / 1000)
          else
            if Mode == "Dynamic Blade" and attack == false and dynamomove == true then
              hwld.Part1 = prt1
              hwld.C0 = clerp(hwld.C0, euler(0, 0, 0) * cf(0, 0, 0), math.random(30, 200) / 1000)
              dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, 0) * euler(0.1, 0, 0) * cf(0, -5.5, -0.3), math.random(30, 200) / 1000)
              dwld6.C0 = clerp(dwld6.C0, euler(0, -1.57, 0) * euler(0, 0, 0) * cf(0, -4, -0.65), math.random(30, 200) / 1000)
              dwld10.C0 = clerp(dwld10.C0, euler(3.14, 1.57, 0) * cf(0, -3, -0.5), math.random(30, 200) / 1000)
              dwldb1.C0 = clerp(dwldb1.C0, euler(0, -1.57, 0) * euler(-0.1, 0, 0) * cf(0, -5.5, 0.3), math.random(30, 200) / 1000)
              dwldb6.C0 = clerp(dwldb6.C0, euler(0, 1.57, 0) * euler(0, 0, 0) * cf(0, -4, 0.65), math.random(30, 200) / 1000)
              dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, -1.57, 0) * cf(0, -3, 0.5), math.random(30, 200) / 1000)
            else
              if Mode == "Energy Reactor" and dynamomove == true then
                hwld.Part1 = RootPart
                hwld.C0 = clerp(hwld.C0, euler(0, 0, -0.5) * cf(0, -2, 0), math.random(30, 200) / 1000)
                dwld1.C0 = clerp(dwld1.C0, euler(0, 1.57, -1.57) * cf(3, 3, 0) * euler(0, 0, 0) * euler(1.57, 0, 0), math.random(30, 200) / 1000)
                dwld6.C0 = clerp(dwld6.C0, euler(0, 4.71, -1.57) * cf(3, 3, 0) * euler(0, 1.046, 0) * euler(1.57, 0, 0), math.random(30, 200) / 1000)
                dwld10.C0 = clerp(dwld10.C0, euler(3.14, 1.57, -1.57) * cf(3, 3, 0) * euler(0, 2.092, 0) * euler(1.57, 0, 0), math.random(30, 200) / 1000)
                dwldb1.C0 = clerp(dwldb1.C0, euler(0, 1.57, -1.57) * cf(3, 3, 0) * euler(0, 3.138, 0) * euler(1.57, 0, 0), math.random(30, 200) / 1000)
                dwldb6.C0 = clerp(dwldb6.C0, euler(0, 4.71, -1.57) * cf(3, 3, 0) * euler(0, 4.184, 0) * euler(1.57, 0, 0), math.random(30, 200) / 1000)
                dwldb10.C0 = clerp(dwldb10.C0, euler(3.14, 1.57, -1.57) * cf(3, 3, 0) * euler(0, 5.23, 0) * euler(1.57, 0, 0), math.random(30, 200) / 1000)
              end
            end
          end
          if Mode == "Energy Reactor" and 8 <= reactlightn then
            reactlightn = 0
            num = math.random(1, 3)
            efprt1 = dprt1
            efprt2 = dprtb1
            if num == 2 then
              efprt1 = dprt6
              efprt2 = dprtb6
            else
              if num == 3 then
                efprt1 = dprt10
                efprt2 = dprtb10
              end
            end
            Lightning(efprt1.Position, efprt2.Position, 5, 1, NewCol2, 0.01, 0.5, 0.2)
          end
          reactlightn = reactlightn + 1
          if 1 < RootPart.Velocity.y and hitfloor == nil then
            Anim = "Jump"
            if attack == false then
              if Mode == "Dynamic Blade" then
                wld1.C0 = clerp(wld1.C0, euler(1.6, 0, 0) * cf(0, 1.1, 0.2), 0.2)
                Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0), 0.2)
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
                RW.C0 = clerp(RW.C0, cf(0.6, 0.4, -0.6) * euler(0.3 + (donum) / 4, 0, -0.4 - (donum) / 4) * euler(0, -1, 0), 0.2)
                RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                LW.C0 = clerp(LW.C0, cf(-0.8, 0.4, -0.5) * euler(0.4 + (donum) / 4, 0, 0.3 - (donum) / 4) * euler(0, -1.3, 0), 0.2)
                LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                RH.C0 = clerp(RH.C0, cf(1, -1, -0.3) * euler(-0.5, 1.57, 0) * euler(-0.2, 0, 0), 0.2)
                LH.C0 = clerp(LH.C0, cf(-1, -1, -0.3) * euler(-0.5, -1.57, 0) * euler(-0.2, 0, 0), 0.2)
              else
                wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
                Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0), 0.2)
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
                RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.4) * euler(0, 0, 0), 0.2)
                RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-1, 0, -0.2), 0.2)
                LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                RH.C0 = clerp(RH.C0, cf(1, -1, -0.3) * euler(-0.5, 1.57, 0) * euler(-0.2, 0, 0), 0.2)
                LH.C0 = clerp(LH.C0, cf(-1, -1, -0.3) * euler(-0.5, -1.57, 0) * euler(-0.2, 0, 0), 0.2)
              end
            end
          else
            if RootPart.Velocity.y < -1 and hitfloor == nil then
              Anim = "Fall"
              if attack == false then
                if Mode == "Dynamic Blade" then
                  wld1.C0 = clerp(wld1.C0, euler(1.6, 0, 0) * cf(0, 1.1, 0.2), 0.2)
                  Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, 0), 0.2)
                  RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
                  RW.C0 = clerp(RW.C0, cf(0.6, 0.4, -0.6) * euler(0.3 + (donum) / 4, 0, -0.4 - (donum) / 4) * euler(0, -1, 0), 0.2)
                  RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                  LW.C0 = clerp(LW.C0, cf(-0.8, 0.4, -0.5) * euler(0.4 + (donum) / 4, 0, 0.3 - (donum) / 4) * euler(0, -1.3, 0), 0.2)
                  LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                  RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0.4, 1.57, 0), 0.2)
                  LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(-0.2, -1.57, 0), 0.2)
                else
                  wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
                  Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, 0), 0.2)
                  RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
                  RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.4) * euler(0, 0, 0), 0.2)
                  RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                  LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.3, 0, -0.2), 0.2)
                  LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                  RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0.4, 1.57, 0), 0.2)
                  LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(-0.2, -1.57, 0), 0.2)
                end
              end
            else
              if torvel < 1 and hitfloor ~= nil then
                Anim = "Idle"
                if attack == false then
                  if Mode == "Dynamic Blade" then
                    wld1.C0 = clerp(wld1.C0, euler(1.6, 0, 0) * cf(0, 1.1, 0.2), 0.2)
                    Neck.C0 = clerp(Neck.C0, necko * euler(0.1, 0, 0) * euler(0, 0, -0.5), 0.2)
                    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.5), 0.2)
                    RW.C0 = clerp(RW.C0, cf(0.6, 0.5, -0.6) * euler(1.2 + (donum) / 4, 0, -0.6 - (donum) / 4) * euler(0, -1, 0), 0.2)
                    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                    LW.C0 = clerp(LW.C0, cf(-0.8, 0.5, -0.5) * euler(1 + (donum) / 4, 0, 0.4 - (donum) / 4) * euler(0, -0.8, 0), 0.2)
                    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                    RH.C0 = clerp(RH.C0, cf(1.1, -0.8, 0.1) * euler(0, 1.57, 0) * euler(0, -0.5, 0) * euler(0, 0, 0.1), 0.2)
                    LH.C0 = clerp(LH.C0, cf(-0.9, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0) * euler(0, 0, 0.2), 0.2)
                  else
                    wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
                    Neck.C0 = clerp(Neck.C0, necko * euler(0.1, 0, 0) * euler(0, 0, 0.5), 0.2)
                    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -0.5), 0.2)
                    if Mode == "Classic" then
                      RW.C0 = clerp(RW.C0, cf(1.1, 0.45, 0.3) * euler(1 - (donum) / 4, 0, 0.6 - (donum) / 4) * euler(0, 0.5, 0), 0.2)
                      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                    else
                      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.2 + (donum) / 4, 0, 0.4 + (donum) / 4) * euler(0, 0, 0), 0.2)
                      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                    end
                    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.6 + (donum) / 4, 0, -0.2 - (donum) / 4) * euler(0, -0.5, 0), 0.2)
                    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, 0) * euler(0, 0, -0.4), 0.2)
                    LH.C0 = clerp(LH.C0, cf(-0.9, -0.8, -0.1) * euler(0, -1.57, 0) * euler(0, 0.5, 0) * euler(0, 0, 0.1), 0.2)
                  end
                end
              else
                if 2 < torvel and torvel < 30 and hitfloor ~= nil then
                  Anim = "Walk"
                  walk = walk + 1
                  if 15 - 5 * Mvmt.Value <= walk then
                    walk = 0
                    if walkforw == true then
                      walkforw = false
                    else
                      if walkforw == false then
                        walkforw = true
                      end
                    end
                  end
                  if attack == false then
                    if Mode == "Dynamic Blade" then
                      wld1.C0 = clerp(wld1.C0, euler(1.6, 0, 0) * cf(0, 1.1, 0.2), 0.2)
                      Neck.C0 = clerp(Neck.C0, necko * euler(0.2 - (donum) / 5, 0, 0) * euler(0, 0, 0), 0.2)
                      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0), 0.2)
                      RW.C0 = clerp(RW.C0, cf(0.6, 0.4, -0.6) * euler(0.5 + (donum) / 4, 0, -0.4 - (donum) / 4) * euler(0, -1, 0), 0.2)
                      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                      LW.C0 = clerp(LW.C0, cf(-0.8, 0.4, -0.5) * euler(0.6 + (donum) / 4, 0, 0.3 - (donum) / 4) * euler(0, -1.3, 0), 0.2)
                      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0), 0.2)
                      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0), 0.2)
                    else
                      wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
                      Neck.C0 = clerp(Neck.C0, necko * euler(0.2 - (donum) / 5, 0, 0), 0.2)
                      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
                      if Mode == "Classic" then
                        RW.C0 = clerp(RW.C0, cf(1.45, 0.5, 0.2) * euler(0.8 - (donum) / 4, 0, 0.2 - (donum) / 4) * euler(0, 0, 0), 0.2)
                        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                      else
                        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.2 + (donum) / 5, 0, 0.2) * euler(0, 0, 0), 0.2)
                        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                      end
                      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4 + (donum) / 3, 0, -0.4 + (donum) / 3), 0.2)
                      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0), 0.2)
                      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0), 0.2)
                    end
                  end
                else
                  if 30 <= torvel and hitfloor ~= nil then
                    Anim = "Run"
                    if attack == false then
                      if Mode == "Dynamic Blade" then
                        wld1.C0 = clerp(wld1.C0, euler(1.6, 0, 0) * cf(0, 1.1, 0.2), 0.2)
                        Neck.C0 = clerp(Neck.C0, necko * euler(0.2 - (donum) / 5, 0, 0) * euler(0, 0, 0), 0.2)
                        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0), 0.2)
                        RW.C0 = clerp(RW.C0, cf(0.6, 0.4, -0.6) * euler(0.5 + (donum) / 4, 0, -0.4 - (donum) / 4) * euler(0, -1, 0), 0.2)
                        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                        LW.C0 = clerp(LW.C0, cf(-0.8, 0.4, -0.5) * euler(0.6 + (donum) / 4, 0, 0.3 - (donum) / 4) * euler(0, -1.3, 0), 0.2)
                        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                        RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0), 0.2)
                        LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0), 0.2)
                      else
                        wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
                        Neck.C0 = clerp(Neck.C0, necko * euler(0.2 - (donum) / 5, 0, 0), 0.2)
                        RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
                        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.2 + (donum) / 3, 0, 0.5 - (donum) / 3), 0.2)
                        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4 + (donum) / 3, 0, -0.4 + (donum) / 3), 0.2)
                        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                        RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0), 0.2)
                        LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0), 0.2)
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if 0 < #Effects then
          for e = 1, #Effects do
            if Effects[e] ~= nil then
              local Thing = Effects[e]
              if Thing ~= nil then
                local Part = Thing[1]
                local Mode = Thing[2]
                local Delay = Thing[3]
                local IncX = Thing[4]
                local IncY = Thing[5]
                local IncZ = Thing[6]
                if Thing[2] == "Shoot" then
                  local Look = Thing[1]
                  local hit, pos = rayCast(Thing[4], Look, 15, Character)
                  local mag = (Thing[4] - pos).magnitude
                  Thing[9] = Thing[9] + 0.5
                  Thing[5] = Thing[5] + 0.2
                  Thing[6] = Thing[6] + 0.2
                  MagicHead(BrickColor.new(NewCol2), CFrame.new((Thing[4] + pos) / 2, pos) * angles(1.57, 0, 0), Thing[9], mag * 5, Thing[9], -0.2, 0, -0.2, 0.1)
                  Thing[4] = Thing[4] + Look * 15
                  Thing[3] = Thing[3] - 1
                  if hit ~= nil then
                    Thing[3] = 0
                    Damagefunc(hit, Thing[5], Thing[6], Thing[7], "Normal", RootPart, 0, 2, (math.random(1, 5)), nil, nil, true)
                    ref = part(3, workspace, 0, 1, BrickColor.new("Really red"), "Reference", vt())
                    ref.Anchored = true
                    ref.CFrame = cf(pos)
                    MagicCircle(BrickColor.new(NewCol2), cf(pos), 5, 5, 5, 1, 1, 1, 0.07)
                    so("300916057", ref, 1, 2)
                    game:GetService("Debris"):AddItem(ref, 1)
                  end
                  if Thing[3] <= 0 then
                    table.remove(Effects, e)
                  end
                end
                do
                  if Thing[2] == "Shoot2" then
                    local Look = Thing[1]
                    local hit, pos = rayCast(Thing[4], Look, 3, Character)
                    local mag = (Thing[4] - pos).magnitude
                    Thing[9] = Thing[9] + 0.5
                    Thing[5] = Thing[5] + 0.2
                    Thing[6] = Thing[6] + 0.2
                    MagicCircle(BrickColor.new(NewCol2), CFrame.new((Thing[4] + pos) / 2, pos), 25, 25, 25, -5, -5, -5, 0.2)
                    Thing[4] = Thing[4] + Look * 3
                    Thing[3] = Thing[3] - 1
                    if hit ~= nil then
                      Thing[3] = 0
                      ref = part(3, workspace, 0, 1, BrickColor.new("Really red"), "Reference", vt())
                      ref.Anchored = true
                      ref.CFrame = cf(pos)
                      MagniDamage(ref, 10, 6, 8, math.random(15, 20), "Knockdown2", ref, 0, 1, (math.random(4, 6)), nil, nil, true)
                      MagicCircle(BrickColor.new(NewCol2), cf(pos), 25, 25, 25, 5, 5, 5, 0.1)
                      MagicCircle(BrickColor.new(NewCol2), cf(pos), 10, 10, 10, 15, 15, 15, 0.08)
                      so("300916057", ref, 1, 1.5)
                      game:GetService("Debris"):AddItem(ref, 1)
                    end
                    if Thing[3] <= 0 then
                      table.remove(Effects, e)
                    end
                  end
                  do
                    do
                      if Thing[2] == "CylinderClang" then
                        if Thing[3] <= 1 then
                          Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, 2.5 * Thing[5], 0) * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
                          Thing[7] = Thing[1].CFrame
                          effect("New Yeller", 0, Thing[8], Thing[7])
                          Thing[8] = Thing[7]
                          Thing[3] = Thing[3] + Thing[4]
                        else
                          Part.Parent = nil
                          table.remove(Effects, e)
                        end
                      end
                      if Thing[2] == "showDamage" then
                        if Thing[6] < Thing[5] then
                          Thing[6] = Thing[6] + 1
                        else
                          if Thing[6] < Thing[7] then
                            Thing[4].position = Thing[4].position + vt(0, -0.2, 0)
                            Thing[6] = Thing[6] + 1
                          else
                            if Thing[6] < Thing[8] then
                              Thing[6] = Thing[6] + 1
                            else
                              if Thing[6] < Thing[9] then
                                Thing[6] = Thing[6] + 1
                                Thing[4].position = Thing[4].position + vt(0, 0.2, 0)
                                Thing[3].TextStrokeTransparency = Thing[3].TextStrokeTransparency + 0.1
                                Thing[3].TextTransparency = Thing[3].TextTransparency + 0.1
                              else
                                Thing[1].Parent = nil
                                table.remove(Effects, e)
                              end
                            end
                          end
                        end
                      end
                      if Thing[2] ~= "Shoot" and Thing[2] ~= "DecreaseStat" and Thing[2] ~= "showDamage" and Thing[2] ~= "Shoot2" then
                        if Thing[1].Transparency <= 1 then
                          if Thing[2] == "Block1" then
                            Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                            Mesh = Thing[7]
                            Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                            Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                          else
                            if Thing[2] == "Block2" then
                              Thing[1].CFrame = Thing[1].CFrame
                              Mesh = Thing[7]
                              Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                              Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            else
                              if Thing[2] == "Block3" then
                                Thing[8].C0 = euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) * Thing[9]
                                Mesh = Thing[7]
                                Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                              else
                                if Thing[2] == "Cylinder" then
                                  Mesh = Thing[7]
                                  Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                  Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                else
                                  if Thing[2] == "Cylinder2" then
                                    Thing[1].CFrame = Thing[1].CFrame * cf(0, Thing[8], 0)
                                    Mesh = Thing[7]
                                    Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                    Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                  else
                                    if Thing[2] == "Blood" then
                                      Mesh = Thing[7]
                                      Thing[1].CFrame = Thing[1].CFrame * cf(0, 0.5, 0)
                                      Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                      Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                    else
                                      if Thing[2] == "Elec" then
                                        Mesh = Thing[10]
                                        Mesh.Scale = Mesh.Scale + vt(Thing[7], Thing[8], Thing[9])
                                        Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                      else
                                        if Thing[2] == "Disappear" then
                                          Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        else
                          Part.Parent = nil
                          table.remove(Effects, e)
                        end
                      end
                      -- DECOMPILER ERROR at PC11212: LeaveBlock: unexpected jumping out DO_STMT

                      -- DECOMPILER ERROR at PC11212: LeaveBlock: unexpected jumping out DO_STMT

                      -- DECOMPILER ERROR at PC11212: LeaveBlock: unexpected jumping out IF_THEN_STMT

                      -- DECOMPILER ERROR at PC11212: LeaveBlock: unexpected jumping out IF_STMT

                      -- DECOMPILER ERROR at PC11212: LeaveBlock: unexpected jumping out IF_THEN_STMT

                      -- DECOMPILER ERROR at PC11212: LeaveBlock: unexpected jumping out IF_STMT

                    end
                  end
                end
              end
            end
          end
        end
        fenbarmana2:TweenSize((UDim2.new(0.4, 0, -4 * mana.Value / 100, 0)), nil, 1, 0.4, true)
        fenbarmana4.Text = "Mana(" .. mana.Value .. ")"
        fenbarhp2.BackgroundColor3 = Color3.new(Humanoid.Health / Humanoid.MaxHealth, 0, 0)
        fenbarhp2:TweenSize((UDim2.new(Humanoid.Health / Humanoid.MaxHealth, 0, 1, 0)), nil, 1, 0.4, true)
        fenbarhp3.Text = "(" .. math.floor(Humanoid.Health) .. ")"
        fenbarblock2:TweenSize((UDim2.new(0.4, 0, -4 * (overload) / 100, 0)), nil, 1, 0.4, true)
        fenbarblock3.Text = "Overload(" .. overload .. ")"
        fenbarmove1b:TweenSize((UDim2.new(1 * cooldowns[1] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
        fenbarmove2b:TweenSize((UDim2.new(1 * cooldowns[2] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
        fenbarmove3b:TweenSize((UDim2.new(1 * cooldowns[3] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
        fenbarmove4b:TweenSize((UDim2.new(1 * cooldowns[4] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
        for _,c in pairs(Decrease:children()) do
          if (c:findFirstChild("Duration")) ~= nil then
            c.Duration.Value = c.Duration.Value - 1
            if c.Duration.Value <= 0 then
              c.Parent = nil
            end
          end
          if c.Name == "DecreaseAtk" then
            decreaseatk = decreaseatk + c.Value
          else
            if c.Name == "DecreaseDef" then
              decreasedef = decreasedef + c.Value
            else
              if c.Name == "DecreaseMvmt" then
                decreasemvmt = decreasemvmt + c.Value
              end
            end
          end
        end
        Atk.Value = 1 - (decreaseatk)
        if Atk.Value <= 0 then
          Atk.Value = 0
        end
        Def.Value = 1 - (decreasedef)
        if Def.Value <= 0 then
          Def.Value = 0.01
        end
        Mvmt.Value = 1 - (decreasemvmt)
        if Mvmt.Value <= 0 then
          Mvmt.Value = 0
        end
        decreaseatk = 0
        decreasedef = 0
        decreasemvmt = 0
        AtkVal = Atk.Value * 100
        AtkVal = math.floor(AtkVal)
        AtkVal = AtkVal / 100
        fenbardamage.Text = "Damage\n(" .. AtkVal .. ")"
        DefVal = Def.Value * 100
        DefVal = math.floor(DefVal)
        DefVal = DefVal / 100
        fenbardef.Text = "Defense\n(" .. DefVal .. ")"
        MvmtVal = Mvmt.Value * 100
        MvmtVal = math.floor(MvmtVal)
        MvmtVal = MvmtVal / 100
        if Rooted.Value == true then
          MvmtVal = 0
        end
        fenbarmove.Text = "Walkspeed\n(" .. MvmtVal .. ")"
        if StunT.Value <= Stun.Value then
          fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4, 0)), nil, 1, 0.4, true)
        else
          fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4 * Stun.Value / StunT.Value, 0)), nil, 1, 0.4, true)
        end
        fenbarstun3.Text = "Stun(" .. Stun.Value .. ")"
        if 100 <= mana.Value then
          mana.Value = 100
        else
          if mananum <= manainc then
            mananum = mananum + 1
          else
            mananum = 0
            mana.Value = mana.Value + 1
          end
        end
        for i = 1, #cooldowns do
          if cooldownmax <= cooldowns[i] then
            cooldowns[i] = cooldownmax
          else
            cooldowns[i] = cooldowns[i] + cooldownsadd[i]
          end
        end
      end
    end
  end
end
]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="HopperBin" referent="RBX12AC8CAE2D64442F95764F32E5E38D33">
			<Properties>
				<bool name="Active">false</bool>
				<token name="BinType">0</token>
				<string name="Name">Grand</string>
				<Content name="TextureId"><null></null></Content>
			</Properties>
			<Item class="LocalScript" referent="RBXD1C5E47800BA4D6AABF73FEBCA065133">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LocalScript</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[Player = game:GetService("Players").LocalPlayer
Character = Player.Character
PlayerGui = Player.PlayerGui
Backpack = Player.Backpack
Torso = Character.Torso
Head = Character.Head
Humanoid = Character.Humanoid
LeftArm = Character["Left Arm"]
LeftLeg = Character["Left Leg"]
RightArm = Character["Right Arm"]
RightLeg = Character["Right Leg"]
LS = Torso["Left Shoulder"]
LH = Torso["Left Hip"]
RS = Torso["Right Shoulder"]
RH = Torso["Right Hip"]
Neck = Torso.Neck
it = Instance.new
vt = Vector3.new
cf = CFrame.new
euler = CFrame.fromEulerAnglesXYZ
angles = CFrame.Angles
necko = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
necko2 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
LHC0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
LHC1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
RHC0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RHC1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RootPart = Character.HumanoidRootPart
RootJoint = RootPart.RootJoint
RootCF = euler(-1.57, 0, 3.14)
attack = false
attackdebounce = false
MMouse = Player:GetMouse()
combo = 0
local hitfloor, posfloor = nil, nil
local idle = 0
local Anim = "Idle"
local Effects = {}
local Weapon = {}
local Welds = {}
local decreaseatk = 0
local decreasedef = 0
local decreasemvmt = 0
local holdz = false
local doing2 = false
local do2mode = "none"
local do2target = nil
local dodrop = false
local instastun = false
local guarding = false
local canguardoff = true
local doing4 = false
local sref = nil
local grabpos = Instance.new("BodyPosition")
local grabhit = false
local grabTarget = nil
local cangrab = true
local mode = "Sheathed"
local move1 = "(Z)\nEarth Breaker"
local move2 = "(X)\nChase/Drop"
local move3 = "(C)\nSiege Guard"
local move4 = "(V)\nEpicenter"
local cooldowns = {}
local cooldown1 = 0
table.insert(cooldowns, cooldown1)
local cooldown2 = 0
table.insert(cooldowns, cooldown2)
local cooldown3 = 0
table.insert(cooldowns, cooldown3)
local cooldown4 = 0
table.insert(cooldowns, cooldown4)
local cooldownsadd = {}
local cooldownadd1 = 0.22
table.insert(cooldownsadd, cooldownadd1)
local cooldownadd2 = 0.28
table.insert(cooldownsadd, cooldownadd2)
local cooldownadd3 = 0.24
table.insert(cooldownsadd, cooldownadd3)
local cooldownadd4 = 0.1
table.insert(cooldownsadd, cooldownadd4)
local cooldownmax = 100
player = nil
RSH = nil
LW = Instance.new("Motor")
RW = Instance.new("Motor")
RW.Name = "Right Shoulder"
LW.Name = "Left Shoulder"
LH = Torso["Left Hip"]
RH = Torso["Right Hip"]
TorsoColor = Torso.BrickColor
NewCol = BrickColor.new("Medium stone grey").Color
NewCol2 = BrickColor.new("Dark stone grey").Color
NewCol3 = BrickColor.new("Hurricane grey").Color
NewCol4 = BrickColor.new("Smoky grey").Color
EffectCol = BrickColor.new("Bright yellow").Color
print(BrickColor.new(NewCol2))
local mdec = Instance.new("NumberValue", Decrease)
mdec.Name = "DecreaseDef"
mdec.Value = 0.4
grnd = it("BoolValue", mdec)
grnd.Name = "Grand"
grnd.Value = true
local mdec2 = Instance.new("NumberValue", Decrease)
mdec2.Name = "DecreaseMvmt"
mdec2.Value = 0.1
grnd = it("BoolValue", mdec2)
grnd.Name = "Grand"
grnd.Value = true
local Animate = Humanoid.Animator
local canjump = true
removeControl = function()
  canjump = false
end
resumeControl = function()
  canjump = true
end
Player.Character.Humanoid.Changed:connect(function()
  if canjump == false then
    Player.Character.Humanoid.Jump = false
  end
end)
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 0, num do
			ArtificialHB.Event:wait()
		end
	end
end
createpassgui = function(parent)
  print("makegui111")
  local g = Instance.new("ScreenGui", parent)
  local f = Instance.new("Frame", g)
  f.Position = UDim2.new(0.3, 0, 0.25, 0)
  f.Size = UDim2.new(0.4, 0, 0.4, 0)
  f.Style = "DropShadow"
  local t = Instance.new("TextBox", f)
  t.BackgroundColor3 = Color3.new(0, 0, 0)
  t.BackgroundTransparency = 0.5
  t.BorderSizePixel = 0
  t.Position = UDim2.new(0.15, 0, 0.2, 0)
  t.Size = UDim2.new(0.7, 0, 0.2, 0)
  t.Font = "SourceSansLight"
  t.Text = "Enter Access Code."
  t.TextScaled = true
  t.TextColor3 = Color3.new(1, 1, 1)
  t.TextStrokeTransparency = 0
  local t2 = Instance.new("TextButton", f)
  t2.BackgroundColor3 = Color3.new(0, 0, 0)
  t2.BackgroundTransparency = 0.5
  t2.BorderSizePixel = 0
  t2.Position = UDim2.new(0.3, 0, 0.5, 0)
  t2.Size = UDim2.new(0.4, 0, 0.15, 0)
  t2.TextScaled = true
  t2.Font = "SourceSansLight"
  t2.Text = "Submit"
  t2.TextColor3 = Color3.new(1, 1, 1)
  t2.TextStrokeTransparency = 0
  print("done1")
  return t2
end
gud = true
repeat
  wait()
until gud
if Character:findFirstChild("Auswirkung", true) ~= nil then
  Character:findFirstChild("Auswirkung", true).Parent = nil
end
if Player.PlayerGui:findFirstChild("WeaponGUI", true) ~= nil then
  Player.PlayerGui:findFirstChild("WeaponGUI", true).Parent = nil
end
if Character:findFirstChild("Stats", true) ~= nil then
  Character:findFirstChild("Stats", true).Parent = nil
end
local Stats = Instance.new("BoolValue")
Stats.Name = "Stats"
Stats.Parent = Character
local Atk = Instance.new("NumberValue")
Atk.Name = "Damage"
Atk.Parent = Stats
Atk.Value = 1
local Def = Instance.new("NumberValue")
Def.Name = "Defense"
Def.Parent = Stats
Def.Value = 1
local Mvmt = Instance.new("NumberValue")
Mvmt.Name = "Movement"
Mvmt.Parent = Stats
Mvmt.Value = 1
local Block = Instance.new("BoolValue")
Block.Name = "Block"
Block.Parent = Stats
Block.Value = false
local Stun = Instance.new("NumberValue")
Stun.Name = "Stun"
Stun.Parent = Stats
Stun.Value = 0
local StunT = Instance.new("NumberValue")
StunT.Name = "StunThreshold"
StunT.Parent = Stats
StunT.Value = 200
local Rooted = Instance.new("BoolValue")
Rooted.Name = "Rooted"
Rooted.Parent = Stats
Rooted.Value = false
local Stunned = Instance.new("BoolValue")
Stunned.Name = "Stunned"
Stunned.Parent = Stats
Stunned.Value = false
local Stagger = Instance.new("BoolValue")
Stagger.Name = "Stagger"
Stagger.Parent = Stats
Stagger.Value = false
local StaggerHit = Instance.new("BoolValue")
StaggerHit.Name = "StaggerHit"
StaggerHit.Parent = Stats
StaggerHit.Value = false
local RecentEnemy = Instance.new("ObjectValue")
RecentEnemy.Name = "RecentEnemy"
RecentEnemy.Parent = Stats
RecentEnemy.Value = nil
local Decrease = Instance.new("BoolValue")
Decrease.Name = "Decrease"
Decrease.Parent = Stats
Decrease.Value = false
local mana = Instance.new("NumberValue")
mana.Name = "Mana"
mana.Parent = Stats
mana.Value = 0
local passive1 = Instance.new("NumberValue", Decrease)
passive1.Name = "DecreaseAtk"
passive1.Value = 0
local passive2 = Instance.new("NumberValue", Decrease)
passive2.Name = "DecreaseDef"
passive2.Value = 0
grnd = it("BoolValue", passive2)
grnd.Name = "Grand"
grnd.Value = true
local passive3 = Instance.new("NumberValue", Decrease)
passive3.Name = "DecreaseMvmt"
passive3.Value = 0
grnd = it("BoolValue", passive3)
grnd.Name = "Grand"
grnd.Value = true
NoOutline = function(Part)
  Part.TopSurface = 10
end
part = function(formfactor, parent, reflectance, transparency, brickcolor, name, size)
  local fp = it("Part")
  fp.formFactor = formfactor
  fp.Parent = parent
  fp.Reflectance = reflectance
  fp.Transparency = transparency
  fp.CanCollide = false
  fp.Locked = true
  fp.BrickColor = brickcolor
  fp.Name = name
  fp.Size = size
  fp.Position = Torso.Position
  NoOutline(fp)
  fp.Material = "SmoothPlastic"
  fp:BreakJoints()
  return fp
end
mesh = function(Mesh, part, meshtype, meshid, offset, scale)
  local mesh = it(Mesh)
  mesh.Parent = part
  if Mesh == "SpecialMesh" then
    mesh.MeshType = meshtype
    if meshid ~= "nil" then
      mesh.MeshId = "http://www.roblox.com/asset/?id=" .. meshid
    end
  end
  mesh.Offset = offset
  mesh.Scale = scale
  return mesh
end
weld = function(parent, part0, part1, c0)
  local weld = it("Motor")
  weld.Parent = parent
  weld.Part0 = part0
  weld.Part1 = part1
  weld.C0 = c0
  return weld
end
gui = function(GuiType, parent, text, backtrans, backcol, pos, size)
  local gui = it(GuiType)
  gui.Parent = parent
  gui.Text = text
  gui.BackgroundTransparency = backtrans
  gui.BackgroundColor3 = backcol
  gui.SizeConstraint = "RelativeXY"
  gui.TextXAlignment = "Center"
  gui.TextYAlignment = "Center"
  gui.Position = pos
  gui.Size = size
  gui.Font = "SourceSans"
  gui.FontSize = "Size14"
  gui.TextWrapped = false
  gui.TextStrokeTransparency = 0
  gui.TextColor = BrickColor.new("White")
  return gui
end
local Color1 = Torso.BrickColor
local fengui = it("GuiMain")
fengui.Parent = Player.PlayerGui
fengui.Name = "WeaponGUI"
local fenframe = it("Frame")
fenframe.Parent = fengui
fenframe.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe.BackgroundTransparency = 1
fenframe.BorderColor3 = Color3.new(17, 17, 17)
fenframe.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe.Position = UDim2.new(0.95, 0, 0.7, 0)
local fenframe2 = it("Frame")
fenframe2.Parent = fengui
fenframe2.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe2.BackgroundTransparency = 1
fenframe2.BorderColor3 = Color3.new(17, 17, 17)
fenframe2.Size = UDim2.new(0.2, 0, 0.1, 0)
fenframe2.Position = UDim2.new(0.4, 0, 0.85, 0)
local fenframe3 = it("Frame")
fenframe3.Parent = fengui
fenframe3.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe3.BackgroundTransparency = 1
fenframe3.BorderColor3 = Color3.new(17, 17, 17)
fenframe3.Size = UDim2.new(0.2, 0, 0.2, 0)
fenframe3.Position = UDim2.new(0.8, 0, 0.8, 0)
local fenframe4 = it("Frame")
fenframe4.Parent = fengui
fenframe4.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe4.BackgroundTransparency = 1
fenframe4.BorderColor3 = Color3.new(17, 17, 17)
fenframe4.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe4.Position = UDim2.new(0, 0, 0.7, 0)
local pressedf = false
local fenframe5 = it("Frame")
fenframe5.Parent = fengui
fenframe5.BackgroundColor3 = Color3.new(0, 0, 0)
fenframe5.BackgroundTransparency = 1
fenframe5.BorderColor3 = Color3.new(0, 0, 0)
fenframe5.Size = UDim2.new(1, 0, 1, 0)
fenframe5.Position = UDim2.new(0, 0, 0, 0)
fenframe5.ZIndex = 2
local tellbar = gui("TextLabel", fenframe5, "Press \'F\' to equip your weapon.", 1, Color3.new(0, 0, 0), UDim2.new(0.25, 0, 0.25, 0), UDim2.new(0.5, 0, 0.5, 0))
tellbar.Font = "Arial"
tellbar.TextScaled = true
tellbar.TextTransparency = 1
tellbar.TextStrokeTransparency = 1
tellbar.ZIndex = 2
local fnumb = 0
local fenbarmana1 = gui("TextLabel", fenframe, "", 0, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarmana2 = gui("TextLabel", fenframe, "", 0, BrickColor.new(NewCol2).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarmana4 = gui("TextLabel", fenframe, "Mana(" .. mana.Value .. ")", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbardamage = gui("TextLabel", fenframe2, "Damage", 0.55, Color3.new(0.6078431372549, 0, 0), UDim2.new(-0.23, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbardef = gui("TextLabel", fenframe2, "Defense", 0.55, Color3.new(0, 0, 0.6078431372549), UDim2.new(-0.46, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarmove = gui("TextLabel", fenframe2, "Walkspeed", 0.55, Color3.new(0, 0.6078431372549, 0), UDim2.new(1.03, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarhp1 = gui("TextLabel", fenframe2, "", 0, Color3.new(0, 0, 0), UDim2.new(-0.46, 0, 1, 0), UDim2.new(1.92, 0, 0.4, 0))
local fenbarhp2 = gui("TextLabel", fenbarhp1, "", 0, Color3.new(1, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarhp3 = gui("TextLabel", fenbarhp1, "(100)", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
local fenbarstun1 = gui("TextLabel", fenframe4, "", 0, Color3.new(0, 0, 0), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarstun2 = gui("TextLabel", fenframe4, "", 0, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarstun3 = gui("TextLabel", fenframe4, "Stun(" .. Stun.Value .. ")", 1, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbarmove1 = gui("TextButton", fenframe3, move1, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove1.ZIndex = 2
local fenbarmove1b = gui("TextLabel", fenbarmove1, "", 0.55, BrickColor.new(NewCol2).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove2 = gui("TextButton", fenframe3, move2, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove2.ZIndex = 2
local fenbarmove2b = gui("TextLabel", fenbarmove2, "", 0.55, BrickColor.new(NewCol2).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove3 = gui("TextButton", fenframe3, move3, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove3.ZIndex = 2
local fenbarmove3b = gui("TextLabel", fenbarmove3, "", 0.55, BrickColor.new(NewCol2).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove4 = gui("TextButton", fenframe3, move4, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove4.ZIndex = 2
local fenbarmove4b = gui("TextLabel", fenbarmove4, "", 0.55, BrickColor.new(NewCol2).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local modelzorz = Instance.new("Model")
modelzorz.Parent = Character
modelzorz.Name = "Auswirkung"
local handle = part(3, modelzorz, 0, 1, BrickColor.new(NewCol), "Handle", vt())
local prt1 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol), "Part01", vt())
local prt3 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol3), "Part03", vt())
local prt4 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol4), "Part04", vt())
local prt6 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol), "Part06", vt())
local prt7 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol), "Part07", vt())
local prt8 = part(3, modelzorz, 0.1, 0, BrickColor.new(NewCol), "Part08", vt())
prt8.Material = "Metal"
local prt9 = part(3, modelzorz, 0.1, 0, BrickColor.new(NewCol), "Part09", vt())
prt9.Material = "Metal"
local prt10 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol3), "Part10", vt())
local prt11 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol2), "Part11", vt())
local prt12 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol3), "Part12", vt())
local prt13 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol2), "Part13", vt())
local prt14 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol3), "Part14", vt())
local prt15 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol2), "Part15", vt())
local prt16 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol2), "Part16", vt())
local prt18 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol2), "Part18", vt())
local prt19 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol2), "Part19", vt())
local prt20 = part(3, modelzorz, 0.4, 0, BrickColor.new(NewCol), "Part20", vt())
local prt23 = part(3, modelzorz, 0.3, 0, BrickColor.new(NewCol4), "Part23", vt())
local prt24 = part(3, modelzorz, 0.3, 0, BrickColor.new(NewCol4), "Part24", vt())
hmsh = mesh("BlockMesh", handle, "", "", vt(0, 0, 0), vt(3, 3, 3))
msh1 = mesh("CylinderMesh", prt1, "", "", vt(0, 0, 0), vt(1.35, 14, 5))
msh3 = mesh("CylinderMesh", prt3, "", "", vt(0, 0, 0), vt(1.25, 1.9, 7))
msh4 = mesh("CylinderMesh", prt4, "", "", vt(0, 0, 0), vt(1.55, 1.75, 5))
msh6 = mesh("SpecialMesh", prt6, "Torso", "nil", vt(0, 0, 0), vt(5, 1, 1.5))
msh7 = mesh("SpecialMesh", prt7, "Torso", "nil", vt(0, 0, 0), vt(10, 1.25, 1.5))
msh8 = mesh("SpecialMesh", prt8, "Torso", "nil", vt(0, 0, 0), vt(4.5, 1, 1.6))
msh9 = mesh("SpecialMesh", prt9, "Torso", "nil", vt(0, 0, 0), vt(9.5, 1, 1.6))
msh10 = mesh("CylinderMesh", prt10, "", "", vt(0, 0, 0), vt(1, 1.9, 7))
msh11 = mesh("BlockMesh", prt11, "", "", vt(0, 0, 0), vt(1.25, 1.25, 1.7))
msh12 = mesh("CylinderMesh", prt12, "", "", vt(0, 0, 0), vt(0.75, 1.85, 7))
msh13 = mesh("BlockMesh", prt13, "", "", vt(0, 0, 0), vt(0.75, 0.075, 1.9))
msh14 = mesh("CylinderMesh", prt14, "", "", vt(0, 0, 0), vt(0.75, 1.85, 7))
msh15 = mesh("BlockMesh", prt15, "", "", vt(0, 0, 0), vt(0.75, 0.075, 1.9))
msh16 = mesh("BlockMesh", prt16, "", "", vt(0, 0, 0), vt(7.5, 0.5, 1.15))
msh18 = mesh("BlockMesh", prt18, "", "", vt(0, 0, 0), vt(1, 7.5, 1.15))
msh19 = mesh("BlockMesh", prt19, "", "", vt(0, 0, 0), vt(1, 1, 1.15))
msh20 = mesh("BlockMesh", prt20, "", "", vt(0, 0, 0), vt(7, 35, 1))
msh23 = mesh("BlockMesh", prt23, "", "", vt(0, 0, 0), vt(7.5, 0.25, 1))
msh24 = mesh("BlockMesh", prt24, "", "", vt(0, 0, 0), vt(7.5, 0.7, 0.7))
local handlewld = weld(handle, handle, Torso, euler(0, 0, -0.9) * cf(3.2, -3, -0.6))
local wld1 = weld(prt1, prt1, handle, euler(0, 0, 0) * cf(0, 0, 0))
local wld3 = weld(prt1, prt3, prt1, euler(0, 0, 0) * cf(0, -1.35, 0))
local wld4 = weld(prt1, prt4, prt1, euler(0, 0, 0) * cf(0, -1.35, 0))
local wld6 = weld(prt1, prt6, prt1, euler(0, 0, 0) * cf(0, 1.475, 0))
local wld7 = weld(prt1, prt7, prt1, euler(-3.14, 0, 0) * cf(0, 1.7, 0))
local wld8 = weld(prt1, prt8, prt1, euler(0, 0, 0) * cf(0, 1.5, 0))
local wld9 = weld(prt1, prt9, prt1, euler(-3.14, 0, 0) * cf(0, 1.7, 0))
local wld10 = weld(prt1, prt10, prt1, euler(1.57, 0, 0) * cf(0, 1.6, 0))
local wld11 = weld(prt1, prt11, prt1, euler(0, 0, 0.785) * cf(0, 1.6, 0))
local wld12 = weld(prt1, prt12, prt1, euler(1.57, 0, 0) * cf(0.3, 1.6, 0))
local wld13 = weld(prt1, prt13, prt1, euler(0, 0, -2.96) * cf(0.3, 1.6, 0))
local wld14 = weld(prt1, prt14, prt1, euler(1.57, 0, 0) * cf(-0.3, 1.6, 0))
local wld15 = weld(prt1, prt15, prt1, euler(0, 0, 2.18) * cf(-0.3, 1.6, 0))
local wld16 = weld(prt1, prt16, prt1, euler(0, 0, 0) * cf(0, 1.875, 0))
local wld18 = weld(prt1, prt18, prt1, euler(0, 0, 0) * cf(0, 2.675, 0))
local wld19 = weld(prt1, prt19, prt1, euler(0, 0, 0.785) * cf(0, 3.45, 0))
local wld20 = weld(prt1, prt20, prt1, euler(0, 0, 0) * cf(0, 5.275, 0))
local wld23 = weld(prt1, prt23, prt1, euler(0, 0, 0) * cf(0, 8.8, 0))
local wld24 = weld(prt1, prt24, prt1, euler(0.785, 0, 0) * cf(0, 8.825, 0))
di = -1.1
for i = 1, 17 do
  local prt2 = part(3, modelzorz, 0, 0, Torso.BrickColor, "Part02", vt())
  prt2.Material = "Plastic"
  msh2 = mesh("CylinderMesh", prt2, "", "", vt(0, 0, 0), vt(1.5, 0.75, 5))
  local wld2 = weld(prt1, prt2, prt1, euler(math.random(-20, 20) / 100, 0, math.random(-20, 20) / 100) * cf(0, di, 0))
  di = di + 0.148
end
for i = 0.785, 2.356 do
  local prt5 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol2), "Part05", vt())
  msh5 = mesh("BlockMesh", prt5, "", "", vt(0, 0, 0), vt(1.25, 0.1, 1.95))
  local wld5 = weld(prt1, prt5, prt1, euler(-1.57, i, 0) * cf(0, -1.35, 0))
end
for i = 1.57, 3.15 do
  local prt12 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol2), "Part12", vt())
  msh12 = mesh("BlockMesh", prt12, "", "", vt(0, 0, 0), vt(1, 0.1, 1.95))
  local wld12 = weld(prt1, prt12, prt1, euler(0, 0, i) * cf(0, 1.6, 0))
end
for i = -0.75, 0.76 do
  local prt17 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol2), "Part17", vt())
  msh17 = mesh("BlockMesh", prt17, "", "", vt(0, 0, 0), vt(0.8, 0.5, 0.8))
  local wld17 = weld(prt1, prt17, prt1, euler(0, 0.785, 0) * cf(i, 1.875, 0))
end
for i = -1, 1, 2 do
  local prt21 = part(3, modelzorz, 0.3, 0, BrickColor.new(NewCol4), "Part21", vt())
  local prt22 = part(3, modelzorz, 0.3, 0, BrickColor.new(NewCol4), "Part22", vt())
  msh21 = mesh("BlockMesh", prt21, "", "", vt(0, 0, 0), vt(0.25, 35, 1))
  msh22 = mesh("BlockMesh", prt22, "", "", vt(0, 0, 0), vt(0.7, 35.25, 0.7))
  local wld21 = weld(prt1, prt21, prt1, euler(0, 0, 0) * cf(0.725 * i, 5.275, 0))
  local wld22 = weld(prt1, prt22, prt1, euler(0, 0.785, 0) * cf(0.75 * i, 5.3, 0))
  local prt25 = part(3, modelzorz, 0.3, 0, BrickColor.new(NewCol4), "Part25", vt())
  msh25 = mesh("SpecialMesh", prt25, "FileMesh", "9756362", vt(0, 0, 0), vt(0.14, 0.14, 0.14))
  local wld25 = weld(prt1, prt25, prt1, euler(2.1517, -1.569, 2.1516) * cf(0.75 * i, 8.825, 0))
end
for _,c in pairs(modelzorz:children()) do
  table.insert(Weapon, c)
end
for _,c in pairs(prt1:children()) do
  if c.className == "Motor" then
    table.insert(Welds, c)
  end
end
local effects = it("Model", modelzorz)
effects.Name = "Effects"
local hitbox = part(3, modelzorz, 0, 1, BrickColor.new("Black"), "Hitbox", vt())
hitbox.Anchored = false
local hitboxCF = cf(0, 0, 0)
hboxpos = Instance.new("BodyPosition", nil)
hboxpos.P = 2000
hboxpos.D = 100
hboxpos.maxForce = Vector3.new(545000, 545000, 545000)
local nr = NumberRange.new
local ns = NumberSequence.new
local cs = ColorSequence.new
local parti = it("ParticleEmitter")
parti.Color = cs(Color3.new(255, 255, 255), EffectCol)
parti.LightEmission = 0
parti.Size = ns(0.2)
parti.Texture = "http://www.roblox.com/asset/?id=37332909"
sizeseq = ns({NumberSequenceKeypoint.new(0, 0.125), NumberSequenceKeypoint.new(0.125, 3), NumberSequenceKeypoint.new(1, 1)})
transseq = ns({NumberSequenceKeypoint.new(0, 0.5), NumberSequenceKeypoint.new(0.8, 0.8), NumberSequenceKeypoint.new(1, 1)})
parti.Transparency = transseq
parti.Size = sizeseq
parti.ZOffset = 0
parti.Acceleration = vt(0, 0, 0)
parti.LockedToPart = true
parti.Lifetime = nr(0.5)
parti.Rate = 50
parti.Rotation = nr(0, 0)
parti.RotSpeed = nr(500)
parti.Speed = nr(-8)
parti.VelocitySpread = 360
parti.Parent = Torso
parti.Enabled = false
parti2 = parti:Clone()
parti2.Color = cs(EffectCol, Color3.new(255, 255, 255))
parti2.Texture = "http://www.roblox.com/asset/?id=316957314"
sizeseq = ns({NumberSequenceKeypoint.new(0, 0.125), NumberSequenceKeypoint.new(0.5, 8), NumberSequenceKeypoint.new(1, 10)})
transseq = ns({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.5, 0.9), NumberSequenceKeypoint.new(1, 1)})
parti2.Transparency = transseq
parti2.Size = sizeseq
parti2.ZOffset = 1
parti2.Lifetime = nr(1)
parti2.Rate = 10
parti2.Rotation = nr(0, 360)
parti2.RotSpeed = nr(100, 360)
parti2.Speed = nr(0)
parti2.VelocitySpread = 0
parti2.Parent = Torso
parti2.Enabled = false
if script.Parent.className ~= "HopperBin" then
  Tool = Instance.new("HopperBin")
  Tool.Parent = Backpack
  Tool.Name = "Auswirkung"
  script.Parent = Tool
end
Bin = script.Parent
if Bin.Name == "Grand" then
  Bin.Name = "Auswirkung"
end
local bodvel = Instance.new("BodyVelocity")
local bg = Instance.new("BodyGyro")
so = function(id, par, vol, pit, sord, dec, timer)
  local sou = Instance.new("Sound", par or workspace)
  sou.Volume = vol
  sou.Pitch = pit or 1
  sou.SoundId = "http://www.roblox.com/asset/?id=" .. id
  coroutine.resume(coroutine.create(function(Sound)
    swait()
    Sound:play()
  end), sou)
  game:GetService("Debris"):AddItem(sou, 6)
  if sord == true then
    table.insert(Effects, {sou, "Sound", dec, timer})
  end
end
function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end
hideanim = function()
  equipped = false
  mdec2.Parent = nil
  mdec.Parent = Decrease
  for i = 0, 1, 0.1 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0), 0.4)
  end
end
mdec.Parent = Decrease
equipanim = function()
  equipped = true
  mdec.Parent = nil
  mdec2.Parent = Decrease
  for i = 0, 1, 0.1 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0.3, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.1) * euler(0, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.8, 0.4, -0.3) * euler(1.3, 0, -1.4) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.8, 0.4, -0.3) * euler(1.3, 0, 1.4) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.1) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.1) * euler(0, -1.57, 0) * euler(-0.1, 0.1, 0), 0.3)
  end
  for i = 0, 1, 0.07 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0.05, 0, 0), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.1) * euler(0, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.4, 0.4, -0.5) * euler(1.5, 0, -1.5) * euler(0, -0.3, 0), 0.6)
    LW.C0 = clerp(LW.C0, cf(-1.4, 0.4, -0.5) * euler(1.5, 0, 1.5) * euler(0, 0.3, 0), 0.6)
    RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.1) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.1) * euler(0, -1.57, 0) * euler(-0.1, 0.1, 0), 0.3)
  end
end
StaggerAnim = function()
  attack = true
  removeControl()
  if mode == "Unsheathed" then
    for i = 1, math.random(2, 4) do
      ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
    end
  end
  do
    for i = 0, 1, 0.35 do
      swait()
      if Rooted.Value == false then
        Torso.Velocity = RootPart.CFrame.lookVector * -40
      end
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, -0.4), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.7) * euler(0, -0.7, 0), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
    end
    for i = 0, 1, 0.2 do
      swait()
      if Rooted.Value == false then
        Torso.Velocity = RootPart.CFrame.lookVector * -40
      end
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(-0.5, 0, -0.4), 0.4)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.7) * euler(0, -0.7, 0), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.5), 0.4)
    end
    for i = 0, 1, 0.1 do
      swait()
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(0.5, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.8) * euler(-0.2, 0, -0.4), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.3, 0, 0.4) * euler(0, -0.4, 0), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.3, 0, -0.2) * euler(0, 0.4, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 1.2), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1, 0, -1) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
    end
    for i = 1, 40 do
      swait()
      if StunT.Value <= Stun.Value then
        break
      end
    end
    do
      resumeControl()
      combo = 0
      attack = false
    end
  end
end
StaggerHitt = function()
  if mode == "Unsheathed" then
    Stun.Value = Stun.Value + math.random(3, 4)
    for i = 1, math.random(2, 4) do
      ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
    end
  end
end
StunAnim = function()
  attack = true
  removeControl()
  Stunned.Value = true
  showDamage(Character, "Stunned", "Interrupt")
  local dec = Instance.new("NumberValue", Decrease)
  dec.Name = "DecreaseMvmt"
  dec.Value = 10
  if mode == "Sheathed" then
    for i = 0, 1, 0.3 do
      swait()
      Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.5), 0.2)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.2, 0, -3), 0.2)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 1.3), 0.2)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
      LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1, 0, 0.4) * euler(0, -0.1, 0), 0.2)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
      RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.3), 0.25)
      LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, 0), 0.25)
    end
    for i = 0, 1, 0.3 do
      swait()
      Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -0.5), 0.2)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0.8, 0, -3), 0.2)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
      LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1.2, 0, 0.8) * euler(0, -0.1, 0), 0.2)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
      RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.25)
      LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(0.1, 0, 0.7), 0.25)
    end
    for i = 0, 1, 0.3 do
      swait()
      Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -1), 0.2)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1.57, 0, -3), 0.2)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, -0.8) * euler(0, -0.1, 0), 0.2)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
      RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.6), 0.25)
      LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.1, 0, 0.3), 0.25)
    end
    local gairost = Instance.new("BodyGyro")
    gairost.Parent = RootPart
    gairost.maxTorque = Vector3.new(400000, 0, 400000) * math.huge
    gairost.P = 20000
    gairost.cframe = cf(0, 0, 0)
    for i = 0, 1, 0.1 do
      swait()
      if hitfloor ~= nil then
        Torso.Velocity = vt(0, 0, 0)
      end
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2.5) * euler(1.57, 0, -3.14), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1.5) * euler(0.2, 0, 0), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.5, 0, -1.57) * euler(0, 0, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 0), 0.3)
    end
    for i = 1, 70 do
      swait()
      gairost.cframe = RootPart.CFrame
      if hitfloor ~= nil then
        Torso.Velocity = vt(0, 0, 0)
      end
    end
    for i = 0, 1, 0.2 do
      swait()
      Stun.Value = 0
      gairost.cframe = RootPart.CFrame
      Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1, 0, -4), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1) * euler(0.2, -1, 0), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, 0.2) * euler(0, 0, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0.4), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1, -1, -1) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 1), 0.3)
    end
    gairost.Parent = nil
  else
    do
      for i = 0, 1, 0.2 do
        swait()
        handlewld.Part1 = RightArm
        handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
        wld1.C0 = clerp(wld1.C0, cf(0, 0.7, 0) * euler(0, 1.57, 0) * euler(-2.1, 0, 0), 0.3)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.2) * euler(0.3, 0, 0), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1) * euler(0.1, 0, 0) * euler(0, 0, -0.3), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.2, 0.5, -0.3) * euler(-0.4, 0, 0.5) * euler(0, 0.3, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(0.4, 0.4, -0.5) * euler(0.4, 0, 0.5) * euler(0, 0.8, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(1, -0.5, -0.6) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0) * euler(0, 0, -0.6), 0.3)
        LH.C0 = clerp(LH.C0, cf(-1.2, -0.1, -0.4) * euler(0, -1.57, 0) * euler(0, 0.3, 0) * euler(0, 0, -0.1) * euler(-0.1, 0, 0), 0.3)
      end
      for i = 0, 1, 0.1 do
        swait()
        handlewld.Part1 = RightArm
        handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
        wld1.C0 = clerp(wld1.C0, cf(0, -0.3, 0) * euler(0, 1.57, 0) * euler(-1.9, 0, 0), 0.3)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(0.4, 0, 0), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.5) * euler(0.1, 0, 0) * euler(0, 0, -0.3), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.2, 0.5, -0.3) * euler(0, 0, 0.5) * euler(0, 0.5, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-1, 0.3, -0.7) * euler(0.2, 0, 1.4) * euler(0, -1.2, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(1, -0.7, -0.7) * euler(0, 1.57, 0) * euler(-0.2, -0.1, 0) * euler(0, 0, -1.2), 0.3)
        LH.C0 = clerp(LH.C0, cf(-1.2, 0.4, -0.4) * euler(0, -1.57, 0) * euler(0, 0.3, 0) * euler(0, 0, 0.1) * euler(0, 0, 0), 0.3)
      end
      for i = 1, 100 do
        swait()
        if hitfloor ~= nil then
          Torso.Velocity = vt(0, 0, 0)
        end
      end
      for i = 0, 1, 0.1 do
        swait()
        handlewld.Part1 = RightArm
        handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
        wld1.C0 = clerp(wld1.C0, cf(0, -0.3, 0) * euler(0, 1.57, 0) * euler(-1.8, 0, 0), 0.3)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(0.1, 0, 0), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1) * euler(0.1, 0, 0) * euler(0, 0, -0.3), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.2, 0.5, -0.3) * euler(0, 0, 0.5) * euler(0, 0.5, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-1, 0.3, -0.7) * euler(0.2, 0, 1.4) * euler(0, -1.2, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(1, -0.5, -0.6) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0) * euler(0, 0, -0.6), 0.3)
        LH.C0 = clerp(LH.C0, cf(-1.2, -0.1, -0.4) * euler(0, -1.57, 0) * euler(0, 0.3, 0) * euler(0, 0, 0.1) * euler(-0.1, 0, 0), 0.3)
      end
      do
        resumeControl()
        dec.Parent = nil
        Stun.Value = 0
        combo = 0
        Stunned.Value = false
        attack = false
        for i = 1, 10 do
          swait()
          Stun.Value = 0
        end
      end
    end
  end
end
attackone = function()
  attack = true
  if mode == "Sheathed" then
    for i = 0, 1, 0.15 do
      swait()
      handlewld.Part1 = Torso
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, -0.9) * cf(3.2, -3, -0.6), 0.4)
      wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0.2, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0), 0.4)
      RW.C0 = clerp(RW.C0, cf(1.4, 0.5, 0.2) * euler(1.7, 0, -0.2) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.4, 0.5, 0.2) * euler(1.7, 0, 0.2) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1, -0.8, -0.1) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -0.8, -0.1) * euler(0, -1.57, 0) * euler(-0.1, 0.1, 0), 0.4)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC197: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC197: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    so("169445092", RightArm, 1, 1)
    for i = 0, 1, 0.1 do
      swait()
      if i <= 0.5 then
        RW.C0 = clerp(RW.C0, cf(1.3, 0.5, -0.8) * euler(1.6, 0, 0.4) * euler(0, 0, 0), 0.6)
        MagniDamage(RightArm, 3, 4, 5, math.random(10, 15), "Normal", RootPart, 0.5, 2, (math.random(4, 6)), nil, true)
      else
        RW.C0 = clerp(RW.C0, cf(1.1, 0.5, 0.2) * euler(1.55, 0, 0.7) * euler(0, 0, 0), 0.4)
      end
      handlewld.Part1 = Torso
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, -0.9) * cf(3.2, -3, -0.6), 0.4)
      wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.4) * euler(0.1, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.4), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.3, 0.5, -0.1) * euler(1.7, 0, 0.4) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1.2, -0.9, -0.1) * euler(0, 1.57, 0) * euler(0, -0.4, 0) * euler(0, 0, -0.2), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -0.8, -0.1) * euler(0, -1.57, 0) * euler(-0.1, 0.1, 0), 0.4)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC451: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC451: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    so("169445092", RightArm, 1, 0.9)
    for i = 0, 1, 0.1 do
      swait()
      MagniDamage(RightArm, 3, 4, 6, math.random(10, 15), "Normal", RootPart, 0.5, 2, (math.random(4, 6)), nil, true)
      if i <= 0.2 then
        RW.C0 = clerp(RW.C0, cf(1.3, 0.5, -0.8) * euler(1.6, 0, 0.5) * euler(0, 0, 0), 0.4)
      else
        RW.C0 = clerp(RW.C0, cf(1, 0.4, -0.8) * euler(1, 0, -0.4) * euler(0, 0, 0), 0.2)
      end
      wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.6) * euler(0.1, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.6), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.4, 0.5, 0) * euler(0.8, 0, -0.6) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1.2, -0.9, -0.1) * euler(0, 1.57, 0) * euler(-0.1, -0.6, 0) * euler(0, 0, -0.2), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -0.8, -0.1) * euler(0, -1.57, 0) * euler(-0.2, 0.1, 0), 0.4)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC684: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC684: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
  else
    RW.C0 = clerp(RW.C0, cf(0.5, 0.5, -0.5) * euler(1.5, 0, 0) * euler(0, 0, -1) * euler(0, 0.5, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.4, 0.4, 0.1) * euler(1.5, 0, -0.3) * euler(0, 0.5, 0), 0.3)
    for i = 0, 1, 0.08 do
      swait()
      handlewld.Part1 = RightArm
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.2)
      wld1.C0 = clerp(wld1.C0, cf(0, 0.3, 0) * euler(0, 1, 0) * euler(-1, 0, 0), 0.2)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.5) * euler(0.1, 0, 0), 0.2)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.3) * euler(0.05, 0, 0) * euler(0, 0, 0.5), 0.2)
      RW.C0 = clerp(RW.C0, cf(0.5, 0.5, -0.5) * euler(2.4, 0, 0) * euler(0, 0, -1) * euler(0, 0.5, 0), 0.2)
      LW.C0 = clerp(LW.C0, cf(-1.4, 0.4, 0.1) * euler(3, 0, -0.3) * euler(0, 0.5, 0), 0.2)
      RH.C0 = clerp(RH.C0, cf(1.2, -0.8, -0.2) * euler(0, 1.57, 0) * euler(0, -0.5, 0) * euler(0, 0, 0.2), 0.2)
      LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.2) * euler(0, -1.57, 0) * euler(-0.2, 0.1, 0) * euler(0, 0, 0.2), 0.2)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC962: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC962: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    LW.C0 = clerp(LW.C0, cf(0.4, 0.4, -1) * euler(1.5, 0, 0.8) * euler(0, 0, 0), 0.4)
    so("320557487", prt20, 1, 0.7)
    hitbox.Parent = modelzorz
    hitbox.Anchored = true
    hitbox.Size = vt(1, 1, 1)
    hitbox.CFrame = prt20.CFrame * cf(0, 1, 0)
    for i = 0, 1, 0.05 do
      swait()
      if i <= 0.5 then
        hitbox.CFrame = prt20.CFrame * cf(0, 1, 0)
        MagniDamage(hitbox, 3, 7, 9, math.random(5, 15), "Normal", RootPart, 0.5, 1, (math.random(8, 10)), nil, true)
        hitbox.CFrame = prt20.CFrame * cf(0, -1, 0)
        MagniDamage(hitbox, 4, 7, 9, math.random(5, 15), "Normal", RootPart, 0.5, 1, (math.random(8, 10)), nil, true)
      end
      handlewld.Part1 = RightArm
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.25)
      wld1.C0 = clerp(wld1.C0, cf(0, 0.2, 0) * euler(0, 1.57, 0) * euler(-1.7, 0, 0), 0.25)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(0.1, 0, 0), 0.25)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.3) * euler(0.1, 0, 0) * euler(0, 0, -0.8), 0.25)
      RW.C0 = clerp(RW.C0, cf(0.5, 0.5, -0.5) * euler(-0.5, 0, 0) * euler(0, 0, 0.8) * euler(0, -0.3, 0), 0.25)
      LW.C0 = clerp(LW.C0, cf(0.4, 0.4, -1) * euler(0.2, 0, 0.8) * euler(0, 0, 0), 0.25)
      RH.C0 = clerp(RH.C0, cf(1.2, -0.8, -0.2) * euler(0, 1.57, 0) * euler(0, -0.5, 0) * euler(0, 0, -0.2), 0.25)
      LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.2) * euler(0, -1.57, 0) * euler(-0.2, 0.1, 0) * euler(0, 0, 0.2), 0.25)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC1303: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC1303: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
  end
  hitbox.Parent = nil
  attack = false
end
attacktwo = function()
  attack = true
  if mode == "Sheathed" then
    for i = 0, 1, 0.2 do
      swait()
      handlewld.Part1 = Torso
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, -0.9) * cf(3.2, -3, -0.6), 0.4)
      wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(-0.1, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -0.6), 0.4)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.4) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-0.4, 0.7, -0.7) * euler(1.57, 0, 1.3) * euler(0.5, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1.1, -0.8, -0.1) * euler(0, 1.57, 0) * euler(-0.2, -0.1, 0) * euler(0, 0, -0.2), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1.4, -0.9, -0.3) * euler(0, -1.57, 0) * euler(0, 0.6, 0) * euler(0, 0, 0.2), 0.4)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC209: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC209: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    so("169445073", LeftArm, 1, 0.95)
    for i = 0, 1, 0.2 do
      swait()
      MagniDamage(LeftArm, 3, 4, 5, math.random(10, 15), "Normal", RootPart, 0.3, 2, (math.random(4, 6)), nil, true)
      wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.5)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.4) * euler(0.1, 0, 0), 0.5)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.4), 0.5)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.1, 0, 1) * euler(0, 0, 0), 0.5)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0.1) * euler(1.57, 0, -1.3) * euler(-0.2, 0, 0), 0.5)
      RH.C0 = clerp(RH.C0, cf(1.1, -0.8, -0.1) * euler(0, 1.57, 0) * euler(-0.2, -0.1, 0) * euler(0, 0, -0.2), 0.5)
      LH.C0 = clerp(LH.C0, cf(-1.1, -0.8, -0.1) * euler(0, -1.57, 0) * euler(0, 0.1, 0) * euler(0, 0, 0), 0.4)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC421: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC421: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    so("169445073", LeftLeg, 1, 1.1)
    for i = 0, 1, 0.2 do
      swait()
      MagniDamage(LeftLeg, 3, 4, 5, math.random(10, 15), "Normal", RootPart, 0.3, 2, (math.random(4, 6)), nil, true)
      Neck.C0 = clerp(Neck.C0, necko * euler(-0.05, 0, 0) * euler(0, 0, 0.4), 0.5)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, -0.4, -0.2) * euler(0.05, 0, 0) * euler(0, 0, -0.4), 0.5)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.6, 0, 0.2) * euler(0, 0, 0), 0.5)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.6, 0, -0.2) * euler(0, 0, 0), 0.5)
      RH.C0 = clerp(RH.C0, cf(1.1, -0.6, -0.6) * euler(0, 1.57, 0) * euler(0, 0, -0.1) * euler(-0.1, 0, 0), 0.5)
      LH.C0 = clerp(LH.C0, cf(-1, -0.5, -0.5) * euler(0, -1.57, 0) * euler(0, 0, -1.8) * euler(-0.1, 0, 0), 0.5)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC621: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC621: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
  else
    for i = 0, 1, 0.08 do
      swait()
      handlewld.Part1 = RightArm
      handlewld.C0 = clerp(handlewld.C0, euler(0, -0.4, 0) * cf(0, 1, 0), 0.2)
      wld1.C0 = clerp(wld1.C0, cf(0, -0.8, 0) * euler(0, 1.57, 0) * euler(-1.2, 0, 0), 0.2)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.6) * euler(0.1, 0, 0), 0.2)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.3) * euler(0.2, 0, 0) * euler(0, 0, -0.6), 0.2)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, -0.2) * euler(-0.2, 0, 0.6) * euler(0, -3, 0), 0.2)
      LW.C0 = clerp(LW.C0, cf(1, 0.5, -0.6) * euler(0.6, 0, 0.6) * euler(0, -2.2, 0), 0.2)
      RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.3) * euler(0, 1.57, 0) * euler(-0.2, 0.6, 0) * euler(0, 0, 0.2), 0.2)
      LH.C0 = clerp(LH.C0, cf(-1.3, -0.7, -0.1) * euler(0, -1.57, 0) * euler(0, 0.6, 0) * euler(0, 0, -0.2), 0.2)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC839: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC839: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    so("320557563", prt20, 1, 0.7)
    hitbox.Parent = modelzorz
    hitbox.Anchored = true
    hitbox.Size = vt(1, 1, 1)
    hitbox.CFrame = prt20.CFrame * cf(0, 1, 0)
    for i = 0, 1, 0.05 do
      swait()
      if i <= 0.3 then
        hitbox.CFrame = prt20.CFrame * cf(0, 1, 0)
        MagniDamage(hitbox, 3, 7, 9, math.random(5, 15), "Normal", RootPart, 0.5, 1, (math.random(6, 8)), nil, true)
        hitbox.CFrame = prt20.CFrame * cf(0, -1, 0)
        MagniDamage(hitbox, 4, 7, 9, math.random(5, 15), "Normal", RootPart, 0.5, 1, (math.random(6, 8)), nil, true)
        wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0) * euler(0, 2.5, 0) * euler(-2, 0, 0), 0.25)
        RW.C0 = clerp(RW.C0, cf(0.5, 0.5, -0.5) * euler(1, 0, -1) * euler(0, -1, 0), 0.25)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.6, 0, 0.6) * euler(0, 0, 0), 0.25)
      else
        wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0) * euler(0, 1, 0) * euler(-1, 0, 0), 0.25)
        RW.C0 = clerp(RW.C0, cf(0.5, 0.5, -0.5) * euler(1, 0, -1) * euler(0, -1.2, 0), 0.25)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.4, -0.2) * euler(1, 0, 0.8) * euler(0, 0, 0), 0.25)
      end
      handlewld.Part1 = RightArm
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.25)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.4) * euler(0.1, 0, 0), 0.25)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.3) * euler(0, 0, 0) * euler(0, 0, 1.8), 0.25)
      RH.C0 = clerp(RH.C0, cf(1, -0.9, 0.6) * euler(0, 1.57, 0) * euler(-0.1, -1.5, 0), 0.2)
      LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.3) * euler(0, -1.57, 0) * euler(-0.1, -1, 0), 0.2)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC1211: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC1211: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    hitbox.Parent = nil
  end
  attack = false
end
attackthree = function()
  attack = true
  if mode == "Sheathed" then
    for i = 0, 1, 0.2 do
      swait()
      handlewld.Part1 = Torso
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, -0.9) * cf(3.2, -3, -0.6), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, -0.3, 0) * euler(0, 0, -0.8), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0.8) * euler(0, 0.3, 0), 0.4)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 1) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -0.5) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(0.6, -0.2, -0.4) * euler(0, 1.57, 0) * euler(-1.27, 0, 0) * euler(0, 0, 1), 0.4)
      LH.C0 = clerp(LH.C0, cf(-0.9, -0.4, -0.4) * euler(0, -1.57, 0) * euler(-0.3, 0, 0), 0.4)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC191: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC191: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    so("169445073", RightLeg, 1, 0.9)
    for i = 0, 1, 0.2 do
      swait()
      MagniDamage(RightLeg, 3, 4, 5, math.random(10, 15), "Normal", RootPart, 0.3, 2, (math.random(4, 6)), nil, true)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, -0.5, 0) * euler(0, 0, -1.4), 0.5)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, -0.6, -0.2) * euler(0, 0, 1.4) * euler(0, 0.5, 0), 0.5)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 1) * euler(0, 0, 0), 0.5)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -0.5) * euler(0, 0, 0), 0.5)
      RH.C0 = clerp(RH.C0, cf(1.2, -0.5, -0.5) * euler(0, 1.57, 0) * euler(-1.07, 0, 0) * euler(0, 0, 0.3), 0.5)
      LH.C0 = clerp(LH.C0, cf(-1.4, -0.2, -0.4) * euler(0, -1.57, 0) * euler(-0.4, 0, 0), 0.5)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC385: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC385: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    for i = 0, 1, 0.3 do
      swait()
      Neck.C0 = clerp(Neck.C0, necko * euler(0, -0.1, 0) * euler(0, 0, -0.2) * euler(0.2, 0, 0), 0.6)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, -0.3, -0.2) * euler(0, 0, 0.2) * euler(0, 0.1, 0), 0.6)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.5) * euler(0, 0, 0), 0.6)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.5) * euler(0, 0, 0), 0.6)
      RH.C0 = clerp(RH.C0, cf(1.2, -0.9, -0.5) * euler(0, 1.57, 0) * euler(0, 0.4, 0) * euler(0.1, 0, 0) * euler(0, 0, 0.1), 0.6)
      LH.C0 = clerp(LH.C0, cf(-1.2, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.1, 0.8, 0) * euler(0, 0, 0.2), 0.6)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC569: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC569: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    so("169445073", LeftLeg, 1, 0.8)
    for i = 0, 1, 0.1 do
      swait()
      MagniDamage(LeftLeg, 3, 4, 5, math.random(10, 15), "Normal", RootPart, 0.3, 2, (math.random(4, 6)), nil, true)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0.2, 0) * euler(0, 0, 1.5) * euler(0, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, -1, -0.2) * euler(0, 0, -1.5) * euler(0, -0.2, 0), 0.4)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 1) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1, 0, -0.2) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(0.4, -0.7, -1) * euler(0, 1.57, 0) * euler(0, 1.5, 0) * euler(0, 0, 0) * euler(0, 0, -0.4), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -0.4, -0.2) * euler(0, -1.57, 0) * euler(-1.5, 0, 0) * euler(0, 0, -0.4), 0.4)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC781: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC781: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
  else
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.5, 0, 0) * euler(0, 0, 0.5), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.4, 0.4, -0.1) * euler(1.5, 0, -0.5) * euler(0, 0, 0), 0.3)
    for i = 0, 1, 0.08 do
      swait()
      handlewld.Part1 = RightArm
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
      wld1.C0 = clerp(wld1.C0, cf(0, -0.6, 0) * euler(0, 1.57, 0) * euler(-2, 0, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(0.4, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.3) * euler(-0.3, 0, 0) * euler(0, 0, -1), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.3, 0.5, -0.1) * euler(2.8, 0, 0) * euler(0, 0, 0.2) * euler(0, -0.6, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(0.5, 0.8, -0.8) * euler(3, 0, 0) * euler(0, 0, 0.6) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(0.7, -0.8, -0.2) * euler(0, 1.57, 0) * euler(0, 1, 0) * euler(0, 0, -0.4), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1, -0.2, -0.2) * euler(0, -1.57, 0) * euler(0, 1, 0) * euler(0, 0, -0.4), 0.3)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC1059: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC1059: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = 10
    game:GetService("Debris"):AddItem(dec, 10)
    so("320557353", prt20, 1, 0.8)
    hitbox.Parent = modelzorz
    hitbox.Anchored = true
    hitbox.Size = vt(1, 1, 1)
    hitbox.CFrame = prt20.CFrame * cf(0, 1, 0)
    dohit = 0
    for i = 0, 1, 0.05 do
      swait()
      dohit = dohit + 1
      if i <= 0.3 then
        hitbox.CFrame = prt20.CFrame * cf(0, 1, 0)
        MagniDamage(hitbox, 3, 7, 9, math.random(5, 15), "Normal", RootPart, 0.3, 1, (math.random(7, 9)), nil, true)
        hitbox.CFrame = prt20.CFrame * cf(0, -1, 0)
        MagniDamage(hitbox, 4, 7, 9, math.random(5, 15), "Normal", RootPart, 0.3, 1, (math.random(7, 9)), nil, true)
      end
      if dohit == 6 then
        ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
        ref.Anchored = true
        ref.CFrame = prt20.CFrame * cf(0, -1.5, 0)
        game:GetService("Debris"):AddItem(ref, 1)
        hitfloor2 = rayCast(ref.Position, CFrame.new(ref.Position, ref.Position - Vector3.new(0, 1, 0)).lookVector, 20, Character)
		posfloor2 = prt24.Position
        if hitfloor2 ~= nil then
          ref.CFrame = cf(posfloor2)
          MagicWave(hitfloor2.BrickColor, cf(posfloor2), 1, 1, 1, 1, 1, 1, 0.05)
          MagniDamage(ref, 10, 7, 9, math.random(15, 20), "Knockdown2", ref, 0.5, 1, (math.random(10, 12)), nil, true)
          for i = 1, 10 do
            cf2 = cf(posfloor2) * cf(math.random(-1000, 1000) / 100, 1, math.random(-1000, 1000) / 100)
            ref.CFrame = cf2
            ghitfloor = rayCast(ref.Position, CFrame.new(ref.Position, ref.Position - Vector3.new(0, 1, 0)).lookVector, 20, Character)
            if ghitfloor ~= nil then
              Col = ghitfloor.BrickColor
              local groundpart = part(3, workspace, 0, 0, Col, "Ground", vt(math.random(50, 200) / 100, math.random(50, 200) / 100, math.random(50, 200) / 100))
              groundpart.Anchored = true
              groundpart.Material = ghitfloor.Material
              groundpart.CanCollide = true
			  local gposfloor = ref.Position
              groundpart.CFrame = cf(gposfloor) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
              game:GetService("Debris"):AddItem(groundpart, 5)
            end
          end
          ref.CFrame = cf(posfloor2)
          so("157878578", ref, 0.8, 0.8)
        end
      end
      handlewld.Part1 = RightArm
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.5)
      wld1.C0 = clerp(wld1.C0, cf(0, 0.6, 0) * euler(0, 1.57, 0) * euler(-1.3, 0, 0), 0.5)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(-0.2, 0, 0), 0.5)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, -1.6, -0.6) * euler(0.4, 0, 0) * euler(0, 0, -1), 0.5)
      RW.C0 = clerp(RW.C0, cf(1, 0.3, -0.5) * euler(0, 1, 0) * euler(0.5, 0, 0) * euler(0, 0, 0), 0.5)
      LW.C0 = clerp(LW.C0, cf(-1, 0.4, -0.5) * euler(0, 1, 0) * euler(0, 0, 0.4) * euler(0, 0, 0.3), 0.5)
      RH.C0 = clerp(RH.C0, cf(0.5, -0.8, -0.8) * euler(0, 1.57, 0) * euler(0, 1, 0) * euler(0, 0, -0.6), 0.5)
      LH.C0 = clerp(LH.C0, cf(-1, 0, -0.2) * euler(0, -1.57, 0) * euler(0, 1, 0) * euler(0, 0, -0.4), 0.5)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC1637: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC1637: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    hitbox.Parent = nil
    dec.Parent = nil
  end
  do
    attack = false
  end
end
attackfour = function()
  attack = true
  if mode == "Sheathed" then
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(3.4, 0, -0.4) * euler(0, 0, 0), 0.3)
    for i = 0, 1, 0.4 do
      swait()
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, -0.9) * cf(3.2, -3, -0.6), 0.6)
      wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.6)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(-0.3, 0, 0), 0.6)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.1) * euler(0, 0, 0), 0.6)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.4, 0, 0.4) * euler(0, -1, 0), 0.6)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(3.6, 0, -0.4) * euler(0, 1.57, 0), 0.6)
      RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.1) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0), 0.6)
      LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.1) * euler(0, -1.57, 0) * euler(-0.1, 0.1, 0), 0.6)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC218: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC218: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    for i = 0, 1, 0.4 do
      swait()
      handlewld.C0 = clerp(handlewld.C0, euler(1.2, 0, -0.8) * cf(1.9, -2.1, 1.6), 0.6)
      wld1.C0 = clerp(wld1.C0, euler(0, 0.4, 0) * cf(0, 0, 0), 0.6)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.2) * euler(-0.4, 0, 0), 0.6)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.1) * euler(0, 0, 0.8), 0.6)
      RW.C0 = clerp(RW.C0, cf(-0.8, 0.7, -0.5) * euler(3, 0, -0.8) * euler(0, 0, 0), 0.6)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(2.8, 0, -0.2) * euler(0, 0, 0), 0.6)
      RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.1) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0), 0.6)
      LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.1) * euler(0, -1.57, 0) * euler(-0.1, 0.1, 0), 0.6)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC408: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC408: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    so("203691447", prt20, 1, 0.8)
    hitbox.Parent = modelzorz
    hitbox.Anchored = true
    hitbox.Size = vt(1, 1, 1)
    hitbox.CFrame = prt20.CFrame * cf(0, 1, 0)
    mode = "Unsheathed"
    handlewld.Part1 = RightArm
    handlewld.C0 = euler(0, 0, 0) * cf(0, 1, 0)
    wld1.C0 = cf(0, -0.8, 0) * euler(0, 0.6, 0) * euler(-2.3, 0, 0) * euler(0, 0, 0)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0.2) * euler(0, 0, 0.8) * euler(0, 0.6, 0), 0.4)
    for i = 0, 1.4, 0.1 do
      swait()
      hitbox.CFrame = prt20.CFrame * cf(0, 1, 0)
      MagniDamage(hitbox, 3, 8, 10, math.random(5, 15), "Normal", RootPart, 0.5, 1, 10, nil, true)
      hitbox.CFrame = prt20.CFrame * cf(0, -1, 0)
      MagniDamage(hitbox, 4, 8, 10, math.random(5, 15), "Normal", RootPart, 0.5, 1, 10, nil, true)
      if i <= 0.3 then
        wld1.C0 = clerp(wld1.C0, cf(0, 0.2, 0) * euler(0, 2, 0) * euler(-1.2, 0, 0), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0.2) * euler(0.4, 0, 0) * euler(0, 0.8, 0), 0.4)
        LW.C0 = clerp(LW.C0, cf(0.5, 0.4, -0.5) * euler(0.4, 0, 0.4) * euler(0, 1, 0), 0.4)
      else
        wld1.C0 = clerp(wld1.C0, cf(0, -0.4, 0) * euler(0, 1, 0) * euler(-0.4, 0, 0), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0.2) * euler(-0.6, 0, 1) * euler(0, -1.2, 0), 0.2)
        LW.C0 = clerp(LW.C0, cf(0.5, 0.4, -0.6) * euler(0.4, 0, 1) * euler(0, 1, 0), 0.4)
      end
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(0.2, 0, 0), 0.25)
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.1) * euler(0, 0, -0.4) * euler(0.2, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.2) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0) * euler(0, 0, -0.2), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1.3, -0.9, -0.1) * euler(0, -1.57, 0) * euler(0, 0.4, 0) * euler(0, 0, -0.2), 0.4)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC848: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC848: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    hitbox.Parent = nil
  else
    for i = 0, 1, 0.08 do
      swait()
      handlewld.Part1 = RightArm
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.25)
      wld1.C0 = clerp(wld1.C0, cf(0, -0.8, 0) * euler(0, 1.57, 0) * euler(-1.4, 0, 0), 0.25)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(-0.2, 0, 0), 0.25)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, -0.4, -0.6) * euler(0.4, 0, 0) * euler(0, 0, -1), 0.25)
      RW.C0 = clerp(RW.C0, cf(1, 0.3, -0.5) * euler(0, 3.8, 0) * euler(-0.5, 0, 0) * euler(0, 0, -0.8), 0.25)
      LW.C0 = clerp(LW.C0, cf(0.2, 0.6, -0.8) * euler(0, -1, 0) * euler(1.2, 0, 0) * euler(0, 0, -0.6), 0.25)
      RH.C0 = clerp(RH.C0, cf(0.5, -0.8, -0.8) * euler(0, 1.57, 0) * euler(0, 1, 0) * euler(0, 0, -0.6), 0.25)
      LH.C0 = clerp(LH.C0, cf(-1, 0, -0.2) * euler(0, -1.57, 0) * euler(0, 1, 0) * euler(0, 0, -0.4), 0.25)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC1080: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC1080: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    so("320557382", prt20, 1, 0.75)
    hitbox.Parent = modelzorz
    hitbox.Anchored = true
    hitbox.Size = vt(1, 1, 1)
    hitbox.CFrame = prt20.CFrame * cf(0, 1, 0)
    for i = 0, 1, 0.08 do
      swait()
      if i <= 0.6 then
        hitbox.CFrame = prt20.CFrame * cf(0, 1, 0)
        MagniDamage(hitbox, 3, 7, 9, math.random(5, 15), "Normal", RootPart, 0.5, 1, (math.random(6, 8)), nil, true)
        hitbox.CFrame = prt20.CFrame * cf(0, -1, 0)
        MagniDamage(hitbox, 4, 7, 9, math.random(5, 15), "Normal", RootPart, 0.5, 1, (math.random(6, 8)), nil, true)
      end
      if i <= 0.2 then
        wld1.C0 = clerp(wld1.C0, cf(0, -0.8, 0) * euler(0, 1.57, 0) * euler(-1.4, 0, 0), 0.25)
        LW.C0 = clerp(LW.C0, cf(-1, 0.4, -0.3) * euler(2, 0, 0.6) * euler(0, -1.57, 0), 0.25)
        LH.C0 = clerp(LH.C0, cf(-1, 0, -0.8) * euler(0, -1.57, 0) * euler(0, -1, 0) * euler(0, 0, 0), 0.25)
      else
        wld1.C0 = clerp(wld1.C0, cf(0, 0.8, 0) * euler(0, 1.57, 0) * euler(1.4, 0, 0), 0.25)
        LW.C0 = clerp(LW.C0, cf(-1, 0.4, -0.3) * euler(2, 0, 0.1) * euler(0, -1.57, 0), 0.25)
        LH.C0 = clerp(LH.C0, cf(-0.8, -0.4, -0.8) * euler(0, -1.57, 0) * euler(0, -1, 0) * euler(0, 0, 0.8), 0.25)
      end
      handlewld.Part1 = RightArm
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.25)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1) * euler(0.4, 0, 0), 0.25)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.6) * euler(-0.4, 0, 0) * euler(0, 0, 1), 0.25)
      RW.C0 = clerp(RW.C0, cf(1, 0.3, -0.5) * euler(3, 0, 0) * euler(0, -2, 0) * euler(0, 0, 1), 0.25)
      RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(0, -1, 0) * euler(0, 0, -0.4), 0.25)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC1478: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC1478: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    hitbox.Parent = nil
    for i = 0, 1, 0.2 do
      swait()
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
      wld1.C0 = clerp(wld1.C0, cf(0, -0.8, 0) * euler(0, 0.6, 0) * euler(-2.3, 0, 0) * euler(0, 0, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.2) * euler(-0.4, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.1) * euler(0, 0, 0.8), 0.3)
      RW.C0 = clerp(RW.C0, cf(-0.8, 0.7, -0.5) * euler(3, 0, -0.8) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(2.8, 0, -0.2) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.1) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.1) * euler(0, -1.57, 0) * euler(-0.1, 0.1, 0), 0.3)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC1682: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC1682: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    mode = "Sheathed"
    handlewld.Part1 = Torso
    handlewld.C0 = euler(1.2, 0, -0.8) * cf(1.9, -2.1, 1.6)
    wld1.C0 = euler(0, 0.4, 0) * cf(0, 0, 0)
    for i = 0, 1, 0.2 do
      swait()
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, -0.9) * cf(3.2, -3, -0.6), 0.3)
      wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(-0.3, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.1) * euler(0, 0, 0), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.4, 0, 0.4) * euler(0, -1, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(3.6, 0, -0.4) * euler(0, 1.57, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.1) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.1) * euler(0, -1.57, 0) * euler(-0.1, 0.1, 0), 0.3)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC1903: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC1903: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1, 0, -0.4) * euler(0, 1.57, 0), 0.4)
    handlewld.C0 = euler(0, 0, -0.9) * cf(3.2, -3, -0.6)
    wld1.C0 = euler(0, 0, 0) * cf(0, 0, 0)
  end
  attack = false
end
Equip = function()
  attack = true
  if mode == "Sheathed" then
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(3.4, 0, -0.4) * euler(0, 0, 0), 0.3)
    for i = 0, 1, 0.2 do
      swait()
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, -0.9) * cf(3.2, -3, -0.6), 0.3)
      wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(-0.3, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.1) * euler(0, 0, 0), 0.4)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.4, 0, 0.4) * euler(0, -1, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(3.6, 0, -0.4) * euler(0, 1.57, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.1) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.1) * euler(0, -1.57, 0) * euler(-0.1, 0.1, 0), 0.4)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC218: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC218: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    for i = 0, 1, 0.2 do
      swait()
      handlewld.C0 = clerp(handlewld.C0, euler(1.2, 0, -0.8) * cf(1.9, -2.1, 1.6), 0.3)
      wld1.C0 = clerp(wld1.C0, euler(0, 0.4, 0) * cf(0, 0, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.2) * euler(-0.4, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.1) * euler(0, 0, 0.8), 0.4)
      RW.C0 = clerp(RW.C0, cf(-0.8, 0.7, -0.5) * euler(3, 0, -0.8) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(2.8, 0, -0.2) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.1) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.1) * euler(0, -1.57, 0) * euler(-0.1, 0.1, 0), 0.4)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC408: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC408: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    so("203691447", prt20, 1, 0.8)
    hitbox.Parent = modelzorz
    hitbox.Anchored = true
    hitbox.Size = vt(1, 1, 1)
    hitbox.CFrame = prt20.CFrame * cf(0, 1, 0)
    mode = "Unsheathed"
    handlewld.Part1 = RightArm
    handlewld.C0 = euler(0, 0, 0) * cf(0, 1, 0)
    wld1.C0 = cf(0, -0.8, 0) * euler(0, 0.6, 0) * euler(-2.3, 0, 0) * euler(0, 0, 0)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0.2) * euler(0, 0, 0.8) * euler(0, 0.6, 0), 0.4)
    for i = 0, 1.4, 0.1 do
      swait()
      hitbox.CFrame = prt20.CFrame * cf(0, 1, 0)
      MagniDamage(hitbox, 3, 7, 9, math.random(5, 15), "Normal", RootPart, 0.5, 1, (math.random(6, 8)), nil, true)
      hitbox.CFrame = prt20.CFrame * cf(0, -1, 0)
      MagniDamage(hitbox, 4, 7, 9, math.random(5, 15), "Normal", RootPart, 0.5, 1, (math.random(6, 8)), nil, true)
      if i <= 0.3 then
        wld1.C0 = clerp(wld1.C0, cf(0, 0.2, 0) * euler(0, 2, 0) * euler(-1.2, 0, 0), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0.2) * euler(0.4, 0, 0) * euler(0, 0.8, 0), 0.4)
        LW.C0 = clerp(LW.C0, cf(0.5, 0.4, -0.5) * euler(0.4, 0, 0.4) * euler(0, 1, 0), 0.4)
      else
        wld1.C0 = clerp(wld1.C0, cf(0, -0.4, 0) * euler(0, 1, 0) * euler(-0.4, 0, 0), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0.2) * euler(-0.6, 0, 1) * euler(0, -1.2, 0), 0.2)
        LW.C0 = clerp(LW.C0, cf(0.5, 0.4, -0.6) * euler(0.4, 0, 1) * euler(0, 1, 0), 0.4)
      end
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(0.2, 0, 0), 0.25)
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.1) * euler(0, 0, -0.4) * euler(0.2, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.2) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0) * euler(0, 0, -0.2), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1.3, -0.9, -0.1) * euler(0, -1.57, 0) * euler(0, 0.4, 0) * euler(0, 0, -0.2), 0.4)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC856: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC856: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    hitbox.Parent = nil
  else
    if mode == "Unsheathed" then
      for i = 0, 1, 0.2 do
        swait()
        handlewld.Part1 = RightArm
        handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.4)
        wld1.C0 = clerp(wld1.C0, cf(0, -0.8, 0) * euler(0, 1.57, 0) * euler(-1.9, 0, 0), 0.4)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.6) * euler(0.1, 0, 0), 0.4)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.3) * euler(0.2, 0, 0) * euler(0, 0, -0.6), 0.4)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, -0.2) * euler(1.2, 0, 0.2) * euler(0, -2.6, 0), 0.4)
        LW.C0 = clerp(LW.C0, cf(0.1, 0.4, -0.5) * euler(1, 0, 0.6) * euler(0, -2, 0), 0.4)
        RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.3) * euler(0, 1.57, 0) * euler(-0.2, 0.6, 0) * euler(0, 0, 0.2), 0.4)
        LH.C0 = clerp(LH.C0, cf(-1.3, -0.7, -0.1) * euler(0, -1.57, 0) * euler(0, 0.6, 0) * euler(0, 0, -0.2), 0.4)
        if Stagger.Value ~= true then
          do
            if StunT.Value <= Stun.Value then
              break
            end
            -- DECOMPILER ERROR at PC1079: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC1079: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      so("320557518", prt20, 0.8, 0.9)
      RW.C0 = clerp(RW.C0, cf(-0.8, 0.7, -0.5) * euler(1.5, 0, -0.8) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.5, 0, -0.2) * euler(0, 0, 0), 0.4)
      for i = 0, 1, 0.3 do
        swait()
        handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.4)
        wld1.C0 = clerp(wld1.C0, cf(0, -0.8, 0) * euler(0, 0.6, 0) * euler(-2.3, 0, 0) * euler(0, 0, 0), 0.4)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.2) * euler(-0.4, 0, 0), 0.4)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.1) * euler(0, 0, 0.8), 0.4)
        RW.C0 = clerp(RW.C0, cf(-0.8, 0.7, -0.5) * euler(3, 0, -0.8) * euler(0, 0, 0), 0.4)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(2.8, 0, -0.2) * euler(0, 0, 0), 0.4)
        RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.1) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0), 0.4)
        LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.1) * euler(0, -1.57, 0) * euler(-0.1, 0.1, 0), 0.4)
        if Stagger.Value ~= true then
          do
            if StunT.Value <= Stun.Value then
              break
            end
            -- DECOMPILER ERROR at PC1335: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC1335: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      mode = "Sheathed"
      handlewld.Part1 = Torso
      handlewld.C0 = euler(1.2, 0, -0.8) * cf(1.9, -2.1, 1.6)
      wld1.C0 = euler(0, 0.4, 0) * cf(0, 0, 0)
      for i = 0, 1, 0.1 do
        swait()
        handlewld.C0 = clerp(handlewld.C0, euler(0, 0, -0.9) * cf(3.2, -3, -0.6), 0.3)
        wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.3)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(-0.3, 0, 0), 0.4)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.1) * euler(0, 0, 0), 0.4)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.4, 0, 0.4) * euler(0, -1, 0), 0.4)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(3.6, 0, -0.4) * euler(0, 1.57, 0), 0.4)
        RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.1) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0), 0.4)
        LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.1) * euler(0, -1.57, 0) * euler(-0.1, 0.1, 0), 0.4)
        if Stagger.Value ~= true then
          do
            if StunT.Value <= Stun.Value then
              break
            end
            -- DECOMPILER ERROR at PC1556: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC1556: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1, 0, -0.4) * euler(0, 1.57, 0), 0.4)
    end
  end
  attack = false
end
do1 = function()
  if holdz == true then
    holdz = false
  end
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[1] and mana.Value >= 20 then
    holdz = true
    if mode == "Sheathed" then
      Equip()
    end
    attack = true
    mana.Value = mana.Value - 20
    local dec2 = Instance.new("NumberValue", Decrease)
    dec2.Name = "DecreaseMvmt"
    dec2.Value = 0.2
    game:GetService("Debris"):AddItem(dec2, 10)
    cooldowns[1] = 0
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.5, 0, 0) * euler(0, 0, 0.5), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.4, 0.4, -0.1) * euler(1.5, 0, -0.5) * euler(0, 0, 0), 0.3)
    for i = 0, 1, 0.1 do
      swait()
      handlewld.Part1 = RightArm
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.15)
      wld1.C0 = clerp(wld1.C0, cf(0, -0.6, 0) * euler(0, 1.57, 0) * euler(-2, 0, 0), 0.15)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(0.4, 0, 0), 0.15)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.3) * euler(-0.1, 0, 0) * euler(0, 0, -1), 0.15)
      RW.C0 = clerp(RW.C0, cf(1.3, 0.5, -0.1) * euler(2.8, 0, 0) * euler(0, 0, 0.2) * euler(0, -0.6, 0), 0.15)
      LW.C0 = clerp(LW.C0, cf(0.5, 0.8, -0.8) * euler(3, 0, 0) * euler(0, 0, 0.6) * euler(0, 0, 0), 0.15)
      RH.C0 = clerp(RH.C0, cf(0.7, -0.8, -0.4) * euler(0, 1.57, 0) * euler(0, 1, 0) * euler(0, 0, -0.2), 0.15)
      LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0.2) * euler(0, -1.57, 0) * euler(0, 1, 0) * euler(-0.2, 0, 0.1), 0.15)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
        end
      end
    end
    local charge = 0
    local dam = 1
    while 1 do
	  swait()
      if holdz == true then
        swait()
        charge = charge + 1
        if charge == 10 then
          print("CHARGE 1")
          dam = 1.2
          parti.Enabled = true
          RingGui(Torso, BrickColor.new(EffectCol), 8)
        end
        if charge == 30 then
          print("CHARGE 2")
          dam = 1.4
          parti2.Enabled = true
          RingGui(Torso, BrickColor.new(EffectCol), 10)
        end
        if charge == 50 then
          print("CHARGE 3")
          dam = 1.8
          RingGui(Torso, BrickColor.new(EffectCol), 6)
          for i = 1, 3 do
            MagicCircle(BrickColor.new(EffectCol), cf(Torso.Position) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 5, 20, 5, -0.05, 20, -0.05, 0.1)
          end
          holdz = false
        end
        handlewld.Part1 = RightArm
        handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.15)
        wld1.C0 = clerp(wld1.C0, cf(0, -0.6, 0) * euler(0, 1.57, 0) * euler(-1.7, 0, 0), 0.15)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(0.4, 0, 0), 0.15)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.3) * euler(-0.1, 0, 0) * euler(0, 0, -1), 0.15)
        RW.C0 = clerp(RW.C0, cf(1.3, 0.5, -0.1) * euler(3.2, 0, 0) * euler(0, 0, 0.2) * euler(0, -0.2, 0), 0.15)
        LW.C0 = clerp(LW.C0, cf(0.6, 0.9, -0.8) * euler(2.9, 0, 0) * euler(0, 0, 0.6) * euler(0, -0.4, 0), 0.15)
        RH.C0 = clerp(RH.C0, cf(0.7, -0.8, -0.4) * euler(0, 1.57, 0) * euler(0, 1, 0) * euler(0, 0, -0.2), 0.15)
        LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0.2) * euler(0, -1.57, 0) * euler(0, 1, 0) * euler(-0.2, 0, 0.1), 0.15)
      else
      break
      end
      if Stagger.Value ~= true and StunT.Value <= Stun.Value then
        break
      end
    end
    parti.Enabled = false
    parti2.Enabled = false
    for i = 0, 1, 0.15 do
      swait()
      handlewld.Part1 = RightArm
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.15)
      wld1.C0 = clerp(wld1.C0, cf(0, -0.6, 0) * euler(0, 1.57, 0) * euler(-2, 0, 0), 0.15)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(0.4, 0, 0), 0.15)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, -0.5, -0.3) * euler(-0.3, 0, 0) * euler(0, 0, -1), 0.15)
      RW.C0 = clerp(RW.C0, cf(1, 0.6, -0.5) * euler(0, 1, 0) * euler(0.5, 0, 0) * euler(1.5, 0, 0), 0.15)
      LW.C0 = clerp(LW.C0, cf(-0.5, -0.1, -0.5) * euler(0, 1, 0) * euler(0, 0, -0.4) * euler(0, 0, -0.3) * euler(2.6, 0, 0), 0.15)
      RH.C0 = clerp(RH.C0, cf(0.7, -0.8, -0.2) * euler(0, 1.57, 0) * euler(0, 1, 0) * euler(0, 0, -0.4), 0.15)
      LH.C0 = clerp(LH.C0, cf(-1, -0.2, -0.2) * euler(0, -1.57, 0) * euler(0, 1, 0) * euler(0, 0, -0.4), 0.15)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
        end
      end
    end
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = 10
    game:GetService("Debris"):AddItem(dec, 10)
    so("320557353", prt20, 1, 0.8)
    hitbox.Parent = modelzorz
    hitbox.Anchored = true
    hitbox.Size = vt(1, 1, 1)
    hitbox.CFrame = prt20.CFrame * cf(0, 1, 0)
    dohit = 0
    for i = 0, 1.5, 0.05 do
      swait()
      dohit = dohit + 1
      if dohit == 6 then
        ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
        ref.Anchored = true
        ref.CFrame = prt20.CFrame * cf(0, -1.5, 0)
        game:GetService("Debris"):AddItem(ref, 1)
        hitfloor2 = rayCast(ref.Position, CFrame.new(ref.Position, ref.Position - Vector3.new(0, 1, 0)).lookVector, 20, Character)
		posfloor2 = prt24.Position
        if hitfloor2 ~= nil then
          ref.CFrame = cf(posfloor2)
          MagicWave(hitfloor2.BrickColor, cf(posfloor2), 1, 1, 1, 1, 1, 1, 0.05)
          MagicRing(hitfloor2.BrickColor, cf(posfloor2) * euler(1.57, 0, 0), 1, 1, 1, 1, 1, 1, 0.03)
          MagniDamage(ref, 15, 10 * dam, 12 * dam, math.random(40, 45), "Knockdown2", ref, 0.5, 1, (math.random(10, 12)), nil, true)
          for i = 1, 10 do
            cf2 = cf(posfloor2) * cf(math.random(-1000, 1000) / 100, 1, math.random(-1000, 1000) / 100)
            ref.CFrame = cf2
            ghitfloor = rayCast(ref.Position, CFrame.new(ref.Position, ref.Position - Vector3.new(0, 1, 0)).lookVector, 20, Character)
            if ghitfloor ~= nil then
              Col = ghitfloor.BrickColor
              local groundpart = part(3, workspace, 0, 0, Col, "Ground", vt(math.random(50, 200) / 100, math.random(50, 200) / 100, math.random(50, 200) / 100))
              groundpart.Anchored = true
              groundpart.Material = ghitfloor.Material
              groundpart.CanCollide = true
			local gposfloor = ref.Position
              groundpart.CFrame = cf(gposfloor) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
              game:GetService("Debris"):AddItem(groundpart, 5)
            end
          end
          ref.CFrame = cf(posfloor2)
          so("157878578", ref, 0.8, 0.8)
        end
      end
      handlewld.Part1 = RightArm
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.5)
      wld1.C0 = clerp(wld1.C0, cf(0, 0.6, 0) * euler(0, 1.57, 0) * euler(-1.3, 0, 0), 0.5)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(-0.2, 0, 0), 0.5)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, -2.1, -0.6) * euler(0.4, 0, 0) * euler(0, 0, -1), 0.5)
      RW.C0 = clerp(RW.C0, cf(1, 0.3, -0.5) * euler(0, 1, 0) * euler(0.5, 0, 0) * euler(0, 0, 0), 0.5)
      LW.C0 = clerp(LW.C0, cf(-1, 0.4, -0.5) * euler(0, 1, 0) * euler(0, 0, 0.4) * euler(0, 0, 0.3), 0.5)
      RH.C0 = clerp(RH.C0, cf(0.5, -0.8, -0.8) * euler(0, 1.57, 0) * euler(0, 1, 0) * euler(0, 0, -0.6), 0.5)
      LH.C0 = clerp(LH.C0, cf(-1, 0, -0.2) * euler(0, -1.57, 0) * euler(0, 1, 0) * euler(0, 0, -0.4), 0.5)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
        end
      end
    end
    hitbox.Parent = nil
    dec2.Parent = nil
    dec.Parent = nil
    attack = false
  end
end
do2 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[2] and mana.Value >= 10 and do2target ~= nil then
    if mode == "Unsheathed" then
      Equip()
    end
    attack = true
    cooldowns[2] = 0
    mana.Value = mana.Value - 10
    if do2mode == "Chase" then
      doing2 = true
      local x, y, z, newpos = nil, nil, nil, nil
      for i = 0, 1, 0.2 do
        swait()
        if do2target ~= nil then
          newpos = vt(do2target.Position.X, RootPart.Position.Y, do2target.Position.Z)
          MoveCF = cf(RootPart.Position, newpos)
          local mpos = Torso.CFrame * euler(0, 0, 0)
          local cff = CFrame.new(mpos.p, newpos) * CFrame.Angles(math.pi / 2, 0, 0)
          x = RootPart.CFrame:toObjectSpace(cff):toEulerAnglesXYZ()
          RootJoint.C0 = clerp(RootJoint.C0, CFrame.Angles(x, y, z) * euler(0, 3.14, 0) * cf(0, 0, -1.5) * euler(1, 0, 0), 0.4)
        end
        do
          Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(-0.4, 0, 0), 0.4)
          RW.C0 = clerp(RW.C0, cf(1.2, 0.5, 0) * euler(1, 0, 0.1) * euler(0, 0, 0) * cf(0, -0.3, 0), 0.4)
          LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -0.4) * euler(0, 0, 0), 0.4)
          RH.C0 = clerp(RH.C0, cf(1.1, -0.6, -1) * euler(0, 1.57, 0) * euler(0, 0, 0) * euler(-0.2, 0, -0.6) * cf(0, 0.5, 0), 0.4)
          LH.C0 = clerp(LH.C0, cf(-0.8, 1, -0.4) * euler(0, -1.57, 0) * euler(0, 0, 0) * euler(-0.05, 0, -0.8), 0.4)
          RW.C1 = clerp(RW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
          if Stagger.Value ~= true then
            do
              if StunT.Value <= Stun.Value then
                break
              end
            end
          end
        end
      end
      so("2767090", Torso, 0.8, 1)
      MagicWave(BrickColor.new(NewCol), Torso.CFrame * euler(2, 0, 0), 1, 1, 1, 0.5, 0.5, 0.5, 0.1)
      for i = 0, 1, 0.2 do
        swait()
        if do2target ~= nil then
          RootJoint.C0 = clerp(RootJoint.C0, CFrame.Angles(x, y, z) * euler(0, 3.14, 0) * cf(0, 0, -0.5) * euler(1.3, 0, 0), 0.4)
        end
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(-0.6, 0, 0), 0.4)
        RW.C0 = clerp(RW.C0, cf(1.2, 0.5, 0) * euler(-0.2, 0, 0.4) * euler(0, 0, 0), 0.4)
        LW.C0 = clerp(LW.C0, cf(-1, 0.8, -0.5) * euler(2, 0, 1.3) * euler(0, 0, 0), 0.4)
        RH.C0 = clerp(RH.C0, cf(0.9, 0.2, -0.4) * euler(0, 1.57, 0) * euler(0, 0, 0) * euler(-0.1, 0, 0.4), 0.4)
        LH.C0 = clerp(LH.C0, cf(-0.9, -0.8, -0.4) * euler(0, -1.57, 0) * euler(0, 0, 0) * euler(-0.2, 0, 0.3), 0.4)
        RH.C1 = clerp(RH.C1, RHC1, 0.6)
        LH.C1 = clerp(LH.C1, LHC1, 0.6)
        RW.C1 = clerp(RW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.6)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.6)
        if Rooted.Value == false then
          Torso.Velocity = MoveCF.lookVector * 150
        end
        if distance <= 10 and Rooted.Value == false then
          Torso.Velocity = MoveCF.lookVector * 70
        end
        do break end
      end
      do
        if do2target ~= nil then
          RootPart.CFrame = cf(RootPart.Position, newpos)
          RootJoint.C0 = RootCF * cf(0, 0, -0.5) * euler(1.3, 0, 0)
        end
        so("169445073", LeftLeg, 1, 1)
        RecentEnemy.Value = nil
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * euler(1.3, 0, 0) * euler(0, 3, 0) * cf(0, 0, -2), 0.4)
        for i = 0, 1, 0.3 do
          swait()
          MagniDamage(LeftLeg, 4, 6, 8, math.random(20, 25), "Normal", RootPart, 0.3, 2, (math.random(6, 8)), nil, true)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * euler(1.3, 0, 0) * euler(0, 3.5, 0) * cf(0, 0, -2), 0.3)
          Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(-0.6, 0, 0), 0.4)
          RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.8) * euler(0, 0, 0), 0.4)
          LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.8) * euler(0, 0, 0), 0.4)
          RH.C0 = clerp(RH.C0, cf(0.9, 0.2, -0.4) * euler(0, 1.57, 0) * euler(0, 0, 0) * euler(-0.1, 0, 0.4), 0.4)
          LH.C0 = clerp(LH.C0, cf(-1, -1, -0.1) * euler(0, -1.57, 0) * euler(0, 0, 0) * euler(-0.2, 0, 0.1), 0.4)
          RH.C1 = clerp(RH.C1, RHC1, 0.6)
          LH.C1 = clerp(LH.C1, LHC1, 0.6)
          RW.C1 = clerp(RW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.6)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.6)
          if Stagger.Value ~= true then
            do
              if StunT.Value <= Stun.Value then
                break
              end
            end
          end
        end
        if RecentEnemy.Value ~= nil then
          cooldowns[2] = 70
        end
        do
          local dec = Instance.new("NumberValue", Decrease)
          dec.Name = "DecreaseMvmt"
          dec.Value = 10
          game:GetService("Debris"):AddItem(dec, 10)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * euler(1.3, 0, 0) * euler(0, 3.5, 0) * cf(0, 0, -2), 0.4)
          for i = 0, 1, 0.1 do
            swait()
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 2, -1.5) * euler(1, 0, 0), 0.3)
            Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(-0.4, 0, 0), 0.3)
            RW.C0 = clerp(RW.C0, cf(1.2, 0.5, 0) * euler(1, 0, 0.1) * euler(0, 0, 0) * cf(0, -0.3, 0), 0.3)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -0.4) * euler(0, 0, 0), 0.3)
            RH.C0 = clerp(RH.C0, cf(1.1, -0.6, -1) * euler(0, 1.57, 0) * euler(0, 0, 0) * euler(-0.2, 0, -0.6) * cf(0, 0.5, 0), 0.3)
            LH.C0 = clerp(LH.C0, cf(-0.8, 1, -0.4) * euler(0, -1.57, 0) * euler(0, 0, 0) * euler(-0.05, 0, -0.8), 0.3)
            if Stagger.Value ~= true then
              do
                if StunT.Value <= Stun.Value then
                  break
                end
              end
            end
          end
          dec.Parent = nil
          doing2 = false
          for i = 0, y, z do
            swait()
            Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0.6) * euler(0, 0, 0), 0.4)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, -0.5, -0.1) * euler(-0.1, 0, -0.6), 0.4)
            RW.C0 = clerp(RW.C0, cf(1.1, 0.5, -0.5) * euler(2, 0, -0.4) * euler(0, 0, 0), 0.4)
            LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.5) * euler(0.6, 0, 1) * euler(0, 0, 0), 0.4)
            RH.C0 = clerp(RH.C0, cf(0.9, -0.9, -0.4) * euler(0, 1.57, 0) * euler(-0.1, 0.6, -0.3), 0.4)
            LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.1) * euler(0, -1.57, 0) * euler(-0.1, 0.6, 0.1), 0.4)
            if Stagger.Value ~= true then
              do
                if StunT.Value <= Stun.Value then
                  break
                end
                -- DECOMPILER ERROR at PC1304: LeaveBlock: unexpected jumping out IF_THEN_STMT

                -- DECOMPILER ERROR at PC1304: LeaveBlock: unexpected jumping out IF_STMT

              end
            end
          end
          dodrop = true
          instastun = false
          so("169445092", RightArm, 1, 0.8)
          for i = 0, 1, 0.1 do
            swait()
            MagniDamage(RightArm, 3, 8, 10, math.random(5, 10), "Normal", RootPart, 0.5, 2, (math.random(8, 10)), nil, true)
            Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.6) * euler(0.2, 0, 0), 0.5)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, -1.4, -0.1) * euler(0.1, 0, 0.6), 0.5)
            if i <= 0.3 then
              RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.7, 0, 0.2) * euler(0, 1.4, 0), 0.5)
              LW.C0 = clerp(LW.C0, cf(-1.4, 0.5, 0.2) * euler(1, 0, -0.2) * euler(0, 0, 0), 0.5)
            else
              RW.C0 = clerp(RW.C0, cf(1.1, 0.5, -0.4) * euler(0.4, 0, -0.4) * euler(0, 1.4, 0), 0.3)
              LW.C0 = clerp(LW.C0, cf(-1.4, 0.5, 0.2) * euler(0.6, 0, -0.4) * euler(0, 0, 0), 0.5)
            end
            RH.C0 = clerp(RH.C0, cf(0.9, -0.9, 0.4) * euler(0, 1.57, 0) * euler(-0.1, -0.6, -0.5), 0.5)
            LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.4) * euler(0, -1.57, 0) * euler(0, -0.6, -0.1), 0.5)
            if Stagger.Value ~= true then
              do
                if StunT.Value <= Stun.Value then
                  break
                end
                -- DECOMPILER ERROR at PC1541: LeaveBlock: unexpected jumping out IF_THEN_STMT

                -- DECOMPILER ERROR at PC1541: LeaveBlock: unexpected jumping out IF_STMT

              end
            end
          end
          if instastun == false then
            cooldowns[2] = 80
          end
          dodrop = false
          attack = false
        end
      end
    end
  end
end
do3 = function()
  if guarding == true and canguardoff == true then
    guarding = false
  end
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[3] and mana.Value >= 10 then
    if mode == "Sheathed" then
      Equip()
    end
    attack = true
    mana.Value = mana.Value - 10
    guarding = true
    canguardoff = false
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = 0.1
    Block.Value = true
    cooldowns[3] = 80
    for i = 0, 1, 0.1 do
      swait()
      cooldowns[3] = cooldowns[3] - 0.5
      handlewld.Part1 = RightArm
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
      wld1.C0 = clerp(wld1.C0, cf(0, -1, -0.2) * euler(0, 0, 0) * euler(-2.6, 0, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.2) * euler(0.1, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.3) * euler(0.1, 0, 0) * euler(0, 0, -0.2), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.3, 0.9, -0.4) * euler(2.2, 0, 0) * euler(0, 0, 0.8) * euler(0, 2.1, 0) * euler(0, 0, 0.2), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.4, 0.3, 0.3) * euler(1, 0, -0.1) * euler(0, 1.57, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(0.9, -0.7, -0.2) * euler(0, 1.57, 0) * euler(-0.2, 0.2, 0), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1.2, -0.7, -0.1) * euler(0, -1.57, 0) * euler(0, 0.5, 0) * euler(0, 0, -0.1), 0.3)
      if Stagger.Value ~= true then
        do
          if StunT.Value <= Stun.Value then
            break
          end
          -- DECOMPILER ERROR at PC290: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC290: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    canguardoff = true
    while guarding == true and cooldowns[3] >= 0 and Block.Value == true do
      swait()
      cooldowns[3] = cooldowns[3] - 0.5
      handlewld.Part1 = RightArm
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
      wld1.C0 = clerp(wld1.C0, cf(0, -1, -0.2) * euler(0, 0, 0) * euler(-2.6, 0, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.2) * euler(0.1, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.3) * euler(0.1, 0, 0) * euler(0, 0, -0.2), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.3, 0.9, -0.4) * euler(2.2, 0, 0) * euler(0, 0, 0.8) * euler(0, 2.1, 0) * euler(0, 0, 0.2), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.4, 0.3, 0.3) * euler(1, 0, -0.1) * euler(0, 1.57, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(0.9, -0.7, -0.2) * euler(0, 1.57, 0) * euler(-0.2, 0.2, 0), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1.2, -0.7, -0.1) * euler(0, -1.57, 0) * euler(0, 0.5, 0) * euler(0, 0, -0.1), 0.3)
    end
    dec.Parent = nil
    cooldowns[3] = math.floor(cooldowns[3])
    if Block.Value == false then
      print("blocked")
      cooldowns[3] = 0
      doing2 = true
      DecreaseStat(Character, "Damage", -0.2, 300)
      for i = 0, 1, 0.05 do
        swait()
        if hitfloor ~= nil then
          Torso.Velocity = RootPart.CFrame.lookVector * (-50 + 50 * i)
        end
        handlewld.Part1 = RightArm
        handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.2)
        wld1.C0 = clerp(wld1.C0, cf(0, -0.8, 0) * euler(0, 1.57, 0) * euler(-1.4, 0, 0), 0.2)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(0.2, 0, 0), 0.2)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.5) * euler(0.2, 0, 0) * euler(0, 0, -1), 0.2)
        RW.C0 = clerp(RW.C0, cf(1.4, 0.5, 0.2) * euler(-0.2, 0, 0.8) * euler(0, -0.2, 0), 0.2)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.3, 0) * euler(0.2, 0, -0.4) * euler(0, 0, 0), 0.2)
        RH.C0 = clerp(RH.C0, cf(0.9, -0.7, -1) * euler(0, 1.57, 0) * euler(-0.2, 0.4, 0) * euler(0, 0, -1), 0.2)
        LH.C0 = clerp(LH.C0, cf(-1, 0.4, -0.2) * euler(0, -1.57, 0) * euler(0.2, 1, 0) * euler(0, 0, -0.1), 0.2)
        if Stagger.Value ~= true then
          do
            if StunT.Value <= Stun.Value then
              break
            end
            -- DECOMPILER ERROR at PC769: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC769: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      doing2 = false
    else
      DecreaseStat(Character, "Damage", 0.2, 300)
    end
    Block.Value = false
    attack = false
  end
end
do4 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[4] and mana.Value >= 50 then
    if mode == "Unsheathed" then
      Equip()
    end
    attack = true
    cooldowns[4] = 0
    for i = 0, 1, 0.1 do
      swait()
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1) * euler(0.1, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 1), 0.4)
      RW.C0 = clerp(RW.C0, cf(1, 0.5, 0.5) * euler(0.8, 0, 0.5), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.6, 0, 1), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1.1, -1, 0) * euler(0, 0.87, -0.1), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -0.9, 0) * euler(0, -2.27, 0.4), 0.4)
    end
    doing4 = true
    grabhit = false
    grabTarget = nil
    sref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
    sref.Anchored = true
    sref.CFrame = LeftArm.CFrame * cf(0, -3, 0)
    game:GetService("Debris"):AddItem(sref, 10)
    so("169445092", LeftArm, 1, 1)
    RecentEnemy.Value = nil
    cangrab = true
    for i = 0, 1, 0.1 do
      swait()
      sref.CFrame = LeftArm.CFrame * cf(0, -1, 0) * euler(-1.57, 0, 0)
      if grabhit == true and cangrab == true then
        if grabTarget ~= nil and grabTarget:findFirstChild("Stats") ~= nil and grabTarget.Stats:findFirstChild("Ungrabbable") ~= nil and grabTarget.Stats.Ungrabbable.Value == true then
          cangrab = false
        end
        if cangrab == true then
          print("nopls")
          grabTarget.Humanoid.PlatformStand = true
          grabpos.position = sref.Position
          grabpos.Parent = grabTarget.Torso
          grabTarget.Torso.CFrame = sref.CFrame
        end
      end
      MagniDamage(LeftArm, 3, 4, 5, math.random(10, 15), "Normal", RootPart, 0.1, 2, (math.random(4, 6)), nil, true)
      Neck.C0 = clerp(Neck.C0, necko * euler(0.3, 0, 1.2) * euler(0.2, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1.2), 0.4)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.6, 0, 0.6), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, -1.57) * euler(0, 0, 0.6), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(0.6, -1, -0.4) * euler(0, 1.57, 0) * euler(0, 1.2, -0.1), 0.4)
      LH.C0 = clerp(LH.C0, cf(-0.6, -0.9, 0.4) * euler(0, -1.57, 0) * euler(0, 1.2, 0.1), 0.4)
      if RecentEnemy.Value ~= nil then
        break
      end
    end
    do
      if grabTarget ~= nil and grabTarget:findFirstChild("Stats") ~= nil and grabTarget.Stats:findFirstChild("Ungrabbable") ~= nil and grabTarget.Stats.Ungrabbable.Value == true then
        cangrab = false
        print("nopls")
      end
      doing4 = false
	  print(doing4)
      if RecentEnemy.Value == nil then
		attack = false
		doing4 = true
		else
        mana.Value = mana.Value - 50
		print("wat")
        print("hitenemy")
        for i = 1, 3 do
          for i = 0, 1, 0.25 do
            swait()
            sref.CFrame = LeftArm.CFrame * cf(0, -1.5, 0) * euler(-1.57, 0, 0)
            if grabhit == true and cangrab == true then
              grabTarget.Humanoid.PlatformStand = true
              grabpos.position = sref.Position
              grabpos.Parent = grabTarget.Torso
              grabTarget.Torso.CFrame = sref.CFrame
            end
            handlewld.Part1 = Torso
            handlewld.C0 = clerp(handlewld.C0, euler(0, 0, -0.9) * cf(3.2, -3, -0.6), 0.5)
            wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.5)
            Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(0.4, 0, 0), 0.5)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0, 0, 0.6), 0.5)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.2, 0, 0.6) * euler(0, 0, 0), 0.5)
            LW.C0 = clerp(LW.C0, cf(-1.7, 0.8, -0.6) * euler(1, 0, 0.4) * euler(0, -0.5, 0), 0.5)
            RH.C0 = clerp(RH.C0, cf(1.1, -0.5, -0.2) * euler(0, 1.57, 0) * euler(-0.1, -0.6, 0) * euler(0, 0, -0.1), 0.5)
            LH.C0 = clerp(LH.C0, cf(-1, -0.8, -0.4) * euler(0, -1.57, 0) * euler(-0.1, 0.1, 0) * euler(0, 0, 0.6), 0.5)
          end
          for i = 0, 1, 0.25 do
            swait()
            sref.CFrame = LeftArm.CFrame * cf(-0.8, -1.5, 0) * euler(-2, 0, 0)
            if grabhit == true and cangrab == true then
              grabTarget.Humanoid.PlatformStand = true
              grabpos.position = sref.Position
              grabpos.Parent = grabTarget.Torso
              grabTarget.Torso.CFrame = sref.CFrame
            end
            handlewld.Part1 = Torso
            handlewld.C0 = clerp(handlewld.C0, euler(0, 0, -0.9) * cf(3.2, -3, -0.6), 0.7)
            wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.7)
            Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(0.6, 0, 0), 0.7)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.5) * euler(0, 0, 0.2), 0.7)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.6) * euler(0, 0, 0), 0.7)
            LW.C0 = clerp(LW.C0, cf(-1.4, 0.2, -0.6) * euler(0.4, 0, 0.2) * euler(0, -0.5, 0), 0.7)
            RH.C0 = clerp(RH.C0, cf(1, 0.2, -0.4) * euler(0, 1.57, 0) * euler(0, -0.2, 0) * euler(0, 0, -0.1), 0.7)
            LH.C0 = clerp(LH.C0, cf(-1, -0.6, -0.6) * euler(0, -1.57, 0) * euler(-0.1, 0.1, 0) * euler(0, 0, 1), 0.7)
          end
		  print("wat")
          MagicWave(BrickColor.new(NewCol), cf(sref.Position), 1, 1, 1, 2, 2, 2, 0.15)
		  print("wat2")
          MagniDamage(sref, 8, 4, 5, 0, "Normal", RootPart, 0, 1, (math.random(4, 6)), nil, true, nil, "Movement", 0.1, 300)
        end
        for i = 1, 5 do
          swait()
          sref.CFrame = LeftArm.CFrame * cf(-0.8, -1.5, 0) * euler(-2, 0, 0)
          if grabhit == true and cangrab == true then
            grabTarget.Humanoid.PlatformStand = true
            grabpos.position = sref.Position
            grabpos.Parent = grabTarget.Torso
            grabTarget.Torso.CFrame = sref.CFrame
          end
        end
        if cangrab == true then
          for i = 0, 1, 0.15 do
            swait()
            sref.CFrame = LeftArm.CFrame * cf(0, -1.5, 0) * euler(-1.57, 0, 0)
            if grabhit == true and cangrab == true then
              grabTarget.Humanoid.PlatformStand = true
              grabpos.position = sref.Position
              grabpos.Parent = grabTarget.Torso
              grabTarget.Torso.CFrame = sref.CFrame
            end
            Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.3)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.1) * euler(0, 0, 1.2), 0.3)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.4, 0, 0.4) * euler(0, 0, 0), 0.3)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0.2) * euler(1.4, 0, 0.2) * euler(0, 0, 0), 0.3)
            RH.C0 = clerp(RH.C0, cf(1, -0.9, 0.2) * euler(0, 1.57, 0) * euler(-0.1, -1, 0) * euler(0, 0, -0.1), 0.3)
            LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.1) * euler(0, -1.57, 0) * euler(-0.1, 0.4, 0) * euler(0, 0, 0.2), 0.3)
          end
          for i = 0, 1, 0.2 do
            swait()
            if i <= 0.4 then
              sref.CFrame = LeftArm.CFrame * cf(0, -1.5, 0) * euler(-1.57, 0, 0)
              if grabhit == true then
                grabTarget.Humanoid.PlatformStand = true
                grabpos.position = sref.Position
                grabpos.Parent = grabTarget.Torso
                grabTarget.Torso.CFrame = sref.CFrame
              end
            else
              if i >= 0.4 and grabhit == true and grabTarget ~= nil then
                grabTarget.Humanoid.PlatformStand = false
                grabpos.Parent = nil
                sref.Parent = nil
              end
            end
            Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(0.1, 0, 0), 0.4)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.1) * euler(0, 0, -1), 0.4)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.6, 0, 0.2) * euler(0, 0, 0), 0.4)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, -1) * euler(0, 0, 0), 0.4)
            RH.C0 = clerp(RH.C0, cf(1, -0.9, 0) * euler(0, 1.57, 0) * euler(-0.1, 0.1, 0) * euler(0, 0, -0.1), 0.4)
            LH.C0 = clerp(LH.C0, cf(-1, -0.9, 0) * euler(0, -1.57, 0) * euler(-0.1, 1, 0) * euler(0, 0, 0.1), 0.4)
          end
          Damagefunc(grabTarget.Torso, 5, 7, math.random(30, 40), "Normal", RootPart, 0, 2, (math.random(3, 5)), nil, true)
          for i = 0, 1, 0.1 do
            swait()
            Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(0.1, 0, 0), 0.4)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.1) * euler(0, 0, -1), 0.4)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.6, 0, 0.2) * euler(0, 0, 0), 0.4)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, -0.5) * euler(0, 0, 0), 0.4)
            RH.C0 = clerp(RH.C0, cf(1, -0.9, 0) * euler(0, 1.57, 0) * euler(-0.1, 0.1, 0) * euler(0, 0, -0.1), 0.4)
            LH.C0 = clerp(LH.C0, cf(-1, -0.9, 0) * euler(0, -1.57, 0) * euler(-0.1, 1, 0) * euler(0, 0, 0.1), 0.4)
          end
        end
        do
          grabpos.Parent = nil
          for i = 0, 1, 0.2 do
            swait()
            handlewld.C0 = clerp(handlewld.C0, euler(0, 0, -0.9) * cf(3.2, -3, -0.6), 0.3)
            wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.3)
            Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.6) * euler(-0.3, 0, 0), 0.4)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.1) * euler(0, 0, 0), 0.4)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.4, 0, 0.4) * euler(0, -1, 0), 0.4)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(3.6, 0, -0.4) * euler(0, 1.57, 0), 0.4)
            RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.1) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0), 0.4)
            LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.1) * euler(0, -1.57, 0) * euler(-0.1, 0.1, 0), 0.4)
          end
          for i = 0, 1, 0.2 do
            swait()
            handlewld.C0 = clerp(handlewld.C0, euler(1.2, 0, -0.8) * cf(1.9, -2.1, 1.6), 0.3)
            wld1.C0 = clerp(wld1.C0, euler(0, 0.4, 0) * cf(0, 0, 0), 0.3)
            Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(-0.4, 0, 0), 0.4)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.1) * euler(0, 0, 0.8), 0.4)
            RW.C0 = clerp(RW.C0, cf(-0.8, 0.7, -0.5) * euler(3, 0, -0.8) * euler(0, 0, 0), 0.4)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(2.8, 0, -0.2) * euler(0, 0, 0), 0.4)
            RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.1) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0), 0.4)
            LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.1) * euler(0, -1.57, 0) * euler(-0.1, 0.1, 0), 0.4)
          end
          mode = "Unsheathed"
          handlewld.Part1 = RightArm
          handlewld.C0 = euler(0, 0, 0) * cf(0, 1, 0)
          wld1.C0 = cf(0, -0.8, 0) * euler(0, 0.6, 0) * euler(-2.3, 0, 0) * euler(0, 0, 0)
          for i = 0, 1, 0.1 do
            swait()
            handlewld.Part1 = RightArm
            handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.4)
            wld1.C0 = clerp(wld1.C0, cf(0, -0.8, 0) * euler(0, 1.57, 0) * euler(-1.2, 0, 0), 0.4)
            Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.2) * euler(0.4, 0, 0), 0.4)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, -0.2, -0.1) * euler(-0.3, 0, 1.2), 0.4)
            RW.C0 = clerp(RW.C0, cf(-0.4, 0.7, -0.5) * euler(3, 0, -0.6) * euler(0, 1.3, 0), 0.4)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.2, 0, -0.4) * euler(0, 0, 0), 0.4)
            RH.C0 = clerp(RH.C0, cf(0.8, -0.3, -0.4) * euler(0, 1.57, 0) * euler(-0.1, -1.2, 0) * euler(0, 0, 0.5), 0.4)
            LH.C0 = clerp(LH.C0, cf(-0.7, -0.8, -0.6) * euler(0, -1.57, 0) * euler(-0.1, -1.2, 0) * euler(0, 0, 0.1), 0.4)
          end
          so("320557353", prt20, 1, 1)
          do
            local dec = Instance.new("NumberValue", Decrease)
            dec.Name = "DecreaseMvmt"
            dec.Value = 10
            game:GetService("Debris"):AddItem(dec, 10)
            dohit = 0
            for i = 0, 1, 0.05 do
              swait()
              dohit = dohit + 1
              if dohit == 7 then
                ref = part(3, workspace, 0, 0, BrickColor.new("Black"), "Reference", vt())
                ref.Anchored = true
                ref.CFrame = RootPart.CFrame * cf(0, 0, -8)
                game:GetService("Debris"):AddItem(ref, 5)
                table.insert(Effects, {ref, "Shockwave", 82, RootPart.CFrame * cf(0, 0, -8), 0})
              end
              handlewld.Part1 = RightArm
              handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
              wld1.C0 = clerp(wld1.C0, cf(0, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.9, 0, 0), 0.3)
              Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.3) * euler(-0.2, 0, 0), 0.3)
              RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, -1.8, -1) * euler(0.3, 0, 1.3), 0.3)
              RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(3, 0, -0.6) * euler(0, 1.3, 0) * euler(-2.8, 0, 0), 0.5)
              LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.2, 0, -0.4) * euler(0, 0, 0), 0.3)
              RH.C0 = clerp(RH.C0, cf(0.8, 0.1, -0.4) * euler(0, 1.57, 0) * euler(-0.1, -1.3, 0) * euler(0, 0, 0.3), 0.3)
              LH.C0 = clerp(LH.C0, cf(-0.7, -0.9, -1) * euler(0, -1.57, 0) * euler(-0.1, -1.3, 0) * euler(0, 0, 0.6), 0.3)
            end
            for i = 1, 10 do
              swait()
            end
            dec.Parent = nil
            if RecentEnemy.Value == nil then
              cooldowns[4] = 70
            end
            attack = false
          end
        end
      end
    end
  end
end
findNearestTorso = function(pos, distance)
  local list = (game.Workspace:children())
  local torso = nil
  local dist = distance
  local temp, human, temp2 = nil, nil, nil
  for x = 1, #list do
    temp2 = list[x]
    canfind = true
    -- DECOMPILER ERROR at PC36: Unhandled construct in 'MakeBoolean' P1

    if game.Players:GetPlayerFromCharacter(temp2) ~= nil and game.Players:GetPlayerFromCharacter(temp2).TeamColor == Player.TeamColor and Player.Neutral == false then
      canfind = false
    end
    canfind = true
    if temp2.className == "Model" and temp2 ~= Character and canfind == true then
      temp = temp2:findFirstChild("Torso")
      human = temp2:findFirstChild("Humanoid")
      if temp ~= nil and human ~= nil and human.Health > 0 and temp.Position - pos.magnitude < dist then
        torso = temp
        dist = temp.Position - pos.magnitude
      end
    end
  end
  return torso, dist
end
DecreaseStat = function(Model, Stat, Amount, Duration)
  if Model:findFirstChild("Stats") ~= nil and Model.Stats[Stat] ~= nil then
    Model.Stats[Stat].Value = Model.Stats[Stat].Value - Amount
    d = Instance.new("NumberValue", Model.Stats.Decrease)
    dur = Instance.new("NumberValue", d)
    dur.Name = "Duration"
    dur.Value = Duration
    game:GetService("Debris"):AddItem(d, 20)
    if Stat == "Damage" then
      d.Name = "DecreaseAtk"
    else
      if Stat == "Defense" then
        d.Name = "DecreaseDef"
      else
        if Stat == "Movement" then
          d.Name = "DecreaseMvmt"
        end
      end
    end
    if Model:findFirstChild("Torso") ~= nil then
      display = ""
      if Stat == "Damage" then
        if Amount > 0 then
          display = "-Damage"
        else
          display = "+Damage"
        end
      else
        if Stat == "Defense" then
          if Amount > 0 then
            display = "-Defense"
          else
            display = "+Defense"
          end
        else
          if Stat == "Movement" then
            if Amount > 0 then
              display = "-Movement"
            else
              display = "+Movement"
            end
          end
        end
      end
      showDamage(Model, display, "Debuff")
    end
    d.Value = Amount
  end
end
GetDist = function(Part1, Part2, magni)
  local targ = Part1.Position - Part2.Position
  local mag = targ.magnitude
  if mag <= magni then
    return true
  else
    return false
  end
end
MagniDamage = function(Part, magni, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
  for _,c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = nil
      for _,d in pairs(c:children()) do
        if d.className == "Model" and ranged ~= true then
          head = d:findFirstChild("Hitbox")
          if d.Parent == Character then
            break
          end
          if head ~= nil then
            local targ = head.Position - Part.Position
            local mag = targ.magnitude
            if mag <= magni and c.Name ~= Player.Name then
              ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
              ref.Anchored = true
              ref.CFrame = cf(head.Position)
              game:GetService("Debris"):AddItem(ref, 1)
              pitch = 1
              if mode == "Unsheathed" then
                pitch = 0.8
              end
              hitnum = math.random(1, 5)
              if hitnum == 1 then
                so("199148971", ref, 1, pitch)
              else
                if hitnum == 2 then
                  so("199149025", ref, 1, pitch)
                else
                  if hitnum == 3 then
                    so("199149072", ref, 1, pitch)
                  else
                    if hitnum == 4 then
                      so("199149109", ref, 1, pitch)
                    else
                      if hitnum == 5 then
                        so("199149119", ref, 1, pitch)
                      end
                    end
                  end
                end
              end
              StaggerHit.Value = true
            end
          end
        end
        do
          if d.className == "Part" then
            head = d
            if head ~= nil then
              local targ = head.Position - Part.Position
              local mag = targ.magnitude
              if mag <= magni and c.Name ~= Player.Name then
                if stun == nil then
                  stun = math.random(5, 10)
                end
                local Rang = nil
                if Ranged == false then
                  Rang = true
                end
                local stag = nil
                if shbash == true then
                  stag = true
                end
                Damagefunc(head, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
              end
            end
          end
          do
            -- DECOMPILER ERROR at PC190: LeaveBlock: unexpected jumping out DO_STMT

          end
        end
      end
    end
  end
end
MagniBuff = function(Part, magni, Dec, DecAm, Dur)
  DecreaseStat(Character, Dec, DecAm, Dur)
  for _,c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        cando = true
        if mag <= magni then
          if Player.Neutral == false then
            if game.Players:GetPlayerFromCharacter(head.Parent) ~= nil then
              if game.Players:GetPlayerFromCharacter(head.Parent).TeamColor == Player.TeamColor then
                cando = true
              else
                cando = false
              end
            else
              cando = false
            end
            if head.Parent:findFirstChild("Alignment") ~= nil and head.Parent.Alignment.Value == Player.TeamColor.Color then
              cando = true
            end
          else
            cando = false
          end
          if cando == true then
            DecreaseStat(head.Parent, Dec, DecAm, Dur)
          end
        end
      end
    end
  end
end
rayCast = function(Pos, Dir, Max, Ignore)
  return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
end
findNearestTorso = function(pos)
  local list = (game.Workspace:children())
  local torso = nil
  local dist = 50
  local temp, human, temp2 = nil, nil, nil
  for x = 1, #list do
    temp2 = list[x]
    canfind = true
    if game.Players:GetPlayerFromCharacter(temp2) ~= nil and game.Players:GetPlayerFromCharacter(temp2).TeamColor == Player.TeamColor and Player.Neutral == false then
      canfind = false
    end
    canfind = true
    if temp2.className == "Model" and temp2 ~= Character and canfind == true then
      temp = temp2:findFirstChild("Torso")
      human = temp2:findFirstChild("Humanoid")
      if temp ~= nil and human ~= nil and human.Health > 0 and (temp.Position - pos).magnitude < dist then
        torso = temp
        dist = (temp.Position - pos).magnitude
      end
    end
  end
  return torso, dist
end
local Point = Torso.CFrame * cf(0, Torso.Size.Y, 0)
LastPoint = Point
effect = function(Color, Ref, LP, P1, returnn, size, thing1)
  if LP == nil or P1 == nil then
    return 
  end
  local effectsmsh = Instance.new("SpecialMesh")
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  effectsmsh.MeshType = "Head"
  effectsmsh.Name = "Mesh"
  local effectsg = Instance.new("Part")
  NoOutline(effectsg)
  effectsg.formFactor = 3
  effectsg.CanCollide = false
  effectsg.Name = "Eff"
  effectsg.Locked = true
  effectsg.Anchored = true
  effectsg.Size = Vector3.new(0.5, 1, 0.5)
  effectsg.Parent = workspace
  effectsmsh.Parent = effectsg
  effectsg.BrickColor = BrickColor.new(Color)
  effectsg.Reflectance = Ref
  local point1 = P1
  local mg = LP.p - point1.p.magnitude
  effectsg.Size = Vector3.new(0.5, mg, 0.5)
  effectsg.CFrame = cf((LP.p + point1.p) / 2, point1.p) * CFrame.Angles(math.rad(90), 0, 0)
  effectsmsh.Scale = Vector3.new(size, 1, size)
  game:GetService("Debris"):AddItem(effectsg, 2)
  if returnn then
    return effectsg
  end
  if not returnn then
    if thing1 == 1 then
      table.insert(Effects, {effectsg, "Cylinder", 0.05, 0.2, 0, 0.2, effectsmsh})
    else
      table.insert(Effects, {effectsg, "Cylinder", 0.2, 0.01, 0, 0.01, effectsmsh})
    end
  end
end
local CFrameFromTopBack = function(at, top, back)
  local right = top:Cross(back)
  return CFrame.new(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end
Triangle = function(a, b, c)
  local edg1 = c - a:Dot(b - a.unit)
  local edg2 = a - b:Dot(c - b.unit)
  local edg3 = b - c:Dot(a - c.unit)
  if edg1 <= b - a.magnitude and edg1 >= 0 then
    a = a
  else
    -- DECOMPILER ERROR at PC35: Overwrote pending register: R1 in 'AssignReg'

    if edg2 <= c - b.magnitude and edg2 >= 0 then
      a = b
    else
      -- DECOMPILER ERROR at PC46: Overwrote pending register: R2 in 'AssignReg'

      -- DECOMPILER ERROR at PC47: Overwrote pending register: R1 in 'AssignReg'

      if edg3 <= a - c.magnitude and edg3 >= 0 then
        a = c
      else
        assert(false, "unreachable")
      end
    end
  end
  local len1 = c - a:Dot(b - a.unit)
  local len2 = b - a.magnitude - len1
  local width = a + b - a.unit * len1 - c.magnitude
  local maincf = CFrameFromTopBack(a, b - a:Cross(c - b).unit, -b - a.unit)
  local list = {}
  if len1 > 0.01 then
    local w1 = Instance.new("WedgePart", m)
    w1.Name = "Triangle"
    game:GetService("Debris"):AddItem(w1, 5)
    w1.Material = "SmoothPlastic"
    w1.FormFactor = "Custom"
    w1.BrickColor = BrickColor.new("Medium blue")
    w1.Transparency = 0
    w1.Reflectance = 0
    w1.Material = "SmoothPlastic"
    w1.CanCollide = false
    NoOutline(w1)
    local sz = Vector3.new(0.2, width, len1)
    w1.Size = sz
    local sp = Instance.new("SpecialMesh", w1)
    sp.MeshType = "Wedge"
    sp.Scale = Vector3.new(0, 1, 1) * sz / w1.Size
    w1:BreakJoints()
    w1.Anchored = true
    w1.Parent = workspace
    w1.Transparency = 0.7
    table.insert(Effects, {w1, "Disappear", 0.05})
    w1.CFrame = maincf * CFrame.Angles(math.pi, 0, math.pi / 2) * CFrame.new(0, width / 2, len1 / 2)
    table.insert(list, w1)
  end
  do
    if len2 > 0.01 then
      local w2 = Instance.new("WedgePart", m)
      w2.Name = "Triangle"
      game:GetService("Debris"):AddItem(w2, 5)
      w2.Material = "SmoothPlastic"
      w2.FormFactor = "Custom"
      w2.BrickColor = BrickColor.new("Medium blue")
      w2.Transparency = 0
      w2.Reflectance = 0
      w2.Material = "SmoothPlastic"
      w2.CanCollide = false
      NoOutline(w2)
      local sz = Vector3.new(0.2, width, len2)
      w2.Size = sz
      local sp = Instance.new("SpecialMesh", w2)
      sp.MeshType = "Wedge"
      sp.Scale = Vector3.new(0, 1, 1) * sz / w2.Size
      w2:BreakJoints()
      w2.Anchored = true
      w2.Parent = workspace
      w2.Transparency = 0.7
      table.insert(Effects, {w2, "Disappear", 0.05})
      w2.CFrame = maincf * CFrame.Angles(math.pi, math.pi, -math.pi / 2) * CFrame.new(0, width / 2, -len1 - len2 / 2)
      table.insert(list, w2)
    end
    do
      return unpack(list)
    end
  end
end
MagicBlock = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
  local prt = part(3, effects, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  if Type == 1 or Type == nil then
    table.insert(Effects, {prt, "Block1", delay, x3, y3, z3, msh})
  else
    if Type == 2 then
      table.insert(Effects, {prt, "Block2", delay, x3, y3, z3, msh})
    end
  end
end
MagicCircle = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, effects, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicCircle2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, push)
  local prt = part(3, effects, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Blood", delay, x3, y3, z3, msh, push})
end
MagicnegCircle = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, effects, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "FileMesh", "1185246", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicRing = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, effects, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
  prt.Anchored = true
  prt.CFrame = cframe * cf(x2, y2, z2)
  local msh = mesh("SpecialMesh", prt, "FileMesh", "3270017", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicCylinder = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, effects, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicHead = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, effects, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Head", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
ClangEffect = function(brickcolor, cframe, duration, decrease, size, power)
  local prt = part(3, effects, 0, 1, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(5, 5, 5))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "CylinderClang", duration, decrease, size, power, prt.CFrame, nil})
end
MagicWave = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, effects, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "FileMesh", "20329976", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicWave2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, effects, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "FileMesh", "1323306", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder2", delay, x3, y3, z3, msh, 0})
end
MagicSpecial = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, effects, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "FileMesh", "24388358", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
RingGui = function(parent, color, thing)
  rgui = Instance.new("BillboardGui")
  game:GetService("Debris"):AddItem(rgui, 10)
  rgui.Parent = parent
  rgui.Size = UDim2.new(1, 0, 1, 0)
  rgui.AlwaysOnTop = true
  rimg = Instance.new("ImageLabel")
  rimg.Parent = rgui
  rimg.BackgroundTransparency = 1
  rimg.Size = UDim2.new(1, 0, 1, 0)
  rimg.Image = "rbxassetid://144580273"
  rimg.ImageTransparency = 0.4
  rimg.ImageColor3 = color.Color
  table.insert(Effects, {rgui, "PunchEf", rimg, 10, thing})
end
Lightning = function(p0, p1, tym, ofs, col, th, tra, last)
  local magz = p0 - p1.magnitude
  local curpos = p0
  local trz = {-ofs, ofs}
  for i = 1, tym do
    local li = Instance.new("Part", workspace)
    li.TopSurface = 0
    li.BottomSurface = 0
    li.Anchored = true
    li.Transparency = tra or 0.4
    li.BrickColor = BrickColor.new(col)
    li.formFactor = "Custom"
    li.CanCollide = false
    li.Size = Vector3.new(th, th, magz / tym)
    local ofz = Vector3.new(trz[math.random(1, 2)], trz[math.random(1, 2)], trz[math.random(1, 2)])
    local trolpos = CFrame.new(curpos, p1) * CFrame.new(0, 0, magz / tym).p + ofz
    if tym == i then
      local magz2 = curpos - p1.magnitude
      li.Size = Vector3.new(th, th, magz2)
      li.CFrame = CFrame.new(curpos, p1) * CFrame.new(0, 0, -magz2 / 2)
    else
      do
        do
          li.CFrame = CFrame.new(curpos, trolpos) * CFrame.new(0, 0, magz / tym / 2)
          curpos = li.CFrame * CFrame.new(0, 0, magz / tym / 2).p
          game.Debris:AddItem(li, 10)
          table.insert(Effects, {li, "Disappear", last})
          -- DECOMPILER ERROR at PC137: LeaveBlock: unexpected jumping out DO_STMT

          -- DECOMPILER ERROR at PC137: LeaveBlock: unexpected jumping out IF_ELSE_STMT

          -- DECOMPILER ERROR at PC137: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
  end
end
Damagefunc = function(hit, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
  if hit.Parent == nil then
    return 
  end
  if hit.Name == "Hitbox" and hit.Parent ~= modelzorz and ranged ~= true then
    ref = part(3, effects, 0, 1, BrickColor.new("Black"), "Reference", vt())
    ref.Anchored = true
    ref.CFrame = cf(hit.Position)
    game:GetService("Debris"):AddItem(ref, 1)
    pitch = 1
    if mode == "Unsheathed" then
      pitch = 0.8
    end
    hitnum = math.random(1, 5)
    if hitnum == 1 then
      so("199148971", ref, 1, pitch)
    else
      if hitnum == 2 then
        so("199149025", ref, 1, pitch)
      else
        if hitnum == 3 then
          so("199149072", ref, 1, pitch)
        else
          if hitnum == 4 then
            so("199149109", ref, 1, pitch)
          else
            if hitnum == 5 then
              so("199149119", ref, 1, pitch)
            end
          end
        end
      end
    end
    StaggerHit.Value = true
  end
  h = hit.Parent:FindFirstChild("Humanoid")
  if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
    if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
      return 
    end
    if Player.Neutral == false then
      if hit.Parent:findFirstChild("Alignment") ~= nil and hit.Parent.Alignment.Value == Player.TeamColor.Color then
        return 
      end
      if game.Players:GetPlayerFromCharacter(hit.Parent) ~= nil and game.Players:GetPlayerFromCharacter(hit.Parent).TeamColor == Player.TeamColor then
        return 
      end
    end
    if hit.Parent:findFirstChild("Stats") ~= nil and hit.Parent.Stats:findFirstChild("Ungrabbable") ~= nil and hit.Parent.Stats.Ungrabbable.Value == true then
      cangrab = false
    end
    if doing4 == true and grabhit == false and cangrab == true then
      print("grabbed")
      grabhit = true
      grabTarget = hit.Parent
      grabpos.Parent = grabTarget.Torso
      grabpos.P = 2000
      grabpos.D = 100
      grabpos.maxForce = Vector3.new(545000, 545000, 545000)
      grabpos.position = sref.Position
    end
    c = Instance.new("ObjectValue")
    c.Name = "creator"
    c.Value = game:service("Players").LocalPlayer
    c.Parent = h
    RecentEnemy.Value = hit.Parent
    game:GetService("Debris"):AddItem(c, 0.5)
    minim = minim * Atk.Value
    maxim = maxim * Atk.Value
    Damage = 0
    if minim == maxim then
      Damage = maxim
    else
      Damage = math.random(minim, maxim)
    end
    blocked = false
    enblock = nil
    Stats = hit.Parent:findFirstChild("Stats")
    if Stats ~= nil then
      invis = Stats:findFirstChild("Invisibility")
      isinvis = Stats:findFirstChild("IsInvisible")
      if (ranged == false or ranged == nil) and invis ~= nil and isinvis.Value == true then
        invis.Value = 0
      end
      enblock = Stats:findFirstChild("Block")
      if enblock ~= nil and enblock.Value == true then
        blocked = true
      end
      if Stats:findFirstChild("Defense") ~= nil then
        Damage = Damage / Stats.Defense.Value
        pitch = 1
        if mode == "Unsheathed" then
          pitch = 0.8
        end
        if Damage <= 3 and (ranged == false or ranged == nil) and blocked ~= true then
          hitnum = math.random(1, 5)
          if hitnum == 1 then
            so("199149321", hit, 1, pitch)
          else
            if hitnum == 2 then
              so("199149338", hit, 1, pitch)
            else
              if hitnum == 3 then
                so("199149367", hit, 1, pitch)
              else
                if hitnum == 4 then
                  so("199149409", hit, 1, pitch)
                else
                  if hitnum == 5 then
                    so("199149452", hit, 1, pitch)
                  end
                end
              end
            end
          end
        else
          if ranged == false or ranged == nil and blocked ~= true then
            hitnum = math.random(1, 6)
            if hitnum == 1 then
              so("199149137", hit, 1, pitch)
            else
              if hitnum == 2 then
                so("199149186", hit, 1, pitch)
              else
                if hitnum == 3 then
                  so("199149221", hit, 1, pitch)
                else
                  if hitnum == 4 then
                    so("199149235", hit, 1, pitch)
                  else
                    if hitnum == 5 then
                      so("199149269", hit, 1, pitch)
                    else
                      if hitnum == 6 then
                        so("199149297", hit, 1, pitch)
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if Damage <= 3 and staghit == true and ranged ~= true then
          StaggerHit.Value = true
        end
      end
      if Stats:findFirstChild("Stun") ~= nil then
        if blocked == true then
          incstun = incstun / 2
        end
        if Stats.Stun.Value < Stats.StunThreshold.Value then
          Stats.Stun.Value = Stats.Stun.Value + incstun
        end
        if dodrop == true and Stats.StunThreshold.Value / 2 <= Stats.Stun.Value then
          instastun = true
          Stats.Stun.Value = 999
        end
      end
      if Stats:findFirstChild("Stagger") ~= nil and stagger == true then
        Stats.Stagger.Value = true
      end
    end
    if blocked == true then
      showDamage(hit.Parent, "Block", "Damage")
      if ranged ~= true then
        enblock.Value = false
        Stagger.Value = true
        hitnum = math.random(1, 2)
        if hitnum == 1 then
          so("199148933", hit, 1, 1)
        else
          if hitnum == 2 then
            so("199148947", hit, 1, 1)
          end
        end
      end
    else
      Damage = math.floor(Damage)
      coroutine.resume(coroutine.create(function(Hum, Dam)
	if Hum.Parent:FindFirstChild("DamDebounce") == nil then
	Hum:TakeDamage(Damage)
	local dam = Instance.new("BoolValue",Hum.Parent)
	dam.Value = true
	dam.Name = "DamDebounce"
	game:GetService("Debris"):AddItem(dam,0.5)
	end
  end), h, Damage)
      showDamage(hit.Parent, Damage, "Damage")
      if DecreaseState ~= nil then
        if DecreaseState == "Temporal" then
          DecreaseStat(hit.Parent, "Damage", DecreaseAmount, Duration)
          DecreaseStat(hit.Parent, "Defense", DecreaseAmount, Duration)
        else
          if DecreaseState == "Temporal2" then
            DecreaseStat(hit.Parent, "Damage", DecreaseAmount, Duration)
            DecreaseStat(hit.Parent, "Movement", DecreaseAmount, Duration)
          else
            DecreaseStat(hit.Parent, DecreaseState, DecreaseAmount, Duration)
          end
        end
      end
      if Type == "NormalDecreaseMvmt1" then
        DecreaseStat(hit.Parent, "Movement", 0.1, 200)
      end
      if Type == "Knockdown" then
        hum = hit.Parent.Humanoid
        hum.PlatformStand = true
        coroutine.resume(coroutine.create(function(HHumanoid)
    swait(1)
    HHumanoid.PlatformStand = false
  end), hum)
        local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
        local bodvol = Instance.new("BodyVelocity")
        bodvol.velocity = angle * knockback
        bodvol.P = 5000
        bodvol.maxForce = Vector3.new(8000, 8000, 8000)
        bodvol.Parent = hit
        rl = Instance.new("BodyAngularVelocity")
        rl.P = 3000
        rl.maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000
        rl.angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10))
        rl.Parent = hit
        game:GetService("Debris"):AddItem(bodvol, 0.5)
        game:GetService("Debris"):AddItem(rl, 0.5)
      else
        do
          if Type == "Knockdown2" then
            hum = hit.Parent.Humanoid
            local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
            local bodvol = Instance.new("BodyVelocity")
            bodvol.velocity = angle * knockback
            bodvol.P = 5000
            bodvol.maxForce = Vector3.new(8000, 8000, 8000)
            bodvol.Parent = hit
            game:GetService("Debris"):AddItem(bodvol, 0.5)
          else
            do
              if Type == "Normal" or Type == "NormalDecreaseMvmt1" then
                vp = Instance.new("BodyVelocity")
                vp.P = 500
                vp.maxForce = Vector3.new(math.huge, 0, math.huge)
                if KnockbackType == 1 then
                  vp.velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
                else
                  if KnockbackType == 2 then
                    vp.velocity = Property.CFrame.lookVector * knockback
                  end
                end
                game:GetService("Debris"):AddItem(vp, 0.5)
                if knockback > 0 then
                  vp.Parent = hit.Parent.Torso
                end
              end
              debounce = Instance.new("BoolValue")
              debounce.Name = "DebounceHit"
              debounce.Parent = hit.Parent
              debounce.Value = true
              game:GetService("Debris"):AddItem(debounce, Delay)
              c = Instance.new("ObjectValue")
              c.Name = "creator"
              c.Value = Player
              c.Parent = h
              game:GetService("Debris"):AddItem(c, 0.5)
              CRIT = false
            end
          end
        end
      end
    end
  end
end
showDamage = function(Char, Dealt, Type)
  m = Instance.new("Model")
  m.Name = "Effect"
  c = Instance.new("Part")
  c.Transparency = 1
  c.Name = "Head"
  c.TopSurface = 0
  c.BottomSurface = 0
  c.formFactor = "Plate"
  c.Size = Vector3.new(1, 0.4, 1)
  b = Instance.new("BillboardGui", c)
  b.Size = UDim2.new(5, 0, 5, 0)
  b.AlwaysOnTop = true
  damgui = gui("TextLabel", b, tostring(Dealt), 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
  if Type == "Damage" then
    damgui.Font = "SourceSans"
    if Dealt == "Block" then
      damgui.TextColor3 = BrickColor.new("Bright blue").Color
    else
      if Dealt < 3 then
        damgui.TextColor3 = BrickColor.new("White").Color
      else
        if Dealt >= 3 and Dealt < 20 then
          damgui.TextColor3 = BrickColor.new("Bright yellow").Color
        else
          damgui.TextColor3 = BrickColor.new("Really red").Color
          damgui.Font = "SourceSansBold"
        end
      end
    end
  else
    if Type == "Debuff" then
      damgui.TextColor3 = BrickColor.new("White").Color
    else
      if Type == "Interrupt" then
        damgui.TextColor3 = BrickColor.new("New Yeller").Color
      end
    end
  end
  damgui.TextScaled = true
  ms = Instance.new("CylinderMesh")
  ms.Scale = Vector3.new(0.8, 0.8, 0.8)
  ms.Parent = c
  c.Reflectance = 0
  Instance.new("BodyGyro").Parent = c
  c.Parent = m
  if Char:findFirstChild("Head") ~= nil then
    c.CFrame = cf(Char.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
  else
    if Char.Parent:findFirstChild("Head") ~= nil then
      c.CFrame = cf(Char.Parent.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
    end
  end
  f = Instance.new("BodyPosition")
  f.P = 2000
  f.D = 100
  f.maxForce = Vector3.new(545000, 545000, 545000)
  if Type == "Damage" then
    f.position = c.Position + Vector3.new(0, 3, 0)
  else
    if Type == "Debuff" or Type == "Interrupt" then
      f.position = c.Position + Vector3.new(0, 5, 0)
    end
  end
  f.Parent = c
  game:GetService("Debris"):AddItem(m, 5)
  table.insert(Effects, {m, "showDamage", damgui, f, 10, 1, 15, 50, 100})
  c.CanCollide = false
  m.Parent = workspace
  c.CanCollide = false
end
combo = 0
ob1d = function(mouse)
  if attack == true or equipped == false then
    return 
  end
  hold = true
  if combo == 0 then
    combo = 1
    attackone()
  else
    if combo == 1 then
      combo = 2
      attacktwo()
    else
      if combo == 2 then
        combo = 3
        attackthree()
      else
        if combo == 3 then
          combo = 0
          attackfour()
        end
      end
    end
  end
  coroutine.resume(coroutine.create(function()
    for i = 1, 50 do
      if attack == false then
        swait()
      end
    end
    if attack == false then
      combo = 0
    end
  end))
end
ob1u = function(mouse)
  hold = false
end
buttonhold = false
fenbarmove1.MouseButton1Click:connect(do1)
fenbarmove2.MouseButton1Click:connect(do2)
fenbarmove3.MouseButton1Click:connect(do3)
fenbarmove4.MouseButton1Click:connect(do4)
eul = 0
equipped = false
key = function(key)
  if key == "g" then
    Stun.Value = 100
  end
  if key == "c" and guarding == true and canguardoff == true then
    guarding = false
  end
  if attack == true then
    return 
  end
  if key == "f" and mode == "Sheathed" then
    pressedf = true
    fnumb = 0
    attack = true
    if equipped == false then
      equipped = true
      RSH = ch.Torso["Right Shoulder"]
      LSH = ch.Torso["Left Shoulder"]
      RSH.Parent = nil
      LSH.Parent = nil
      RW.Name = "Right Shoulder"
      RW.Part0 = ch.Torso
      RW.C0 = cf(1.5, 0.5, 0)
      RW.C1 = cf(0, 0.5, 0)
      RW.Part1 = ch["Right Arm"]
      RW.Parent = ch.Torso
      LW.Name = "Left Shoulder"
      LW.Part0 = ch.Torso
      LW.C0 = cf(-1.5, 0.5, 0)
      LW.C1 = cf(0, 0.5, 0)
      LW.Part1 = ch["Left Arm"]
      LW.Parent = ch.Torso
      Animate.Parent = nil
      equipanim()
    else
      equipped = false
      hideanim()
      LH.C1 = LHC1
      RH.C1 = RHC1
      Animate.Parent = Humanoid
      swait(0)
      RW.Parent = nil
      LW.Parent = nil
      RSH.Parent = player.Character.Torso
      LSH.Parent = player.Character.Torso
    end
    attack = false
  end
  if equipped == false then
    return 
  end
  if key == "e" and mana.Value >= 5 then
    mana.Value = mana.Value - 5
    Equip()
    combo = 0
  end
  if key == "z" then
    do1()
  end
  if key == "x" then
    do2()
  end
  if key == "g" then
    cooldowns[3] = 100
  end
  if key == "c" then
    do3()
  end
  if key == "v" then
    do4()
  end
end
key2 = function(key)
  if key == "z" and holdz == true then
    holdz = false
  end
end
s = function(mouse)
  mouse.Button1Down:connect(function()
    ob1d(mouse)
  end)
  mouse.Button1Up:connect(function()
    ob1u(mouse)
  end)
  mouse.KeyDown:connect(key)
  mouse.KeyUp:connect(key2)
  player = Player
  ch = Character
end
ds = function(mouse)
end
Bin.Selected:connect(s)
Bin.Deselected:connect(ds)
print("Grand loaded.")
local mananum = 0
local donum = 0
local stunnum = 0
local staggeranim = false
local stunanim = false
local walk = 0
local walkforw = true
local dawalk = 0
while 1 do
  swait()
  if mode == "Sheathed" then
    passive1.Value = 0
    passive2.Value = 0
    passive3.Value = 0
  else
    passive1.Value = -0.5
    passive2.Value = -0.1
    passive3.Value = 0.3
  end
  target = findNearestTorso(RootPart.Position)
  do2target = target
  if math.random(1,2) == 1 then
	distance = 0
else
	distance = 10
end
  if distance <= 10 then
    do2mode = "Drop"
    fenbarmove2.Text = "(X)\nDrop"
  else
    do2mode = "Chase"
    fenbarmove2.Text = "(X)\nChase"
  end
  if Humanoid.Health <= 0 then
    attack = true
    resumeControl()
    modelzorz.Parent = workspace
    game:GetService("Debris"):AddItem(modelzorz, 30)
    for i = 1, #Weapon do
      Weapon[i].Parent = modelzorz
      Weapon[i].CanCollide = true
    end
    for i = 1, #Welds do
      if Welds[i].Part0.Parent == Character or Welds[i].Part1.Parent == Character then
        Welds[i].Parent = nil
      else
        Welds[i].Parent = prt1
      end
    end
  end
  do
    if fnumb < 21 then
      fnumb = fnumb + 1
      if pressedf == false then
        fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency - 0.025
        tellbar.TextTransparency = tellbar.TextTransparency - 0.05
        tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency - 0.05
      else
        if fnumb == 20 then
          fenframe5.Parent = nil
          print("daigui")
        end
        fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency + 0.025
        tellbar.TextTransparency = tellbar.TextTransparency + 0.05
        tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency + 0.05
      end
    end
    if Stagger.Value == true and staggeranim == false then
      coroutine.resume(coroutine.create(function()
  if mode == "Unsheathed" then
    Stagger.Value = false
    Stun.Value = Stun.Value + math.random(4, 6)
    return 
  end
  staggeranim = true
  while attack == true do
    swait()
  end
  StaggerAnim()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end))
    end
    if StaggerHit.Value == true and staggeranim == false then
      coroutine.resume(coroutine.create(function()
  staggeranim = true
  StaggerHitt()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end))
    end
    if Mvmt.Value < 0 or Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true or Rooted.Value == true then
      Humanoid.WalkSpeed = 0
    else
      Humanoid.WalkSpeed = 16 * Mvmt.Value
    end
    if StunT.Value <= Stun.Value and stunanim == false then
      coroutine.resume(coroutine.create(function()
  stunanim = true
  while attack == true do
    swait()
  end
  StunAnim()
  Stun.Value = 0
  stunanim = false
end))
    end
    local stunnum2 = 40
    if stunnum2 <= stunnum and (0 < Stun.Value) then
      stunnum = 0
    end
    stunnum = stunnum + 1
    if 0.5 <= donum then
      handidle = true
    else
      if donum <= 0 then
        handidle = false
      end
    end
    if handidle == false then
      donum = donum + 0.003
    else
      donum = donum - 0.003
    end
    local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
    local velderp = RootPart.Velocity.y
    hitfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
    if equipped == true then
      if Anim == "Walk" then
        if walkforw == true then
          RH.C1 = clerp(RH.C1, RHC1 * cf(0.2, -0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
          LH.C1 = clerp(LH.C1, LHC1 * cf(0.1, 0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
          if attack == false and mode == "Sheathed" then
            RW.C1 = clerp(RW.C1, cf(0, 0.5, 0) * euler(-0.5, 0, 0), Mvmt.Value * 10 / 50)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0.5, 0, 0), Mvmt.Value * 10 / 50)
          else
            RW.C1 = clerp(RW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
          end
        else
          RH.C1 = clerp(RH.C1, RHC1 * cf(-0.1, 0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
          LH.C1 = clerp(LH.C1, LHC1 * cf(-0.2, -0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
          if attack == false and mode == "Sheathed" then
            RW.C1 = clerp(RW.C1, cf(0, 0.5, 0) * euler(0.5, 0, 0), Mvmt.Value * 10 / 50)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(-0.5, 0, 0), Mvmt.Value * 10 / 50)
          else
            RW.C1 = clerp(RW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
          end
        end
      else
        RH.C1 = clerp(RH.C1, RHC1, 0.2)
        LH.C1 = clerp(LH.C1, LHC1, 0.2)
        RW.C1 = clerp(RW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
      end
      if 1 < RootPart.Velocity.y and hitfloor == nil then
        Anim = "Jump"
        if attack == false then
          if mode == "Sheathed" then
            handlewld.Part1 = Torso
            handlewld.C0 = clerp(handlewld.C0, euler(0, 0, -0.9) * cf(3.2, -3, -0.6), 0.3)
            wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.3)
            Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0), 0.2)
            Neck.C1 = clerp(Neck.C1, necko2 * euler(0, 0, 0), 0.2)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1, 0, 0.2), 0.2)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-1, 0, -0.2), 0.2)
            RH.C0 = clerp(RH.C0, cf(1, -1, -0.3) * euler(-0.5, 1.57, 0) * euler(-0.2, 0, 0), 0.2)
            LH.C0 = clerp(LH.C0, cf(-1, -1, -0.3) * euler(-0.5, -1.57, 0) * euler(-0.2, 0, 0), 0.2)
          else
            handlewld.Part1 = RightArm
            handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
            wld1.C0 = clerp(wld1.C0, cf(0, -0.8, 0) * euler(0, 1.57, 0) * euler(-1.9, 0, 0), 0.3)
            Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0), 0.2)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.3) * euler(0.2, 0, 0) * euler(0, 0, 0), 0.2)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, -0.2) * euler(0.8, 0, -0.2) * euler(0, -2.6, 0), 0.2)
            LW.C0 = clerp(LW.C0, cf(0.1, 0.4, -0.5) * euler(1, 0, 0.6) * euler(0, -2, 0), 0.2)
            RH.C0 = clerp(RH.C0, cf(1, -1, -0.3) * euler(-0.5, 1.57, 0) * euler(-0.2, 0, 0), 0.2)
            LH.C0 = clerp(LH.C0, cf(-1, -1, -0.3) * euler(-0.5, -1.57, 0) * euler(-0.2, 0, 0), 0.2)
          end
        end
      else
        if RootPart.Velocity.y < -1 and hitfloor == nil then
          Anim = "Fall"
          if attack == false then
            if mode == "Sheathed" then
              handlewld.Part1 = Torso
              handlewld.C0 = clerp(handlewld.C0, euler(0, 0, -0.9) * cf(3.2, -3, -0.6), 0.3)
              wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.3)
              Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, 0), 0.2)
              Neck.C1 = clerp(Neck.C1, necko2 * euler(0, 0, 0), 0.2)
              RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
              RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.8), 0.2)
              LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.8), 0.2)
              RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0.4, 1.57, 0), 0.2)
              LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(-0.2, -1.57, 0), 0.2)
            else
              handlewld.Part1 = RightArm
              handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
              wld1.C0 = clerp(wld1.C0, cf(0, -0.8, 0) * euler(0, 1.57, 0) * euler(-1.9, 0, 0), 0.3)
              Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, 0), 0.2)
              RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.3) * euler(0, 0, 0) * euler(0, 0, 0), 0.2)
              RW.C0 = clerp(RW.C0, cf(1.5, 0.5, -0.2) * euler(0.8, 0, -0.2) * euler(0, -2.6, 0), 0.2)
              LW.C0 = clerp(LW.C0, cf(0.1, 0.4, -0.5) * euler(1, 0, 0.6) * euler(0, -2, 0), 0.2)
              RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0.4, 1.57, 0), 0.2)
              LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(-0.2, -1.57, 0), 0.2)
            end
          end
        else
          if torvel < 1 and hitfloor ~= nil then
            Anim = "Idle"
            if attack == false then
              if mode == "Sheathed" then
                handlewld.Part1 = Torso
                handlewld.C0 = clerp(handlewld.C0, euler(0, 0, -0.9) * cf(3.2, -3, -0.6), 0.3)
                wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.3)
                Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0.1, 0, 0), 0.15)
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.1) * euler(0, 0, 0), 0.15)
                RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.4 - (donum) / 3, 0, 0.4 - (donum) / 5) * euler(0, -1, 0), 0.15)
                LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.4 - (donum) / 3, 0, -0.4 + (donum) / 5) * euler(0, 1, 0), 0.15)
                RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.1) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0), 0.2)
                LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.1) * euler(0, -1.57, 0) * euler(-0.1, 0.1, 0), 0.2)
              else
                handlewld.Part1 = RightArm
                handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
                wld1.C0 = clerp(wld1.C0, cf(0, -0.8, 0) * euler(0, 1.57, 0) * euler(-1.3, 0, 0), 0.3)
                Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.3) * euler(0.1, 0, 0), 0.15)
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.3) * euler(0.1, 0, 0) * euler(0, 0, -0.3), 0.15)
                RW.C0 = clerp(RW.C0, cf(1.1, 0.5, 0.4) * euler(-0.4, 0, 0.8) * euler(0, -0.5, 0), 0.15)
                LW.C0 = clerp(LW.C0, cf(-1.4, 0.4, -0.1) * euler(0.4, 0, -0.5) * euler(0, 0, 0), 0.15)
                RH.C0 = clerp(RH.C0, cf(1, -0.8, -0.2) * euler(0, 1.57, 0) * euler(-0.1, -0.1, 0), 0.2)
                LH.C0 = clerp(LH.C0, cf(-1.3, -0.7, -0.1) * euler(0, -1.57, 0) * euler(0, 0.3, 0) * euler(0, 0, -0.2), 0.2)
              end
            end
          else
            if 2 < torvel and hitfloor ~= nil and doing2 == false then
              Anim = "Walk"
              walk = walk + 1
              if 15 - 5 * Mvmt.Value <= walk then
                walk = 0
                if walkforw == true then
                  walkforw = false
                else
                  if walkforw == false then
                    walkforw = true
                  end
                end
              end
              if attack == false then
                if mode == "Sheathed" then
                  handlewld.Part1 = Torso
                  handlewld.C0 = clerp(handlewld.C0, euler(0, 0, -0.9) * cf(3.2, -3, -0.6), 0.3)
                  wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.3)
                  Neck.C0 = clerp(Neck.C0, necko * euler(0.1, 0, 0), 0.2)
                  RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.1, 0, 0), 0.2)
                  RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 0.1) * euler(0, 0, 0), 0.2)
                  LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -0.1), 0.2)
                  RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.2)
                  LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.2)
                else
                  handlewld.Part1 = RightArm
                  handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.3)
                  wld1.C0 = clerp(wld1.C0, cf(0, -0.8, 0) * euler(0, 1.57, 0) * euler(-1.9, 0, 0), 0.3)
                  Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.6) * euler(0.1, 0, 0), 0.15)
                  RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.3) * euler(0.2, 0, 0) * euler(0, 0, -0.6), 0.15)
                  RW.C0 = clerp(RW.C0, cf(1.5, 0.5, -0.2) * euler(0.8, 0, -0.2) * euler(0, -2.6, 0), 0.15)
                  LW.C0 = clerp(LW.C0, cf(-0.2, 0.4, -1) * euler(1.4, 0, 0.4) * euler(0, -2, 0), 0.15)
                  RH.C0 = clerp(RH.C0, cf(1, -0.9, -0.3) * euler(0, 1.57, 0) * euler(-0.2, 0.6, 0) * euler(0, 0, 0.2), 0.2)
                  LH.C0 = clerp(LH.C0, cf(-1.3, -0.7, -0.1) * euler(0, -1.57, 0) * euler(0, 0.6, 0) * euler(0, 0, -0.2), 0.2)
                end
              end
            else
            end
          end
        end
      end
    end
    if (30 <= torvel and hitfloor == nil) or 0 < #Effects then
      for e = 1, #Effects do
        if Effects[e] ~= nil then
          local Thing = Effects[e]
          if Thing ~= nil then
            local Part = Thing[1]
            local Mode = Thing[2]
            local Delay = Thing[3]
            local IncX = Thing[4]
            local IncY = Thing[5]
            local IncZ = Thing[6]
            if Thing[2] == "CylinderClang" then
              if Thing[3] <= 1 then
                Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, 2.5 * Thing[5], 0) * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
                Thing[7] = Thing[1].CFrame
                effect("New Yeller", 0, Thing[8], Thing[7], nil, 0.1, 2)
                Thing[8] = Thing[7]
                Thing[3] = Thing[3] + Thing[4]
              else
                Part.Parent = nil
                table.remove(Effects, e)
              end
            end
            if Thing[2] == "showDamage" then
              if Thing[6] < Thing[5] then
                Thing[6] = Thing[6] + 1
              else
                if Thing[6] < Thing[7] then
                  Thing[4].position = Thing[4].position + vt(0, -0.2, 0)
                  Thing[6] = Thing[6] + 1
                else
                  if Thing[6] < Thing[8] then
                    Thing[6] = Thing[6] + 1
                  else
                    if Thing[6] < Thing[9] then
                      Thing[6] = Thing[6] + 1
                      Thing[4].position = Thing[4].position + vt(0, 0.2, 0)
                      Thing[3].TextStrokeTransparency = Thing[3].TextStrokeTransparency + 0.1
                      Thing[3].TextTransparency = Thing[3].TextTransparency + 0.1
                    else
                      Thing[1].Parent = nil
                      table.remove(Effects, e)
                    end
                  end
                end
              end
            end
            if Thing[2] == "CloneEf" then
              if Thing[3] <= 500 then
                Thing[3] = Thing[3] + 1
                if 10 <= Thing[4] then
                  Thing[4] = 0
                  Clone()
                end
                Thing[4] = Thing[4] + 1
              else
                table.remove(Effects, e)
              end
            end
            if Thing[2] == "Sound" then
              if 1 <= Thing[4] and 0 < Thing[1].Pitch then
                Thing[4] = Thing[4] - 1
                Thing[1].Pitch = Thing[1].Pitch + Thing[3]
              else
                Thing[1].Volume = 0
                Thing[1].Parent = nil
                table.remove(Effects, e)
              end
            end
            if Thing[2] == "PunchEf" then
              if 0 <= Thing[4] then
                Thing[4] = Thing[4] - 1
                Thing[3].ImageTransparency = Thing[3].ImageTransparency + 0.15
                Thing[1].Size = Thing[1].Size + UDim2.new(Thing[5], 0, Thing[5], 0)
              else
                Thing[1].Parent = nil
                table.remove(Effects, e)
              end
            end
            if Thing[2] == "Shockwave" then
              if 0 <= Thing[3] then
                Thing[3] = Thing[3] - 2
                if Thing[3] % 10 == 0 then
                  Thing[5] = Thing[5] + 12
                  hitfloor2 = rayCast(Thing[1].Position, CFrame.new(Thing[1].Position, Thing[1].Position - Vector3.new(0, 1, 0)).lookVector, 20, Character)
                  if hitfloor2 ~= nil then
					local posfloor2 = Thing[1].Position
                    Thing[1].CFrame = cf(posfloor2)
                    MagicWave(hitfloor2.BrickColor, cf(posfloor2), 1, 1, 1, 1, 0.2, 1, 0.05)
                    MagicWave2(BrickColor.new(NewCol2), cf(posfloor2), 1, 1, 1, 1.2, 2, 1.2, 0.05)
					swait()
                    MagniDamage(Thing[1], 10, 10, 14, math.random(15, 20), "Knockdown2", RootPart, 0.5, 1, (math.random(10, 12)), nil, true)
                    for i = 1, 4 do
                      cf2 = cf(posfloor2) * cf(math.random(-800, 800) / 100, 1, math.random(-800, 800) / 100)
                      Thing[1].CFrame = cf2
                      ghitfloor = rayCast(Thing[1].Position, CFrame.new(Thing[1].Position, Thing[1].Position - Vector3.new(0, 1, 0)).lookVector, 20, Character)
                      if ghitfloor ~= nil then
                        Col = ghitfloor.BrickColor
                        local groundpart = part(3, workspace, 0, 0, Col, "Ground", vt(math.random(50, 200) / 100, math.random(50, 200) / 100, math.random(50, 200) / 100))
                        groundpart.Anchored = true
                        groundpart.Material = ghitfloor.Material
                        groundpart.CanCollide = true
						local gposfloor = prt24.Position
                        groundpart.CFrame = cf(gposfloor) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                        game:GetService("Debris"):AddItem(groundpart, 5)
                      end
                    end
                    ref2 = part(3, effects, 0, 1, BrickColor.new("Black"), "Reference", vt())
                    ref2.Anchored = true
                    ref2.CFrame = Thing[4] * cf(0, 0, -Thing[5])
                    game:GetService("Debris"):AddItem(ref2, 1)
                    Thing[1].CFrame = ref2.CFrame * cf(0, 5, 0)
                    so("178452221", ref2, 0.6, 0.6)
                  end
                end
              else
                Thing[1].Parent = nil
                table.remove(Effects, e)
              end
            end
            if Thing[2] ~= "DecreaseStat" and Thing[2] ~= "showDamage" and Thing[2] ~= "CloneEf" and Thing[2] ~= "Sound" and Thing[2] ~= "PunchEf" and Thing[2] ~= "Shockwave" then
              if Thing[1].Transparency <= 1 then
                if Thing[2] == "Block1" then
                  Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                  Mesh = Thing[7]
                  Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                  Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                else
                  if Thing[2] == "Block2" then
                    Thing[1].CFrame = Thing[1].CFrame
                    Mesh = Thing[7]
                    Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                    Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                  else
                    if Thing[2] == "Cylinder" then
                      Mesh = Thing[7]
                      Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                      Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                    else
                      if Thing[2] == "Cylinder2" then
                        Mesh = Thing[7]
                        if Thing[1].Transparency <= 0.5 then
                          Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                          Thing[8] = Thing[8] + 0.2
                          Thing[1].CFrame = Thing[1].CFrame * cf(0, 1, 0) * euler(0, Thing[8], 0)
                        else
                          Mesh.Scale = Mesh.Scale + vt(Thing[4], -Thing[5] / 1, Thing[6])
                          Thing[1].CFrame = Thing[1].CFrame * cf(0, -1, 0)
                        end
                        Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                      else
                        if Thing[2] == "Blood" then
                          Mesh = Thing[7]
                          Thing[1].CFrame = Thing[1].CFrame * cf(0, Thing[8], 0)
                          Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                          Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                        else
                          if Thing[2] == "Elec" then
                            Mesh = Thing[7]
                            Mesh.Scale = Mesh.Scale + vt(Thing[7], Thing[8], Thing[9])
                            Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                          else
                            if Thing[2] == "Disappear" then
                              Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            end
                          end
                        end
                      end
                    end
                  end
                end
              else
                Part.Parent = nil
                table.remove(Effects, e)
              end
            end
          end
        end
      end
    end
    do
      fenbarmana2:TweenSize((UDim2.new(0.4, 0, -4 * mana.Value / 100, 0)), nil, 1, 0.4, true)
      fenbarmana4.Text = "Mana(" .. mana.Value .. ")"
      fenbarhp2.BackgroundColor3 = Color3.new(Humanoid.Health / Humanoid.MaxHealth, 0, 0)
      fenbarhp2:TweenSize((UDim2.new(Humanoid.Health / Humanoid.MaxHealth, 0, 1, 0)), nil, 1, 0.4, true)
      fenbarhp3.Text = "(" .. math.floor(Humanoid.Health) .. ")"
      fenbarmove1b:TweenSize((UDim2.new(1 * cooldowns[1] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
      fenbarmove2b:TweenSize((UDim2.new(1 * cooldowns[2] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
      fenbarmove3b:TweenSize((UDim2.new(1 * cooldowns[3] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
      fenbarmove4b:TweenSize((UDim2.new(1 * cooldowns[4] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
      for _,c in pairs(Decrease:children()) do
        -- DECOMPILER ERROR at PC6830: Unhandled construct in 'MakeBoolean' P1

        if Humanoid.Health / 2 <= Humanoid.Health and c.Name == "DecreaseMvmt" and (c:findFirstChild("Grand")) == nil then
          c.Parent = nil
        end
        if c.Name == "DecreaseDef" and (c:findFirstChild("Grand")) == nil and 0 <= c.Value then
          c.Parent = nil
        end
        if (c:findFirstChild("Duration")) ~= nil then
          c.Duration.Value = c.Duration.Value - 1
          if c.Duration.Value <= 0 then
            c.Parent = nil
          end
        end
        if c.Name == "DecreaseAtk" then
          decreaseatk = decreaseatk + c.Value
        else
          if c.Name == "DecreaseDef" then
            decreasedef = decreasedef + c.Value
          else
            if c.Name == "DecreaseMvmt" then
              decreasemvmt = decreasemvmt + c.Value
            end
          end
        end
      end
      Atk.Value = 1 - (decreaseatk)
      if Atk.Value <= 0 then
        Atk.Value = 0
      end
      Def.Value = 1 - (decreasedef)
      if Def.Value <= 0 then
        Def.Value = 0.01
      end
      Mvmt.Value = 1 - (decreasemvmt)
      if Mvmt.Value <= 0 then
        Mvmt.Value = 0
      end
      decreaseatk = 0
      decreasedef = 0
      decreasemvmt = 0
      AtkVal = Atk.Value * 100
      AtkVal = math.floor(AtkVal)
      AtkVal = AtkVal / 100
      fenbardamage.Text = "Damage\n(" .. AtkVal .. ")"
      DefVal = Def.Value * 100
      DefVal = math.floor(DefVal)
      DefVal = DefVal / 100
      fenbardef.Text = "Defense\n(" .. DefVal .. ")"
      MvmtVal = Mvmt.Value * 100
      MvmtVal = math.floor(MvmtVal)
      MvmtVal = MvmtVal / 100
      if Rooted.Value == true then
        MvmtVal = 0
      end
      fenbarmove.Text = "Walkspeed\n(" .. MvmtVal .. ")"
      if StunT.Value <= Stun.Value then
        fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4, 0)), nil, 1, 0.4, true)
      else
        fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4 * Stun.Value / StunT.Value, 0)), nil, 1, 0.4, true)
      end
      fenbarstun3.Text = "Stun(" .. Stun.Value .. ")"
      if 100 <= mana.Value then
        mana.Value = 100
      else
        if mananum <= 12 then
          mananum = mananum + 1
        else
          mananum = 0
          mana.Value = mana.Value + 1
        end
      end
      for i = 1, #cooldowns do
        if cooldownmax <= cooldowns[i] then
          cooldowns[i] = cooldownmax
        else
          cooldowns[i] = cooldowns[i] + cooldownsadd[i]
        end
      end
      -- DECOMPILER ERROR at PC7059: LeaveBlock: unexpected jumping out DO_STMT

      -- DECOMPILER ERROR at PC7059: LeaveBlock: unexpected jumping out DO_STMT

    end
  end
end]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="HopperBin" referent="RBXD9B2681076DC4BFFB955F4B102E20D0A">
			<Properties>
				<bool name="Active">true</bool>
				<token name="BinType">0</token>
				<string name="Name">Tempus</string>
				<Content name="TextureId"><null></null></Content>
			</Properties>
			<Item class="LocalScript" referent="RBXEEB7386C71C2469DBB22D9428D755CA8">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Epoch</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[Player = game:GetService("Players").LocalPlayer
Character = Player.Character
PlayerGui = Player.PlayerGui
Backpack = Player.Backpack
Torso = Character.Torso
Head = Character.Head
Humanoid = Character.Humanoid
LeftArm = Character["Left Arm"]
LeftLeg = Character["Left Leg"]
RightArm = Character["Right Arm"]
RightLeg = Character["Right Leg"]
LS = Torso["Left Shoulder"]
LH = Torso["Left Hip"]
RS = Torso["Right Shoulder"]
RH = Torso["Right Hip"]
Neck = Torso.Neck
it = Instance.new
vt = Vector3.new
cf = CFrame.new
euler = CFrame.fromEulerAnglesXYZ
angles = CFrame.Angles
necko = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
necko2 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
LHC0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
LHC1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
RHC0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RHC1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RootPart = Character.HumanoidRootPart
RootJoint = RootPart.RootJoint
RootCF = euler(-1.57, 0, 3.14)
attack = false
attackdebounce = false
MMouse = Player:GetMouse()
combo = 0
local hitfloor, posfloor = nil, nil
local idle = 0
local Anim = "Idle"
local graviting = false
local distort = 100
local doanim = true
local Effects = {}
local Weapon = {}
local Welds = {}
local decreaseatk = 0
local decreasedef = 0
local decreasemvmt = 0
local doingcomb = false
local distorcharge = false
local move4do = false
local move1 = "(Z)\nClock"
local move2 = "(X)\nGravity Impact"
local move3 = "(C)\nTime Blink"
local move4 = "(V)\nTemporal Waltz"
local cooldowns = {}
local cooldown1 = 0
table.insert(cooldowns, cooldown1)
local cooldown2 = 0
table.insert(cooldowns, cooldown2)
local cooldown3 = 0
table.insert(cooldowns, cooldown3)
local cooldown4 = 0
table.insert(cooldowns, cooldown4)
local cooldownsadd = {}
local cooldownadd1 = 0.2
table.insert(cooldownsadd, cooldownadd1)
local cooldownadd2 = 0.25
table.insert(cooldownsadd, cooldownadd2)
local cooldownadd3 = 0.4
table.insert(cooldownsadd, cooldownadd3)
local cooldownadd4 = 0.1
table.insert(cooldownsadd, cooldownadd4)
local cooldownmax = 100
player = nil
RSH = nil
RW = Instance.new("Motor")
LW = Instance.new("Motor")
RW.Name = "Right Shoulder"
LW.Name = "Left Shoulder"
LH = Torso["Left Hip"]
RH = Torso["Right Hip"]
TorsoColor = Torso.BrickColor
TorsoRed = TorsoColor.Color.r
TorsoGreen = TorsoColor.Color.g
NewCol = BrickColor.new("Dark green").Color
NewCol2 = Color3.new(0, 0.86274509803922, 0.86274509803922)
print(BrickColor.new(NewCol2))
local mdec = Instance.new("NumberValue", Decrease)
mdec.Name = "DecreaseDef"
mdec.Value = 0.4
local mdec2 = Instance.new("NumberValue", Decrease)
mdec2.Name = "DecreaseMvmt"
mdec2.Value = 0.1
local Animate = Humanoid.Animator
local canjump = true
removeControl = function()
  canjump = false
end
resumeControl = function()
  canjump = true
end
Player.Character.Humanoid.Changed:connect(function()
  if canjump == false then
    Player.Character.Humanoid.Jump = false
  end
end)
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

frame = 1 / 40
tf = 0
allowframeloss = true
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
    tf = tf + s
    if tf >= frame then
        if allowframeloss then
            script.Heartbeat:Fire()
            lastframe = tick()
        else
            for i = 1, math.floor(tf / frame) do
                script.Heartbeat:Fire()
            end
            lastframe = tick()
        end
        if tossremainder then
            tf = 0
        else
            tf = tf - frame * math.floor(tf / frame)
        end
    end
end)

function swait(num)
    if num == 0 or num == nil then
        ArtificialHB.Event:wait()
    else
        for i = 0, num do
            ArtificialHB.Event:wait()
        end
    end
end
if Character:findFirstChild("Kam\'s Hand", true) ~= nil then
  Character:findFirstChild("Kam\'s Hand", true).Parent = nil
end
if Player.PlayerGui:findFirstChild("WeaponGUI", true) ~= nil then
  Player.PlayerGui:findFirstChild("WeaponGUI", true).Parent = nil
end
if Character:findFirstChild("Stats", true) ~= nil then
  Character:findFirstChild("Stats", true).Parent = nil
end
local Stats = Instance.new("BoolValue")
Stats.Name = "Stats"
Stats.Parent = Character
local Atk = Instance.new("NumberValue")
Atk.Name = "Damage"
Atk.Parent = Stats
Atk.Value = 131
local Def = Instance.new("NumberValue")
Def.Name = "Defense"
Def.Parent = Stats
Def.Value = 13
local Mvmt = Instance.new("NumberValue")
Mvmt.Name = "Movement"
Mvmt.Parent = Stats
Mvmt.Value = 1
local Block = Instance.new("BoolValue")
Block.Name = "Block"
Block.Parent = Stats
Block.Value = false
local Stun = Instance.new("NumberValue")
Stun.Name = "Stun"
Stun.Parent = Stats
Stun.Value = 0
local StunT = Instance.new("NumberValue")
StunT.Name = "StunThreshold"
StunT.Parent = Stats
StunT.Value = 100
local Rooted = Instance.new("BoolValue")
Rooted.Name = "Rooted"
Rooted.Parent = Stats
Rooted.Value = false
local Stunned = Instance.new("BoolValue")
Stunned.Name = "Stunned"
Stunned.Parent = Stats
Stunned.Value = false
local Stagger = Instance.new("BoolValue")
Stagger.Name = "Stagger"
Stagger.Parent = Stats
Stagger.Value = false
local StaggerHit = Instance.new("BoolValue")
StaggerHit.Name = "StaggerHit"
StaggerHit.Parent = Stats
StaggerHit.Value = false
local RecentEnemy = Instance.new("ObjectValue")
RecentEnemy.Name = "RecentEnemy"
RecentEnemy.Parent = Stats
RecentEnemy.Value = nil
local Decrease = Instance.new("BoolValue")
Decrease.Name = "Decrease"
Decrease.Parent = Stats
Decrease.Value = false
local mana = Instance.new("NumberValue")
mana.Name = "Mana"
mana.Parent = Stats
mana.Value = 0
passive1 = Instance.new("NumberValue", nil)
passive1.Name = "DecreaseAtk"
passive1.Value = -0.3
passive2 = Instance.new("NumberValue", nil)
passive2.Name = "DecreaseDef"
passive2.Value = 0.1
NoOutline = function(Part)
  Part.TopSurface = 10
end
part = function(formfactor, parent, reflectance, transparency, brickcolor, name, size)
  local fp = it("Part")
  fp.formFactor = formfactor
  fp.Parent = parent
  fp.Reflectance = reflectance
  fp.Transparency = transparency
  fp.CanCollide = false
  fp.Locked = true
  fp.BrickColor = brickcolor
  fp.Name = name
  fp.Size = size
  fp.Position = Torso.Position
  NoOutline(fp)
  fp.Material = "SmoothPlastic"
  fp:BreakJoints()
  return fp
end
mesh = function(Mesh, part, meshtype, meshid, offset, scale)
  local mesh = it(Mesh)
  mesh.Parent = part
  if Mesh == "SpecialMesh" then
    mesh.MeshType = meshtype
    if meshid ~= "nil" then
      mesh.MeshId = "http://www.roblox.com/asset/?id=" .. meshid
    end
  end
  mesh.Offset = offset
  mesh.Scale = scale
  return mesh
end
weld = function(parent, part0, part1, c0)
  local weld = it("Motor")
  weld.Parent = parent
  weld.Part0 = part0
  weld.Part1 = part1
  weld.C0 = c0
  return weld
end
gui = function(GuiType, parent, text, backtrans, backcol, pos, size)
  local gui = it(GuiType)
  gui.Parent = parent
  gui.Text = text
  gui.BackgroundTransparency = backtrans
  gui.BackgroundColor3 = backcol
  gui.SizeConstraint = "RelativeXY"
  gui.TextXAlignment = "Center"
  gui.TextYAlignment = "Center"
  gui.Position = pos
  gui.Size = size
  gui.Font = "SourceSans"
  gui.FontSize = "Size14"
  gui.TextWrapped = false
  gui.TextStrokeTransparency = 0
  gui.TextColor = BrickColor.new("White")
  return gui
end
local Color1 = Torso.BrickColor
local fengui = it("GuiMain")
fengui.Parent = Player.PlayerGui
fengui.Name = "WeaponGUI"
local fenframe = it("Frame")
fenframe.Parent = fengui
fenframe.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe.BackgroundTransparency = 1
fenframe.BorderColor3 = Color3.new(17, 17, 17)
fenframe.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe.Position = UDim2.new(0.95, 0, 0.7, 0)
local fenframe2 = it("Frame")
fenframe2.Parent = fengui
fenframe2.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe2.BackgroundTransparency = 1
fenframe2.BorderColor3 = Color3.new(17, 17, 17)
fenframe2.Size = UDim2.new(0.2, 0, 0.1, 0)
fenframe2.Position = UDim2.new(0.4, 0, 0.85, 0)
local fenframe3 = it("Frame")
fenframe3.Parent = fengui
fenframe3.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe3.BackgroundTransparency = 1
fenframe3.BorderColor3 = Color3.new(17, 17, 17)
fenframe3.Size = UDim2.new(0.2, 0, 0.2, 0)
fenframe3.Position = UDim2.new(0.8, 0, 0.8, 0)
local fenframe4 = it("Frame")
fenframe4.Parent = fengui
fenframe4.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe4.BackgroundTransparency = 1
fenframe4.BorderColor3 = Color3.new(17, 17, 17)
fenframe4.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe4.Position = UDim2.new(0, 0, 0.7, 0)
local pressedf = false
local fenframe5 = it("Frame")
fenframe5.Parent = fengui
fenframe5.BackgroundColor3 = Color3.new(0, 0, 0)
fenframe5.BackgroundTransparency = 1
fenframe5.BorderColor3 = Color3.new(0, 0, 0)
fenframe5.Size = UDim2.new(1, 0, 1, 0)
fenframe5.Position = UDim2.new(0, 0, 0, 0)
fenframe5.ZIndex = 2
local tellbar = gui("TextLabel", fenframe5, "-Fixed by AureIion_sol =D (+)\n-Temporal Image changed to Distortion Charge where Tempus uses up all Distortion to, for a couple of seconds, gains increased damage and enemies around Tempus gets decreased movement (+)\n-All abilities can target an enemy for Time Blink (+)\n-Clock changed such that Tempus throws Kam\'s Hand forward first. Clock no longer buffs allies, and Tempus cannot move during the ability (+/-)\n-Graviga changed to Gravity Impact where Tempus stabs Kam\'s Hand to the ground to create a gravity wave to pull enemies towards Tempus\' self (+/-)\n-Time Crack changed to Time Blink where Tempus blinks towards the target, then hits normally with Time Crack (+/-)\n-Temporal Stun changed to Temporal Waltz where Tempus teleports to a random area near the targeted enemy, then do a Time Crack slash with increased damage and debuffs damage. Tempus does this 5 times (+/-)\n-Distortion charges up slower (-)\n-Abilities no longer uses Distortion as a substitute for mana (-)", 1, Color3.new(0, 0, 0), UDim2.new(0.25, 0, 0.25, 0), UDim2.new(0.5, 0, 0.5, 0))
tellbar.Font = "Arial"
tellbar.TextScaled = true
tellbar.TextTransparency = 1
tellbar.TextStrokeTransparency = 1
tellbar.ZIndex = 2
local fnumb = 0
local fenbarmana1 = gui("TextLabel", fenframe, "", 0, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarmana2 = gui("TextLabel", fenframe, "", 0, BrickColor.new(NewCol2).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarmana4 = gui("TextLabel", fenframe, "Wakfu(" .. mana.Value .. ")", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbarblock1 = gui("TextLabel", fenframe, "", 0, Color3.new(0, 0, 0), UDim2.new(-0.7, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarblock2 = gui("TextLabel", fenframe, "", 0, BrickColor.new("White").Color, UDim2.new(-0.7, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarblock3 = gui("TextLabel", fenframe, "Distortion(" .. distort .. ")", 1, Color3.new(0, 0, 0), UDim2.new(-0.7, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbardamage = gui("TextLabel", fenframe2, "Damage", 0.55, Color3.new(0.6078431372549, 0, 0), UDim2.new(-0.23, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbardef = gui("TextLabel", fenframe2, "Defense", 0.55, Color3.new(0, 0, 0.6078431372549), UDim2.new(-0.46, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarmove = gui("TextLabel", fenframe2, "Walkspeed", 0.55, Color3.new(0, 0.6078431372549, 0), UDim2.new(1.03, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarhp1 = gui("TextLabel", fenframe2, "", 0, Color3.new(0, 0, 0), UDim2.new(-0.46, 0, 1, 0), UDim2.new(1.92, 0, 0.4, 0))
local fenbarhp2 = gui("TextLabel", fenbarhp1, "", 0, Color3.new(1, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarhp3 = gui("TextLabel", fenbarhp1, "(100)", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
local fenbarstun1 = gui("TextLabel", fenframe4, "", 0, Color3.new(0, 0, 0), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarstun2 = gui("TextLabel", fenframe4, "", 0, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarstun3 = gui("TextLabel", fenframe4, "Stun(" .. Stun.Value .. ")", 1, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbarmove1 = gui("TextButton", fenframe3, move1, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove1.ZIndex = 2
local fenbarmove1b = gui("TextLabel", fenbarmove1, "", 0.55, BrickColor.new(NewCol2).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove2 = gui("TextButton", fenframe3, move2, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove2.ZIndex = 2
local fenbarmove2b = gui("TextLabel", fenbarmove2, "", 0.55, BrickColor.new("Navy blue").Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove3 = gui("TextButton", fenframe3, move3, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove3.ZIndex = 2
local fenbarmove3b = gui("TextLabel", fenbarmove3, "", 0.55, BrickColor.new(NewCol2).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove4 = gui("TextButton", fenframe3, move4, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove4.ZIndex = 2
local fenbarmove4b = gui("TextLabel", fenbarmove4, "", 0.55, BrickColor.new(NewCol2).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local modelzorz = Instance.new("Model")
modelzorz.Parent = Character
modelzorz.Name = "Kam\'s Hand"
local handle = part(3, modelzorz, 0, 1, BrickColor.new(NewCol), "Handle", vt())
local prt1 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part01", vt())
local prt2 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part02", vt())
local prt4 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part04", vt())
local prt5 = part(3, modelzorz, 0.5, 0, BrickColor.new("Medium blue"), "Part05", vt())
local prt6 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part06", vt())
local prt11 = part(3, modelzorz, 0.5, 0, BrickColor.new("Medium blue"), "Part11", vt())
local prt12 = part(3, modelzorz, 0.5, 0, BrickColor.new("Medium blue"), "Part12", vt())
local prt13 = part(3, modelzorz, 0.5, 0, BrickColor.new("Medium blue"), "Part13", vt())
local prt14 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part14", vt())
local prt17 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part17", vt())
msh1 = mesh("CylinderMesh", prt1, "", "", vt(0, 0, 0), vt(1, 10, 1))
msh2 = mesh("SpecialMesh", prt2, "FileMesh", "3270017", vt(0, 0, 0), vt(0.6, 0.6, 2))
msh4 = mesh("SpecialMesh", prt4, "FileMesh", "1778999", vt(0, 0, 0), vt(0.2, 0.3, 0.2))
msh5 = mesh("SpecialMesh", prt5, "FileMesh", "1778999", vt(0, 0, 0), vt(0.3, 0.2, 0.5))
msh6 = mesh("BlockMesh", prt6, "", "", vt(0, 0, 0), vt(2, 1, 3))
msh11 = mesh("SpecialMesh", prt11, "Torso", "nil", vt(0, 0, 0), vt(2.6, 1, 1))
msh12 = mesh("BlockMesh", prt12, "", "", vt(0, 0, 0), vt(2, 25, 0.5))
msh13 = mesh("SpecialMesh", prt13, "Torso", "nil", vt(0, 0, 0), vt(2.3, 1, 0.5))
msh14 = mesh("BlockMesh", prt14, "", "", vt(0, 0, 0), vt(1, 2, 1))
msh17 = mesh("SpecialMesh", prt17, "FileMesh", "1778999", vt(0, 0, 0), vt(0.4, 0.4, 0.1))
local handlewld = weld(handle, handle, Torso, euler(-2.5, 1.57, 0) * cf(-2, -2.5, -0.5))
local wld1 = weld(prt1, prt1, handle, cf(0, 0, 0) * euler(0, 0, 0))
local wld2 = weld(prt1, prt2, prt1, euler(0, 1.57, 0) * cf(0, 1.3, 0))
local wld4 = weld(prt1, prt4, prt2, euler(0, 0, 3.14) * cf(0, 0.55, 0))
local wld5 = weld(prt1, prt5, prt1, euler(0, 0, 3.14) * cf(0, -1, 0))
local wld6 = weld(prt1, prt6, prt5, euler(0, 0, 3.14) * cf(0, 0.25, 0))
local wld11 = weld(prt1, prt11, prt6, euler(0, 1.57, 0) * cf(0, -0.2, 0))
local wld12 = weld(prt1, prt12, prt11, euler(0, 0, 0) * cf(0, -2.6, 0))
local wld13 = weld(prt1, prt13, prt12, euler(0, 0, 3.14) * cf(0, -2.6, 0))
local wld14 = weld(prt1, prt14, prt13, euler(0, 0, 0) * cf(0, 0.3, 0))
local wld17 = weld(prt1, prt17, prt14, euler(0, 0, 3.14) * cf(0, 0.53, 0))
for i = 0.785, 6.28, 0.785 do
  if i ~= 6.28 and i ~= 3.14 then
    local prt3 = part(3, modelzorz, 0.5, 0, BrickColor.new("Medium blue"), "Part03", vt())
    msh3 = mesh("BlockMesh", prt3, "", "", vt(0, 0, 0), vt(1, 0.8, 1))
    local wld3 = weld(prt1, prt3, prt2, cf(0, 0.4, 0) * euler(0, 0, i))
  end
end
oldprt = prt6
num = 0.2
ulnum = 0.4
num2 = 1
num3 = 2
for i = 1, 3 do
  local prt7 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part07", vt())
  msh7 = mesh("BlockMesh", prt7, "", "", vt(0, 0, 0), vt(num3, num2, 1.5))
  local wld7 = weld(prt1, prt7, oldprt, euler(num, 0, 0) * cf(0, num / 10, ulnum))
  local prt8 = part(3, modelzorz, 0.5, 0, BrickColor.new("Medium blue"), "Part08", vt())
  msh8 = mesh("BlockMesh", prt8, "", "", vt(0, 0, 0), vt(num3 / 2, 1, 1))
  local wld8 = weld(prt1, prt8, prt7, euler(0, 0, 0) * cf(0, -num2 * 0.1 - 0.1, 0))
  oldprt = prt7
  num = num + 0.05
  ulnum = 0.25
  num2 = num2 - 0.2
  num3 = num3 - 0.5
end
oldprt = prt6
num = 0.2
ulnum = -0.4
num2 = 1
num3 = 2
for i = 1, 3 do
  local prt9 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part09", vt())
  msh9 = mesh("BlockMesh", prt9, "", "", vt(0, 0, 0), vt(num3, num2, 1.5))
  local wld9 = weld(prt1, prt9, oldprt, euler(-num, 0, 0) * cf(0, num / 10, ulnum))
  local prt10 = part(3, modelzorz, 0.5, 0, BrickColor.new("Medium blue"), "Part08", vt())
  msh10 = mesh("BlockMesh", prt10, "", "", vt(0, 0, 0), vt(num3 / 2, 1, 1))
  local wld10 = weld(prt1, prt10, prt9, euler(0, 0, 0) * cf(0, -num2 * 0.1 - 0.1, 0))
  oldprt = prt9
  num = num + 0.05
  ulnum = -0.25
  num2 = num2 - 0.2
  num3 = num3 - 0.5
end
eul1 = 0.785
eul2 = 2.355
eul3 = 0.785
for i = 0.2, -0.2, -0.4 do
  local prt15 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part15", vt())
  msh15 = mesh("SpecialMesh", prt15, "FileMesh", "3270017", vt(0, 0, 0), vt(0.5, 0.5, 0.5))
  local wld15 = weld(prt1, prt15, prt14, euler(0, 0, 0) * cf(i, 0, 0))
  for i = eul1, eul2, eul3 do
    local prt16 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part03", vt())
    msh16 = mesh("BlockMesh", prt16, "", "", vt(0, 0, 0), vt(0.5, 0.8, 0.3))
    local wld16 = weld(prt1, prt16, prt15, cf(0, 0.3, 0) * euler(0, 0, i))
  end
  eul1 = -0.785
  eul2 = -2.355
  eul3 = -0.785
end
for _,c in pairs(modelzorz:children()) do
  table.insert(Weapon, c)
end
for _,c in pairs(prt1:children()) do
  if c.className == "Motor" then
    table.insert(Welds, c)
  end
end
local hitbox = part(3, modelzorz, 0, 1, BrickColor.new("Black"), "Hitbox2", vt())
hitbox.Anchored = false
local hbwld = weld(hitbox, hitbox, RootPart, euler(0, 0, 0) * cf(0, 0, 0))
local hitbox2 = part(3, nil, 0, 1, BrickColor.new("Black"), "Hitbox", vt(1, 1, 1))
hitbox2.Anchored = true
local hitboxCF = cf(0, 0, 0)
hboxpos = Instance.new("BodyPosition", nil)
hboxpos.P = 2000
hboxpos.D = 100
hboxpos.maxForce = Vector3.new(545000, 545000, 545000)
hitboxweld = function()
  hbwld.Parent = modelzorz
  hbwld.Part0 = hitbox
  hbwld.Part1 = prt12
end
local Image = it("Model")
Image.Name = "Image"
local CloneJoints = {}
ImageRoot = RootPart:Clone()
table.insert(CloneJoints, ImageRoot)
ImageTors = Torso:Clone()
table.insert(CloneJoints, ImageTors)
ImageHead = Head:Clone()
table.insert(CloneJoints, ImageHead)
ImageLA = LeftArm:Clone()
table.insert(CloneJoints, ImageLA)
ImageRA = RightArm:Clone()
table.insert(CloneJoints, ImageRA)
ImageLG = LeftLeg:Clone()
table.insert(CloneJoints, ImageLG)
ImageRG = RightLeg:Clone()
table.insert(CloneJoints, ImageRG)
RootJointClone = cf(0, 0, 0)
NeckClone = cf(0, 0, 0)
RWClone = cf(0, 0, 0)
LWClone = cf(0, 0, 0)
RHClone = cf(0, 0, 0)
LHClone = cf(0, 0, 0)
for i = 1, #CloneJoints do
  CloneJoints[i].Parent = Image
  if CloneJoints[i] ~= ImageRoot then
    CloneJoints[i].Transparency = 0.5
  end
  CloneJoints[i].Anchored = true
  CloneJoints[i].CanCollide = false
  CloneJoints[i].BrickColor = BrickColor.new(NewCol2)
  NoOutline(CloneJoints[i])
  for _,c in pairs(CloneJoints[i]:children()) do
    if c.className ~= "SpecialMesh" then
      c.Parent = nil
    end
  end
end
Bin = script.Parent
local bodvel = Instance.new("BodyVelocity")
local bg = Instance.new("BodyGyro")
so = function(id, par, vol, pit)
  local sou = Instance.new("Sound", par or workspace)
  sou.Volume = vol
  sou.Pitch = pit or 1
  sou.SoundId = "http://www.roblox.com/asset/?id=" .. id
  coroutine.resume(coroutine.create(function(Sound)
    swait()
    Sound:play()
  end), sou)
  game:GetService("Debris"):AddItem(sou, 6)
end
function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

hideanim = function()
  equipped = false
  for i = 0, 1, 0.1 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, -0.5), 0.3)
    wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 1.57), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1.57), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0), 0.3)
  end
  so("206083107", handle, 1, 1)
  handlewld.Part1 = Torso
  handlewld.C0 = euler(1.57, 0, 1.57) * cf(-3, 0, 0)
  wld1.C0 = euler(0, 0, 0) * cf(0, 0, 0)
  mdec2.Parent = nil
  mdec.Parent = Decrease
  for i = 0, 1, 0.1 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(-2.5, 1.57, 0) * cf(-2, -2.5, -0.5), 0.5)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0), 0.3)
  end
  handlewld.Part1 = Torso
  handlewld.C0 = euler(-2.5, 1.57, 0) * cf(-2, -2.5, -0.5)
  wld1.C0 = euler(0, 0, 0) * cf(0, 0, 0)
end
mdec.Parent = Decrease
equipanim = function()
  equipped = true
  mdec.Parent = nil
  for i = 0, 1, 0.1 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 1.57), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1.57), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
  end
  local dec = Instance.new("NumberValue", Decrease)
  dec.Name = "DecreaseMvmt"
  dec.Value = 10
  handlewld.Part1 = RootPart
  n = 2
  so("206083107", handle, 1, 1)
  for i = 0, 1, 0.1 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(3.14, 1.57, 0) * cf(0, -2.5, 2), 0.3)
    wld1.C0 = euler(0, 0, 6.28 * i * n) * cf(0, 0, 0)
    n = n - 0.1
  end
  for i = 0, 1, 0.1 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.8) * euler(-0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.8), 0.3)
    RW.C0 = clerp(RW.C0, cf(1, 0.8, -0.5) * euler(2.5, 0, 0.4), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.2), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
  end
  handlewld.Part1 = RightArm
  handlewld.C0 = euler(1.57, 0, 0) * cf(0, 1.2, 0.5)
  wld1.C0 = euler(0, 1.57, 0) * euler(3.8, 0, 0) * euler(0, 0, 0) * cf(0, 0, 0)
  dec.Parent = nil
  mdec2.Parent = Decrease
end
StaggerAnim = function()
  attack = true
  removeControl()
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.35 do
    swait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -40
    end
    handlewld.Part1 = RightArm
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 0.9, 0), 0.2)
    wld1.C0 = clerp(wld1.C0, euler(0.1, 0, 0) * cf(0, 0.5, 0), 0.2)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, -0.4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.7) * euler(0, -0.7, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  for i = 0, 1, 0.2 do
    swait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -40
    end
    handlewld.Part1 = RightArm
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 0.9, 0), 0.2)
    wld1.C0 = clerp(wld1.C0, euler(0.1, 0, 0) * cf(0, 0.5, 0), 0.2)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(-0.5, 0, -0.4), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.7) * euler(0, -0.7, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.5), 0.4)
  end
  for i = 0, 1, 0.1 do
    swait()
    handlewld.Part1 = RightArm
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 0.9, 0), 0.2)
    wld1.C0 = clerp(wld1.C0, euler(0.1, 0, 0) * cf(0, 0.5, 0), 0.2)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(0.5, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.8) * euler(-0.2, 0, -0.4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.3, 0, 0.4) * euler(0, -0.4, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.3, 0, -0.2) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 1.2), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, 0, -1) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  for i = 1, 40 do
    swait()
    if StunT.Value <= Stun.Value then
      break
    end
  end
  do
    resumeControl()
    combo = 0
    attack = false
  end
end
StaggerHitt = function()
  attack = true
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.1 do
    swait()
    handlewld.Part1 = RightArm
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 0.9, 0), 0.2)
    wld1.C0 = clerp(wld1.C0, euler(0.1, 0, 0) * cf(0, 0.5, 0), 0.2)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.7) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, -0.6), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.9) * euler(0, -0.7, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, -0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  attack = false
end
StunAnim = function()
  attack = true
  removeControl()
  Stunned.Value = true
  showDamage(Character, "Stunned", "Interrupt")
  local dec = Instance.new("NumberValue", Decrease)
  dec.Name = "DecreaseMvmt"
  dec.Value = 10
  for i = 0, 1, 0.3 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.2, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1, 0, 0.4) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.3), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, 0), 0.25)
  end
  for i = 0, 1, 0.3 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0.8, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1.2, 0, 0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(0.1, 0, 0.7), 0.25)
  end
  for i = 0, 1, 0.3 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -1), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1.57, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, -0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.1, 0, 0.3), 0.25)
  end
  local gairost = Instance.new("BodyGyro")
  gairost.Parent = RootPart
  gairost.maxTorque = Vector3.new(400000, 0, 400000) * math.huge
  gairost.P = 20000
  gairost.cframe = cf(0, 0, 0)
  for i = 0, 1, 0.1 do
    swait()
    if hitfloor ~= nil then
      Torso.Velocity = vt(0, 0, 0)
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2.5) * euler(1.57, 0, -3.14), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1.5) * euler(0.2, 0, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.5, 0, -1.57) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 0), 0.3)
  end
  for i = 1, 70 do
    swait()
    gairost.cframe = RootPart.CFrame
    if hitfloor ~= nil then
      Torso.Velocity = vt(0, 0, 0)
    end
  end
  for i = 0, 1, 0.2 do
    swait()
    Stun.Value = 0
    gairost.cframe = RootPart.CFrame
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1, 0, -4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1) * euler(0.2, -1, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, 0.2) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, -1) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 1), 0.3)
  end
  resumeControl()
  gairost.Parent = nil
  dec.Parent = nil
  Stun.Value = 0
  combo = 0
  Stunned.Value = false
  attack = false
  for i = 1, 10 do
    swait()
    Stun.Value = 0
  end
end
attackone = function()
  attack = true
  for i = 0, 1, 0.15 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 0.6, -0.3), 0.4)
    wld1.C0 = clerp(wld1.C0, euler(1, 0, 0) * cf(0, 0, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.2) * euler(0.1, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -1.2), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(2.5, 0, 1.2) * euler(0, -0.6, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.4, 0, -1.3), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.7, -1, -0.5) * euler(0, 1.57, 0) * euler(-0.1, 1.2, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.7, -1, 0.5) * euler(0, -1.57, 0) * euler(0, 1.2, 0.1), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC219: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC219: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("199145887", prt12, 1, 1.2)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(1, 7, 0.5)
  hitboxCF = prt12.CFrame
  hitbox.CFrame = hitboxCF
  blcf = nil
  scfr = nil
  for i = 0, 1, 0.1 do
    swait()
    hitboxCF = prt12.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 6, 4, 8, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(3, 6)), nil, true)
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 0.6, -0.3), 0.4)
    wld1.C0 = clerp(wld1.C0, euler(1, 0, 0) * cf(0, 0, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.6) * euler(0.2, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1.4), 0.4)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(0.5, 0, -1) * euler(0, -0.6, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.2), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.3) * euler(0, 1.57, 0) * euler(0, -1, -0.1), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.8, -1, -0.3) * euler(0, -1.57, 0) * euler(0, -1, 0), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC496: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC496: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
attacktwo = function()
  attack = true
  handlewld.Part1 = Torso
  handlewld.C0 = euler(1.57, 0, 1.57) * cf(-3, 1, 0)
  wld1.C1 = euler(0, 0, 0)
  for i = 0, 1, 0.15 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 1.57) * cf(0, -1, 0), 0.3)
    wld1.C0 = clerp(wld1.C0, euler(1, 0, 0) * cf(0, -7, 0) * euler(1, 0, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.4) * euler(0, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1.4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -1) * euler(0, 1.4, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.2), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.3) * euler(0, 1.57, 0) * euler(0, -1, -0.1), 0.2)
    LH.C0 = clerp(LH.C0, cf(-0.8, -1, -0.3) * euler(0, -1.57, 0) * euler(0, -1, 0), 0.2)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC248: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC248: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("199145841", prt12, 1, 0.8)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(1, 7, 0.5)
  hitboxCF = prt12.CFrame
  hitbox.CFrame = hitboxCF
  blcf = nil
  scfr = nil
  num = 0
  for i = 0, 1, 0.1 do
    swait()
    num = num + 0.6
    hitboxCF = prt12.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 6, 4, 8, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(3, 6)), nil, true)
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 1.57) * cf(0, -1, 0), 0.3)
    wld1.C0 = euler(1, 0, 0) * cf(0, -4, 0) * euler(1 - num, 0, 0)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.6) * euler(0.2, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -1.2), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.2) * euler(0, 1.7, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.2, 0, -1.3), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.7, -1, -0.5) * euler(0, 1.57, 0) * euler(-0.1, 1.2, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.7, -1, 0.5) * euler(0, -1.57, 0) * euler(0, 1.2, 0.1), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC532: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC532: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  handlewld.Part1 = RightArm
  handlewld.C0 = euler(1.57, 0, 1.57) * cf(0, -1, 0)
  wld1.C0 = euler(-1, 1.57, 0) * cf(0, -4, 0) * euler(0, 0, 0)
  attack = false
end
attackthree = function()
  attack = true
  handlewld.Part1 = Torso
  handlewld.C0 = euler(1.57, 0, 1.57) * cf(-3, 1, 0)
  wld1.C1 = euler(0, 0, 0)
  n = 7
  for i = 0, 1, 0.1 do
    swait()
    n = n + 1
    if n >= 7 then
      so("199145146", prt12, 1, 1.2)
      n = 0
    end
    handlewld.C0 = clerp(handlewld.C0, euler(0, 1.57, 1.3) * euler(0.2, 0, 0) * cf(0, -1, 3), 0.3)
    wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 3, 0), 0.3)
    wld1.C1 = wld1.C1 * euler(0.6, 0, 0)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.2) * euler(-0.05, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1.4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -1) * euler(0, 1.4, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.7, 0, 0.4), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.3) * euler(0, 1.57, 0) * euler(0, -1.4, -0.1), 0.2)
    LH.C0 = clerp(LH.C0, cf(-1, -0.9, -0.2) * euler(0, -1.57, 0) * euler(0, -0.5, 0) * euler(-0.2, 0, 0), 0.2)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC280: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC280: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  wld1.C1 = euler(0, 0, 0)
  so("199145913", prt12, 1, 1.4)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(1, 7, 0.5)
  hitboxCF = prt12.CFrame
  hitbox.CFrame = hitboxCF
  blcf = nil
  scfr = nil
  for i = 0, 1, 0.1 do
    swait()
    hitboxCF = prt12.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 6, 4, 8, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(3, 6)), nil, true)
    handlewld.C0 = clerp(handlewld.C0, euler(1.7, -1, 0) * euler(0, 0, 0) * cf(7, -0.5, 1.5), 0.5)
    wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 3, 0), 0.5)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.2) * euler(-0.05, 0, 0), 0.5)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -1.2), 0.5)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.2, 0, 0.5) * euler(0, 0, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.6, 0, -1), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, -0.4) * euler(0, 1.57, 0) * euler(0, 1.2, 0), 0.2)
    LH.C0 = clerp(LH.C0, cf(-0.6, -1, 0.4) * euler(0, -1.57, 0) * euler(0, 1.2, -0.1) * euler(0, 0, 0), 0.2)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC576: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC576: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  handlewld.Part1 = RightArm
  attack = false
end
attackfour = function()
  attack = true
  for i = 0, 1, 0.15 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, -0.3), 0.4)
    wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.2) * euler(0.1, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -1.2), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(2.5, 0, 0.8) * euler(0, -0.6, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.4, 0, -1.3), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.7, -1, -0.5) * euler(0, 1.57, 0) * euler(-0.1, 1.2, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.7, -1, 0.5) * euler(0, -1.57, 0) * euler(0, 1.2, 0.1), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC219: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC219: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  handlewld.Part1 = RootPart
  handlewld.C0 = euler(-0.7, 0, -0.6) * cf(-1, -3, -4)
  wld1.C0 = euler(0, 0, 0) * cf(0, 3, 0)
  wld1.C1 = euler(0, 0, 0)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(1, 7, 0.5)
  hitboxCF = prt12.CFrame
  hitbox.CFrame = hitboxCF
  blcf = nil
  scfr = nil
  n = 4
  mov = 0
  for i = 0, 1, 0.1 do
    swait()
    mov = mov + 3
    n = n + 1
    if n >= 4 then
      so("199145146", prt12, 1, 1.4)
      n = 0
    end
    hitboxCF = prt12.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 6, 5, 8, 0, "Normal", RootPart, 0.5, 1, (math.random(3, 6)), nil, true)
    handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, -1, mov), 0.4)
    wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 1, 0), 0.4)
    wld1.C1 = wld1.C1 * euler(-0.6, 0, 0)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57) * euler(0.1, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1.57), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.57) * euler(0, 0, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.2, 0, -1), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.3) * euler(0, 1.57, 0) * euler(0, -1.57, -0.1), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.3) * euler(0, -1.57, 0) * euler(0, -1.57, 0.2), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC553: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC553: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  handlewld.Part1 = RightArm
  wld1.C1 = euler(0, 0, 0)
  attack = false
end
DistortionCharge = function()
  if distort == 100 then
    distort = 0
    distorcharge = true
    table.insert(Effects, {nil, "DisCharge", 400, 0})
  end
end
do1 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[1] and mana.Value >= 20 then
    attack = true
    doingcomb = true
    cooldowns[1] = 0
    for i = 0, 1, 0.15 do
      swait()
      handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, -0.3), 0.4)
      wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0, 0), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.2) * euler(0.1, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -1.2), 0.4)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(2.5, 0, 0.8) * euler(0, -0.6, 0), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.4, 0, -1.3), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(0.7, -1, -0.5) * euler(0, 1.57, 0) * euler(-0.1, 1.2, 0), 0.4)
      LH.C0 = clerp(LH.C0, cf(-0.7, -1, 0.5) * euler(0, -1.57, 0) * euler(0, 1.2, 0.1), 0.4)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
        end
      end
    end
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = 10
    handlewld.Part1 = RootPart
    handlewld.C0 = euler(-0.7, 0, -0.6) * cf(-1, -3, -4)
    wld1.C0 = euler(0, 0, 0) * cf(0, 3, 0)
    wld1.C1 = euler(0, 0, 0)
    so("199145146", prt12, 1, 0.8)
    mov = 0
    for i = 0, 1, 0.15 do
      swait()
      mov = mov + 5
      handlewld.C0 = clerp(handlewld.C0, euler(0, 0, 0) * cf(0, -1, mov), 0.4)
      wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 3, 0), 0.4)
      wld1.C1 = wld1.C1 * euler(-0.6, 0, 0)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57) * euler(0.1, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1.57), 0.4)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.57) * euler(0, 0, 0), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.2, 0, -1), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.3) * euler(0, 1.57, 0) * euler(0, -1.57, -0.1), 0.4)
      LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.3) * euler(0, -1.57, 0) * euler(0, -1.57, 0.2), 0.4)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
        end
      end
    end
    n = 5
    for i = 0, 1, 0.1 do
      swait()
      mov = mov + n
      n = n / 2
      handlewld.C0 = clerp(handlewld.C0, euler(0, 1.57, 0) * cf(0, -2, mov), 0.4)
      wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 3, 0), 0.4)
      wld1.C1 = clerp(wld1.C1, euler(0, 0, 0) * cf(0, 0, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 1.57), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1.57), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0), 0.3)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
        end
      end
    end
        mana.Value = mana.Value - 20
        so("206083122", handle, 1, 1)
        CF = cf(prt12.Position)
        MagicCircle(BrickColor.new(NewCol2), CF, 150, 150, 150, 1, 1, 1, 0.02)
        MagniDamage(prt12, 20, 5, 10, math.random(20, 30), "Knockdown2", prt12, 0, 1, (math.random(5, 10)), nil, nil, true, "Movement", 0.2, 300)
        num = 0
        eul = math.random(-50, 50)
        eul2 = math.random(-50, 50)
        for i = 0, 1, 0.05 do
          swait()
          wld1.C0 = cf(0, 3, 0) * euler(-6.6 * i, 0, 0)
          if num >= 3 then
            num = 0
            eul = eul - 0.5
            eul2 = eul2 - 0.05
            MagicCircle2(BrickColor.new(NewCol2), CF * euler(-1.57, 0, eul) * cf(0, 0, 0), 3, 7, 3, -0.1, 9, -0.1, 0.1, 1.2)
            MagicCircle2(BrickColor.new(NewCol2), CF * euler(-1.57, 0, eul2) * cf(0, 0, 0), 3, 5, 3, -0.1, 6, -0.1, 0.1, 1.2)
          end
          num = num + 1
          for i = 0.523, 6.28, 0.523 do
            MagicBlock(BrickColor.new(NewCol2), CF * euler(0, i, 0) * cf(0, 0, 20), 1, 1, 1, 1, 1, 1, 0.1, 1)
          end
        end
        swait(10)
        handlewld.Part1 = RightArm
        dec.Parent = nil
        doingcomb = false
        attack = false
      end
    end
do2 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[2] and mana.Value >= 15 then
    attack = true
    doingcomb = true
    cooldowns[2] = 0
    for i = 0, 1, 0.15 do
      swait()
      handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, -0.3) * euler(0, -0.1, 0), 0.4)
      wld1.C0 = clerp(wld1.C0, euler(0, 1.1, 0) * cf(0, 0, 0), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(-0.4, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
      RW.C0 = clerp(RW.C0, cf(1, 1, -0.5) * euler(2.8, 0, -0.8) * euler(0, 0, 0), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1, 1, -0.5) * euler(2.8, 0, 0.8), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.3)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
        end
      end
    end
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = 10
    for i = 0, 1, 0.1 do
      swait()
      handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.4)
      wld1.C0 = clerp(wld1.C0, euler(3.14, 0, 0) * cf(0, -0.5, 0), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0.3, 0, 0), 0.4)
      RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.87, 0, -0.8) * euler(0, 0, 0), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.97, 0, 0.8) * euler(0, 0, 0), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1, -0.7, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.2), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -0.7, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, -0.2), 0.4)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
        end
      end
    end
        hitfloor2, posfloor2 = rayCast(prt1.Position, CFrame.new(prt1.Position, prt1.Position - Vector3.new(0, 1, 0)).lookVector, 100, Character)
        if hitfloor2 ~= nil then
          mana.Value = mana.Value - 15
          MagicWave(BrickColor.new("Navy blue"), cf(posfloor2), 60, 5, 60, -1, -0.2, -1, 0.05)
          MagicCircle(BrickColor.new("Really blue"), cf(posfloor2), 550, 5, 550, -10, 1, -10, 0.03)
          ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
          ref.Anchored = true
          ref.CFrame = cf(posfloor2)
          game:GetService("Debris"):AddItem(ref, 3)
          so("183763487", ref, 1, 0.4)
          so("183763487", ref, 1, 1)
          so("161006182", ref, 1, 0.2)
          so("158210228", ref, 1, 0.4)
          MagniDamage(ref, 55, 4, 6, math.random(-40, -30), "Knockdown2", ref, 0, 1, (math.random(4, 7)), nil, nil, true, nil, nil, nil)
        end
        for i = 1, 10 do
          swait()
          if Stagger.Value ~= true and StunT.Value > Stun.Value then
            do
              if StaggerHit.Value == true then
                break
              end
            end
          end
        end
        dec.Parent = nil
        doingcomb = false
        attack = false
      end
    end
do3 = function()
  doanim = true
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[3] and mana.Value >= 15 and RecentEnemy.Value ~= nil then
    decreasemana = true
    hits = 0
    num1 = 0
    hits2 = 0
    attack = true
    doingcomb = true
    cooldowns[3] = 0
    local BodGy = Instance.new("BodyGyro", RootPart)
    BodGy.maxTorque = Vector3.new(0, math.huge, 0)
    BodGy.P = 2000
    BodGy.D = 100
    Guy = nil
    Tors = nil
    if RecentEnemy.Value ~= nil then
      Guy = RecentEnemy.Value
      if RecentEnemy.Value:findFirstChild("Torso") ~= nil then
        Tors = RecentEnemy.Value.Torso
        BodGy.cframe = cf(Torso.Position, RecentEnemy.Value.Torso.Position)
      end
    end
    for i = 0, 1, 0.1 do
      swait()
      if Tors.Parent ~= nil then
        BodGy.cframe = cf(Torso.Position, Tors.Position)
      end
      handlewld.Part1 = RightArm
      handlewld.C0 = clerp(handlewld.C0, euler(1.7, 0, 0) * cf(0, 0.9, 0), 0.3)
      wld1.C0 = clerp(wld1.C0, euler(0.1, 0, 0) * cf(0, 0.5, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.6) * euler(0.2, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.6), 0.3)
      RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.7, 0, -1) * euler(0, 1.4, 0), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1, 0.3, -0.5) * euler(1.2, 0, 1) * euler(0, -1.57, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(0.9, -1, 0.1) * euler(0, 1.57, 0) * euler(-0.1, -0.6, 0), 0.3)
      LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.3) * euler(0, -1.57, 0) * euler(0, -0.6, 0.1), 0.3)
    end
    if Tors.Parent ~= nil then
      so("206083431", RootPart, 1, 1)
      Clone()
      BodGy.Parent = nil
      local targ = Torso.Position - Tors.Position
      local mag = targ.magnitude
      oldpos = Torso.Position
      Torso.CFrame = cf(Torso.Position, Tors.Position) * cf(0, 0, -mag * 0.8)
      effect(NewCol2, 0, Torso.CFrame, (cf(oldpos)), nil, 1, 1)
      MagicSpecial(BrickColor.new(NewCol2), cf(Torso.Position), 1, 1, 1, 5, 5, 5, 0.2)
      MagicSpecial(BrickColor.new(NewCol2), cf(oldpos), 1, 1, 1, 5, 5, 5, 0.2)
      swait(5)
      so("199145913", prt12, 1, 1.2)
      for i = 0, 1, 0.3 do
        swait()
        handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 0.6, -0.3), 0.5)
        wld1.C0 = clerp(wld1.C0, euler(1, 0, 0) * cf(0, 0, 0), 0.5)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.6) * euler(0.2, 0, 0), 0.5)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -1.2), 0.5)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.2) * euler(0, 1.4, 0), 0.5)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.2, 0, -1.3), 0.5)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
        RH.C0 = clerp(RH.C0, cf(0.7, -1, -0.5) * euler(0, 1.57, 0) * euler(-0.1, 1.2, 0), 0.5)
        LH.C0 = clerp(LH.C0, cf(-0.7, -1, 0.5) * euler(0, -1.57, 0) * euler(0, 1.2, 0.1), 0.5)
      end
      if Tors.Parent ~= nil then
        mana.Value = mana.Value - 15
        so("206083232", Tors, 1, 1)
        so("206083252", Tors, 1, 1)
        so("206083267", Tors, 1, 1)
        for i = 1, 2 do
          MagicCircle(BrickColor.new(NewCol2), cf(Tors.Position) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 3, 5, 3, -0.2, 10, -0.2, 0.05)
        end
        for i = 1, 5 do
          Lightning(Tors.Position + vt(math.random(-500, 500) / 100, math.random(-500, 500) / 100, math.random(-500, 500) / 100), Tors.Position + vt(math.random(-500, 500) / 100, math.random(-500, 500) / 100, math.random(-500, 500) / 100), 5, 2, NewCol2, 0.05, 0.4, 0.05)
        end
        if Tors.Parent ~= nil then
          Damagefunc(Tors, 6, 8, 0, "Normal", RootPart, 0, 1, (math.random(1, 3)), nil, false, true, "Movement", 0.1, 300)
        end
      end
      for i = 0, 1, 0.15 do
        swait()
        handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 0.6, -0.3), 0.5)
        wld1.C0 = clerp(wld1.C0, euler(1, 0, 0) * cf(0, 0, 0), 0.5)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.6) * euler(0.2, 0, 0), 0.5)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -1.2), 0.5)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.2) * euler(0, 1.4, 0), 0.5)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.2, 0, -1.3), 0.5)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
        RH.C0 = clerp(RH.C0, cf(0.7, -1, -0.5) * euler(0, 1.57, 0) * euler(-0.1, 1.2, 0), 0.5)
        LH.C0 = clerp(LH.C0, cf(-0.7, -1, 0.5) * euler(0, -1.57, 0) * euler(0, 1.2, 0.1), 0.5)
      end
    end
    do
      BodGy.Parent = nil
      doingcomb = false
      attack = false
    end
  end
end
do4 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[4] and mana.Value >= 25 and RecentEnemy.Value ~= nil then
    attack = true
    doingcomb = true
    move4do = true
    cooldowns[4] = 0
    Guy = nil
    Tors = nil
    if RecentEnemy.Value ~= nil then
      Guy = RecentEnemy.Value
      if RecentEnemy.Value:findFirstChild("Torso") ~= nil then
        Tors = RecentEnemy.Value.Torso
      end
    end
    print(Guy)
    for i = 0, 1, 0.1 do
      swait()
      handlewld.Part1 = RightArm
      handlewld.C0 = clerp(handlewld.C0, euler(1.7, 0, 0) * cf(0, 0.9, 0), 0.3)
      wld1.C0 = clerp(wld1.C0, euler(0.1, 0, 0) * cf(0, 0.5, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.6) * euler(0.2, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.6), 0.3)
      RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.7, 0, -1) * euler(0, 1.4, 0), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1, 0.3, -0.5) * euler(1.2, 0, 1) * euler(0, -1.57, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(0.9, -1, 0.1) * euler(0, 1.57, 0) * euler(-0.1, -0.6, 0), 0.3)
      LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.3) * euler(0, -1.57, 0) * euler(0, -0.6, 0.1), 0.3)
    end
    if Tors.Parent ~= nil then
      mana.Value = mana.Value - 25
      for i = 1, 5 do
        ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
        ref.Anchored = true
        ref.CFrame = cf(Tors.Position) * cf(0, 10, 0)
        game:GetService("Debris"):AddItem(ref, 1)
        oldpos = Torso.Position
        so("206083431", RootPart, 1, 1)
        Clone()
        ref.CFrame = ref.CFrame * euler(0, math.random(-50, 50), 0) * cf(0, 0, math.random(1000, 2000) / 100) * euler(0, 0, 0)
        hitfloor2, posfloor2 = rayCast(ref.Position, CFrame.new(ref.Position, ref.Position - Vector3.new(0, 1, 0)).lookVector, 100, Character)
        if hitfloor2 ~= nil then
          RootPart.CFrame = cf(posfloor2) * cf(0, 3, 0)
        end
        RootPart.CFrame = cf(RootPart.Position, Tors.Position)
        effect(NewCol2, 0, Torso.CFrame, (cf(oldpos)), nil, 1, 1)
        MagicSpecial(BrickColor.new(NewCol2), cf(Torso.Position), 1, 1, 1, 5, 5, 5, 0.2)
        MagicSpecial(BrickColor.new(NewCol2), cf(oldpos), 1, 1, 1, 5, 5, 5, 0.2)
        so("199145913", prt12, 1, math.random(90, 120) / 100)
        handlewld.C0 = euler(1.7, 0, 0) * cf(0, 0.9, 0)
        wld1.C0 = euler(0.1, 0, 0) * cf(0, 0.5, 0)
        Neck.C0 = necko * euler(0, 0, -0.6) * euler(0.2, 0, 0)
        RootJoint.C0 = RootCF * euler(0, 0, 0.6)
        RW.C0 = cf(1, 0.5, -0.5) * euler(1.7, 0, -1) * euler(0, 1.4, 0)
        LW.C0 = cf(-1, 0.3, -0.5) * euler(1.2, 0, 1) * euler(0, -1.57, 0)
        RH.C0 = cf(0.9, -1, 0.1) * euler(0, 1.57, 0) * euler(-0.1, -0.6, 0)
        LH.C0 = cf(-0.9, -1, -0.3) * euler(0, -1.57, 0) * euler(0, -0.6, 0.1)
        d = math.random(1, 4)
        for i = 0, 1, 0.3 do
          swait()
          if d == 1 then
            handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 0.6, -0.3), 0.5)
            wld1.C0 = clerp(wld1.C0, euler(1, 0, 0) * cf(0, 0, 0), 0.5)
            Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.6) * euler(0.2, 0, 0), 0.5)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -1.2), 0.5)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.2) * euler(0, 1.4, 0), 0.5)
            RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.2, 0, -1.3), 0.5)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
            RH.C0 = clerp(RH.C0, cf(0.7, -1, -0.5) * euler(0, 1.57, 0) * euler(-0.1, 1.2, 0), 0.5)
            LH.C0 = clerp(LH.C0, cf(-0.7, -1, 0.5) * euler(0, -1.57, 0) * euler(0, 1.2, 0.1), 0.5)
          else
            if d == 2 then
              handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 0.6, -0.3), 0.5)
              wld1.C0 = clerp(wld1.C0, euler(1, 0, 0) * cf(0, 0, 0), 0.5)
              Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.6) * euler(0.2, 0, 0), 0.5)
              RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1.4), 0.5)
              RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(0.5, 0, -1) * euler(0, -0.6, 0), 0.5)
              RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
              LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.2), 0.5)
              LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
              RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.3) * euler(0, 1.57, 0) * euler(0, -1, -0.1), 0.5)
              LH.C0 = clerp(LH.C0, cf(-0.8, -1, -0.3) * euler(0, -1.57, 0) * euler(0, -1, 0), 0.5)
            else
              if d == 3 then
                handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, -0.3) * euler(0, -0.1, 0), 0.5)
                wld1.C0 = clerp(wld1.C0, euler(0, 1.1, 0) * cf(0, 0, 0) * euler(0.5, 0, 0.5), 0.5)
                Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, 0), 0.5)
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.5)
                RW.C0 = clerp(RW.C0, cf(1, 0.1, -0.5) * euler(0.2, 0, -0.8) * euler(0, 0, 0), 0.5)
                RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
                LW.C0 = clerp(LW.C0, cf(-1, 0.1, -0.5) * euler(0.2, 0, 0.8), 0.5)
                LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
                RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.5)
                LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.5)
              else
                if d == 4 then
                  handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 0.6, -0.3), 0.5)
                  wld1.C0 = clerp(wld1.C0, euler(1, 0, 0) * cf(0, 0, 0), 0.5)
                  Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.4) * euler(0.2, 0, 0), 0.5)
                  RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.4), 0.5)
                  RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(0.4, 0, -0.8) * euler(0, -0.5, 0), 0.5)
                  RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
                  LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.7, 0, -0.7) * euler(0, 0, 0), 0.5)
                  LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
                  RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.4, -0.1), 0.5)
                  LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, -0.4, 0.3), 0.5)
                end
              end
            end
          end
        end
        if Tors.Parent ~= nil then
          so("206083232", Tors, 1, 1)
          so("206083252", Tors, 1, 1)
          so("206083267", Tors, 1, 1)
          for i = 1, 2 do
            MagicCircle(BrickColor.new(NewCol2), cf(Tors.Position) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 3, 5, 3, -0.2, 10, -0.2, 0.05)
          end
          for i = 1, 5 do
            Lightning(Tors.Position + vt(math.random(-500, 500) / 100, math.random(-500, 500) / 100, math.random(-500, 500) / 100), Tors.Position + vt(math.random(-500, 500) / 100, math.random(-500, 500) / 100, math.random(-500, 500) / 100), 5, 2, NewCol2, 0.05, 0.4, 0.05)
          end
          if Tors.Parent ~= nil then
            Damagefunc(Tors, 6, 8, 0, "Normal", RootPart, 0, 1, (math.random(1, 3)), nil, false, true, "Damage", 0.05, 300)
          end
        end
        if Tors.Parent == nil then
          break
        end
        swait(5)
      end
    end
    do
      move4do = false
      doingcomb = false
      attack = false
    end
  end
end
findNearestTorso = function(pos, distance)
  local list = (game.Workspace:children())
  local torso = nil
  local dist = distance
  local temp, human, temp2 = nil, nil, nil
  for x = 1, #list do
    temp2 = list[x]
    canfind = true
    -- DECOMPILER ERROR at PC36: Unhandled construct in 'MakeBoolean' P1

    if game.Players:GetPlayerFromCharacter(temp2) ~= nil and game.Players:GetPlayerFromCharacter(temp2).TeamColor == Player.TeamColor and Player.Neutral == false then
      canfind = false
    end
    canfind = true
    if temp2.className == "Model" and temp2 ~= Character and canfind == true then
      temp = temp2:findFirstChild("Torso")
      human = temp2:findFirstChild("Humanoid")
      if temp ~= nil and human ~= nil and human.Health > 0 and temp.Position - pos.magnitude < dist then
        torso = temp
        dist = temp.Position - pos.magnitude
      end
    end
  end
  return torso, dist
end
DecreaseStat = function(Model, Stat, Amount, Duration)
  if Model:findFirstChild("Stats") ~= nil and Model.Stats[Stat] ~= nil then
    Model.Stats[Stat].Value = Model.Stats[Stat].Value - Amount
    d = Instance.new("NumberValue", Model.Stats.Decrease)
    dur = Instance.new("NumberValue", d)
    dur.Name = "Duration"
    dur.Value = Duration
    game:GetService("Debris"):AddItem(d, 20)
    if Stat == "Damage" then
      d.Name = "DecreaseAtk"
    else
      if Stat == "Defense" then
        d.Name = "DecreaseDef"
      else
        if Stat == "Movement" then
          d.Name = "DecreaseMvmt"
        end
      end
    end
    if Model:findFirstChild("Torso") ~= nil then
      display = ""
      if Stat == "Damage" then
        if Amount > 0 then
          display = "-Damage"
        else
          display = "+Damage"
        end
      else
        if Stat == "Defense" then
          if Amount > 0 then
            display = "-Defense"
          else
            display = "+Defense"
          end
        else
          if Stat == "Movement" then
            if Amount > 0 then
              display = "-Movement"
            else
              display = "+Movement"
            end
          end
        end
      end
      showDamage(Model, display, "Debuff")
    end
    d.Value = Amount
  end
end
GetDist = function(Part1, Part2, magni)
  local targ = Part1.Position - Part2.Position
  local mag = targ.magnitude
  if mag <= magni then
    return true
  else
    return false
  end
end
MagniDamage = function(Part, magni, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
  for _,c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = nil
      for _,d in pairs(c:children()) do
        if d.className == "Model" and ranged ~= true then
          head = d:findFirstChild("Hitbox")
          if d.Parent == Character then
            break
          end
          if head ~= nil then
            local targ = head.Position - Part.Position
            local mag = targ.magnitude
            if mag <= magni and c.Name ~= Player.Name then
              ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
              ref.Anchored = true
              ref.CFrame = cf(head.Position)
              game:GetService("Debris"):AddItem(ref, 1)
              hitnum = math.random(1, 5)
              if hitnum == 1 then
                so("199148971", ref, 1, 1)
              else
                if hitnum == 2 then
                  so("199149025", ref, 1, 1)
                else
                  if hitnum == 3 then
                    so("199149072", ref, 1, 1)
                  else
                    if hitnum == 4 then
                      so("199149109", ref, 1, 1)
                    else
                      if hitnum == 5 then
                        so("199149119", ref, 1, 1)
                      end
                    end
                  end
                end
              end
              StaggerHit.Value = true
            end
          end
        end
        do
          if d.className == "Part" and d.Name=="Torso" then
            head = d
            if head ~= nil then
              local targ = head.Position - Part.Position
              local mag = targ.magnitude
              if mag <= magni and c.Name ~= Player.Name then
                if stun == nil then
                  stun = math.random(5, 10)
                end
                local Rang = nil
                if Ranged == false then
                  Rang = true
                end
                local stag = nil
                if shbash == true then
                  stag = true
                end
                Damagefunc(head, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
              end
            end
          end
          do
            -- DECOMPILER ERROR at PC183: LeaveBlock: unexpected jumping out DO_STMT

          end
        end
      end
    end
  end
end
MagniBuff = function(Part, magni, Dec, DecAm, Dur)
  if Player.Neutral == true then
    DecreaseStat(Character, Dec, DecAm, Dur)
  end
  for _,c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        cando = true
        if mag <= magni then
          if Player.Neutral == false then
            if game.Players:GetPlayerFromCharacter(head.Parent) ~= nil then
              if game.Players:GetPlayerFromCharacter(head.Parent).TeamColor == Player.TeamColor then
                cando = true
              else
                cando = false
              end
            else
              cando = false
            end
            if head.Parent:findFirstChild("Alignment") ~= nil and head.Parent.Alignment.Value == Player.TeamColor.Color then
              cando = true
            end
          else
            cando = false
          end
          if cando == true then
            DecreaseStat(head.Parent, Dec, DecAm, Dur)
          end
        end
      end
    end
  end
end
MagniDebuff = function(Part, magni, Dec, DecAm, Dur)
  for _,c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if mag <= magni and c.Name ~= Player.Name and game.Players:GetPlayerFromCharacter(head.Parent) ~= nil and (game.Players:GetPlayerFromCharacter(head.Parent).TeamColor ~= Player.TeamColor or Player.Neutral == true) then
          DecreaseStat(head.Parent, Dec, DecAm, Dur)
        end
      end
  end
end
end
rayCast = function(Pos, Dir, Max, Ignore)
  return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
end
local Point = Torso.CFrame * cf(0, Torso.Size.Y, 0)
LastPoint = Point
effect = function(Color, Ref, LP, P1, returnn, size, thing1)
  if LP == nil or P1 == nil then
    return 
  end
  local effectsmsh = Instance.new("SpecialMesh")
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  effectsmsh.MeshType = "Head"
  effectsmsh.Name = "Mesh"
  local effectsg = Instance.new("Part")
  NoOutline(effectsg)
  effectsg.formFactor = 3
  effectsg.CanCollide = false
  effectsg.Name = "Eff"
  effectsg.Locked = true
  effectsg.Anchored = true
  effectsg.Size = Vector3.new(0.5, 1, 0.5)
  effectsg.Parent = workspace
  effectsmsh.Parent = effectsg
  effectsg.BrickColor = BrickColor.new(Color)
  effectsg.Reflectance = Ref
  local point1 = P1
  local mg = (LP.p - point1.p).magnitude
  effectsg.Size = Vector3.new(0.5, mg, 0.5)
  effectsg.CFrame = cf((LP.p + point1.p) / 2, point1.p) * CFrame.Angles(math.rad(90), 0, 0)
  effectsmsh.Scale = Vector3.new(size, 1, size)
  game:GetService("Debris"):AddItem(effectsg, 2)
  if returnn then
    return effectsg
  end
  if not returnn then
    if thing1 == 1 then
      table.insert(Effects, {effectsg, "Cylinder", 0.05, 0.2, 0, 0.2, effectsmsh})
    else
      table.insert(Effects, {effectsg, "Cylinder", 0.2, 0.01, 0, 0.01, effectsmsh})
    end
  end
end
local CFrameFromTopBack = function(at, top, back)
  local right = top:Cross(back)
  return CFrame.new(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end
Triangle = function(a, b, c)
  local edg1 = c - a:Dot(b - a.unit)
  local edg2 = a - b:Dot(c - b.unit)
  local edg3 = b - c:Dot(a - c.unit)
  if edg1 <= b - a.magnitude and edg1 >= 0 then
    a = a
  else
    -- DECOMPILER ERROR at PC35: Overwrote pending register: R1 in 'AssignReg'

    if edg2 <= c - b.magnitude and edg2 >= 0 then
      a = b
    else
      -- DECOMPILER ERROR at PC46: Overwrote pending register: R2 in 'AssignReg'

      -- DECOMPILER ERROR at PC47: Overwrote pending register: R1 in 'AssignReg'

      if edg3 <= a - c.magnitude and edg3 >= 0 then
        a = c
      else
        assert(false, "unreachable")
      end
    end
  end
  local len1 = c - a:Dot(b - a.unit)
  local len2 = b - a.magnitude - len1
  local width = a + b - a.unit * len1 - c.magnitude
  local maincf = CFrameFromTopBack(a, b - a:Cross(c - b).unit, -b - a.unit)
  local list = {}
  if len1 > 0.01 then
    local w1 = Instance.new("WedgePart", m)
    w1.Name = "Triangle"
    game:GetService("Debris"):AddItem(w1, 5)
    w1.Material = "SmoothPlastic"
    w1.FormFactor = "Custom"
    w1.BrickColor = BrickColor.new("Medium blue")
    w1.Transparency = 0
    w1.Reflectance = 0
    w1.Material = "SmoothPlastic"
    w1.CanCollide = false
    NoOutline(w1)
    local sz = Vector3.new(0.2, width, len1)
    w1.Size = sz
    local sp = Instance.new("SpecialMesh", w1)
    sp.MeshType = "Wedge"
    sp.Scale = Vector3.new(0, 1, 1) * sz / w1.Size
    w1:BreakJoints()
    w1.Anchored = true
    w1.Parent = workspace
    w1.Transparency = 0.7
    table.insert(Effects, {w1, "Disappear", 0.05})
    w1.CFrame = maincf * CFrame.Angles(math.pi, 0, math.pi / 2) * CFrame.new(0, width / 2, len1 / 2)
    table.insert(list, w1)
  end
  do
    if len2 > 0.01 then
      local w2 = Instance.new("WedgePart", m)
      w2.Name = "Triangle"
      game:GetService("Debris"):AddItem(w2, 5)
      w2.Material = "SmoothPlastic"
      w2.FormFactor = "Custom"
      w2.BrickColor = BrickColor.new("Medium blue")
      w2.Transparency = 0
      w2.Reflectance = 0
      w2.Material = "SmoothPlastic"
      w2.CanCollide = false
      NoOutline(w2)
      local sz = Vector3.new(0.2, width, len2)
      w2.Size = sz
      local sp = Instance.new("SpecialMesh", w2)
      sp.MeshType = "Wedge"
      sp.Scale = Vector3.new(0, 1, 1) * sz / w2.Size
      w2:BreakJoints()
      w2.Anchored = true
      w2.Parent = workspace
      w2.Transparency = 0.7
      table.insert(Effects, {w2, "Disappear", 0.05})
      w2.CFrame = maincf * CFrame.Angles(math.pi, math.pi, -math.pi / 2) * CFrame.new(0, width / 2, -len1 - len2 / 2)
      table.insert(list, w2)
    end
    do
      return unpack(list)
    end
  end
end
MagicBlock = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  if Type == 1 or Type == nil then
    table.insert(Effects, {prt, "Block1", delay, x3, y3, z3, msh})
  else
    if Type == 2 then
      table.insert(Effects, {prt, "Block2", delay, x3, y3, z3, msh})
    end
  end
end
MagicCircle = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicCircle2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, push)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Blood", delay, x3, y3, z3, msh, push})
end
MagicCircle3 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, partt)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cf(partt.Position) * cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder2", delay, x3, y3, z3, msh, cframe, partt})
end
MagicCylinder = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicHead = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Head", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
ClangEffect = function(brickcolor, cframe, duration, decrease, size, power)
  local prt = part(3, workspace, 0, 1, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(5, 5, 5))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "CylinderClang", duration, decrease, size, power, prt.CFrame, nil})
end
MagicWave = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "FileMesh", "20329976", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicSpecial = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "FileMesh", "24388358", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
Lightning = function(p0, p1, tym, ofs, col, th, tra, last)
  local magz = (p0 - p1).magnitude
  local curpos = p0
  local trz = {-ofs, ofs}
  for i = 1, tym do
    local li = Instance.new("Part", workspace)
    li.TopSurface = 0
    li.BottomSurface = 0
    li.Anchored = true
    li.Transparency = tra or 0.4
    li.BrickColor = BrickColor.new(col)
    li.formFactor = "Custom"
    li.CanCollide = false
    li.Size = Vector3.new(th, th, magz / tym)
    local ofz = Vector3.new(trz[math.random(1, 2)], trz[math.random(1, 2)], trz[math.random(1, 2)])
    local trolpos = CFrame.new(curpos, p1) * CFrame.new(0, 0, magz / tym).p + ofz
    if tym == i then
      local magz2 = (curpos - p1).magnitude
      li.Size = Vector3.new(th, th, magz2)
      li.CFrame = CFrame.new(curpos, p1) * CFrame.new(0, 0, -magz2 / 2)
table.insert(Effects, {li, "Disappear", last})
    else
      do
        do
          li.CFrame = CFrame.new(curpos, trolpos) * CFrame.new(0, 0, magz / tym / 2)
          curpos = li.CFrame * CFrame.new(0, 0, magz / tym / 2).p
          game.Debris:AddItem(li, 10)
          table.insert(Effects, {li, "Disappear", last})
        end
      end
    end
  end
end
Clone = function()
  for _,v in pairs(Torso.Parent:children()) do
    if v.className == "Part" and v.Name ~= "HumanoidRootPart" then
      local c = part(3, workspace, 0, 0.5, BrickColor.new(NewCol2), "Effect", v.Size)
      c.Anchored = true
      c.CFrame = v.CFrame
      game:GetService("Debris"):AddItem(c, 5)
      if v.Name == "Head" then
        cmsh = mesh("SpecialMesh", c, "Head", "nil", vt(0, 0, 0), v.Mesh.Scale)
      end
      table.insert(Effects, {c, "Disappear", 0.01})
    end
  end
end
CloneArms = function()
  for _,v in pairs(Torso.Parent:children()) do
    if v.Name == "Left Arm" or v.Name == "Right Arm" then
      local c = part(3, workspace, 0, 0.5, v.BrickColor, "Effect", v.Size)
      c.Anchored = true
      c.CFrame = v.CFrame
      game:GetService("Debris"):AddItem(c, 5)
      if v.Name == "Head" then
        cmsh = mesh("SpecialMesh", c, "Head", "nil", vt(0, 0, 0), v.Mesh.Scale)
      end
      table.insert(Effects, {c, "Disappear", 0.05})
    end
  end
end
Damagefunc = function(hit, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
  if hit.Parent == nil then
    return 
  end
  if hit.Name == "Hitbox" and hit.Parent ~= modelzorz and ranged ~= true then
    ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
    ref.Anchored = true
    ref.CFrame = cf(hit.Position)
    game:GetService("Debris"):AddItem(ref, 1)
    hitnum = math.random(1, 5)
    if hitnum == 1 then
      so("199148971", ref, 1, 1)
    else
      if hitnum == 2 then
        so("199149025", ref, 1, 1)
      else
        if hitnum == 3 then
          so("199149072", ref, 1, 1)
        else
          if hitnum == 4 then
            so("199149109", ref, 1, 1)
          else
            if hitnum == 5 then
              so("199149119", ref, 1, 1)
            end
          end
        end
      end
    end
    StaggerHit.Value = true
  end
  h = hit.Parent:FindFirstChild("Humanoid")
  if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
    if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
      return 
    end
    if Player.Neutral == false then
      if hit.Parent:findFirstChild("Alignment") ~= nil and hit.Parent.Alignment.Value == Player.TeamColor.Color then
        return 
      end
      if game.Players:GetPlayerFromCharacter(hit.Parent) ~= nil and game.Players:GetPlayerFromCharacter(hit.Parent).TeamColor == Player.TeamColor then
        return 
      end
    end
    c = Instance.new("ObjectValue")
    c.Name = "creator"
    c.Value = game:service("Players").LocalPlayer
    c.Parent = h
    if doingcomb == true then
      RecentEnemy.Value = hit.Parent
    end
    game:GetService("Debris"):AddItem(c, 0.5)
    minim = minim * Atk.Value
    maxim = maxim * Atk.Value
    Damage = 0
    if minim == maxim then
      Damage = maxim
    else
      Damage = math.random(minim, maxim)
    end
    blocked = false
    enblock = nil
    Stats = hit.Parent:findFirstChild("Stats")
    if Stats ~= nil then
      invis = Stats:findFirstChild("Invisibility")
      isinvis = Stats:findFirstChild("IsInvisible")
      if (ranged == false or ranged == nil) and invis ~= nil and isinvis.Value == true then
        invis.Value = 0
      end
      enblock = Stats:findFirstChild("Block")
      if enblock ~= nil and enblock.Value == true then
        blocked = true
      end
      if Stats:findFirstChild("Defense") ~= nil then
        Damage = Damage / Stats.Defense.Value
        if Damage <= 3 and (ranged == false or ranged == nil) and blocked ~= true then
          hitnum = math.random(1, 5)
          if hitnum == 1 then
            so("199149321", hit, 1, 1)
          else
            if hitnum == 2 then
              so("199149338", hit, 1, 1)
            else
              if hitnum == 3 then
                so("199149367", hit, 1, 1)
              else
                if hitnum == 4 then
                  so("199149409", hit, 1, 1)
                else
                  if hitnum == 5 then
                    so("199149452", hit, 1, 1)
                  end
                end
              end
            end
          end
        else
          if ranged == false or ranged == nil and blocked ~= true then
            hitnum = math.random(1, 6)
            if hitnum == 1 then
              so("199149137", hit, 1, 1)
            else
              if hitnum == 2 then
                so("199149186", hit, 1, 1)
              else
                if hitnum == 3 then
                  so("199149221", hit, 1, 1)
                else
                  if hitnum == 4 then
                    so("199149235", hit, 1, 1)
                  else
                    if hitnum == 5 then
                      so("199149269", hit, 1, 1)
                    else
                      if hitnum == 6 then
                        so("199149297", hit, 1, 1)
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if Damage <= 3 and staghit == true and ranged ~= true then
          StaggerHit.Value = true
        end
      end
      if Stats:findFirstChild("Stun") ~= nil then
        if blocked == true then
          incstun = incstun / 2
        end
        --[[if Stats.Stun.Value < Stats.StunThreshold.Value then
          Stats.Stun.Value = Stats.Stun.Value + incstun
        end--]]
      end
      if Stats:findFirstChild("Stagger") ~= nil and stagger == true then
        Stats.Stagger.Value = true
      end
    end
    if blocked == true then
      showDamage(hit.Parent, "Block", "Damage")
      if ranged ~= true then
        enblock.Value = false
        Stagger.Value = true
        hitnum = math.random(1, 2)
        if hitnum == 1 then
          so("199148933", hit, 1, 1)
        else
          if hitnum == 2 then
            so("199148947", hit, 1, 1)
          end
        end
      end
    else
      Damage = math.floor(Damage)
      coroutine.resume(coroutine.create(function(Hum, Dam)
	hit.Parent.Humanoid:TakeDamage(Damage)
  end
), h, Damage)
      showDamage(hit.Parent, Damage, "Damage")
      if DecreaseState ~= nil then
        if DecreaseState == "Temporal" then
          DecreaseStat(hit.Parent, "Damage", DecreaseAmount, Duration)
          DecreaseStat(hit.Parent, "Defense", DecreaseAmount, Duration)
        else
          if DecreaseState == "Temporal2" then
            DecreaseStat(hit.Parent, "Damage", DecreaseAmount, Duration)
            DecreaseStat(hit.Parent, "Movement", DecreaseAmount, Duration)
          else
            DecreaseStat(hit.Parent, DecreaseState, DecreaseAmount, Duration)
          end
        end
      end
      if Type == "NormalDecreaseMvmt1" then
        DecreaseStat(hit.Parent, "Movement", 0.1, 200)
      end
      if Type == "Knockdown" then
        hum = hit.Parent.Humanoid
        hum.PlatformStand = true
        coroutine.resume(coroutine.create(function(HHumanoid)
    swait(1)
    HHumanoid.PlatformStand = false
  end), hum)
        local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
        local bodvol = Instance.new("BodyVelocity")
        bodvol.velocity = angle * knockback
        bodvol.P = 500
        bodvol.maxForce = Vector3.new(3000, 3000, 3000)
        bodvol.Parent = hit
        rl = Instance.new("BodyAngularVelocity")
        rl.P = 3000
        rl.maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000
        rl.angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10))
        rl.Parent = hit
        game:GetService("Debris"):AddItem(bodvol, 0.5)
        game:GetService("Debris"):AddItem(rl, 0.5)
      else
        do
          if Type == "Knockdown2" then
            hum = hit.Parent.Humanoid
            local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
            local bodvol = Instance.new("BodyVelocity")
            bodvol.velocity = angle * knockback
            bodvol.P = 500
            bodvol.maxForce = Vector3.new(3000, 3000, 3000)
            bodvol.Parent = hit
            game:GetService("Debris"):AddItem(bodvol, 0.5)
          else
            do
              if Type == "Normal" or Type == "NormalDecreaseMvmt1" then
                vp = Instance.new("BodyVelocity")
                vp.P = 500
                vp.maxForce = Vector3.new(math.huge, 0, math.huge)
                if KnockbackType == 1 then
                  vp.velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
                else
                  if KnockbackType == 2 then
                    vp.velocity = Property.CFrame.lookVector * knockback
                  end
                end
                game:GetService("Debris"):AddItem(vp, 0.5)
                if knockback > 0 then
                  vp.Parent = hit.Parent.Torso
                end
              end
              debounce = Instance.new("BoolValue")
              debounce.Name = "DebounceHit"
              debounce.Parent = hit.Parent
              debounce.Value = true
              game:GetService("Debris"):AddItem(debounce, Delay)
              c = Instance.new("ObjectValue")
              c.Name = "creator"
              c.Value = Player
              c.Parent = h
              game:GetService("Debris"):AddItem(c, 0.5)
              CRIT = false
            end
          end
        end
      end
    end
  end
end
showDamage = function(Char, Dealt, Type)
  m = Instance.new("Model")
  m.Name = "Effect"
  c = Instance.new("Part")
  c.Transparency = 1
  c.Name = "Head"
  c.TopSurface = 0
  c.BottomSurface = 0
  c.formFactor = "Plate"
  c.Size = Vector3.new(1, 0.4, 1)
  b = Instance.new("BillboardGui", c)
  b.Size = UDim2.new(5, 0, 5, 0)
  b.AlwaysOnTop = true
  damgui = gui("TextLabel", b, tostring(Dealt), 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
  if Type == "Damage" then
    damgui.Font = "SourceSans"
    if Dealt == "Block" then
      damgui.TextColor3 = BrickColor.new("Bright blue").Color
    else
      if Dealt < 3 then
        damgui.TextColor3 = BrickColor.new("White").Color
      else
        if Dealt >= 3 and Dealt < 20 then
          damgui.TextColor3 = BrickColor.new("Bright yellow").Color
        else
          damgui.TextColor3 = BrickColor.new("Really red").Color
          damgui.Font = "SourceSansBold"
        end
      end
    end
  else
    if Type == "Debuff" then
      damgui.TextColor3 = BrickColor.new("White").Color
    else
      if Type == "Interrupt" then
        damgui.TextColor3 = BrickColor.new("New Yeller").Color
      end
    end
  end
  damgui.TextScaled = true
  ms = Instance.new("CylinderMesh")
  ms.Scale = Vector3.new(0.8, 0.8, 0.8)
  ms.Parent = c
  c.Reflectance = 0
  Instance.new("BodyGyro").Parent = c
  c.Parent = m
  if Char:findFirstChild("Head") ~= nil then
    c.CFrame = cf(Char.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
  else
    if Char.Parent:findFirstChild("Head") ~= nil then
      c.CFrame = cf(Char.Parent.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
    end
  end
  f = Instance.new("BodyPosition")
  f.P = 2000
  f.D = 100
  f.maxForce = Vector3.new(545000, 545000, 545000)
  if Type == "Damage" then
    f.position = c.Position + Vector3.new(0, 3, 0)
  else
    if Type == "Debuff" or Type == "Interrupt" then
      f.position = c.Position + Vector3.new(0, 5, 0)
    end
  end
  f.Parent = c
  game:GetService("Debris"):AddItem(m, 5)
  table.insert(Effects, {m, "showDamage", damgui, f, 10, 1, 15, 50, 100})
  c.CanCollide = false
  m.Parent = workspace
  c.CanCollide = false
end
combo = 0
ob1d = function(mouse)
  if attack == true or equipped == false then
    return 
  end
  hold = true
  doingcomb = true
  if combo == 0 then
    combo = 1
    attackone()
  else
    if combo == 1 then
      combo = 2
      attacktwo()
    else
      if combo == 2 then
        combo = 3
        attackthree()
      else
        if combo == 3 then
          combo = 0
          attackfour()
        end
      end
    end
  end
  doingcomb = false
  coroutine.resume(coroutine.create(function()
    for i = 1, 50 do
      if doingcomb == false then
        swait()
      end
    end
    if doingcomb == false then
      combo = 0
      RecentEnemy.Value = nil
    end
  end))
end
ob1u = function(mouse)
  hold = false
end
buttonhold = false
fenbarmove1.MouseButton1Click:connect(do1)
fenbarmove2.MouseButton1Click:connect(do2)
fenbarmove3.MouseButton1Click:connect(do3)
fenbarmove4.MouseButton1Click:connect(do4)
eul = 0
equipped = false
key = function(key)
  if key == "e" then
    DistortionCharge()
  end
  if key == "x" and graviting == true then
    do2()
    return 
  end
  if key == "c" and doanim == false then
    do3()
    return 
  end
  if attack == true then
    return 
  end
  if key == "f" then
    pressedf = true
    fnumb = 0
    attack = true
    if equipped == false then
      equipped = true
      RSH = ch.Torso["Right Shoulder"]
      LSH = ch.Torso["Left Shoulder"]
      RSH.Parent = nil
      LSH.Parent = nil
      RW.Name = "Right Shoulder"
      RW.Part0 = ch.Torso
      RW.C0 = cf(1.5, 0.5, 0)
      RW.C1 = cf(0, 0.5, 0)
      RW.Part1 = ch["Right Arm"]
      RW.Parent = ch.Torso
      LW.Name = "Left Shoulder"
      LW.Part0 = ch.Torso
      LW.C0 = cf(-1.5, 0.5, 0)
      LW.C1 = cf(0, 0.5, 0)
      LW.Part1 = ch["Left Arm"]
      LW.Parent = ch.Torso
      Animate.Parent = nil
      equipanim()
    else
      equipped = false
      hideanim()
      LH.C1 = LHC1
      RH.C1 = RHC1
      Animate.Parent = Humanoid
      swait(0)
      RW.Parent = nil
      LW.Parent = nil
      RSH.Parent = player.Character.Torso
      LSH.Parent = player.Character.Torso
    end
    attack = false
  end
  if equipped == false then
    return 
  end
  if key == "z" then
    do1()
  end
  if key == "x" then
    do2()
  end
  if key == "c" then
    do3()
  end
  if key == "v" then
    do4()
  end
end
key2 = function(key)
end
s = function(mouse)
  mouse.Button1Down:connect(function()
    ob1d(mouse)
  end)
  mouse.Button1Up:connect(function()
    ob1u(mouse)
  end)
  mouse.KeyDown:connect(key)
  mouse.KeyUp:connect(key2)
  player = Player
  ch = Character
end
ds = function(mouse)
end
Bin.Selected:connect(s)
Bin.Deselected:connect(ds)
print("Tempus loaded.")
local mananum = 0
local donum = 0
local stunnum = 0
local staggeranim = false
local stunanim = false
local passivenum = 0
local passivenum2 = 0
local walk = 0
local walkforw = true
while 1 do
  swait()
  if Humanoid.Health <= 0 then
    attack = true
    resumeControl()
    modelzorz.Parent = workspace
    game:GetService("Debris"):AddItem(modelzorz, 30)
    for i = 1, #Weapon do
      Weapon[i].Parent = modelzorz
      Weapon[i].CanCollide = true
    end
    for i = 1, #Welds do
      if Welds[i].Part0.Parent == Character or Welds[i].Part1.Parent == Character then
        Welds[i].Parent = nil
      else
        Welds[i].Parent = prt1
      end
    end
  end
  do
    if fnumb < 21 then
      fnumb = fnumb + 1
      if pressedf == false then
        fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency - 0.025
        tellbar.TextTransparency = tellbar.TextTransparency - 0.05
        tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency - 0.05
      else
        if fnumb == 20 then
          fenframe5.Parent = nil
          print("daigui")
        end
        fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency + 0.025
        tellbar.TextTransparency = tellbar.TextTransparency + 0.05
        tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency + 0.05
      end
    end
    if hbwld.Parent == nil then
      hitbox2.Name = "Hitbox"
    else
      hitbox2.Name = "Hitbox2"
    end
    hitbox2.Parent = hitbox.Parent
    hitbox2.Size = hitbox.Size
    hitbox2.CFrame = hitboxCF
    hboxpos.position = hitbox2.Position + vt(math.random(-100, 100) / 100, math.random(-100, 100) / 100, math.random(-100, 100) / 100)
    if Humanoid.Health <= 0 then
      Image.Parent = nil
    end
    passivenum = passivenum + 1
    if 8 <= passivenum then
      passivenum = 0
      distort = distort + 1
    end
    if 100 <= distort then
      distort = 100
    end
    if 30 <= passivenum2 then
      if Image.Parent ~= nil and RootPart.Position - ImageRoot.Position.magnitude <= 150 then
        Lightning(RootPart.Position, ImageRoot.Position, 5, 1, NewCol2, 0.05, 0.4, 0.1)
      end
      passivenum2 = 0
    end
    passivenum2 = passivenum2 + 1
    if Stagger.Value == true and staggeranim == false then
      coroutine.resume(coroutine.create(function()
  staggeranim = true
  while attack == true do
    swait()
  end
  StaggerAnim()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end))
    end
    if StaggerHit.Value == true and staggeranim == false then
      coroutine.resume(coroutine.create(function()
  staggeranim = true
  while attack == true do
    swait()
  end
  StaggerHitt()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end))
    end
    if Mvmt.Value < 0 or Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true or Rooted.Value == true then
      Humanoid.WalkSpeed = 0
    else
      Humanoid.WalkSpeed = 16 * Mvmt.Value
    end
    if StunT.Value <= Stun.Value and stunanim == false then
      coroutine.resume(coroutine.create(function()
  stunanim = true
  while attack == true do
    swait()
  end
  StunAnim()
  Stun.Value = 0
  stunanim = false
end))
    end
    local stunnum2 = 50
    if stunnum2 <= stunnum then
      if 0 < Stun.Value then
        Stun.Value = Stun.Value - 1
      end
      stunnum = 0
    end
    stunnum = stunnum + 1
    if 0.5 <= donum then
      handidle = true
    else
      if donum <= 0 then
        handidle = false
      end
    end
    if handidle == false then
      donum = donum + 0.003
    else
      donum = donum - 0.003
    end
    local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
    local velderp = RootPart.Velocity.y
    hitfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
    if equipped == true then
      if attack == false then
        idle = idle + 1
      else
        idle = 0
      end
      if (500 <= idle and attack ~= false) or Anim == "Walk" then
        if walkforw == true then
          RH.C1 = clerp(RH.C1, RHC1 * cf(0.2, -0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
          LH.C1 = clerp(LH.C1, LHC1 * cf(0.1, 0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
        else
          RH.C1 = clerp(RH.C1, RHC1 * cf(-0.1, 0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
          LH.C1 = clerp(LH.C1, LHC1 * cf(-0.2, -0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
        end
      else
        RH.C1 = clerp(RH.C1, RHC1, 0.2)
        LH.C1 = clerp(LH.C1, LHC1, 0.2)
      end
      if 1 < RootPart.Velocity.y and hitfloor == nil then
        Anim = "Jump"
        if attack == false then
          handlewld.Part1 = RightArm
          handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
          wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0.5, 0), 0.2)
          Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0), 0.2)
          Neck.C1 = clerp(Neck.C1, necko2 * euler(0, 0, 0), 0.2)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
          RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1, 0, 0.2), 0.2)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
          LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.3, 0, 0), 0.2)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
          RH.C0 = clerp(RH.C0, cf(1, -1, -0.3) * euler(-0.5, 1.57, 0) * euler(-0.2, 0, 0), 0.2)
          LH.C0 = clerp(LH.C0, cf(-1, -1, -0.3) * euler(-0.5, -1.57, 0) * euler(-0.2, 0, 0), 0.2)
        end
      else
        if RootPart.Velocity.y < -1 and hitfloor == nil then
          Anim = "Fall"
          if attack == false then
            handlewld.Part1 = RightArm
            handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
            wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0.5, 0), 0.2)
            Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, 0), 0.2)
            Neck.C1 = clerp(Neck.C1, necko2 * euler(0, 0, 0), 0.2)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.8), 0.2)
            RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.3, 0, 0), 0.2)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
            RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0.4, 1.57, 0), 0.2)
            LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(-0.2, -1.57, 0), 0.2)
          end
        else
          if torvel < 1 and hitfloor ~= nil then
            Anim = "Idle"
            if attack == false then
              handlewld.Part1 = RightArm
              handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 0.9, 0), 0.2)
              wld1.C0 = clerp(wld1.C0, euler(0.1, 0, 0) * cf(0, 0.5, 0), 0.2)
              Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.6) * euler(0.05, 0, 0), 0.15)
              RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.6), 0.15)
              RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2 + (donum) / 3, 0, 0.2 + (donum) / 3) * euler(0, -0.3, 0), 0.15)
              RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.15)
              LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.2 - (donum) / 3, 0, -0.2 - (donum) / 3), 0.15)
              LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.15)
              RH.C0 = clerp(RH.C0, cf(0.9, -1, -0.3) * euler(0, 1.57, 0) * euler(-0.1, 0.6, 0), 0.2)
              LH.C0 = clerp(LH.C0, cf(-0.9, -1, 0.1) * euler(0, -1.57, 0) * euler(0, 0.6, 0.1), 0.2)
            end
          else
            if 2 < torvel and torvel < 30 and hitfloor ~= nil then
              Anim = "Walk"
              walk = walk + 1
              if 15 - 5 * Mvmt.Value <= walk then
                walk = 0
                if walkforw == true then
                  walkforw = false
                else
                  if walkforw == false then
                    walkforw = true
                  end
                end
              end
              if attack == false then
                handlewld.Part1 = RightArm
                handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
                wld1.C0 = clerp(wld1.C0, euler(0, 0, 0) * cf(0, 0.5, 0), 0.2)
                Neck.C0 = clerp(Neck.C0, necko * euler(0.1, 0, 0), 0.2)
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.1, 0, 0), 0.2)
                RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.4) * euler(0, -1, 0), 0.2)
                RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.2), 0.2)
                LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.2)
                LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.2)
              end
            else
              if 30 <= torvel and hitfloor ~= nil then
                Anim = "Run"
                if attack == false then
                  handlewld.Part1 = RightArm
                  handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
                  wld1.C0 = clerp(wld1.C0, euler(3.14, 0, 0) * cf(0, -0.5, 0), 0.2)
                  Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.4)
                  RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0.3, 0, 0), 0.4)
                  RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.87, 0, -0.8) * euler(0, 0, 0), 0.4)
                  RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
                  LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.97, 0, 0.8) * euler(0, 0, 0), 0.4)
                  LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
                  RH.C0 = clerp(RH.C0, cf(1, -0.7, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.2), 0.4)
                  LH.C0 = clerp(LH.C0, cf(-1, -0.7, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, -0.2), 0.4)
                end
              end
            end
          end
        end
      end
    end
    if 0 < #Effects then
      for e = 1, #Effects do
        if Effects[e] ~= nil then
          local Thing = Effects[e]
          if Thing ~= nil then
            local Part = Thing[1]
            local Mode = Thing[2]
            local Delay = Thing[3]
            local IncX = Thing[4]
            local IncY = Thing[5]
            local IncZ = Thing[6]
            if Thing[2] == "CylinderClang" then
              if Thing[3] <= 1 then
                Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, 2.5 * Thing[5], 0) * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
                Thing[7] = Thing[1].CFrame
                effect("New Yeller", 0, Thing[8], Thing[7], nil, 0.1, 2)
                Thing[8] = Thing[7]
                Thing[3] = Thing[3] + Thing[4]
              else
                Part.Parent = nil
                table.remove(Effects, e)
              end
            end
            if Thing[2] == "showDamage" then
              if Thing[6] < Thing[5] then
                Thing[6] = Thing[6] + 1
              else
                if Thing[6] < Thing[7] then
                  Thing[4].position = Thing[4].position + vt(0, -0.2, 0)
                  Thing[6] = Thing[6] + 1
                else
                  if Thing[6] < Thing[8] then
                    Thing[6] = Thing[6] + 1
                  else
                    if Thing[6] < Thing[9] then
                      Thing[6] = Thing[6] + 1
                      Thing[4].position = Thing[4].position + vt(0, 0.2, 0)
                      Thing[3].TextStrokeTransparency = Thing[3].TextStrokeTransparency + 0.1
                      Thing[3].TextTransparency = Thing[3].TextTransparency + 0.1
                    else
                      Thing[1].Parent = nil
                      table.remove(Effects, e)
                    end
                  end
                end
              end
            end
            if Thing[2] == "CloneEf" then
              if Thing[3] <= 500 then
                Thing[3] = Thing[3] + 1
                if 10 <= Thing[4] then
                  Thing[4] = 0
                  Clone()
                end
                Thing[4] = Thing[4] + 1
              else
                table.remove(Effects, e)
              end
            end
            if Thing[2] == "DisCharge" then
              if 0 <= Thing[3] then
                passive1.Parent = Decrease
                passive2.Parent = Decrease
                if Thing[4] % 100 == 0 then
                  MagniDebuff(prt14, 50, "Movement", 0.2, 120)
                end
                if Thing[4] % 5 == 0 then
                  MagicCircle3(BrickColor.new(NewCol2), euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 5, 1, 5, -0.5, 5, -0.5, 0.1, prt14)
                end
                Thing[4] = Thing[4] + 1
                Thing[3] = Thing[3] - 1
              else
                print("end")
                distortcharge = false
                passive1.Parent = nil
                passive2.Parent = nil
                table.remove(Effects, e)
              end
            end
            if Thing[2] ~= "DecreaseStat" and Thing[2] ~= "showDamage" and Thing[2] ~= "CloneEf" and Thing[2] ~= "DisCharge" then
              if Thing[1].Transparency <= 1 then
                if Thing[2] == "Block1" then
                  Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                  Mesh = Thing[7]
                  Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                  Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                else
                  if Thing[2] == "Block2" then
                    Thing[1].CFrame = Thing[1].CFrame
                    Mesh = Thing[7]
                    Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                    Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                  else
                    if Thing[2] == "Cylinder" then
                      Mesh = Thing[7]
                      Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                      Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                    else
                      if Thing[2] == "Cylinder2" then
                        Mesh = Thing[7]
                        Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                        Thing[1].CFrame = cf(Thing[9].Position) * Thing[8]
                        Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                      else
                        if Thing[2] == "Blood" then
                          Mesh = Thing[7]
                          Thing[1].CFrame = Thing[1].CFrame * cf(0, Thing[8], 0)
                          Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                          Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                        else
                          if Thing[2] == "Elec" then
                            Mesh = Thing[7]
                            Mesh.Scale = Mesh.Scale + vt(Thing[7], Thing[8], Thing[9])
                            Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                          else
                            if Thing[2] == "Disappear" then
                              Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            end
                          end
                        end
                      end
                    end
                  end
                end
              else
                Part.Parent = nil
                table.remove(Effects, e)
              end
            end
          end
        end
      end
    end
    do
      fenbarmana2:TweenSize((UDim2.new(0.4, 0, -4 * mana.Value / 100, 0)), nil, 1, 0.4, true)
      fenbarmana4.Text = "Wakfu(" .. mana.Value .. ")"
      fenbarhp2.BackgroundColor3 = Color3.new(Humanoid.Health / Humanoid.MaxHealth, 0, 0)
      fenbarhp2:TweenSize((UDim2.new(Humanoid.Health / Humanoid.MaxHealth, 0, 1, 0)), nil, 1, 0.4, true)
      fenbarhp3.Text = "(" .. math.floor(Humanoid.Health) .. ")"
      fenbarblock2:TweenSize((UDim2.new(0.4, 0, -4 * distort / 100, 0)), nil, 1, 0.4, true)
      fenbarblock3.Text = "Distortion(" .. distort .. ")"
      fenbarmove1b:TweenSize((UDim2.new(1 * cooldowns[1] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
      fenbarmove2b:TweenSize((UDim2.new(1 * cooldowns[2] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
      fenbarmove3b:TweenSize((UDim2.new(1 * cooldowns[3] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
      fenbarmove4b:TweenSize((UDim2.new(1 * cooldowns[4] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
      for _,c in pairs(Decrease:children()) do
        if (c:findFirstChild("Duration")) ~= nil then
          c.Duration.Value = c.Duration.Value - 1
          if c.Duration.Value <= 0 then
            c.Parent = nil
          end
        end
        if c.Name == "DecreaseAtk" then
          decreaseatk = decreaseatk + c.Value
        else
          if c.Name == "DecreaseDef" then
            decreasedef = decreasedef + c.Value
          else
            if c.Name == "DecreaseMvmt" then
              decreasemvmt = decreasemvmt + c.Value
            end
          end
        end
      end
      Atk.Value = 1 - (decreaseatk)
      if Atk.Value <= 0 then
        Atk.Value = 0
      end
      Def.Value = 1 - (decreasedef)
      if Def.Value <= 0 then
        Def.Value = 0.01
      end
      Mvmt.Value = 1 - (decreasemvmt)
      if Mvmt.Value <= 0 then
        Mvmt.Value = 0
      end
      decreaseatk = 0
      decreasedef = 0
      decreasemvmt = 0
      AtkVal = Atk.Value * 100
      AtkVal = math.floor(AtkVal)
      AtkVal = AtkVal / 100
      fenbardamage.Text = "Damage\n(" .. AtkVal .. ")"
      DefVal = Def.Value * 100
      DefVal = math.floor(DefVal)
      DefVal = DefVal / 100
      fenbardef.Text = "Defense\n(" .. DefVal .. ")"
      MvmtVal = Mvmt.Value * 100
      MvmtVal = math.floor(MvmtVal)
      MvmtVal = MvmtVal / 100
      if Rooted.Value == true then
        MvmtVal = 0
      end
      fenbarmove.Text = "Walkspeed\n(" .. MvmtVal .. ")"
      if StunT.Value <= Stun.Value then
        fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4, 0)), nil, 1, 0.4, true)
      else
        fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4 * Stun.Value / StunT.Value, 0)), nil, 1, 0.4, true)
      end
      fenbarstun3.Text = "Stun(" .. Stun.Value .. ")"
      if 100 <= mana.Value then
        mana.Value = 100
      else
        if mananum <= 15 then
          mananum = mananum + 1
        else
          mananum = 0
          mana.Value = mana.Value + 1
        end
      end
      for i = 1, #cooldowns do
        if cooldownmax <= cooldowns[i] then
          cooldowns[i] = cooldownmax
        else
          cooldowns[i] = cooldowns[i] + cooldownsadd[i]
        end
      end
      -- DECOMPILER ERROR at PC5600: LeaveBlock: unexpected jumping out DO_STMT

      -- DECOMPILER ERROR at PC5600: LeaveBlock: unexpected jumping out DO_STMT

    end
  end
end]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="HopperBin" referent="RBXEBB9747F40C04ACC8DD3FFF16A254351">
			<Properties>
				<bool name="Active">false</bool>
				<token name="BinType">0</token>
				<string name="Name">Obsidian</string>
				<Content name="TextureId"><null></null></Content>
			</Properties>
			<Item class="LocalScript" referent="RBX0D2DF0C243AF4EBE9E257936C3C39913">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LocalScript</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[Player = game:GetService("Players").LocalPlayer
Character = Player.Character
PlayerGui = Player.PlayerGui
Backpack = Player.Backpack
Torso = Character.Torso
Head = Character.Head
Humanoid = Character.Humanoid
LeftArm = Character["Left Arm"]
LeftLeg = Character["Left Leg"]
RightArm = Character["Right Arm"]
RightLeg = Character["Right Leg"]
LS = Torso["Left Shoulder"]
LH = Torso["Left Hip"]
RS = Torso["Right Shoulder"]
RH = Torso["Right Hip"]
Neck = Torso.Neck
it = Instance.new
vt = Vector3.new
cf = CFrame.new
euler = CFrame.fromEulerAnglesXYZ
angles = CFrame.Angles
necko = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
necko2 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
LHC0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
LHC1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
RHC0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RHC1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RootPart = Character.HumanoidRootPart
RootJoint = RootPart.RootJoint
RootCF = euler(-1.57, 0, 3.14)
attack = false
attackdebounce = false
MMouse = nil
combo = 0
local hitfloor, posfloor = nil, nil
local idle = 0
local Anim = "Idle"
local Effects = {}
local Weapon = {}
local Welds = {}
local decreaseatk = 0
local decreasedef = 0
local decreasemvmt = 0
local Obelisks = {}
local maxobelisks = 16
local manaregain = 7
local passivenum = 30
local move1 = "(Z)\nEnergy Ball"
local move2 = "(X)\nFissure"
local move3 = "(C)\nReinforce"
local move4 = "(V)\nObelisk Field"
local cooldowns = {}
local cooldown1 = 0
table.insert(cooldowns, cooldown1)
local cooldown2 = 0
table.insert(cooldowns, cooldown2)
local cooldown3 = 0
table.insert(cooldowns, cooldown3)
local cooldown4 = 0
table.insert(cooldowns, cooldown4)
local cooldownsadd = {}
local cooldownadd1 = 0.35
table.insert(cooldownsadd, cooldownadd1)
local cooldownadd2 = 0.26
table.insert(cooldownsadd, cooldownadd2)
local cooldownadd3 = 0.1
table.insert(cooldownsadd, cooldownadd3)
local cooldownadd4 = 0.25
table.insert(cooldownsadd, cooldownadd4)
local cooldownmax = 100
--local damageFunc = workspace.damageFunc
player = nil
RSH = nil
LW = Instance.new("Motor")
RW = Instance.new("Motor")
RW.Name = "Right Shoulder"
LW.Name = "Left Shoulder"
LH = Torso["Left Hip"]
RH = Torso["Right Hip"]
TorsoColor = Torso.BrickColor
TorsoRed = TorsoColor.Color.r
TorsoGreen = TorsoColor.Color.g
TorsoBlue = TorsoColor.Color.b
NewCol = Color3.new(TorsoRed / 2, TorsoGreen / 2, 0.6)
NewCol2 = Color3.new(TorsoRed / 4, TorsoGreen / 4, 0.6)
if Player:findFirstChild("Color1") ~= nil then
  NewCol = Player.Color1.Value
end
if Player:findFirstChild("Color2") ~= nil then
  NewCol2 = Player.Color2.Value
end
local mdec = Instance.new("NumberValue", Decrease)
mdec.Name = "DecreaseDef"
mdec.Value = 0.4
local mdec2 = Instance.new("NumberValue", Decrease)
mdec2.Name = "DecreaseMvmt"
mdec2.Value = 0.1
local Animate = Humanoid.Animator
local canjump = true
removeControl = function()
  canjump = false
end
resumeControl = function()
  canjump = true
end
Player.Character.Humanoid.Changed:connect(function()
  if canjump == false then
    Player.Character.Humanoid.Jump = false
  end
end)
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

frame = 1 / 40
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 0, num do
			ArtificialHB.Event:wait()
		end
	end
end
if Character:findFirstChild("Hashira", true) ~= nil then
  Character:findFirstChild("Hashira", true).Parent = nil
end
if Player.PlayerGui:findFirstChild("WeaponGUI", true) ~= nil then
  Player.PlayerGui:findFirstChild("WeaponGUI", true).Parent = nil
end
if Character:findFirstChild("Stats", true) ~= nil then
  Character:findFirstChild("Stats", true).Parent = nil
end
local Stats = Instance.new("BoolValue")
Stats.Name = "Stats"
Stats.Parent = Character
local Atk = Instance.new("NumberValue")
Atk.Name = "Damage"
Atk.Parent = Stats
Atk.Value = 1
local Def = Instance.new("NumberValue")
Def.Name = "Defense"
Def.Parent = Stats
Def.Value = 1
local Mvmt = Instance.new("NumberValue")
Mvmt.Name = "Movement"
Mvmt.Parent = Stats
Mvmt.Value = 1
local Block = Instance.new("BoolValue")
Block.Name = "Block"
Block.Parent = Stats
Block.Value = false
local Stun = Instance.new("NumberValue")
Stun.Name = "Stun"
Stun.Parent = Stats
Stun.Value = 0
local StunT = Instance.new("NumberValue")
StunT.Name = "StunThreshold"
StunT.Parent = Stats
StunT.Value = 100
local Rooted = Instance.new("BoolValue")
Rooted.Name = "Rooted"
Rooted.Parent = Stats
Rooted.Value = false
local Stunned = Instance.new("BoolValue")
Stunned.Name = "Stunned"
Stunned.Parent = Stats
Stunned.Value = false
local Stagger = Instance.new("BoolValue")
Stagger.Name = "Stagger"
Stagger.Parent = Stats
Stagger.Value = false
local StaggerHit = Instance.new("BoolValue")
StaggerHit.Name = "StaggerHit"
StaggerHit.Parent = Stats
StaggerHit.Value = false
local RecentEnemy = Instance.new("ObjectValue")
RecentEnemy.Name = "RecentEnemy"
RecentEnemy.Parent = Stats
RecentEnemy.Value = nil
local Decrease = Instance.new("BoolValue")
Decrease.Name = "Decrease"
Decrease.Parent = Stats
Decrease.Value = false
local mana = Instance.new("NumberValue")
mana.Name = "Mana"
mana.Parent = Stats
mana.Value = 0
local passive = Instance.new("NumberValue", Decrease)
passive.Name = "DecreaseDef"
passive.Value = -1
passivenum2 = -1
local passive2 = Instance.new("NumberValue", Decrease)
passive2.Name = "DecreaseMvmt"
passive2.Value = passive.Value * -0.3
local passive3 = Instance.new("NumberValue", Decrease)
passive3.Name = "DecreaseAtk"
passive3.Value = 0.1
NoOutline = function(Part)
  Part.TopSurface = 10
end
part = function(formfactor, parent, reflectance, transparency, brickcolor, name, size)
  local fp = it("Part")
  fp.formFactor = formfactor
  fp.Parent = parent
  fp.Reflectance = reflectance
  fp.Transparency = transparency
  fp.CanCollide = false
  fp.Locked = true
  fp.BrickColor = brickcolor
  fp.Name = name
  fp.Size = size
  fp.Position = Torso.Position
  NoOutline(fp)
  fp.Material = "SmoothPlastic"
  fp:BreakJoints()
  return fp
end
mesh = function(Mesh, part, meshtype, meshid, offset, scale)
  local mesh = it(Mesh)
  mesh.Parent = part
  if Mesh == "SpecialMesh" then
    mesh.MeshType = meshtype
    if meshid ~= "nil" then
      mesh.MeshId = "http://www.roblox.com/asset/?id=" .. meshid
    end
  end
  mesh.Offset = offset
  mesh.Scale = scale
  return mesh
end
weld = function(parent, part0, part1, c0)
  local weld = it("Motor")
  weld.Parent = parent
  weld.Part0 = part0
  weld.Part1 = part1
  weld.C0 = c0
  return weld
end
gui = function(GuiType, parent, text, backtrans, backcol, pos, size)
  local gui = it(GuiType)
  gui.Parent = parent
  gui.Text = text
  gui.BackgroundTransparency = backtrans
  gui.BackgroundColor3 = backcol
  gui.SizeConstraint = "RelativeXY"
  gui.TextXAlignment = "Center"
  gui.TextYAlignment = "Center"
  gui.Position = pos
  gui.Size = size
  gui.Font = "SourceSans"
  gui.FontSize = "Size14"
  gui.TextWrapped = false
  gui.TextStrokeTransparency = 0
  gui.TextColor = BrickColor.new("White")
  return gui
end
local Color1 = Torso.BrickColor
local fengui = it("GuiMain")
fengui.Parent = Player.PlayerGui
fengui.Name = "WeaponGUI"
local fenframe = it("Frame")
fenframe.Parent = fengui
fenframe.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe.BackgroundTransparency = 1
fenframe.BorderColor3 = Color3.new(17, 17, 17)
fenframe.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe.Position = UDim2.new(0.95, 0, 0.7, 0)
local fenframe2 = it("Frame")
fenframe2.Parent = fengui
fenframe2.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe2.BackgroundTransparency = 1
fenframe2.BorderColor3 = Color3.new(17, 17, 17)
fenframe2.Size = UDim2.new(0.2, 0, 0.1, 0)
fenframe2.Position = UDim2.new(0.4, 0, 0.85, 0)
local fenframe3 = it("Frame")
fenframe3.Parent = fengui
fenframe3.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe3.BackgroundTransparency = 1
fenframe3.BorderColor3 = Color3.new(17, 17, 17)
fenframe3.Size = UDim2.new(0.2, 0, 0.2, 0)
fenframe3.Position = UDim2.new(0.8, 0, 0.8, 0)
local fenframe4 = it("Frame")
fenframe4.Parent = fengui
fenframe4.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe4.BackgroundTransparency = 1
fenframe4.BorderColor3 = Color3.new(17, 17, 17)
fenframe4.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe4.Position = UDim2.new(0, 0, 0.7, 0)
local pressedf = false
local fenframe5 = it("Frame")
fenframe5.Parent = fengui
fenframe5.BackgroundColor3 = Color3.new(0, 0, 0)
fenframe5.BackgroundTransparency = 1
fenframe5.BorderColor3 = Color3.new(0, 0, 0)
fenframe5.Size = UDim2.new(1, 0, 1, 0)
fenframe5.Position = UDim2.new(0, 0, 0, 0)
fenframe5.ZIndex = 2
local tellbar = gui("TextLabel", fenframe5, "-No longer a limit to how many obelisks can be placed (+)\n-Summoning an obelisk mana cost decreased (+)\n-Mana cost of obelisk-related abilities reduced (+)\n-Obelisk Hop changed to Obelisk Field which slams the ground with Hashira, dealing an AOE damage and creating up to 5 obelisks depending on how much mana is left (+)\n-Mana regain slightly increased (+)\n-Reinforce changed to giving Obsidian a defense buff and movement debuff for a couple of seconds (+/-)\n-Fissure changed to be an AOE around Obsidian. Cooldown increased (+/-)\n-Obelisks slightly lasts shorter (-)\n-Obsidian\'s Obsidian Armor now depends on how many obelisks there are on the field. The more obelisks there are, the lower Obsidian Armor\'s defense is (-)\n-General damage and debuffs of Obsidian\'s combos, abilities, and AOE reduced (-)", 1, Color3.new(0, 0, 0), UDim2.new(0.25, 0, 0.25, 0), UDim2.new(0.5, 0, 0.5, 0))
tellbar.Font = "Arial"
tellbar.TextScaled = true
tellbar.TextTransparency = 1
tellbar.TextStrokeTransparency = 1
tellbar.ZIndex = 2
local fnumb = 0
local fenbarmana1 = gui("TextLabel", fenframe, "", 0, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarmana2 = gui("TextLabel", fenframe, "", 0, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarmana4 = gui("TextLabel", fenframe, "Mana(" .. mana.Value .. ")", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbardamage = gui("TextLabel", fenframe2, "Damage", 0.55, Color3.new(0.6078431372549, 0, 0), UDim2.new(-0.23, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbardef = gui("TextLabel", fenframe2, "Defense", 0.55, Color3.new(0, 0, 0.6078431372549), UDim2.new(-0.46, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarmove = gui("TextLabel", fenframe2, "Walkspeed", 0.55, Color3.new(0, 0.6078431372549, 0), UDim2.new(1.03, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarhp1 = gui("TextLabel", fenframe2, "", 0, Color3.new(0, 0, 0), UDim2.new(-0.46, 0, 1, 0), UDim2.new(1.92, 0, 0.4, 0))
local fenbarhp2 = gui("TextLabel", fenbarhp1, "", 0, Color3.new(1, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarhp3 = gui("TextLabel", fenbarhp1, "(100)", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
local fenbarstun1 = gui("TextLabel", fenframe4, "", 0, Color3.new(0, 0, 0), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarstun2 = gui("TextLabel", fenframe4, "", 0, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarstun3 = gui("TextLabel", fenframe4, "Stun(" .. Stun.Value .. ")", 1, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbarmove1 = gui("TextButton", fenframe3, move1, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove1.ZIndex = 2
local fenbarmove1b = gui("TextLabel", fenbarmove1, "", 0.55, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove2 = gui("TextButton", fenframe3, move2, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove2.ZIndex = 2
local fenbarmove2b = gui("TextLabel", fenbarmove2, "", 0.55, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove3 = gui("TextButton", fenframe3, move3, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove3.ZIndex = 2
local fenbarmove3b = gui("TextLabel", fenbarmove3, "", 0.55, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove4 = gui("TextButton", fenframe3, move4, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove4.ZIndex = 2
local fenbarmove4b = gui("TextLabel", fenbarmove4, "", 0.55, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbaroblsk1 = gui("TextButton", fenframe2, "Obelisks", 0.55, BrickColor.new(NewCol2).Color, UDim2.new(1.26, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local modelzorz = Instance.new("Model")
modelzorz.Parent = Character
modelzorz.Name = "Hashira"
local prt1 = part(3, modelzorz, 0, 0, TorsoColor, "Part01", vt())
local prt2 = part(3, modelzorz, 0.5, 0, BrickColor.new("Light stone grey"), "Part02", vt())
local prt3 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part03", vt())
local prt4 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part04", vt())
local prt5 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part05", vt())
local prt6 = part(3, modelzorz, 0.5, 0, BrickColor.new("Light stone grey"), "Part06", vt())
local prt7 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part07", vt())
local prt8 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part08", vt())
local prt9 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part09", vt())
local prt10 = part(3, modelzorz, 0.5, 0, BrickColor.new("Light stone grey"), "Part10", vt())
local prt11 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol), "Part11", vt())
local prt12 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Part12", vt())
local prt13 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol), "Part13", vt())
local prt14 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Part14", vt())
local prt15 = part(3, modelzorz, 0.2, 0, BrickColor.new(NewCol), "Part15", vt())
local prt16 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Part16", vt())
local prt17 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Part17", vt())
local prt18 = part(3, modelzorz, 0.5, 0, BrickColor.new("Light stone grey"), "Part18", vt())
local prt19 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part19", vt())
local prt20 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part20", vt())
local msh1 = mesh("BlockMesh", prt1, "", "", vt(0, 0, 0), vt(1, 1, 1))
local msh2 = mesh("CylinderMesh", prt2, "", "", vt(0, 0, 0), vt(2, 20, 2))
local msh3 = mesh("SpecialMesh", prt3, "FileMesh", "1778999", vt(0, 0, 0), vt(0.8, 0.8, 0.8))
local msh4 = mesh("CylinderMesh", prt4, "", "", vt(0, 0, 0), vt(5, 0.5, 5))
local msh5 = mesh("CylinderMesh", prt5, "", "", vt(0, 0, 0), vt(3, 10, 3))
local msh6 = mesh("CylinderMesh", prt6, "", "", vt(0, 0, 0), vt(4, 3, 4))
local msh7 = mesh("SpecialMesh", prt7, "FileMesh", "9756362", vt(0, 0, 0), vt(0.8, 1, 0.8))
local msh8 = mesh("SpecialMesh", prt8, "FileMesh", "1778999", vt(0, 0, 0), vt(0.8, 0.8, 0.8))
local msh9 = mesh("CylinderMesh", prt9, "", "", vt(0, 0, 0), vt(5.4, 2, 5.4))
local msh10 = mesh("CylinderMesh", prt10, "", "", vt(0, 0, 0), vt(4.5, 1, 4.5))
local msh11 = mesh("BlockMesh", prt11, "", "", vt(0, 0, 0), vt(10, 6, 6))
local msh12 = mesh("BlockMesh", prt12, "", "", vt(0, 0, 0), vt(10, 4, 7))
local msh13 = mesh("BlockMesh", prt13, "", "", vt(0, 0, 0), vt(15, 6, 5.9))
local msh14 = mesh("BlockMesh", prt14, "", "", vt(0, 0, 0), vt(13, 4, 6.9))
local msh15 = mesh("BlockMesh", prt15, "", "", vt(0, 0, 0), vt(15, 6, 5.9))
local msh16 = mesh("BlockMesh", prt16, "", "", vt(0, 0, 0), vt(13, 4, 6.9))
local msh17 = mesh("CylinderMesh", prt17, "", "", vt(0, 0, 0), vt(6, 2, 6))
local msh18 = mesh("SpecialMesh", prt18, "FileMesh", "1778999", vt(0, 0, 0), vt(0.9, 0.3, 0.9))
local msh19 = mesh("SpecialMesh", prt19, "FileMesh", "9756362", vt(0, 0, 0), vt(1.5, 1.2, 1.2))
local msh20 = mesh("SpecialMesh", prt20, "FileMesh", "9756362", vt(0, 0, 0), vt(1.5, 1.2, 1.2))
local wld1 = weld(prt1, prt1, Torso, euler(0, 0, -2.5) * cf(-1.4, -2, -0.6))
local wld2 = weld(prt1, prt2, prt1, euler(0, 0, 0) * cf(0, 0, 0))
local wld3 = weld(prt1, prt3, prt2, euler(0, 0, 0) * cf(0, 2, 0))
local wld4 = weld(prt1, prt4, prt3, euler(0, 0, 0) * cf(0, 0.6, 0))
local wld5 = weld(prt1, prt5, prt2, euler(0, 0, 0) * cf(0, -1, 0))
local wld6 = weld(prt1, prt6, prt5, euler(0, 0, 0) * cf(0, -1, 0))
local wld7 = weld(prt1, prt7, prt6, euler(0, 0, 0) * cf(0, 0, 0))
local wld8 = weld(prt1, prt8, prt6, euler(3.14, 0, 0) * cf(0, 0, 0))
local wld9 = weld(prt1, prt9, prt8, euler(0, 0, 0) * cf(0, 0.85, 0))
local wld10 = weld(prt1, prt10, prt9, euler(0, 0, 0) * cf(0, 0.3, 0))
local wld11 = weld(prt1, prt11, prt10, euler(0, 0, 0) * cf(0, 0.7, 0))
local wld12 = weld(prt1, prt12, prt11, euler(0, 0, 0) * cf(0, 0, 0))
local wld13 = weld(prt1, prt13, prt11, cf(1.45, 0, 0) * euler(0, 0, 0.2) * cf(0.9, 0, 0))
local wld14 = weld(prt1, prt14, prt13, euler(0, 0, 0) * cf(-0.2, 0, 0))
local wld15 = weld(prt1, prt15, prt11, cf(-1.45, 0, 0) * euler(0, 0, -0.2) * cf(-0.9, 0, 0))
local wld16 = weld(prt1, prt16, prt15, euler(0, 0, 0) * cf(0.2, 0, 0))
local wld17 = weld(prt1, prt17, prt11, euler(0, 0, 0) * cf(0, 0.8, 0))
local wld18 = weld(prt1, prt18, prt17, euler(3.14, 0, 0) * cf(0, 0.45, 0))
local wld19 = weld(prt1, prt19, prt13, euler(0.785, 0, 0) * cf(1.5, 0, 0))
local wld20 = weld(prt1, prt20, prt15, euler(0.785, 0, 0) * cf(-1.5, 0, 0))
theprt = prt13
eul = -1.57
for i = 1, 2 do
  if i == 2 then
    theprt = prt15
  end
  eul1 = 0
  for b = 0.8, -1.6, -1.6 do
    num = -1
    for j = 1, 3 do
      local prt21 = part(3, modelzorz, 0.5, 0, BrickColor.new("Light stone grey"), "Part21", vt())
      local msh21 = mesh("SpecialMesh", prt21, "Wedge", "nil", vt(0, 0, 0), vt(1, 2, 2))
      local wld21 = weld(prt1, prt21, theprt, euler(1.57, eul, eul1) * cf(num, b, 0))
      num = num + 1
    end
    if i == 1 then
      eul1 = eul1 + 1.57
    else
      eul1 = eul1 - 1.57
    end
  end
  eul = eul + 3.14
end
for _,c in pairs(modelzorz:children()) do
  table.insert(Weapon, c)
end
for _,c in pairs(prt1:children()) do
  if c.className == "Motor" then
    table.insert(Welds, c)
  end
end
local hitbox = part(3, modelzorz, 0, 1, BrickColor.new("Black"), "Hitbox2", vt())
hitbox.Anchored = false
local hbwld = weld(hitbox, hitbox, RootPart, euler(0, 0, 0) * cf(0, 0, 0))
local hitbox2 = part(3, nil, 0, 1, BrickColor.new("Black"), "Hitbox", vt(1, 1, 1))
hitbox2.Anchored = true
local hitboxCF = cf(0, 0, 0)
hboxpos = Instance.new("BodyPosition", nil)
hboxpos.P = 2000
hboxpos.D = 100
hboxpos.maxForce = Vector3.new(545000, 545000, 545000)
hitboxweld = function()
  hbwld.Parent = modelzorz
  hbwld.Part0 = hitbox
  hbwld.Part1 = prt11
end
if script.Parent.className ~= "HopperBin" then
  Tool = Instance.new("HopperBin")
  Tool.Parent = Backpack
  Tool.Name = "Hashira"
  script.Parent = Tool
end
Bin = script.Parent
if Bin.Name == "Obsidian: Apocrea" then
  Bin.Name = "Hashira"
end
local bodvel = Instance.new("BodyVelocity")
local bg = Instance.new("BodyGyro")
so = function(id, par, vol, pit)
  local sou = Instance.new("Sound", par or workspace)
  sou.Volume = vol
  sou.Pitch = pit or 1
  sou.SoundId = "http://www.roblox.com/asset/?id=" .. id
  coroutine.resume(coroutine.create(function(Sound)
    swait()
    Sound:play()
  end), sou)
  game:GetService("Debris"):AddItem(sou, 6)
end
function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end
hideanim = function()
  equipped = false
  for i = 0, 1, 0.1 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(0.2, 0, 0) * cf(0, 1, 0.2) * euler(0, 0, -0.4), 0.3)
    wld2.C0 = clerp(wld2.C0, euler(0, 0.2, 0) * cf(0, -0.4, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.4, 0, -0.6), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.8, 0) * euler(3.3, 0, 0.4), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.3)
  end
  mdec2.Parent = nil
  mdec.Parent = Decrease
  wld1.Part1 = Torso
  wld1.C0 = euler(0, 0, -2.5) * cf(-1.4, -2, -0.6)
  wld2.C0 = euler(0, 0, 0) * cf(0, 0, 0)
  for i = 0, 1, 0.2 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.5)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.5)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 0), 0.5)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, 0), 0.5)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.5)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.5)
  end
end
mdec.Parent = Decrease
equipanim = function()
  equipped = true
  mdec.Parent = nil
  mdec2.Parent = Decrease
  for i = 0, 1, 0.1 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.4, 0, -0.6), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.8, 0) * euler(3.3, 0, 0.4), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.3)
  end
  wld1.Part1 = RightArm
  wld1.C0 = euler(0.2, 0, 0) * cf(0, 1, 0.2) * euler(0, 0, -0.4)
  wld2.C0 = euler(0, 0.2, 0) * cf(0, -0.4, 0)
end
StaggerAnim = function()
  attack = true
  removeControl()
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.35 do
    swait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -40
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, -0.4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.7) * euler(0, -0.7, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  for i = 0, 1, 0.2 do
    swait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -40
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(-0.5, 0, -0.4), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.7) * euler(0, -0.7, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.5), 0.4)
  end
  for i = 0, 1, 0.1 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
    wld2.C0 = clerp(wld2.C0, euler(0, 2.74, 0) * cf(0, -1, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(0.5, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.8) * euler(-0.2, 0, -0.4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.3, 0, 0.4) * euler(0, -0.4, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.3, 0, -0.2) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 1.2), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, 0, -1) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  for i = 1, 50 do
    swait()
    if StunT.Value <= Stun.Value then
      break
    end
  end
  do
    resumeControl()
    combo = 0
    attack = false
  end
end
StaggerHitt = function()
  attack = true
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.1 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
    wld2.C0 = clerp(wld2.C0, euler(0, 1.57, 0) * cf(0, -1, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.7) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, -0.6), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.8) * euler(0, 0, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.2), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, -0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  attack = false
end
StunAnim = function()
  attack = true
  removeControl()
  Stunned.Value = true
  showDamage(Character, "Stunned", "Interrupt")
  local dec = Instance.new("NumberValue", Decrease)
  dec.Name = "DecreaseMvmt"
  dec.Value = 10
  for i = 0, 1, 0.3 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
    wld2.C0 = clerp(wld2.C0, euler(0, 1.57, 0) * cf(0, -1, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.2, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1, 0, 0.4) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.3), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, 0), 0.25)
  end
  for i = 0, 1, 0.3 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
    wld2.C0 = clerp(wld2.C0, euler(0, 1.57, 0) * cf(0, -1, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0.8, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1.2, 0, 0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(0.1, 0, 0.7), 0.25)
  end
  for i = 0, 1, 0.3 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
    wld2.C0 = clerp(wld2.C0, euler(0, 1.57, 0) * cf(0, -1, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -1), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1.57, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, -0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.1, 0, 0.3), 0.25)
  end
  local gairost = Instance.new("BodyGyro")
  gairost.Parent = RootPart
  gairost.maxTorque = Vector3.new(400000, 0, 400000) * math.huge
  gairost.P = 20000
  gairost.cframe = cf(0, 0, 0)
  for i = 0, 1, 0.1 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
    wld2.C0 = clerp(wld2.C0, euler(0, 1.57, 0) * cf(0, -1, 0), 0.3)
    if hitfloor ~= nil then
      Torso.Velocity = vt(0, 0, 0)
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2.5) * euler(1.57, 0, -3.14), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1.5) * euler(0.2, 0, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.5, 0, -1.57) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 0), 0.3)
  end
  for i = 1, 70 do
    swait()
    gairost.cframe = RootPart.CFrame
    if hitfloor ~= nil then
      Torso.Velocity = vt(0, 0, 0)
    end
  end
  for i = 0, 1, 0.2 do
    swait()
    Stun.Value = 0
    gairost.cframe = RootPart.CFrame
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1, 0, -4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1) * euler(0.2, -1, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, 0.2) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, -1) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 1), 0.3)
  end
  resumeControl()
  gairost.Parent = nil
  dec.Parent = nil
  Stun.Value = 0
  combo = 0
  Stunned.Value = false
  attack = false
  for i = 1, 10 do
    swait()
    Stun.Value = 0
  end
end
attackone = function()
  attack = true
  for i = 0, 1, 0.1 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(0.3, 0, -0.2) * cf(0, 1, 0), 0.3)
    wld2.C0 = clerp(wld2.C0, euler(0, 1.57, 0) * cf(0, -1, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.2), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -1), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.2, 0, 1) * euler(0, -1, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(0.2, 0.5, -0.5) * euler(0.8, 0, 2.2), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.9, -1, -0.3) * euler(0, 1.57, 0) * euler(0, 1, -0.2), 0.3)
    LH.C0 = clerp(LH.C0, cf(-0.9, -1, 0.3) * euler(0, -1.57, 0) * euler(0, 1, -0.05), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC213: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC213: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("203691447", prt11, 1, 1)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(9, 2.5, 1.5)
  hitboxCF = prt11.CFrame * cf(0, 0.5, 0)
  hitbox.CFrame = hitboxCF
  for i = 0, 1, 0.08 do
    swait()
    hitboxCF = prt11.CFrame * cf(0, 0.5, 0)
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 8, 4, 6, math.random(2, 5), "Normal", RootPart, 0.5, 2, (math.random(3, 5)), nil, true)
    wld1.C0 = clerp(wld1.C0, euler(2.2, 0, -0.2) * cf(0, 1, 0), 0.25)
    wld2.C0 = clerp(wld2.C0, euler(0, 1.57, 0) * cf(0, -0.6, 0), 0.25)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.6), 0.25)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1), 0.25)
    RW.C0 = clerp(RW.C0, cf(0.8, 0.5, -0.5) * euler(1.4, 0, -1.2) * euler(0, -1.4, 0), 0.25)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.25)
    LW.C0 = clerp(LW.C0, cf(-1.3, 0.5, -0.3) * euler(1.4, 0, 0.2), 0.25)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.25)
    RH.C0 = clerp(RH.C0, cf(0.9, -1, 0.3) * euler(0, 1.57, 0) * euler(0, -1, 0), 0.25)
    LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.3) * euler(0, -1.57, 0) * euler(0, -1, 0), 0.25)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC492: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC492: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
attacktwo = function()
  attack = true
  for i = 0, 1, 0.07 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(2.8, 0, -0.2) * cf(0, 1, 0), 0.2)
    wld2.C0 = clerp(wld2.C0, euler(0, 1.57, 0) * cf(0, -0.6, 0), 0.2)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.2), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1.2), 0.2)
    RW.C0 = clerp(RW.C0, cf(0.8, 0.5, -0.5) * euler(1, 0, -1.2) * euler(0, -1.4, 0), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, 0.4), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(0.7, -1, 0.3) * euler(0, 1.57, 0) * euler(0, -1.2, 0), 0.2)
    LH.C0 = clerp(LH.C0, cf(-0.7, -1, -0.3) * euler(0, -1.57, 0) * euler(0, -1.2, 0), 0.2)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC213: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC213: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("203691467", prt11, 1, 1)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(9, 2.5, 1.5)
  hitboxCF = prt11.CFrame * cf(0, 0.5, 0)
  hitbox.CFrame = hitboxCF
  for i = 0, 1, 0.08 do
    swait()
    hitboxCF = prt11.CFrame * cf(0, 0.5, 0)
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 8, 4, 6, math.random(2, 5), "Normal", RootPart, 0.5, 2, (math.random(3, 5)), nil, true)
    wld1.C0 = clerp(wld1.C0, euler(3.8, 0, -0.2) * cf(0, 1, 0), 0.3)
    wld2.C0 = clerp(wld2.C0, euler(0, 1.57, 0) * cf(0, -0.2, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -1), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.4, 0, 1.2) * euler(0, -2.4, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1, 0, 1), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.9, -1, -0.3) * euler(0, 1.57, 0) * euler(0, 1, -0.2), 0.3)
    LH.C0 = clerp(LH.C0, cf(-0.9, -1, 0.3) * euler(0, -1.57, 0) * euler(0, 1, -0.05), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC492: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC492: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
attackthree = function()
  attack = true
  for i = 0, 1, 0.1 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * cf(0, 1, 0), 0.3)
    wld2.C0 = clerp(wld2.C0, euler(0, 2.37, 0) * cf(0, -0.4, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1, 1.2, 0) * euler(3.6, 0, -0.8), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1, 1.2, 0) * euler(3.6, 0, 0.8), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, -0.2), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0.2), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC207: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC207: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("203691492", prt11, 1, 1)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(9, 2.5, 1.5)
  hitboxCF = prt11.CFrame * cf(0, 0.5, 0)
  hitbox.CFrame = hitboxCF
  for i = 0, 1, 0.1 do
    swait()
    hitboxCF = prt11.CFrame * cf(0, 0.5, 0)
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 8, 4, 6, math.random(2, 5), "Normal", RootPart, 0.5, 2, (math.random(3, 5)), nil, true)
    wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * cf(0, 1, 0), 0.4)
    wld2.C0 = clerp(wld2.C0, euler(0, 2.37, 0) * cf(0, -0.4, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.4, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1, 0.3, -0.5) * euler(0.5, 0, -0.8), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1, 0.3, -0.5) * euler(0.5, 0, 0.8), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.3), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, -0.7), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC480: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC480: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
attackfour = function()
  attack = true
  for i = 0, 1, 0.1 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(2.2, 0, -0.2) * cf(0, 1, 0), 0.3)
    wld2.C0 = clerp(wld2.C0, euler(0, 1.57, 0) * cf(0, -0.6, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.2), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -1), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.4, 0, 0.2) * euler(0, -1.4, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(0, 0.5, -0.5) * euler(1.4, 0, 1), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.9, -1, -0.3) * euler(0, 1.57, 0) * euler(0, 1, -0.2), 0.3)
    LH.C0 = clerp(LH.C0, cf(-0.9, -1, 0.3) * euler(0, -1.57, 0) * euler(0, 1, -0.05), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC213: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC213: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("203691447", prt11, 1, 1)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(9, 2.5, 1.5)
  hitboxCF = prt11.CFrame * cf(0, 0.5, 0)
  hitbox.CFrame = hitboxCF
  CF = RootPart.CFrame.lookVector
  for i = 0, 1, 0.03 do
    swait()
    if i == 0.21 or i >= 0.48 and i <= 0.51 then
      so("203691447", prt11, 1, 1)
    end
    hitboxCF = prt11.CFrame * cf(0, 0.5, 0)
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 8, 4, 6, math.random(2, 5), "Normal", RootPart, 0.4, 2, (math.random(3, 5)), nil, true)
    wld1.C0 = clerp(wld1.C0, euler(2.2, 0, -0.2) * cf(0, 1, 0), 0.3)
    wld2.C0 = clerp(wld2.C0, euler(0, 1.57, 0) * cf(0, -0.6, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.6), 0.3)
    RootJoint.C0 = RootCF * euler(0, 0, -1 + 17 * i)
    RW.C0 = clerp(RW.C0, cf(0.8, 0.5, -0.5) * euler(1.4, 0, -1.2) * euler(0, -1.4, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.3, 0.5, -0.3) * euler(1.4, 0, 0.2), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.9, -1, 0.3) * euler(0, 1.57, 0) * euler(0, -1, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-0.9, -1, -0.3) * euler(0, -1.57, 0) * euler(0, -1, 0), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC504: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC504: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
Obelisk = function()
  attack = true
  if #Obelisks < maxobelisks then
    for i = 0, 1, 0.2 do
      swait()
      wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * cf(0, 1, 0), 0.4)
      wld2.C0 = clerp(wld2.C0, euler(0, 2.37, 0) * cf(0, -0.4, 0), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, 0), 0.4)
      RW.C0 = clerp(RW.C0, cf(1, 1.2, 0) * euler(3.6, 0, -0.8), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1, 1.2, 0) * euler(3.6, 0, 0.8), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, -0.2), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0.2), 0.4)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC212: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC212: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = 10
    hbwld.Parent = nil
    hboxpos.Parent = hitbox
    hitbox.Parent = modelzorz
    hitbox.Size = vt(9, 2.5, 1.5)
    hitboxCF = prt11.CFrame * cf(0, 0.5, 0)
    hitbox.CFrame = hitboxCF
    for i = 0, 1, 0.25 do
      swait()
      hitboxCF = prt11.CFrame * cf(0, 0.5, 0)
      hitbox.CFrame = hitboxCF
      MagniDamage(hitbox, 8, 4, 6, math.random(2, 5), "Normal", RootPart, 0.5, 2, 2, nil, true)
      wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * cf(0, 1, 0), 0.5)
      wld2.C0 = clerp(wld2.C0, euler(0, 2.37, 0) * cf(0, -0.4, 0), 0.5)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.5)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.4, 0, 0), 0.5)
      RW.C0 = clerp(RW.C0, cf(1, 0.3, -0.5) * euler(0.5, 0, -0.8), 0.5)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
      LW.C0 = clerp(LW.C0, cf(-1, 0.3, -0.5) * euler(0.5, 0, 0.8), 0.5)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.3), 0.5)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, -0.7), 0.5)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC482: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC482: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    hitbox.Parent = modelzorz
    hitbox.Size = vt()
    hitboxweld()
    hboxpos.Parent = nil
    MagicCircle(BrickColor.new(NewCol2), cf(prt13.Position), 1, 1, 1, 5, 5, 5, 0.1)
    local MouseLook = cf((RootPart.Position + MMouse.Hit.p) / 2, MMouse.Hit.p)
    local hit, pos = rayCast(RootPart.Position, MouseLook.lookVector, 50, Character)
    ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
    ref.Anchored = true
    ref.CFrame = cf(pos) * cf(0, 3, 0)
    game:GetService("Debris"):AddItem(ref, 1)
    hitfloor, posfloor = rayCast(ref.Position, CFrame.new(ref.Position, ref.Position - Vector3.new(0, 1, 0)).lookVector, 100, Character)
    if hitfloor ~= nil and mana.Value >= 10 then
      mana.Value = mana.Value - 10
      local refsate = part(3, workspace, 0, 1, BrickColor.new("White"), "Reference", vt())
      refsate.Anchored = true
      refsate.CFrame = cf(posfloor)
      game:GetService("Debris"):AddItem(refsate, 1)
      local obe = Instance.new("Model", workspace)
      obe.Name = "Obelisk"
      game:GetService("Debris"):AddItem(obe, 20)
      table.insert(Obelisks, obe)
      local oprt1 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part01", vt())
      local oprt2 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part02", vt())
      local oprt6 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part06", vt())
      local oprt7 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part07", vt())
      local oprt8 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part08", vt())
      local oprt9 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part09", vt())
      local oprt10 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part10", vt())
      local omsh1 = mesh("BlockMesh", oprt1, "", "", vt(0, 0, 0), vt(1, 1, 1))
      local omsh2 = mesh("BlockMesh", oprt2, "", "", vt(0, 0, 0), vt(7, 20, 7))
      local omsh6 = mesh("SpecialMesh", oprt6, "FileMesh", "9756362", vt(0, 0, 0), vt(1.4, 1, 1.4))
      local omsh7 = mesh("SpecialMesh", oprt7, "FileMesh", "9756362", vt(0, 0, 0), vt(1.2, math.random(100, 250) / 100, 1.5))
      local omsh8 = mesh("SpecialMesh", oprt8, "FileMesh", "9756362", vt(0, 0, 0), vt(1.2, math.random(100, 250) / 100, 1.5))
      local omsh9 = mesh("SpecialMesh", oprt9, "FileMesh", "9756362", vt(0, 0, 0), vt(1.2, math.random(100, 250) / 100, 1.5))
      local omsh10 = mesh("SpecialMesh", oprt10, "FileMesh", "9756362", vt(0, 0, 0), vt(1.2, math.random(100, 250) / 100, 1.5))
      local owld2 = weld(oprt2, oprt2, oprt1, euler(0, 0, 0) * cf(0, 0, 0))
      local owld6 = weld(oprt6, oprt6, oprt2, euler(0, 0.785, 0) * cf(0, -2, 0))
      local owld7 = weld(oprt7, oprt7, oprt2, euler(-0.5, 0.785, 0.5) * cf(0.5, 2, 0.5))
      local owld8 = weld(oprt8, oprt8, oprt2, euler(0.5, 0.785, -0.5) * cf(-0.5, 2, -0.5))
      local owld9 = weld(oprt9, oprt9, oprt2, euler(0.5, -0.785, 0.5) * cf(0.5, 2, -0.5))
      local owld10 = weld(oprt10, oprt10, oprt2, euler(-0.5, -0.785, -0.5) * cf(-0.5, 2, 0.5))
      eul = 0
      for i = 1, 4 do
        local oprt3 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part03", vt())
        local omsh3 = mesh("SpecialMesh", oprt3, "Wedge", "nil", vt(0, 0, 0), vt(7, 20, 2))
        local owld3 = weld(oprt3, oprt3, oprt2, euler(0, 0, 0) * cf(0, 0, 0.9) * euler(0, eul, 0))
        local oprt4 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part04", vt())
        local omsh4 = mesh("SpecialMesh", oprt4, "FileMesh", "11294911", vt(0, 0, 0), vt(0.8, 8.2, 0.8))
        local owld4 = weld(oprt4, oprt4, oprt3, euler(0, 1.57, 0) * cf(0.9, -0.05, 0))
        local oprt5 = part(3, obe, 0, 0, BrickColor.new("Black"), "Obelisk Part05", vt())
        local omsh5 = mesh("SpecialMesh", oprt5, "Wedge", "nil", vt(0, 0, 0), vt(4, 15, 3))
        local owld5 = weld(oprt5, oprt5, oprt3, euler(0, 0, 0) * cf(0, -0.5, 0))
        eul = eul + 1.57
      end
      for i = 1, 5 do
        local oprt11 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part11", vt())
        num = math.random(10, 40) / 100
        local omsh11 = mesh("SpecialMesh", oprt11, "FileMesh", "9756362", vt(0, 0, 0), vt(num, math.random(60, 150) / 100, num))
        local owld11 = weld(oprt11, oprt11, oprt2, euler(0, 0, -math.random(20, 50) / 100) * cf(math.random(100, 300) / 100, math.random(100, 500) / 100, 0) * euler(0, math.random(-50, 50), 0))
      end
      oprt1.CFrame = refsate.CFrame
      so("203691785", oprt1, 1, 1)
      so("183763487", oprt1, 1, 1)
      f = Instance.new("BodyPosition", oprt1)
      f.P = 2000
      f.D = 100
      f.maxForce = Vector3.new(545000, 545000, 545000)
      f.position = refsate.Position + vt(0, math.random(700, 900) / 100, 0)
      ogy = Instance.new("BodyGyro", oprt1)
      ogy.maxTorque = Vector3.new(400000, 400000, 400000)
      ogy.P = 2000
      ogy.D = 100
      ogy.cframe = cf(0, math.random(-314, 314) / 100, 0)
      for i = 1, 5 do
        MagicObsidian(BrickColor.new(NewCol2), cf(refsate.Position) * cf(math.random(-500, 500) / 100, 0, math.random(-500, 500) / 100), 1, 1, 1, 0, 0, 0, math.random(2, 10) / 100)
      end
      MagicBlock(BrickColor.new(NewCol2), cf(oprt1.Position) * cf(0, 1, 0) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 4, 4, 4, 0.05, 2)
      MagniDamage(oprt1, 20, 10, 13, math.random(-15, -10), "Knockdown2", RootPart, 0, 1, (math.random(3, 4)), nil, nil, true, "Defense", 0.03, 300)
      table.insert(Effects, {obe, "Obelisk", 0, 0, oprt1, 0, #Obelisks})
    end
    do
      do
        swait(5)
        dec.Parent = nil
        attack = false
      end
    end
  end
end
do1 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[1] and #Obelisks * 4 <= mana.Value and #Obelisks > 0 then
    attack = true
    cooldowns[1] = 0
    for i = 0, 1, 0.1 do
      swait()
      wld1.C0 = clerp(wld1.C0, euler(0.2, 0, -0.2) * cf(0, 1, 0.2), 0.3)
      wld2.C0 = clerp(wld2.C0, euler(0, 1.57, 0) * cf(0, -1.4, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(0.2, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.5, 0, 0.8), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.8, 0, 1), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(0.7, -1, -0.3) * euler(0, 1.57, 0) * euler(0, 1, -0.2), 0.3)
      LH.C0 = clerp(LH.C0, cf(-0.7, -1, 0.3) * euler(0, -1.57, 0) * euler(0, 1, 0), 0.3)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC256: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC256: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    so("2101137", LeftArm, 1, 1)
    for i = 1, 20 do
      swait()
      MagicBlock(BrickColor.new(NewCol2), LeftArm.CFrame * cf(0, -1, 0) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 2, 2, 2, 0.1, 2)
      for i = 1, #Obelisks do
        Part = Obelisks[i]:findFirstChild("Obelisk Part06")
        if Part ~= nil then
          MagicBlock(BrickColor.new(NewCol2), cf(Part.Position) * cf(0, 1, 0) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 2, 2, 2, 0.1, 2)
        end
      end
    end
    for i = 0, 1, 0.1 do
      swait()
      wld1.C0 = clerp(wld1.C0, euler(0.2, 0, -0.2) * cf(0, 1, 0.2), 0.3)
      wld2.C0 = clerp(wld2.C0, euler(0, 1.57, 0) * cf(0, -1.4, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.57), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1.57), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.5, 0, 0.8), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, -1.57), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(0.7, -1, -0.3) * euler(0, 1.57, 0) * euler(0, 1, -0.2), 0.3)
      LH.C0 = clerp(LH.C0, cf(-0.7, -1, 0.3) * euler(0, -1.57, 0) * euler(0, 1, 0), 0.3)
      MagicBlock(BrickColor.new(NewCol2), LeftArm.CFrame * cf(0, -1, 0) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 2, 2, 2, 0.1, 2)
      for i = 1, #Obelisks do
        Part = Obelisks[i]:findFirstChild("Obelisk Part06")
        if Part ~= nil then
          MagicBlock(BrickColor.new(NewCol2), cf(Part.Position) * cf(0, 1, 0) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 2, 2, 2, 0.1, 2)
        end
      end
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC675: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC675: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      if StaggerHit.Value ~= true then
        mana.Value = mana.Value - #Obelisks * 4
        for i = 1, #Obelisks do
          Part = Obelisks[i]:findFirstChild("Obelisk Part06")
          if Part ~= nil then
            so("203691562", Part, 1, 1)
            Orb(Part)
          end
        end
        do
          attack = false
        end
      end
    end
  end
end
do2 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[2] and mana.Value >= 25 then
    attack = true
    cooldowns[2] = 0
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = 10
    for i = 0, 1, 0.1 do
      swait()
      wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * cf(0, 1, 0), 0.3)
      wld2.C0 = clerp(wld2.C0, euler(0, 2.37, 0) * cf(0, -0.4, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, 0), 0.3)
      RW.C0 = clerp(RW.C0, cf(1, 1.2, 0) * euler(3.6, 0, -0.8), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1, 1.2, 0) * euler(3.6, 0, 0.8), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, -0.2), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0.2), 0.3)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC244: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC244: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    for i = 0, 1, 0.15 do
      swait()
      wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * cf(0, 1, 0), 0.4)
      wld2.C0 = clerp(wld2.C0, euler(0, 2.37, 0) * cf(0, -0.4, 0), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.4, 0, 0), 0.4)
      RW.C0 = clerp(RW.C0, cf(1, 0.3, -0.5) * euler(0.5, 0, -0.8), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1, 0.3, -0.5) * euler(0.5, 0, 0.8), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0.2), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, -0.4), 0.4)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC450: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC450: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      if StaggerHit.Value ~= true then
        mana.Value = mana.Value - 25
        do
          local tehc = 0
          for d = 1, 2, 0.5 do
            tehc = tehc + 1
            poss = RootPart.CFrame * cf(0, 0, 0)
            refb = part(3, nil, 0, 1, BrickColor.new("Black"), "Reference", vt())
            refb.Anchored = true
            refb.CFrame = poss
            game:GetService("Debris"):AddItem(refb, 10)
            hit, pos = rayCast(refb.Position, CFrame.new(refb.Position, refb.Position - Vector3.new(0, 1, 0)).lookVector, 40, Character)
            do
              do
                if hit ~= nil then
                  local ref2 = part(3, workspace, 0, 1, hit.BrickColor, "Effect", vt())
                  ref2.Anchored = true
                  ref2.CFrame = cf(pos)
                  if tehc == 1 then
                    so("2691586", ref2, 0.6, 0.5)
                  else
                    if tehc == 2 then
                      so("2691586", ref2, 0.7, 0.45)
                    else
                      if tehc == 3 then
                        so("2691586", ref2, 0.8, 0.4)
                        so("2691586", ref2, 0.8, 0.4)
                      end
                    end
                  end
                  game:GetService("Debris"):AddItem(ref2, 1)
                  for i = 1, #Obelisks do
                    ThePrt = Obelisks[i]:findFirstChild("Obelisk Part07")
                    if ThePrt ~= nil then
                      local mag = (ref2.Position - ThePrt.Position).magnitude
                      if mag <= 15 * d then
                        Prt1 = Obelisks[i]:findFirstChild("Obelisk Part01")
                        if Prt1 ~= nil then
                          local refd = part(3, workspace, 0, 1, BrickColor.new("Black"), "Effect", vt())
                          refd.Anchored = true
                          refd.CFrame = cf(Prt1.Position)
                          game:GetService("Debris"):AddItem(refd, 1)
                          so("161006069", refd, 1, 0.8)
                          so("203691610", refd, 1, 1)
                          MagniDamage(Prt1, 15, 10, 15, math.random(20, 30), "Knockdown2", Prt1, 0.1, 1, (math.random(15, 25)), nil, nil, true, "Defense", 0.05, 300)
                          MagicBlock(BrickColor.new(NewCol2), cf(Prt1.Position) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 5, 5, 5, 3, 3, 3, 0.05, 2)
                          for i = -5, 5, 2.5 do
                            MagicRing(BrickColor.new(NewCol2), cf(Prt1.Position) * euler(1.57, 0, 0) * cf(0, 0, i), 2, 2, 2, 1, 1, 0.5, 0.05)
                          end
                        end
                        do
                          do
                            Obelisks[i].Parent = nil
                            -- DECOMPILER ERROR at PC763: LeaveBlock: unexpected jumping out DO_STMT

                            -- DECOMPILER ERROR at PC763: LeaveBlock: unexpected jumping out IF_THEN_STMT

                            -- DECOMPILER ERROR at PC763: LeaveBlock: unexpected jumping out IF_STMT

                            -- DECOMPILER ERROR at PC763: LeaveBlock: unexpected jumping out IF_THEN_STMT

                            -- DECOMPILER ERROR at PC763: LeaveBlock: unexpected jumping out IF_STMT

                          end
                        end
                      end
                    end
                  end
                  Col = hit.BrickColor
                  MagicWave(Col, cf(ref2.Position), 1, 1, 1, 1.5 * d, 1, 1.5 * d, 0.1)
                  MagniDamage(ref2, 15 * d, 4, 6, math.random(10, 20), "Knockdown2", ref2, 0, 1, (math.random(4, 6)), nil, nil, true, "Obsidian", 0.05, 300)
                  for i = 1, 8 * d do
                    ref2.CFrame = cf(pos) * cf(math.random(-1000 * d, 1000 * d) / 100, 0, math.random(-1000 * d, 1000 * d) / 100)
                    hit2, pos2 = rayCast(ref2.Position, CFrame.new(ref2.Position, ref2.Position - Vector3.new(0, 1, 0)).lookVector, 50, Character)
                    do
                      do
                        if hit2 ~= nil then
                          local groundpart = part(3, workspace, 0, 0, Col, "Ground", vt(math.random(50, 200) / 100, math.random(50, 200) / 100, math.random(50, 200) / 100))
                          groundpart.Anchored = true
                          groundpart.Material = hit.Material
                          groundpart.CanCollide = true
                          groundpart.CFrame = cf(ref2.Position) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                          game:GetService("Debris"):AddItem(groundpart, 5)
                        end
                        ref2.CFrame = cf(pos)
                        -- DECOMPILER ERROR at PC919: LeaveBlock: unexpected jumping out DO_STMT

                      end
                    end
                  end
                end
                refb.Parent = nil
                swait(10)
                -- DECOMPILER ERROR at PC925: LeaveBlock: unexpected jumping out DO_STMT

              end
            end
          end
          dec.Parent = nil
          attack = false
        end
      end
    end
  end
end
do3 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[3] and mana.Value >= 30 then
    attack = true
    cooldowns[3] = 0
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = 10
    local dec2 = Instance.new("NumberValue", Decrease)
    dec2.Name = "DecreaseDef"
    dec2.Value = -10
    LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(2, 0, 1), 0.5)
    for i = 0, 1, 0.1 do
      swait()
      wld1.C0 = clerp(wld1.C0, euler(0.2, 0, -0.2) * cf(0, 1, 0.2), 0.3)
      wld2.C0 = clerp(wld2.C0, euler(0, 1.57, 0) * cf(0, -1.4, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.2) * euler(0.2, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -0.6), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.2, 0, 0.8), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(2.8, 0, 0.8), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(0.9, -1, -0.3) * euler(0, 1.57, 0) * euler(0, 0.6, -0.3), 0.3)
      LH.C0 = clerp(LH.C0, cf(-0.9, -1, 0.3) * euler(0, -1.57, 0) * euler(0, 0.6, -0.1), 0.3)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC281: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC281: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    so("315746833", Torso, 1, 1)
    for i = 1, 50 do
      swait()
      MagicBlock(BrickColor.new(NewCol2), cf(RootPart.Position) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) * cf(0, -8, 0), 3, 3, 3, -0.2, -0.2, -0.2, 0.05, 3)
    end
    do
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        if StaggerHit.Value ~= true then
          mana.Value = mana.Value - 30
          passivenum = -30
          dec.Parent = nil
          dec2.Parent = nil
          DecreaseStat(Character, "Defense", -0.5, 300)
          DecreaseStat(Character, "Movement", 0.3, 300)
          so("87767777", Torso, 1, 1)
          MagicWave(BrickColor.new(NewCol2), cf(RootPart.Position) * cf(0, -2, 0), 1, 2, 1, 1, -0.02, 1, 0.05)
          MagicCircle(BrickColor.new(NewCol2), cf(Torso.Position), 1, 1, 1, 3, 3, 3, 0.02)
          MagniDamage(RootPart, 20, 4, 6, math.random(30, 50), "Knockdown2", RootPart, 0, 1, (math.random(4, 8)), nil, nil, false)
          for i = 0, 1, 0.1 do
            swait()
            wld1.C0 = clerp(wld1.C0, euler(0.2, 0, 0.2) * cf(0, 1, 0.2), 0.5)
            wld2.C0 = clerp(wld2.C0, euler(0, 1.57, 0) * cf(0, -1.4, 0), 0.5)
            Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0.2, 0, 0), 0.5)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, 0), 0.5)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.57), 0.5)
            RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, -1.57), 0.5)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
            RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, -0.3), 0.5)
            LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, -0.1), 0.5)
            if Stagger.Value ~= true and StunT.Value > Stun.Value then
              do
                if StaggerHit.Value == true then
                  break
                end
                -- DECOMPILER ERROR at PC658: LeaveBlock: unexpected jumping out IF_THEN_STMT

                -- DECOMPILER ERROR at PC658: LeaveBlock: unexpected jumping out IF_STMT

              end
            end
          end
          dec.Parent = nil
          dec2.Parent = nil
          attack = false
        end
      end
    end
  end
end
do4 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[4] and mana.Value >= 10 then
    attack = true
    cooldowns[4] = 0
    Humanoid.Jump = true
    if Rooted.Value == false then
      Torso.Velocity = vt(0, 100, 0)
    end
    for i = 0, 1, 0.1 do
      swait()
      wld1.C0 = clerp(wld1.C0, euler(-1.5, 0, 0) * cf(0, 1, 0), 0.3)
      wld2.C0 = clerp(wld2.C0, euler(0, 2.37, 0) * cf(0, -0.4, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, 0), 0.3)
      RW.C0 = clerp(RW.C0, cf(1, 1.2, 0) * euler(3.6, 0, -0.8), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1, 1.2, 0) * euler(3.6, 0, 0.8), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, -0.2), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0.2), 0.3)
    end
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = 10
    for i = 0, 1, 0.15 do
      swait()
      wld1.C0 = clerp(wld1.C0, euler(-1.57, 0, 0) * cf(0, 1, 0), 0.3)
      wld2.C0 = clerp(wld2.C0, euler(0, 2.37, 0) * cf(0, 1, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.4, 0, 0), 0.4)
      RW.C0 = clerp(RW.C0, cf(1, 0.8, -0.5) * euler(2, 0, -0.8), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1, 0.8, -0.5) * euler(2, 0, 0.8), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0.2), 0.4)
      LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, -0.4), 0.4)
    end
    do
      while hitfloor == nil do
        swait()
      end
      mana.Value = mana.Value - 10
      MagicCircle(BrickColor.new(NewCol2), cf(prt18.Position), 5, 5, 5, 5, 5, 5, 0.05)
      MagicBlock(BrickColor.new(NewCol2), cf(prt18.Position) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 5, 5, 5, 6, 6, 6, 0.05, 1)
      MagicRing(BrickColor.new(NewCol2), cf(prt18.Position), 1, 1, 3, 2, 2, 0.1, 0.03)
      MagicRing(BrickColor.new(NewCol2), cf(prt18.Position) * euler(1.57, 0, 0), 1, 1, 3, 2, 2, 0.1, 0.03)
      MagicRing(BrickColor.new(NewCol2), cf(prt18.Position) * euler(0, 1.57, 0), 1, 1, 3, 2, 2, 0.1, 0.03)
      MagniDamage(prt18, 30, 5, 8, math.random(20, 40), "Knockdown2", prt18, 0, 1, (math.random(5, 10)), nil, nil, false, "Obsidian", 0.05, 400)
      ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
      ref.Anchored = true
      ref.CFrame = cf(Torso.Position)
      game:GetService("Debris"):AddItem(ref, 1)
      so("203691653", ref, 1, 1)
      so("203691699", Torso, 1, 1)
      for i = 1, 5 do
        swait(5)
        ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
        ref.Anchored = true
        ref.CFrame = cf(Torso.Position) * cf(math.random(-20, 20), 3, math.random(-20, 20))
        game:GetService("Debris"):AddItem(ref, 1)
        hitfloor, posfloor = rayCast(ref.Position, CFrame.new(ref.Position, ref.Position - Vector3.new(0, 1, 0)).lookVector, 100, Character)
        if hitfloor ~= nil and mana.Value >= 5 then
          mana.Value = mana.Value - 5
          local refsate = part(3, workspace, 0, 1, BrickColor.new("White"), "Reference", vt())
          refsate.Anchored = true
          refsate.CFrame = cf(posfloor)
          game:GetService("Debris"):AddItem(refsate, 1)
          local obe = Instance.new("Model", workspace)
          obe.Name = "Obelisk"
          game:GetService("Debris"):AddItem(obe, 20)
          table.insert(Obelisks, obe)
          local oprt1 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part01", vt())
          local oprt2 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part02", vt())
          local oprt6 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part06", vt())
          local oprt7 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part07", vt())
          local oprt8 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part08", vt())
          local oprt9 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part09", vt())
          local oprt10 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part10", vt())
          local omsh1 = mesh("BlockMesh", oprt1, "", "", vt(0, 0, 0), vt(1, 1, 1))
          local omsh2 = mesh("BlockMesh", oprt2, "", "", vt(0, 0, 0), vt(7, 20, 7))
          local omsh6 = mesh("SpecialMesh", oprt6, "FileMesh", "9756362", vt(0, 0, 0), vt(1.4, 1, 1.4))
          local omsh7 = mesh("SpecialMesh", oprt7, "FileMesh", "9756362", vt(0, 0, 0), vt(1.2, math.random(100, 250) / 100, 1.5))
          local omsh8 = mesh("SpecialMesh", oprt8, "FileMesh", "9756362", vt(0, 0, 0), vt(1.2, math.random(100, 250) / 100, 1.5))
          local omsh9 = mesh("SpecialMesh", oprt9, "FileMesh", "9756362", vt(0, 0, 0), vt(1.2, math.random(100, 250) / 100, 1.5))
          local omsh10 = mesh("SpecialMesh", oprt10, "FileMesh", "9756362", vt(0, 0, 0), vt(1.2, math.random(100, 250) / 100, 1.5))
          local owld2 = weld(oprt2, oprt2, oprt1, euler(0, 0, 0) * cf(0, 0, 0))
          local owld6 = weld(oprt6, oprt6, oprt2, euler(0, 0.785, 0) * cf(0, -2, 0))
          local owld7 = weld(oprt7, oprt7, oprt2, euler(-0.5, 0.785, 0.5) * cf(0.5, 2, 0.5))
          local owld8 = weld(oprt8, oprt8, oprt2, euler(0.5, 0.785, -0.5) * cf(-0.5, 2, -0.5))
          local owld9 = weld(oprt9, oprt9, oprt2, euler(0.5, -0.785, 0.5) * cf(0.5, 2, -0.5))
          local owld10 = weld(oprt10, oprt10, oprt2, euler(-0.5, -0.785, -0.5) * cf(-0.5, 2, 0.5))
          eul = 0
          for i = 1, 4 do
            local oprt3 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part03", vt())
            local omsh3 = mesh("SpecialMesh", oprt3, "Wedge", "nil", vt(0, 0, 0), vt(7, 20, 2))
            local owld3 = weld(oprt3, oprt3, oprt2, euler(0, 0, 0) * cf(0, 0, 0.9) * euler(0, eul, 0))
            local oprt4 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part04", vt())
            local omsh4 = mesh("SpecialMesh", oprt4, "FileMesh", "11294911", vt(0, 0, 0), vt(0.8, 8.2, 0.8))
            local owld4 = weld(oprt4, oprt4, oprt3, euler(0, 1.57, 0) * cf(0.9, -0.05, 0))
            local oprt5 = part(3, obe, 0, 0, BrickColor.new("Black"), "Obelisk Part05", vt())
            local omsh5 = mesh("SpecialMesh", oprt5, "Wedge", "nil", vt(0, 0, 0), vt(4, 15, 3))
            local owld5 = weld(oprt5, oprt5, oprt3, euler(0, 0, 0) * cf(0, -0.5, 0))
            eul = eul + 1.57
          end
          for i = 1, 5 do
            local oprt11 = part(3, obe, 0, 0, BrickColor.new(NewCol2), "Obelisk Part11", vt())
            num = math.random(10, 40) / 100
            local omsh11 = mesh("SpecialMesh", oprt11, "FileMesh", "9756362", vt(0, 0, 0), vt(num, math.random(60, 150) / 100, num))
            local owld11 = weld(oprt11, oprt11, oprt2, euler(0, 0, -math.random(20, 50) / 100) * cf(math.random(100, 300) / 100, math.random(100, 500) / 100, 0) * euler(0, math.random(-50, 50), 0))
          end
          oprt1.CFrame = refsate.CFrame
          so("203691785", oprt1, 1, 1)
          so("183763487", oprt1, 1, 1)
          f = Instance.new("BodyPosition", oprt1)
          f.P = 2000
          f.D = 100
          f.maxForce = Vector3.new(545000, 545000, 545000)
          f.position = refsate.Position + vt(0, math.random(700, 900) / 100, 0)
          ogy = Instance.new("BodyGyro", oprt1)
          ogy.maxTorque = Vector3.new(400000, 400000, 400000)
          ogy.P = 2000
          ogy.D = 100
          ogy.cframe = cf(0, math.random(-314, 314) / 100, 0)
          for i = 1, 5 do
            MagicObsidian(BrickColor.new(NewCol2), cf(refsate.Position) * cf(math.random(-500, 500) / 100, 0, math.random(-500, 500) / 100), 1, 1, 1, 0, 0, 0, math.random(2, 10) / 100)
          end
          MagicBlock(BrickColor.new(NewCol2), cf(oprt1.Position) * cf(0, 1, 0) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 4, 4, 4, 0.05, 2)
          MagniDamage(oprt1, 20, 6, 7, math.random(10, 20), "Knockdown2", oprt1, 0, 1, (math.random(5, 8)), nil, nil, true, "Defense", 0.02, 300)
          table.insert(Effects, {obe, "Obelisk", 0, 0, oprt1, 0, #Obelisks})
        end
      end
      swait(10)
      dec.Parent = nil
      attack = false
    end
  end
end
Orb = function(Part)
  spread = vt((math.random(-1, 0) + math.random()) * 3, (math.random(-1, 0) + math.random()) * 3, (math.random(-1, 0) + math.random()) * 3) * ((Part.Position - MMouse.Hit.p).magnitude / 100)
  local MouseLook = cf((Part.Position + MMouse.Hit.p) / 2, MMouse.Hit.p + spread)
  table.insert(Effects, {MouseLook.lookVector, "Shoot", 100, Part.Position, 8, 12, math.random(5, 10)})
end
DecreaseStat = function(Model, Stat, Amount, Duration)
  if Model:findFirstChild("Stats") ~= nil and Model.Stats[Stat] ~= nil then
    Model.Stats[Stat].Value = Model.Stats[Stat].Value - Amount
    d = Instance.new("NumberValue", Model.Stats.Decrease)
    dur = Instance.new("NumberValue", d)
    dur.Name = "Duration"
    dur.Value = Duration
    game:GetService("Debris"):AddItem(d, 20)
    if Stat == "Damage" then
      d.Name = "DecreaseAtk"
    else
      if Stat == "Defense" then
        d.Name = "DecreaseDef"
      else
        if Stat == "Movement" then
          d.Name = "DecreaseMvmt"
        end
      end
    end
    if Model:findFirstChild("Torso") ~= nil then
      display = ""
      if Stat == "Damage" then
        if Amount > 0 then
          display = "-Damage"
        else
          display = "+Damage"
        end
      else
        if Stat == "Defense" then
          if Amount > 0 then
            display = "-Defense"
          else
            display = "+Defense"
          end
        else
          if Stat == "Movement" then
            if Amount > 0 then
              display = "-Movement"
            else
              display = "+Movement"
            end
          end
        end
      end
      showDamage(Model, display, "Debuff")
    end
    d.Value = Amount
  end
end
GetDist = function(Part1, Part2, magni)
  local targ = Part1.Position - Part2.Position
  local mag = targ.magnitude
  if mag <= magni then
    return true
  else
    return false
  end
end
MagniDamage = function(Part, magni, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
  for _,c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = nil
      for _,d in pairs(c:children()) do
        if d.className == "Model" and ranged ~= true then
          head = d:findFirstChild("Hitbox")
          if d.Parent == Character then
            break
          end
          if head ~= nil then
            local targ = head.Position - Part.Position
            local mag = targ.magnitude
            if mag <= magni and c.Name ~= Player.Name then
              ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
              ref.Anchored = true
              ref.CFrame = cf(head.Position)
              game:GetService("Debris"):AddItem(ref, 1)
              hitnum = math.random(1, 5)
              if hitnum == 1 then
                so("199148971", ref, 1, 1)
              else
                if hitnum == 2 then
                  so("199149025", ref, 1, 1)
                else
                  if hitnum == 3 then
                    so("199149072", ref, 1, 1)
                  else
                    if hitnum == 4 then
                      so("199149109", ref, 1, 1)
                    else
                      if hitnum == 5 then
                        so("199149119", ref, 1, 1)
                      end
                    end
                  end
                end
              end
              StaggerHit.Value = true
            end
          end
        end
        do
          if d.className == "Part" then
            head = d
            if head ~= nil then
              local targ = head.Position - Part.Position
              local mag = targ.magnitude
              if mag <= magni and c.Name ~= Player.Name then
                if stun == nil then
                  stun = math.random(5, 10)
                end
                local Rang = nil
                if Ranged == false then
                  Rang = true
                end
                local stag = nil
                if shbash == true then
                  stag = true
                end
                Damagefunc(head, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
              end
            end
          end
          do
            -- DECOMPILER ERROR at PC183: LeaveBlock: unexpected jumping out DO_STMT

          end
        end
      end
    end
  end
end
MagniBuff = function(Part, magni, Dec, DecAm, Dur)
  if Player.Neutral == true then
    DecreaseStat(Character, Dec, DecAm, Dur)
  end
  for _,c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        cando = true
        if mag <= magni then
          if Player.Neutral == false then
            if game.Players:GetPlayerFromCharacter(head.Parent) ~= nil then
              if game.Players:GetPlayerFromCharacter(head.Parent).TeamColor == Player.TeamColor then
                cando = true
              else
                cando = false
              end
            else
              cando = false
            end
            if head.Parent:findFirstChild("Alignment") ~= nil and head.Parent.Alignment.Value == Player.TeamColor.Color then
              cando = true
            end
          else
            cando = false
          end
          if cando == true then
            DecreaseStat(head.Parent, Dec, DecAm, Dur)
          end
        end
      end
    end
  end
end
rayCast = function(Pos, Dir, Max, Ignore)
  return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
end
local Point = Torso.CFrame * cf(0, Torso.Size.Y, 0)
LastPoint = Point
effect = function(Color, Ref, LP, P1, returnn)
  if LP == nil or P1 == nil then
    return 
  end
  local effectsmsh = Instance.new("CylinderMesh")
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  effectsmsh.Name = "Mesh"
  local effectsg = Instance.new("Part")
  NoOutline(effectsg)
  effectsg.formFactor = 3
  effectsg.CanCollide = false
  effectsg.Name = "Eff"
  effectsg.Locked = true
  effectsg.Anchored = true
  effectsg.Size = Vector3.new(0.5, 1, 0.5)
  effectsg.Parent = workspace
  effectsmsh.Parent = effectsg
  effectsg.BrickColor = BrickColor.new(Color)
  effectsg.Reflectance = Ref
  local point1 = P1
  local mg = LP.p - point1.p.magnitude
  effectsg.Size = Vector3.new(0.5, mg, 0.5)
  effectsg.CFrame = cf((LP.p + point1.p) / 2, point1.p) * CFrame.Angles(math.rad(90), 0, 0)
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  game:GetService("Debris"):AddItem(effectsg, 2)
  if returnn then
    return effectsg
  end
  if not returnn then
    table.insert(Effects, {effectsg, "Cylinder", 0.2, 0.01, 0, 0.01, effectsmsh})
  end
end
local CFrameFromTopBack = function(at, top, back)
  local right = top:Cross(back)
  return CFrame.new(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end
Triangle = function(a, b, c)
  local edg1 = c - a:Dot(b - a.unit)
  local edg2 = a - b:Dot(c - b.unit)
  local edg3 = b - c:Dot(a - c.unit)
  if edg1 <= b - a.magnitude and edg1 >= 0 then
    a = a
  else
    -- DECOMPILER ERROR at PC35: Overwrote pending register: R1 in 'AssignReg'

    if edg2 <= c - b.magnitude and edg2 >= 0 then
      a = b
    else
      -- DECOMPILER ERROR at PC46: Overwrote pending register: R2 in 'AssignReg'

      -- DECOMPILER ERROR at PC47: Overwrote pending register: R1 in 'AssignReg'

      if edg3 <= a - c.magnitude and edg3 >= 0 then
        a = c
      else
        assert(false, "unreachable")
      end
    end
  end
  local len1 = c - a:Dot(b - a.unit)
  local len2 = b - a.magnitude - len1
  local width = a + b - a.unit * len1 - c.magnitude
  local maincf = CFrameFromTopBack(a, b - a:Cross(c - b).unit, -b - a.unit)
  local list = {}
  if len1 > 0.01 then
    local w1 = Instance.new("WedgePart", m)
    w1.Name = "Triangle"
    game:GetService("Debris"):AddItem(w1, 5)
    w1.Material = "SmoothPlastic"
    w1.FormFactor = "Custom"
    w1.BrickColor = BrickColor.new("Teal")
    w1.Transparency = 0
    w1.Reflectance = 0
    w1.Material = "SmoothPlastic"
    w1.CanCollide = false
    NoOutline(w1)
    local sz = Vector3.new(0.2, width, len1)
    w1.Size = sz
    local sp = Instance.new("SpecialMesh", w1)
    sp.MeshType = "Wedge"
    sp.Scale = Vector3.new(0, 1, 1) * sz / w1.Size
    w1:BreakJoints()
    w1.Anchored = true
    w1.Parent = workspace
    w1.Transparency = 0.7
    table.insert(Effects, {w1, "Disappear", 0.05})
    w1.CFrame = maincf * CFrame.Angles(math.pi, 0, math.pi / 2) * CFrame.new(0, width / 2, len1 / 2)
    table.insert(list, w1)
  end
  do
    if len2 > 0.01 then
      local w2 = Instance.new("WedgePart", m)
      w2.Name = "Triangle"
      game:GetService("Debris"):AddItem(w2, 5)
      w2.Material = "SmoothPlastic"
      w2.FormFactor = "Custom"
      w2.BrickColor = BrickColor.new("Teal")
      w2.Transparency = 0
      w2.Reflectance = 0
      w2.Material = "SmoothPlastic"
      w2.CanCollide = false
      NoOutline(w2)
      local sz = Vector3.new(0.2, width, len2)
      w2.Size = sz
      local sp = Instance.new("SpecialMesh", w2)
      sp.MeshType = "Wedge"
      sp.Scale = Vector3.new(0, 1, 1) * sz / w2.Size
      w2:BreakJoints()
      w2.Anchored = true
      w2.Parent = workspace
      w2.Transparency = 0.7
      table.insert(Effects, {w2, "Disappear", 0.05})
      w2.CFrame = maincf * CFrame.Angles(math.pi, math.pi, -math.pi / 2) * CFrame.new(0, width / 2, -len1 - len2 / 2)
      table.insert(list, w2)
    end
    do
      return unpack(list)
    end
  end
end
MagicBlock = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  if Type == 1 or Type == nil then
    table.insert(Effects, {prt, "Block1", delay, x3, y3, z3, msh})
  else
    if Type == 2 then
      table.insert(Effects, {prt, "Block2", delay, x3, y3, z3, msh})
    else
      if Type == 3 then
        table.insert(Effects, {prt, "Block3", delay, x3, y3, z3, msh, prt.CFrame, math.random(5, 20) / 100})
      end
    end
  end
end
MagicCircle = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicCircle2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Blood", delay, x3, y3, z3, msh})
end
MagicCylinder = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicHead = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Head", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
ClangEffect = function(brickcolor, cframe, duration, decrease, size, power)
  local prt = part(3, workspace, 0, 1, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(5, 5, 5))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "CylinderClang", duration, decrease, size, power, prt.CFrame, nil})
end
MagicWave = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "FileMesh", "20329976", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicRing = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
  prt.Anchored = true
  prt.CFrame = cframe * cf(x2, y2, z2)
  local msh = mesh("SpecialMesh", prt, "FileMesh", "3270017", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicObsidian = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Obsidian", delay, x3, y3, z3, msh, math.random(80, 140) / 100, 0.1})
end
Damagefunc = function(hit, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
  if hit.Parent == nil then
    return 
  end
  if hit.Name == "Hitbox" and hit.Parent ~= modelzorz and ranged ~= true then
    ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
    ref.Anchored = true
    ref.CFrame = cf(hit.Position)
    game:GetService("Debris"):AddItem(ref, 1)
    hitnum = math.random(1, 5)
    if hitnum == 1 then
      so("199148971", ref, 1, 1)
    else
      if hitnum == 2 then
        so("199149025", ref, 1, 1)
      else
        if hitnum == 3 then
          so("199149072", ref, 1, 1)
        else
          if hitnum == 4 then
            so("199149109", ref, 1, 1)
          else
            if hitnum == 5 then
              so("199149119", ref, 1, 1)
            end
          end
        end
      end
    end
    StaggerHit.Value = true
  end
  h = hit.Parent:FindFirstChild("Humanoid")
  if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
    if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
      return 
    end
    if Player.Neutral == false then
      if hit.Parent:findFirstChild("Alignment") ~= nil and hit.Parent.Alignment.Value == Player.TeamColor.Color then
        return 
      end
      if game.Players:GetPlayerFromCharacter(hit.Parent) ~= nil and game.Players:GetPlayerFromCharacter(hit.Parent).TeamColor == Player.TeamColor then
        return 
      end
    end
    c = Instance.new("ObjectValue")
    c.Name = "creator"
    c.Value = game:service("Players").LocalPlayer
    c.Parent = h
    RecentEnemy.Value = hit.Parent
    game:GetService("Debris"):AddItem(c, 0.5)
    minim = minim * Atk.Value
    maxim = maxim * Atk.Value
    Damage = 0
    if minim == maxim then
      Damage = maxim
    else
      Damage = math.random(minim, maxim)
    end
    blocked = false
    enblock = nil
    Stats = hit.Parent:findFirstChild("Stats")
    if Stats ~= nil then
      invis = Stats:findFirstChild("Invisibility")
      isinvis = Stats:findFirstChild("IsInvisible")
      if (ranged == false or ranged == nil) and invis ~= nil and isinvis.Value == true then
        invis.Value = 0
      end
      enblock = Stats:findFirstChild("Block")
      if enblock ~= nil and enblock.Value == true then
        blocked = true
      end
      if Stats:findFirstChild("Defense") ~= nil then
        Damage = Damage / Stats.Defense.Value
        if Damage <= 3 and (ranged == false or ranged == nil) and blocked ~= true then
          hitnum = math.random(1, 5)
          if hitnum == 1 then
            so("199149321", hit, 1, 1)
          else
            if hitnum == 2 then
              so("199149338", hit, 1, 1)
            else
              if hitnum == 3 then
                so("199149367", hit, 1, 1)
              else
                if hitnum == 4 then
                  so("199149409", hit, 1, 1)
                else
                  if hitnum == 5 then
                    so("199149452", hit, 1, 1)
                  end
                end
              end
            end
          end
        else
          if ranged == false or ranged == nil and blocked ~= true then
            hitnum = math.random(1, 6)
            if hitnum == 1 then
              so("199149137", hit, 1, 1)
            else
              if hitnum == 2 then
                so("199149186", hit, 1, 1)
              else
                if hitnum == 3 then
                  so("199149221", hit, 1, 1)
                else
                  if hitnum == 4 then
                    so("199149235", hit, 1, 1)
                  else
                    if hitnum == 5 then
                      so("199149269", hit, 1, 1)
                    else
                      if hitnum == 6 then
                        so("199149297", hit, 1, 1)
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if Damage <= 3 and staghit == true and ranged ~= true then
          StaggerHit.Value = true
        end
      end
      if Stats:findFirstChild("Stun") ~= nil then
        if blocked == true then
          incstun = incstun / 2
        end
        if Stats.Stun.Value < Stats.StunThreshold.Value then
          Stats.Stun.Value = Stats.Stun.Value + incstun
        end
      end
      if Stats:findFirstChild("Stagger") ~= nil and stagger == true then
        Stats.Stagger.Value = true
      end
    end
    if blocked == true then
      showDamage(hit.Parent, "Block", "Damage")
      if ranged ~= true then
        enblock.Value = false
        Stagger.Value = true
        hitnum = math.random(1, 2)
        if hitnum == 1 then
          so("199148933", hit, 1, 1)
        else
          if hitnum == 2 then
            so("199148947", hit, 1, 1)
          end
        end
      end
    else
      Damage = math.floor(Damage)
      coroutine.resume(coroutine.create(function(Hum, Dam)
	if Hum.Parent:FindFirstChild("DebounceHit") == nil then
    Hum:TakeDamage(Damage)
end
  end), h, Damage)
      showDamage(hit.Parent, Damage, "Damage")
      if DecreaseState ~= nil then
        if DecreaseState == "Obsidian" then
          DecreaseStat(hit.Parent, "Movement", DecreaseAmount, Duration)
          DecreaseStat(hit.Parent, "Damage", DecreaseAmount, Duration)
        else
          DecreaseStat(hit.Parent, DecreaseState, DecreaseAmount, Duration)
        end
      end
      if Type == "Knockdown" then
        hum = hit.Parent.Humanoid
        hum.PlatformStand = true
        coroutine.resume(coroutine.create(function(HHumanoid)
    swait(1)
    HHumanoid.PlatformStand = false
  end), hum)
        local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
        local bodvol = Instance.new("BodyVelocity")
        bodvol.velocity = angle * knockback
        bodvol.P = 5000
        bodvol.maxForce = Vector3.new(8000, 8000, 8000)
        bodvol.Parent = hit
        rl = Instance.new("BodyAngularVelocity")
        rl.P = 3000
        rl.maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000
        rl.angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10))
        rl.Parent = hit
        game:GetService("Debris"):AddItem(bodvol, 0.5)
        game:GetService("Debris"):AddItem(rl, 0.5)
      else
        do
          if Type == "Knockdown2" then
            hum = hit.Parent.Humanoid
            local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
            local bodvol = Instance.new("BodyVelocity")
            bodvol.velocity = angle * knockback
            bodvol.P = 5000
            bodvol.maxForce = Vector3.new(8000, 8000, 8000)
            bodvol.Parent = hit
            game:GetService("Debris"):AddItem(bodvol, 0.5)
          else
            do
              if Type == "Normal" or Type == "NormalDecreaseMvmt1" then
                vp = Instance.new("BodyVelocity")
                vp.P = 500
                vp.maxForce = Vector3.new(math.huge, 0, math.huge)
                if KnockbackType == 1 then
                  vp.velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
                else
                  if KnockbackType == 2 then
                    vp.velocity = Property.CFrame.lookVector * knockback
                  end
                end
                game:GetService("Debris"):AddItem(vp, 0.5)
                if knockback > 0 then
                  vp.Parent = hit.Parent.Torso
                end
              end
              debounce = Instance.new("BoolValue")
              debounce.Name = "DebounceHit"
              debounce.Parent = hit.Parent
              debounce.Value = true
              game:GetService("Debris"):AddItem(debounce, Delay)
              c = Instance.new("ObjectValue")
              c.Name = "creator"
              c.Value = Player
              c.Parent = h
              game:GetService("Debris"):AddItem(c, 0.5)
              CRIT = false
            end
          end
        end
      end
    end
  end
end
showDamage = function(Char, Dealt, Type)
  m = Instance.new("Model")
  m.Name = "Effect"
  c = Instance.new("Part")
  c.Transparency = 1
  c.Name = "Head"
  c.TopSurface = 0
  c.BottomSurface = 0
  c.formFactor = "Plate"
  c.Size = Vector3.new(1, 0.4, 1)
  b = Instance.new("BillboardGui", c)
  b.Size = UDim2.new(5, 0, 5, 0)
  b.AlwaysOnTop = true
  damgui = gui("TextLabel", b, tostring(Dealt), 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
  if Type == "Damage" then
    damgui.Font = "SourceSans"
    if Dealt == "Block" then
      damgui.TextColor3 = BrickColor.new("Bright blue").Color
    else
      if Dealt < 3 then
        damgui.TextColor3 = BrickColor.new("White").Color
      else
        if Dealt >= 3 and Dealt < 20 then
          damgui.TextColor3 = BrickColor.new("Bright yellow").Color
        else
          damgui.TextColor3 = BrickColor.new("Really red").Color
          damgui.Font = "SourceSansBold"
        end
      end
    end
  else
    if Type == "Debuff" then
      damgui.TextColor3 = BrickColor.new("White").Color
    else
      if Type == "Interrupt" then
        damgui.TextColor3 = BrickColor.new("New Yeller").Color
      end
    end
  end
  damgui.TextScaled = true
  ms = Instance.new("CylinderMesh")
  ms.Scale = Vector3.new(0.8, 0.8, 0.8)
  ms.Parent = c
  c.Reflectance = 0
  Instance.new("BodyGyro").Parent = c
  c.Parent = m
  if Char:findFirstChild("Head") ~= nil then
    c.CFrame = cf(Char.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
  else
    if Char.Parent:findFirstChild("Head") ~= nil then
      c.CFrame = cf(Char.Parent.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
    end
  end
  f = Instance.new("BodyPosition")
  f.P = 2000
  f.D = 100
  f.maxForce = Vector3.new(545000, 545000, 545000)
  if Type == "Damage" then
    f.position = c.Position + Vector3.new(0, 3, 0)
  else
    if Type == "Debuff" or Type == "Interrupt" then
      f.position = c.Position + Vector3.new(0, 5, 0)
    end
  end
  f.Parent = c
  game:GetService("Debris"):AddItem(m, 5)
  table.insert(Effects, {m, "showDamage", damgui, f, 10, 1, 15, 50, 100})
  c.CanCollide = false
  m.Parent = workspace
  c.CanCollide = false
end
combo = 0
ob1d = function(mouse)
  if attack == true or equipped == false then
    return 
  end
  hold = true
  if combo == 0 then
    combo = 1
    attackone()
  else
    if combo == 1 then
      combo = 2
      attacktwo()
    else
      if combo == 2 then
        combo = 3
        attackthree()
      else
        if combo == 3 then
          combo = 0
          attackfour()
        end
      end
    end
  end
  coroutine.resume(coroutine.create(function()
    for i = 1, 50 do
      if attack == false then
        swait()
      end
    end
    if attack == false then
      combo = 0
    end
  end))
end
ob1u = function(mouse)
  hold = false
end
buttonhold = false
fenbarmove1.MouseButton1Click:connect(do1)
fenbarmove2.MouseButton1Click:connect(do2)
fenbarmove3.MouseButton1Click:connect(do3)
fenbarmove4.MouseButton1Click:connect(do4)
eul = 0
equipped = false
key = function(key)
  if attack == true then
    return 
  end
  if key == "f" then
    pressedf = true
    fnumb = 0
    attack = true
    if equipped == false then
      equipped = true
      RSH = ch.Torso["Right Shoulder"]
      LSH = ch.Torso["Left Shoulder"]
      RSH.Parent = nil
      LSH.Parent = nil
      RW.Name = "Right Shoulder"
      RW.Part0 = ch.Torso
      RW.C0 = cf(1.5, 0.5, 0)
      RW.C1 = cf(0, 0.5, 0)
      RW.Part1 = ch["Right Arm"]
      RW.Parent = ch.Torso
      LW.Name = "Left Shoulder"
      LW.Part0 = ch.Torso
      LW.C0 = cf(-1.5, 0.5, 0)
      LW.C1 = cf(0, 0.5, 0)
      LW.Part1 = ch["Left Arm"]
      LW.Parent = ch.Torso
      Animate.Parent = nil
      equipanim()
    else
      equipped = false
      hideanim()
      LH.C1 = LHC1
      RH.C1 = RHC1
      Animate.Parent = Humanoid
      swait(0)
      RW.Parent = nil
      LW.Parent = nil
      RSH.Parent = player.Character.Torso
      LSH.Parent = player.Character.Torso
    end
    attack = false
  end
  if equipped == false then
    return 
  end
  if key == "e" then
    Obelisk()
  end
  if key == "z" then
    do1()
  end
  if key == "x" then
    do2()
  end
  if key == "c" then
    do3()
  end
  if key == "v" then
    do4()
  end
  if attack == false then
    RecentEnemy.Value = nil
  end
end
key2 = function(key)
end
s = function(mouse)
  mouse.Button1Down:connect(function()
    ob1d(mouse)
  end)
  mouse.Button1Up:connect(function()
    ob1u(mouse)
  end)
  mouse.KeyDown:connect(key)
  mouse.KeyUp:connect(key2)
  player = Player
  ch = Character
  MMouse = mouse
end
ds = function(mouse)
end
Bin.Selected:connect(s)
Bin.Deselected:connect(ds)
print("Obsidian loaded.")
local mananum = 0
local donum = 0
local stunnum = 0
local staggeranim = false
local stunanim = false
local pnum = 0
local pnum2 = 0
local pref = part(3, modelzorz, 0, 1, BrickColor.new("Black"), "Effect", vt())
pref.Anchored = true
local oldhealth = Humanoid.Health
local walk = 0
local walkforw = true
while 1 do
  swait()
  if Humanoid.Health <= 0 then
    attack = true
    resumeControl()
    modelzorz.Parent = workspace
    game:GetService("Debris"):AddItem(modelzorz, 30)
    for i = 1, #Weapon do
      Weapon[i].Parent = modelzorz
      Weapon[i].CanCollide = true
    end
    for i = 1, #Welds do
      if Welds[i].Part0.Parent == Character or Welds[i].Part1.Parent == Character then
        Welds[i].Parent = nil
      else
        Welds[i].Parent = prt1
      end
    end
  end
  do
    if fnumb < 21 then
      fnumb = fnumb + 1
      if pressedf == false then
        fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency - 0.025
        tellbar.TextTransparency = tellbar.TextTransparency - 0.05
        tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency - 0.05
      else
        if fnumb == 20 then
          fenframe5.Parent = nil
          print("daigui")
        end
        fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency + 0.025
        tellbar.TextTransparency = tellbar.TextTransparency + 0.05
        tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency + 0.05
      end
    end
    if hbwld.Parent == nil then
      hitbox2.Name = "Hitbox"
    else
      hitbox2.Name = "Hitbox2"
    end
    hitbox2.Parent = hitbox.Parent
    hitbox2.Size = hitbox.Size
    hitbox2.CFrame = hitboxCF
    hboxpos.position = hitbox2.Position + vt(math.random(-100, 100) / 100, math.random(-100, 100) / 100, math.random(-100, 100) / 100)
    if Humanoid.Health < oldhealth then
      passive.Value = passive.Value * 0.7
      passivenum = 0
    end
    oldhealth = Humanoid.Health
    if 3 <= pnum2 then
      pnum2 = 0
      if passivenum < 15 then
        pref.CFrame = cf(RootPart.Position) * cf(math.random(-1000, 1000) / 100, 0, math.random(-1000, 1000) / 100)
        hitfloor2, posfloor2 = rayCast(pref.Position, CFrame.new(pref.Position, pref.Position - Vector3.new(0, 1, 0)).lookVector, 30, Character)
        if hitfloor2 ~= nil then
          MagicObsidian(BrickColor.new(NewCol2), cf(posfloor2) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 3, 3, 3, -0.2, -0.2, -0.2, 0.05)
        end
        passivenum = passivenum + 1
      end
    end
    pnum = pnum + 1
    pnum2 = pnum2 + 1
    passive2.Value = (-0.1 + passive.Value * 0.2) * -1
    dnum = #Obelisks + 1
    passivenum2 = -1 / dnum
    if passive.Value < passivenum2 then
      passive.Value = passivenum2
    end
    if 150 <= pnum then
      if passivenum2 < passive.Value then
        passive.Value = passive.Value - 0.1
      end
      pnum = 0
    end
    if Stagger.Value == true and staggeranim == false then
      coroutine.resume(coroutine.create(function()
  staggeranim = true
  while attack == true do
    swait()
  end
  StaggerAnim()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end))
    end
    if StaggerHit.Value == true and staggeranim == false then
      coroutine.resume(coroutine.create(function()
  staggeranim = true
  while attack == true do
    swait()
  end
  StaggerHitt()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end))
    end
    if Mvmt.Value < 0 or Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true or Rooted.Value == true then
      Humanoid.WalkSpeed = 0
    else
      Humanoid.WalkSpeed = 16 * Mvmt.Value
    end
    if StunT.Value <= Stun.Value and stunanim == false then
      coroutine.resume(coroutine.create(function()
  stunanim = true
  while attack == true do
    swait()
  end
  StunAnim()
  Stun.Value = 0
  stunanim = false
end))
    end
    local stunnum2 = 20
    if stunnum2 <= stunnum then
      if 0 < Stun.Value then
        Stun.Value = Stun.Value - 1
      end
      stunnum = 0
    end
    stunnum = stunnum + 1
    if 0.5 <= donum then
      handidle = true
    else
      if donum <= 0 then
        handidle = false
      end
    end
    if handidle == false then
      donum = donum + 0.003
    else
      donum = donum - 0.003
    end
    local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
    local velderp = RootPart.Velocity.y
    hitfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
    if equipped == true then
      if attack == false then
        idle = idle + 1
      else
        idle = 0
      end
      if (500 <= idle and attack ~= false) or Anim == "Walk" then
        if walkforw == true then
          RH.C1 = clerp(RH.C1, RHC1 * cf(0.2, -0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
          LH.C1 = clerp(LH.C1, LHC1 * cf(0.1, 0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
        else
          RH.C1 = clerp(RH.C1, RHC1 * cf(-0.1, 0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
          LH.C1 = clerp(LH.C1, LHC1 * cf(-0.2, -0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
        end
      else
        RH.C1 = clerp(RH.C1, RHC1, 0.2)
        LH.C1 = clerp(LH.C1, LHC1, 0.2)
      end
      if 1 < RootPart.Velocity.y and hitfloor == nil then
        Anim = "Jump"
        if attack == false then
          Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0), 0.2)
          Neck.C1 = clerp(Neck.C1, necko2 * euler(0, 0, 0), 0.2)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
          RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 0.5), 0.2)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
          LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -0.8), 0.2)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
          RH.C0 = clerp(RH.C0, cf(1, -1, -0.3) * euler(-0.5, 1.57, 0) * euler(-0.2, 0, 0), 0.2)
          LH.C0 = clerp(LH.C0, cf(-1, -1, -0.3) * euler(-0.5, -1.57, 0) * euler(-0.2, 0, 0), 0.2)
        end
      else
        if RootPart.Velocity.y < -1 and hitfloor == nil then
          Anim = "Fall"
          if attack == false then
            Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, 0), 0.2)
            Neck.C1 = clerp(Neck.C1, necko2 * euler(0, 0, 0), 0.2)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.2, 0, 0), 0.2)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(2, 0, 1), 0.2)
            RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.2), 0.2)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
            RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0.4, 1.57, 0), 0.2)
            LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(-0.2, -1.57, 0), 0.2)
          end
        else
          if torvel < 1 and hitfloor ~= nil then
            Anim = "Idle"
            if attack == false then
              wld1.C0 = clerp(wld1.C0, euler(0.2, 0, -0.2) * cf(0, 1, 0.2), 0.15)
              wld2.C0 = clerp(wld2.C0, euler(0, 1.57, 0) * cf(0, -1.4, 0), 0.15)
              Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.6) * euler(0.2, 0, 0), 0.15)
              RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -0.6) * euler(0.1, 0, 0), 0.15)
              RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.2 - (donum) / 5, 0, 0.8 - (donum) / 5), 0.15)
              RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.15)
              LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4 + (donum) / 3, 0, -0.2 - (donum) / 5), 0.15)
              LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.15)
              RH.C0 = clerp(RH.C0, cf(0.9, -1, -0.3) * euler(0, 1.57, 0) * euler(0, 0.6, -0.3), 0.2)
              LH.C0 = clerp(LH.C0, cf(-0.9, -1, 0.3) * euler(0, -1.57, 0) * euler(0, 0.6, -0.1), 0.2)
            end
          else
            if 2 < torvel and torvel < 30 and hitfloor ~= nil then
              Anim = "Walk"
              walk = walk + 1
              if 15 - 5 * Mvmt.Value <= walk then
                walk = 0
                if walkforw == true then
                  walkforw = false
                else
                  if walkforw == false then
                    walkforw = true
                  end
                end
              end
              if attack == false then
                wld1.C0 = clerp(wld1.C0, euler(0.2, 0, 0) * cf(0, 1, 0.2), 0.2)
                wld2.C0 = clerp(wld2.C0, euler(0, 1.57, 0) * cf(0, -1.4, 0), 0.2)
                Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.2)
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.1, 0, 0), 0.2)
                RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.2, 0, 0.6), 0.2)
                RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.2), 0.2)
                LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.2)
                LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.2)
              end
            else
              if 30 <= torvel and hitfloor ~= nil then
                Anim = "Run"
                if attack == false then
                  wld1.C0 = clerp(wld1.C0, euler(-1.57, 0, 0) * cf(0, 1, 0), 0.3)
                  wld2.C0 = clerp(wld2.C0, euler(0, 2.37, 0) * cf(0, 1, 0), 0.3)
                  Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.4)
                  RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.4, 0, 0), 0.4)
                  RW.C0 = clerp(RW.C0, cf(1, 0.8, -0.5) * euler(2, 0, -0.8), 0.4)
                  RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
                  LW.C0 = clerp(LW.C0, cf(-1, 0.8, -0.5) * euler(2, 0, 0.8), 0.4)
                  LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
                  RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0.2), 0.4)
                  LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, -0.4), 0.4)
                end
              end
            end
          end
        end
      end
    end
    if 0 < #Effects then
      for e = 1, #Effects do
        if Effects[e] ~= nil then
          local Thing = Effects[e]
          if Thing ~= nil then
            local Mode = Thing[2]
            local Delay = Thing[3]
            local IncX = Thing[4]
            local IncY = Thing[5]
            local IncZ = Thing[6]
            if Thing[2] == "CylinderClang" then
              if Thing[3] <= 1 then
                Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, 2.5 * Thing[5], 0) * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
                Thing[7] = Thing[1].CFrame
                effect("New Yeller", 0, Thing[8], Thing[7])
                Thing[8] = Thing[7]
                Thing[3] = Thing[3] + Thing[4]
              else
                Thing[1].Parent = nil
                table.remove(Effects, e)
              end
            else
              if Thing[2] == "showDamage" then
                if Thing[6] < Thing[5] then
                  Thing[6] = Thing[6] + 1
                else
                  if Thing[6] < Thing[7] then
                    Thing[4].position = Thing[4].position + vt(0, -0.2, 0)
                    Thing[6] = Thing[6] + 1
                  else
                    if Thing[6] < Thing[8] then
                      Thing[6] = Thing[6] + 1
                    else
                      if Thing[6] < Thing[9] then
                        Thing[6] = Thing[6] + 1
                        Thing[4].position = Thing[4].position + vt(0, 0.2, 0)
                        Thing[3].TextStrokeTransparency = Thing[3].TextStrokeTransparency + 0.1
                        Thing[3].TextTransparency = Thing[3].TextTransparency + 0.1
                      else
                        Thing[1].Parent = nil
                        table.remove(Effects, e)
                      end
                    end
                  end
                end
              else
                if Thing[2] == "Obelisk" then
                  if Thing[6] <= 400 and Thing[1].Parent ~= nil then
                    Thing[6] = Thing[6] + 1
                    if 10 <= Thing[3] then
                      Thing[3] = 0
                      ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
                      ref.Anchored = true
                      ref.CFrame = cf(Thing[5].Position) * cf(math.random(-500, 500) / 100, 0, math.random(-500, 500) / 100)
                      game:GetService("Debris"):AddItem(ref, 0.2)
                      hitfloor2, posfloor2 = rayCast(ref.Position, CFrame.new(ref.Position, ref.Position - Vector3.new(0, 1, 0)).lookVector, 30, Character)
                      MagicObsidian(BrickColor.new(NewCol2), cf(posfloor2), 1, 1, 1, 0, 0, 0, math.random(10, 20) / 100)
                    end
                    if 100 <= Thing[4] then
                      Thing[4] = 0
                      MagniBuff(Thing[5], 20, "Defense", -0.05, 100)
                      MagniDamage(Thing[5], 20, 6, 7, 0, "Normal", Thing[5], 0, 1, 1, nil, nil, true)
                      MagicCircle(BrickColor.new(NewCol2), cf(Thing[5].Position) * cf(0, -8, 0), 1, 2, 1, 10, 1, 10, 0.05)
                    end
                    Thing[3] = Thing[3] + 1
                    Thing[4] = Thing[4] + 1
                  else
                    for i = 1, 3 do
                      MagicBlock(BrickColor.new(NewCol2), cf(Thing[5].Position) * cf(0, math.random(-300, 300) / 100, 0) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 5, 5, 5, 2, 2, 2, 0.05, 2)
                    end
                    for i = 1, 5 do
                      ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
                      ref.Anchored = true
                      ref.CFrame = cf(Thing[5].Position) * cf(math.random(-900, 900) / 100, 0, math.random(-900, 900) / 100)
                      game:GetService("Debris"):AddItem(ref, 0.2)
                      hitfloor2 = rayCast(ref.Position, CFrame.new(ref.Position, ref.Position - Vector3.new(0, 1, 0)).lookVector, 30, Character)
                      MagicObsidian(BrickColor.new(NewCol2), cf(posfloor2), 1, 1, 1, 0, 0, 0, math.random(2, 10) / 100)
                    end
                    print("officialend")
                    Thing[1].Parent = nil
                    if Thing[5].Parent ~= nil then
                      Thing[5].Parent.Parent = nil
                    end
                    table.remove(Effects, e)
                    for i = 1, #Obelisks do
                      if Obelisks[i] == Thing[1] then
                        table.remove(Obelisks, i)
                      end
                    end
                  end
                else
                  do
                    if Thing[2] == "Shoot" then
                      local Look = Thing[1]
                      local hit, pos = rayCast(Thing[4], Look, 3, modelzorz)
                      local mag = (Thing[4] - pos).magnitude
                      MagicCircle(BrickColor.new(NewCol), CFrame.new((Thing[4] + pos) / 2, pos) * angles(1.57, 0, 0), 10, 10, 10, 1, 1, 1, 0.3)
                      Thing[4] = Thing[4] + Look * 3
                      Thing[3] = Thing[3] - 1
                      if hit ~= nil then
                        Thing[3] = 0
                        Damagefunc(hit, Thing[5], Thing[6], Thing[7], "Knockdown2", RootPart, 0, 2, (math.random(3, 8)), nil, nil, true, "Obsidian", 0.05, 500)
                        ref = part(3, workspace, 0, 1, BrickColor.new("Really red"), "Reference", vt())
                        ref.Anchored = true
                        ref.CFrame = cf(pos)
                        game:GetService("Debris"):AddItem(ref, 1)
                        so("183763506", ref, 1, 1)
                        so("203691510", ref, 1, 1)
                        MagicCircle(BrickColor.new(NewCol2), cf(pos), 10, 10, 10, 2, 2, 2, 0.1)
                        MagicBlock(BrickColor.new(NewCol2), cf(ref.Position) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 10, 10, 10, 0.15, 2)
                        MagicRing(BrickColor.new(NewCol2), cf(ref.Position) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 0.1, 4, 4, 0.1, 0.15)
                        MagniDamage(ref, 10, Thing[5] / 1.2, Thing[6] / 1.2, 0, "Normal", ref, 0, 1, (math.random(3, 8)), nil, nil, true, "Obsidian", 0.05, 300)
                      end
                      if Thing[3] <= 0 then
                        table.remove(Effects, e)
                      end
                    end
                    do
                      do
                        if Thing[2] ~= "DecreaseStat" and Thing[2] ~= "showDamage" and Thing[2] ~= "Obelisk" and Thing[2] ~= "Shoot" then
                          if Thing[1].Transparency <= 1 then
                            if Thing[2] == "Block1" then
                              Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                              Mesh = Thing[7]
                              Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                              Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            else
                              if Thing[2] == "Block2" then
                                Thing[1].CFrame = Thing[1].CFrame
                                Mesh = Thing[7]
                                Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                              else
                                if Thing[2] == "Block3" then
                                  Thing[8] = Thing[8] * cf(0, math.random(50, 80) / 100, 0)
                                  Thing[1].CFrame = Thing[8] * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                                  Mesh = Thing[7]
                                  Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                  Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                else
                                  if Thing[2] == "Obsidian" then
                                    Thing[1].CFrame = cf(Thing[1].Position) * cf(0, Thing[8], 0)
                                    Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                                    Thing[8] = Thing[8] - Thing[9]
                                    Mesh = Thing[7]
                                    Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                    Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                  else
                                    if Thing[2] == "Cylinder" then
                                      Mesh = Thing[7]
                                      Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                      Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                    else
                                      if Thing[2] == "Blood" then
                                        Mesh = Thing[7]
                                        Thing[1].CFrame = Thing[1].CFrame * cf(0, 0.4, 0)
                                        Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                        Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                      else
                                        if Thing[2] == "Elec" then
                                          Mesh = Thing[7]
                                          Mesh.Scale = Mesh.Scale + vt(Thing[7], Thing[8], Thing[9])
                                          Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                        else
                                          if Thing[2] == "Disappear" then
                                            Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          else
                            Thing[1].Parent = nil
                            table.remove(Effects, e)
                          end
                        end
                        -- DECOMPILER ERROR at PC5764: LeaveBlock: unexpected jumping out DO_STMT

                        -- DECOMPILER ERROR at PC5764: LeaveBlock: unexpected jumping out DO_STMT

                        -- DECOMPILER ERROR at PC5764: LeaveBlock: unexpected jumping out IF_ELSE_STMT

                        -- DECOMPILER ERROR at PC5764: LeaveBlock: unexpected jumping out IF_STMT

                        -- DECOMPILER ERROR at PC5764: LeaveBlock: unexpected jumping out IF_ELSE_STMT

                        -- DECOMPILER ERROR at PC5764: LeaveBlock: unexpected jumping out IF_STMT

                        -- DECOMPILER ERROR at PC5764: LeaveBlock: unexpected jumping out IF_ELSE_STMT

                        -- DECOMPILER ERROR at PC5764: LeaveBlock: unexpected jumping out IF_STMT

                        -- DECOMPILER ERROR at PC5764: LeaveBlock: unexpected jumping out IF_THEN_STMT

                        -- DECOMPILER ERROR at PC5764: LeaveBlock: unexpected jumping out IF_STMT

                        -- DECOMPILER ERROR at PC5764: LeaveBlock: unexpected jumping out IF_THEN_STMT

                        -- DECOMPILER ERROR at PC5764: LeaveBlock: unexpected jumping out IF_STMT

                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    fenbarmana2:TweenSize((UDim2.new(0.4, 0, -4 * mana.Value / 100, 0)), nil, 1, 0.4, true)
    fenbarmana4.Text = "Mana(" .. mana.Value .. ")"
    fenbarhp2.BackgroundColor3 = Color3.new(Humanoid.Health / Humanoid.MaxHealth, 0, 0)
    fenbarhp2:TweenSize((UDim2.new(Humanoid.Health / Humanoid.MaxHealth, 0, 1, 0)), nil, 1, 0.4, true)
    fenbarhp3.Text = "(" .. math.floor(Humanoid.Health) .. ")"
    fenbarmove1b:TweenSize((UDim2.new(1 * cooldowns[1] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
    fenbarmove2b:TweenSize((UDim2.new(1 * cooldowns[2] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
    fenbarmove3b:TweenSize((UDim2.new(1 * cooldowns[3] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
    fenbarmove4b:TweenSize((UDim2.new(1 * cooldowns[4] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
    for _,c in pairs(Decrease:children()) do
      if (c:findFirstChild("Duration")) ~= nil then
        c.Duration.Value = c.Duration.Value - 1
        if c.Duration.Value <= 0 then
          c.Parent = nil
        end
      end
      if c.Name == "DecreaseAtk" then
        decreaseatk = decreaseatk + c.Value
      else
        if c.Name == "DecreaseDef" then
          decreasedef = decreasedef + c.Value
        else
          if c.Name == "DecreaseMvmt" then
            decreasemvmt = decreasemvmt + c.Value
          end
        end
      end
    end
    Atk.Value = 1 - (decreaseatk)
    if Atk.Value <= 0 then
      Atk.Value = 0
    end
    Def.Value = 1 - (decreasedef)
    if Def.Value <= 0 then
      Def.Value = 0.01
    end
    Mvmt.Value = 1 - (decreasemvmt)
    if Mvmt.Value <= 0 then
      Mvmt.Value = 0
    end
    decreaseatk = 0
    decreasedef = 0
    decreasemvmt = 0
    AtkVal = Atk.Value * 100
    AtkVal = math.floor(AtkVal)
    AtkVal = AtkVal / 100
    fenbardamage.Text = "Damage\n(" .. AtkVal .. ")"
    DefVal = Def.Value * 100
    DefVal = math.floor(DefVal)
    DefVal = DefVal / 100
    fenbardef.Text = "Defense\n(" .. DefVal .. ")"
    MvmtVal = Mvmt.Value * 100
    MvmtVal = math.floor(MvmtVal)
    MvmtVal = MvmtVal / 100
    if Rooted.Value == true then
      MvmtVal = 0
    end
    fenbarmove.Text = "Walkspeed\n(" .. MvmtVal .. ")"
    fenbaroblsk1.Text = "Obelisks\n(" .. #Obelisks .. ")"
    if StunT.Value <= Stun.Value then
      fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4, 0)), nil, 1, 0.4, true)
    else
      fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4 * Stun.Value / StunT.Value, 0)), nil, 1, 0.4, true)
    end
    fenbarstun3.Text = "Stun(" .. Stun.Value .. ")"
    if 100 <= mana.Value then
      mana.Value = 100
    else
      if mananum <= manaregain then
        mananum = mananum + 1
      else
        mananum = 0
        mana.Value = mana.Value + 1
      end
    end
    for i = 1, #cooldowns do
      if cooldownmax <= cooldowns[i] then
        cooldowns[i] = cooldownmax
      else
        cooldowns[i] = cooldowns[i] + cooldownsadd[i]
      end
    end
    -- DECOMPILER ERROR at PC6128: LeaveBlock: unexpected jumping out DO_STMT

  end
end

]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="HopperBin" referent="RBX0DD127E8A99B4899BE6A3D7C980F0CF3">
			<Properties>
				<bool name="Active">false</bool>
				<token name="BinType">0</token>
				<string name="Name">Nether</string>
				<Content name="TextureId"><null></null></Content>
			</Properties>
			<Item class="LocalScript" referent="RBX7AA429A2ED46453D9213AE65FBA67A86">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Main</string>
					<string name="ScriptGuid">{26E7D29A-1C3A-4771-AEF0-81531EAC2CF5}</string>
					<ProtectedString name="Source"><![CDATA[Player = game:GetService("Players").LocalPlayer
Character = Player.Character
PlayerGui = Player.PlayerGui
Backpack = Player.Backpack
Torso = Character.Torso
Head = Character.Head
Humanoid = Character.Humanoid
Face = Head.face
LeftArm = Character["Left Arm"]
LeftLeg = Character["Left Leg"]
RightArm = Character["Right Arm"]
RightLeg = Character["Right Leg"]
LS = Torso["Left Shoulder"]
LH = Torso["Left Hip"]
RS = Torso["Right Shoulder"]
RH = Torso["Right Hip"]
Neck = Torso.Neck
it = Instance.new
vt = Vector3.new
cf = CFrame.new
euler = CFrame.fromEulerAnglesXYZ
angles = CFrame.Angles
necko = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
necko2 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
LHC0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
LHC1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
RHC0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RHC1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RootPart = Character.HumanoidRootPart
RootJoint = RootPart.RootJoint
RootCF = euler(-1.57, 0, 3.14)
attack = false
stanceattack = false
attackdebounce = false
MMouse = Player:GetMouse()
combo = 0
local hitfloor, posfloor = nil, nil
local idle = 0
local Anim = "Idle"
local Effects = {}
local Weapon = {}
local Welds = {}
local stance = false
local triangparent = workspace
local prechit = false
local MovePart = nil
local Fly = false
local shatterpos = Instance.new("BodyPosition")
local prop = Instance.new("RocketPropulsion")
local decreaseatk = 0
local decreasedef = 0
local decreasemvmt = 0
local move1 = "(Z)\nPrecise Slash"
local move2 = "(X)\nSlice Wave"
local move3 = "(C)\nSonic Strike"
local move4 = "(V)\nVoid Shatter"
local cooldowns = {}
local cooldown1 = 0
table.insert(cooldowns, cooldown1)
local cooldown2 = 0
table.insert(cooldowns, cooldown2)
local cooldown3 = 0
table.insert(cooldowns, cooldown3)
local cooldown4 = 0
table.insert(cooldowns, cooldown4)
local cooldownsadd = {}
local cooldownadd1 = 0.5--0.5
table.insert(cooldownsadd, cooldownadd1)
local cooldownadd2 =0.4-- 0.4
table.insert(cooldownsadd, cooldownadd2)
local cooldownadd3 = 0.3--0.3
table.insert(cooldownsadd, cooldownadd3)
local cooldownadd4 = 0.07--0.07
table.insert(cooldownsadd, cooldownadd4)
local cooldownmax = 100
player = nil
RSH = nil
LSH = nil
RW = Instance.new("Motor")
LW = Instance.new("Motor")
RW.Name = "Right Shoulder"
LW.Name = "Left Shoulder"
LH = Torso["Left Hip"]
RH = Torso["Right Hip"]
TorsoColor = Torso.BrickColor
TorsoRed = TorsoColor.Color.r
TorsoGreen = TorsoColor.Color.g
TorsoBlue = TorsoColor.Color.b
NewCol = Color3.new(0,0,0)
NewCol2 = BrickColor.new("Navy blue").Color
NewCol3 = BrickColor.new("Navy blue").Color
if Player:findFirstChild("Color1") ~= nil then
  NewCol = Player.Color1.Value
end
print(BrickColor.new(NewCol))
local mdec = Instance.new("NumberValue", Decrease)
mdec.Name = "DecreaseDef"
mdec.Value = 0.4
local mdec2 = Instance.new("NumberValue", Decrease)
mdec2.Name = "DecreaseMvmt"
mdec2.Value = 0.1
local Animate = Humanoid.Animator
local canjump = true
removeControl = function()
  canjump = false
end
resumeControl = function()
  canjump = true
end
Player.Character.Humanoid.Changed:connect(function()
  if canjump == false then
    Player.Character.Humanoid.Jump = false
  end
end)
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

frame = 1 / 40
tf = 0
allowframeloss = true
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
    tf = tf + s
    if tf >= frame then
        if allowframeloss then
            script.Heartbeat:Fire()
            lastframe = tick()
        else
            for i = 1, math.floor(tf / frame) do
                script.Heartbeat:Fire()
            end
            lastframe = tick()
        end
        if tossremainder then
            tf = 0
        else
            tf = tf - frame * math.floor(tf / frame)
        end
    end
end)

function swait(num)
    if num == 0 or num == nil then
        ArtificialHB.Event:wait()
    else
        for i = 0, num do
            ArtificialHB.Event:wait()
        end
    end
end

if Character:findFirstChild("Void Katana", true) ~= nil then
  Character:findFirstChild("Void Katana", true).Parent = nil
end
if Player.PlayerGui:findFirstChild("WeaponGUI", true) ~= nil then
  Player.PlayerGui:findFirstChild("WeaponGUI", true).Parent = nil
end
if Character:findFirstChild("Stats", true) ~= nil then
  Character:findFirstChild("Stats", true).Parent = nil
end
local Stats = Instance.new("BoolValue")
Stats.Name = "Stats"
Stats.Parent = Character
local Atk = Instance.new("NumberValue")
Atk.Name = "Damage"
Atk.Parent = Stats
Atk.Value = 1
local Def = Instance.new("NumberValue")
Def.Name = "Defense"
Def.Parent = Stats
Def.Value = 1
local Mvmt = Instance.new("NumberValue")
Mvmt.Name = "Movement"
Mvmt.Parent = Stats
Mvmt.Value = 1
local Block = Instance.new("BoolValue")
Block.Name = "Block"
Block.Parent = Stats
Block.Value = false
local Stun = Instance.new("NumberValue")
Stun.Name = "Stun"
Stun.Parent = Stats
Stun.Value = 0
local StunT = Instance.new("NumberValue")
StunT.Name = "StunThreshold"
StunT.Parent = Stats
StunT.Value = 100
local Rooted = Instance.new("BoolValue")
Rooted.Name = "Rooted"
Rooted.Parent = Stats
Rooted.Value = false
local Stunned = Instance.new("BoolValue")
Stunned.Name = "Stunned"
Stunned.Parent = Stats
Stunned.Value = false
local Stagger = Instance.new("BoolValue")
Stagger.Name = "Stagger"
Stagger.Parent = Stats
Stagger.Value = false
local StaggerHit = Instance.new("BoolValue")
StaggerHit.Name = "StaggerHit"
StaggerHit.Parent = Stats
StaggerHit.Value = false
local RecentEnemy = Instance.new("ObjectValue")
RecentEnemy.Name = "RecentEnemy"
RecentEnemy.Parent = Stats
RecentEnemy.Value = nil
local Decrease = Instance.new("BoolValue")
Decrease.Name = "Decrease"
Decrease.Parent = Stats
Decrease.Value = false
local mana = Instance.new("NumberValue")
mana.Name = "Mana"
mana.Parent = Stats
mana.Value = 0
local passive = Instance.new("NumberValue", Decrease)
passive.Name = "DecreaseDef"
passive.Value = 0.1
local passive2 = Instance.new("NumberValue", Decrease)
passive2.Name = "DecreaseMvmt"
passive2.Value = 0
local passive3 = Instance.new("NumberValue", nil)
passive3.Name = "DecreaseMvmt"
passive3.Value = 0.1
NoOutline = function(Part)
Part.TopSurface = 10
Part.BottomSurface = 10
Part.LeftSurface = 10
Part.RightSurface = 10
Part.FrontSurface = 10
Part.BackSurface = 10
end
part = function(formfactor, parent, reflectance, transparency, brickcolor, name, size)
  local fp = it("Part")
  fp.formFactor = formfactor
  fp.Parent = parent
  fp.Reflectance = reflectance
  fp.Transparency = transparency
  fp.CanCollide = false
  fp.Locked = true
  fp.BrickColor = brickcolor
  fp.Name = name
  fp.Size = size
  fp.Position = Torso.Position
  NoOutline(fp)
  fp.Material = "SmoothPlastic"
  fp:BreakJoints()
  return fp
end
mesh = function(Mesh, part, meshtype, meshid, offset, scale)
  local mesh = it(Mesh)
  mesh.Parent = part
  if Mesh == "SpecialMesh" then
    mesh.MeshType = meshtype
    if meshid ~= "nil" then
      mesh.MeshId = "http://www.roblox.com/asset/?id=" .. meshid
    end
  end
  mesh.Offset = offset
  mesh.Scale = scale
  return mesh
end
weld = function(parent, part0, part1, c0)
  local weld = it("Motor")
  weld.Parent = parent
  weld.Part0 = part0
  weld.Part1 = part1
  weld.C0 = c0
  return weld
end
gui = function(GuiType, parent, text, backtrans, backcol, pos, size)
  local gui = it(GuiType)
  gui.Parent = parent
  gui.Text = text
  gui.BackgroundTransparency = backtrans
  gui.BackgroundColor3 = backcol
  gui.SizeConstraint = "RelativeXY"
  gui.TextXAlignment = "Center"
  gui.TextYAlignment = "Center"
  gui.Position = pos
  gui.Size = size
  gui.Font = "SourceSans"
  gui.FontSize = "Size14"
  gui.TextWrapped = false
  gui.TextStrokeTransparency = 0
  gui.TextColor = BrickColor.new("White")
  return gui
end
local Color1 = Torso.BrickColor
local fengui = it("GuiMain")
fengui.Parent = Player.PlayerGui
fengui.Name = "WeaponGUI"
local fenframe = it("Frame")
fenframe.Parent = fengui
fenframe.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe.BackgroundTransparency = 1
fenframe.BorderColor3 = Color3.new(17, 17, 17)
fenframe.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe.Position = UDim2.new(0.95, 0, 0.7, 0)
local fenframe2 = it("Frame")
fenframe2.Parent = fengui
fenframe2.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe2.BackgroundTransparency = 1
fenframe2.BorderColor3 = Color3.new(17, 17, 17)
fenframe2.Size = UDim2.new(0.2, 0, 0.1, 0)
fenframe2.Position = UDim2.new(0.4, 0, 0.85, 0)
local fenframe3 = it("Frame")
fenframe3.Parent = fengui
fenframe3.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe3.BackgroundTransparency = 1
fenframe3.BorderColor3 = Color3.new(17, 17, 17)
fenframe3.Size = UDim2.new(0.2, 0, 0.2, 0)
fenframe3.Position = UDim2.new(0.8, 0, 0.8, 0)
fenframe3.Name = "MoveFrame"
local fenframe4 = it("Frame")
fenframe4.Parent = fengui
fenframe4.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe4.BackgroundTransparency = 1
fenframe4.BorderColor3 = Color3.new(17, 17, 17)
fenframe4.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe4.Position = UDim2.new(0, 0, 0.7, 0)
local pressedf = false
local fenframe5 = it("Frame")
fenframe5.Parent = fengui
fenframe5.BackgroundColor3 = Color3.new(0, 0, 0)
fenframe5.BackgroundTransparency = 1
fenframe5.BorderColor3 = Color3.new(0, 0, 0)
fenframe5.Size = UDim2.new(1, 0, 1, 0)
fenframe5.Position = UDim2.new(0, 0, 0, 0)
fenframe5.ZIndex = 2
local tellbar = gui("TextLabel", fenframe5, "Press \'F\' to equip your weapon.", 1, Color3.new(0, 0, 0), UDim2.new(0.25, 0, 0.25, 0), UDim2.new(0.5, 0, 0.5, 0))
tellbar.Font = "Arial"
tellbar.TextScaled = true
tellbar.TextTransparency = 1
tellbar.TextStrokeTransparency = 1
tellbar.ZIndex = 2
local fnumb = 0
local fenbarmana1 = gui("TextLabel", fenframe, "", 0, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarmana2 = gui("TextLabel", fenframe, "", 0, BrickColor.new(NewCol3).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarmana4 = gui("TextLabel", fenframe, "Mana(" .. mana.Value .. ")", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbardamage = gui("TextLabel", fenframe2, "Damage", 0.55, Color3.new(0.6078431372549, 0, 0), UDim2.new(-0.23, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbardef = gui("TextLabel", fenframe2, "Defense", 0.55, Color3.new(0, 0, 0.6078431372549), UDim2.new(-0.46, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarmove = gui("TextLabel", fenframe2, "Walkspeed", 0.55, Color3.new(0, 0.6078431372549, 0), UDim2.new(1.03, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarhp1 = gui("TextLabel", fenframe2, "", 0, Color3.new(0, 0, 0), UDim2.new(-0.46, 0, 1, 0), UDim2.new(1.92, 0, 0.4, 0))
local fenbarhp2 = gui("TextLabel", fenbarhp1, "", 0, Color3.new(1, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarhp3 = gui("TextLabel", fenbarhp1, "(100)", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
local fenbarstun1 = gui("TextLabel", fenframe4, "", 0, Color3.new(0, 0, 0), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarstun2 = gui("TextLabel", fenframe4, "", 0, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarstun3 = gui("TextLabel", fenframe4, "Stun(" .. Stun.Value .. ")", 1, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbarmove1 = gui("TextButton", fenframe3, move1, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove1.ZIndex = 2
local fenbarmove1b = gui("TextLabel", fenbarmove1, "", 0.55, BrickColor.new("Medium stone grey").Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove2 = gui("TextButton", fenframe3, move2, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove2.ZIndex = 2
local fenbarmove2b = gui("TextLabel", fenbarmove2, "", 0.55, BrickColor.new("Medium stone grey").Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove3 = gui("TextButton", fenframe3, move3, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove3.ZIndex = 2
local fenbarmove3b = gui("TextLabel", fenbarmove3, "", 0.55, BrickColor.new("Medium stone grey").Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove4 = gui("TextButton", fenframe3, move4, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove4.ZIndex = 2
local fenbarmove4b = gui("TextLabel", fenbarmove4, "", 0.55, BrickColor.new(NewCol3).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local modelzorz = Instance.new("Model")
modelzorz.Parent = Character
modelzorz.Name = "Void Katana"
local prta1 = part(3, modelzorz, 0, 1, BrickColor.new(NewCol), "Parta01", vt())
local prt1 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part01", vt())
local prt2 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part02", vt())
local prt3 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part03", vt())
local prt4 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part04", vt())
local prt5 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part05", vt())
local prt6 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part06", vt())
local prt7 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part07", vt())
local prt8 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part08", vt())
local prt9 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part09", vt())
local prt10 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part10", vt())
local prt11 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part11", vt())
local prt12 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part12", vt())
local prt13 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part13", vt())
local prt14 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part14", vt())
local prt15 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part15", vt())
local prt16 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part16", vt())
local prt17 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part17", vt())
local prt18 = part(3, modelzorz, 0.5, 0, BrickColor.new("White"), "Part18", vt())
local prt19 = part(3, modelzorz, 0.5, 0, BrickColor.new("White"), "Part19", vt())
local prt20 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part20", vt())
msh1 = mesh("BlockMesh", prt1, "", "", vt(0, 0, 0), vt(2, 5, 1))
msh2 = mesh("BlockMesh", prt2, "", "", vt(0, 0, 0), vt(2.01, 2, 2.01))
msh3 = mesh("BlockMesh", prt3, "", "", vt(0, 0, 0), vt(2, 5, 0.5))
msh4 = mesh("BlockMesh", prt4, "", "", vt(0, 0, 0), vt(1, 2, 1))
msh5 = mesh("SpecialMesh", prt5, "Wedge", "nil", vt(0, 0, 0), vt(1, 2, 1))
msh6 = mesh("BlockMesh", prt6, "", "", vt(0, 0, 0), vt(2.02, 3, 2.02))
msh7 = mesh("SpecialMesh", prt7, "Wedge", "nil", vt(0, 0, 0), vt(2.02, 1, 2.02))
msh8 = mesh("BlockMesh", prt8, "", "", vt(0, 0, 0), vt(2, 6, 1))
msh9 = mesh("BlockMesh", prt9, "", "", vt(0, 0, 0), vt(2.01, 3, 1))
msh10 = mesh("BlockMesh", prt10, "", "", vt(0, 0, 0), vt(2.01, 3, 1))
msh11 = mesh("SpecialMesh", prt11, "Wedge", "nil", vt(0, 0, 0), vt(2, 3, 0.5))
msh12 = mesh("SpecialMesh", prt12, "Wedge", "nil", vt(0, 0, 0), vt(2, 1, 1))
msh13 = mesh("SpecialMesh", prt13, "Wedge", "nil", vt(0, 0, 0), vt(2, 1, 1))
msh14 = mesh("BlockMesh", prt14, "", "", vt(0, 0, 0), vt(0.5, 15, 1))
msh15 = mesh("BlockMesh", prt15, "", "", vt(0, 0, 0), vt(0.49, 1, 1))
msh16 = mesh("BlockMesh", prt16, "", "", vt(0, 0, 0), vt(0.49, 1, 1))
msh17 = mesh("BlockMesh", prt17, "", "", vt(0, 0, 0), vt(0.49, 1, 1))
msh18 = mesh("BlockMesh", prt18, "", "", vt(0, 0, 0), vt(0.4, 18, 1.49))
msh19 = mesh("SpecialMesh", prt19, "Wedge", "nil", vt(0, 0, 0), vt(0.4, 5, 1.49))
msh20 = mesh("SpecialMesh", prt20, "Wedge", "nil", vt(0, 0, 0), vt(0.5, 7, 1))
local wlda1 = weld(prta1, prta1, LeftArm, cf(0, 1, 0))
local wld1 = weld(prt1, prt1, Torso, euler(1.4, 0, 0) * euler(0, -1.57, 0) * cf(-1.8, 0.8, -0.6))
local wld2 = weld(prt1, prt2, prt1, euler(0, 0, 0) * cf(0, 0.5, 0.1))
local wld3 = weld(prt1, prt3, prt2, euler(0, 0, 0) * cf(0, -0.5, 0.15))
local wld4 = weld(prt1, prt4, prt2, euler(0.5, 0, 0) * cf(0, 0.2, -0.1))
local wld5 = weld(prt1, prt5, prt2, euler(3.14, 3.14, 0) * cf(0, 0.4, 0.1))
local wld6 = weld(prt1, prt6, prt2, euler(-0.2, 0, 0) * cf(0, -1, 0))
local wld7 = weld(prt1, prt7, prt6, euler(0, 3.14, 0) * cf(0, -0.4, 0))
local wld8 = weld(prt1, prt8, prt2, euler(0, 0, 0) * cf(0, -1.5, 0))
local wld9 = weld(prt1, prt9, prt8, euler(-0.785, 0, 0) * cf(0, 0.05, -0.2))
local wld10 = weld(prt1, prt10, prt8, euler(0.785, 0, 0) * cf(0, -0.25, -0.2))
local wld11 = weld(prt1, prt11, prt8, euler(0, 0, 3.14) * cf(0, 0, 0.15))
local wld12 = weld(prt1, prt12, prt8, euler(0, 0, 3.14) * cf(0, -0.2, 0.2))
local wld13 = weld(prt1, prt13, prt8, euler(0, 0, 0) * cf(0, -0.4, 0.2))
local wld14 = weld(prt1, prt14, prt8, euler(0, 0, 0) * cf(0, -1.8, 0.1))
local wld15 = weld(prt1, prt15, prt14, euler(0.785, 0, 0) * cf(0, 0.8, -0.1))
local wld16 = weld(prt1, prt16, prt14, euler(0.785, 0, 0) * cf(0, 0.3, -0.1))
local wld17 = weld(prt1, prt17, prt14, euler(0.785, 0, 0) * cf(0, -0.2, -0.1))
local wld18 = weld(prt1, prt18, prt14, euler(0, 0, 0) * cf(0, -0.3, 0.05))
local wld19 = weld(prt1, prt19, prt18, euler(0, 0, 0) * cf(0, -2.3, 0))
local wld20 = weld(prt1, prt20, prt14, euler(0, 0, 0) * cf(0, -2.2, 0))
for _,c in pairs(modelzorz:children()) do
  table.insert(Weapon, c)
end
for _,c in pairs(prt1:children()) do
  if c.className == "Motor" then
    table.insert(Welds, c)
  end
end
local hitbox = part(3, modelzorz, 0, 1, BrickColor.new("Black"), "Hitbox2", vt())
hitbox.Anchored = false
local hbwld = weld(hitbox, hitbox, RootPart, euler(0, 0, 0) * cf(0, 0, 0))
local hitbox2 = part(3, nil, 0, 1, BrickColor.new("Black"), "Hitbox", vt(1, 1, 1))
hitbox2.Anchored = true
local hitboxCF = cf(0, 0, 0)
hboxpos = Instance.new("BodyPosition", nil)
hboxpos.P = 2000
hboxpos.D = 100
hboxpos.maxForce = Vector3.new(545000, 545000, 545000)
hitboxweld = function()
  hbwld.Parent = modelzorz
  hbwld.Part0 = hitbox
  hbwld.Part1 = prt6
end
Bin = script.Parent
Bin.Name = "Void Katana"
script.Parent = Bin
if Bin.Name == "Nether: Baneful Void" then
  Bin.Name = "Void Katana"
end
local bodvel = Instance.new("BodyVelocity")
local bg = Instance.new("BodyGyro")
so = function(id, par, vol, pit)
  local sou = Instance.new("Sound", par or workspace)
  sou.Volume = vol
  sou.Pitch = pit or 1
  sou.SoundId = "http://www.roblox.com/asset/?id=" .. id
  coroutine.resume(coroutine.create(function(Sound)
    swait()
    Sound:play()
  end), sou)
  game:GetService("Debris"):AddItem(sou, 6)
end
so2 = function(id, par, vol, pit)
  local sou = Instance.new("Sound", par or workspace)
  sou.Volume = vol
  sou.Pitch = pit or 1
  sou.SoundId = id
  sou:play()
  game:GetService("Debris"):AddItem(sou, 6)
end
function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end
hideanim = function()
  equipped = false
  for i = 0, 1, 0.1 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.3, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, -0.6), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.2) * euler(0, -1.57, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -0.4), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, RHC0, 0.4)
    LH.C0 = clerp(LH.C0, LHC0, 0.4)
  end
  wld1.Part1 = Torso
  wld1.C0 = euler(1.4, 0, 0) * euler(0, -1.57, 0) * cf(-1.8, 0.8, -0.6)
  for i = 0, 1, 0.1 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
  end
  mdec2.Parent = nil
  mdec.Parent = Decrease
end
mdec.Parent = Decrease
equipanim = function()
  equipped = true
  mdec.Parent = nil
  for i = 0, 1, 0.1 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, -0.6), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.2) * euler(0, -1.57, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -0.4), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
  end
  wld1.Part1 = RightArm
  wld1.C0 = euler(1.3, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0)
  mdec2.Parent = Decrease
end
StaggerAnim = function()
  attack = true
  removeControl()
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.35 do
    swait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -40
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, -0.4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.7) * euler(0, -0.7, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  for i = 0, 1, 0.2 do
    swait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -40
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0.1, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(-0.5, 0, -0.4), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.7) * euler(0, -0.7, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.5), 0.4)
  end
  for i = 0, 1, 0.1 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.4) * euler(0.5, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.8) * euler(-0.2, 0, -0.4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.3, 0, 0.4) * euler(0, -0.4, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.3, 0, -0.2) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 1.2), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, 0, -1) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  for i = 1, 50 do
    swait()
    if StunT.Value <= Stun.Value then
      break
    end
  end
  do
    resumeControl()
    combo = 0
    attack = false
  end
end
StaggerHitt = function()
  attack = true
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.1 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.7) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, -0.6), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.9) * euler(0, -0.7, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.4, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, -0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.2, 0.2), 0.3)
  end
  attack = false
end
StunAnim = function()
  attack = true
  removeControl()
  Stunned.Value = true
  showDamage(Character, "Stunned", "Interrupt")
  local dec = Instance.new("NumberValue", Decrease)
  dec.Name = "DecreaseMvmt"
  dec.Value = 10
  for i = 0, 1, 0.3 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.2, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1, 0, 0.4) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.3), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, 0), 0.25)
  end
  for i = 0, 1, 0.3 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0.8, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1.2, 0, 0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(0.1, 0, 0.7), 0.25)
  end
  for i = 0, 1, 0.3 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -1), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1.57, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, -0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.1, 0, 0.3), 0.25)
  end
  local gairost = Instance.new("BodyGyro")
  gairost.Parent = RootPart
  gairost.maxTorque = Vector3.new(400000, 0, 400000) * math.huge
  gairost.P = 20000
  gairost.cframe = cf(0, 0, 0)
  for i = 0, 1, 0.1 do
    swait()
    if hitfloor ~= nil then
      Torso.Velocity = vt(0, 0, 0)
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2.5) * euler(1.57, 0, -3.14), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1.5) * euler(0.2, 0, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.5, 0, -1.57) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 0), 0.3)
  end
  for i = 1, 70 do
    swait()
    gairost.cframe = RootPart.CFrame
    if hitfloor ~= nil then
      Torso.Velocity = vt(0, 0, 0)
    end
  end
  for i = 0, 1, 0.2 do
    swait()
    Stun.Value = 0
    gairost.cframe = RootPart.CFrame
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1, 0, -4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1) * euler(0.2, -1, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, 0.2) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, -1) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 1), 0.3)
  end
  resumeControl()
  gairost.Parent = nil
  dec.Parent = nil
  Stun.Value = 0
  combo = 0
  Stunned.Value = false
  attack = false
  for i = 1, 10 do
    swait()
    Stun.Value = 0
  end
end
attackone = function()
  attack = true
  stance = true
  for i = 0, 1, 0.2 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * euler(0, 0, 0) * cf(0, 1, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0.5), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.5), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(2, 0, 1) * euler(0, -1, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.5, 0), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC201: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC201: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("199146359", prt18, 1, 1.1)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(0.5, 5, 1)
  hitboxCF = prt18.CFrame
  hitbox.CFrame = hitboxCF
  blcf = nil
  scfr = nil
  for i = 0, 1, 0.3 do
    swait()
    hitboxCF = prt18.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 5, 5, 10, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(5, 8)), nil, true)
    wld1.C0 = clerp(wld1.C0, euler(2.5, 0, 0) * euler(0, 0, 0) * cf(0, 1, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.5) * euler(0.2, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.5), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.2, 0.5, -0.3) * euler(0.6, 0, -0.8) * euler(0, -0.5, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.6, 0, -0.4), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.5, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, -0.5, 0), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC466: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC466: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  for i = 0, 1, 0.2 do
    swait()
    hitboxCF = prt18.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 5, 5, 10, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(5, 8)), nil, true)
    wld1.C0 = clerp(wld1.C0, euler(2.8, 0, 0) * euler(0, 0, 0) * cf(0, 1, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.5) * euler(0.2, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.5), 0.4)
    RW.C0 = clerp(RW.C0, cf(0.5, 0.5, -0.5) * euler(0.6, 0, -1) * euler(0, -0.7, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.6, 0, -0.4), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.5, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, -0.5, 0), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC700: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC700: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
attacktwo = function()
  attack = true
 stance = true
  for i = 0, 1, 0.2 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * euler(0, 0, 0) * cf(0, 1, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.7) * euler(0.2, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.7), 0.4)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -1) * euler(0, 1.2, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.8, 0, -0.4), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.2) * euler(0, 1.57, 0) * euler(0, -0.7, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.8, -1, 0.2) * euler(0, -1.57, 0) * euler(0, -0.7, 0), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC207: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC207: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("199150686", prt18, 1, 1.2)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(0.5, 5, 1)
  hitboxCF = prt18.CFrame
  hitbox.CFrame = hitboxCF
  for i = 0, 1, 0.3 do
    swait()
    hitboxCF = prt18.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 5, 5, 10, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(5, 8)), nil, true)
    wld1.C0 = clerp(wld1.C0, euler(2.5, 0, 0) * euler(0, 0, 0) * cf(0, 1, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5) * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.5), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.3, 0, 1) * euler(0, 1.6, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.2), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.5, 0), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC468: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC468: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  for i = 0, 1, 0.35 do
    swait()
    hitboxCF = prt18.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 5, 5, 10, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(5, 8)), nil, true)
    wld1.C0 = clerp(wld1.C0, euler(2.8, 0, 0) * euler(0, 0, 0) * cf(0, 1, 0), 0.5)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.8) * euler(0.1, 0, 0), 0.5)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.8), 0.5)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 0.8) * euler(0, 1.3, 0), 0.5)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.2), 0.5)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, -0.2) * euler(0, 1.57, 0) * euler(0, 0.8, 0), 0.5)
    LH.C0 = clerp(LH.C0, cf(-0.8, -1, 0.2) * euler(0, -1.57, 0) * euler(0, 0.8, 0), 0.5)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC702: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC702: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
attackthree = function()
  attack = true
 stance = true
  for i = 0, 1, 0.2 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * euler(0, 0, 0) * cf(0, 1, 0), 0.5)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.7) * euler(0.2, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.7), 0.4)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -1) * euler(0, -1.4, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, 0.8), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.1) * euler(0, 1.57, 0) * euler(0, -0.7, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.8, -1, -0.1) * euler(0, -1.57, 0) * euler(0, -0.7, 0), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC207: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC207: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("199146359", prt18, 1, 0.8)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(0.5, 5, 1)
  hitboxCF = prt18.CFrame
  hitbox.CFrame = hitboxCF
  for i = 0, 1, 0.3 do
    swait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * 60
    end
    hitboxCF = prt18.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 5, 5, 10, math.random(10, 20), "Normal", RootPart, 0.5, 2, (math.random(5, 8)), nil, true)
    wld1.C0 = clerp(wld1.C0, euler(3, 0, 0) * euler(0, 0, 0) * cf(0, 1, 0), 0.5)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57) * euler(0.2, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1.57), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.7) * euler(0, -1.57, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -1), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.4) * euler(0, 1.57, 0) * euler(0.2, -1.57, 0), 0.2)
    LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.4) * euler(0, -1.57, 0) * euler(-0.4, -1.57, 0), 0.2)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC478: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC478: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  for i = 0, 1, 0.3 do
    swait()
    hitboxCF = prt18.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 5, 5, 10, math.random(10, 20), "Normal", RootPart, 0.5, 2, (math.random(5, 8)), nil, true)
    wld1.C0 = clerp(wld1.C0, euler(3, 0, 0) * euler(0, 0, 0) * cf(0, 1, 0), 0.5)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57) * euler(0.2, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1.57), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.7) * euler(0, -1.57, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -1), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.4) * euler(0, 1.57, 0) * euler(0.2, -1.57, 0), 0.2)
    LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.4) * euler(0, -1.57, 0) * euler(-0.4, -1.57, 0), 0.2)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC712: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC712: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
attackfour = function()
  attack = true
 stance = true
  for i = 0, 1, 0.2 do
    swait()
    wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1) * euler(0.2, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -1), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.2) * euler(0, -1.57, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.7, 0, -1), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, -0.3) * euler(0, 1.57, 0) * euler(0, 1, 0), 0.4)
    LH.C0 = clerp(LH.C0, cf(-0.8, -1, 0.3) * euler(0, -1.57, 0) * euler(0, 1, 0), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
      end
    end
  end
      hit, pos = rayCast(RootPart.Position, RootPart.CFrame.lookVector, 30, Character)
      ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
      ref.Anchored = true
      ref.CFrame = cf(pos)
      so("228343249", ref, 1, 1)
      MagniDamage(ref, 10, 7, 8, math.random(10, 20), "Knockdown", ref, 0, 1, (math.random(8, 10)), nil, nil, true)
      MagicBlock(BrickColor.new(NewCol3), cf(ref.Position), 1, 1, 1, 5, 5, 5, 0.1, 1, workspace)
      MagicBlock(BrickColor.new(NewCol3), cf(ref.Position), 1, 1, 1, 2, 2, 2, 0.05, 1, workspace)
      eul = euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      MagicRing(BrickColor.new(NewCol3), cf(ref.Position) * eul, 1, 1, 1, 1, 1, 1, 0.05)
      MagicRing(BrickColor.new(NewCol3), cf(ref.Position) * eul * euler(1.57, 0, 0), 1, 1, 1, 1, 1, 1, 0.05)
      MagicCircle(BrickColor.new(NewCol3), LeftArm.CFrame * cf(0, -1, 0), 1, 1, 1, 2, 2, 2, 0.05)
      game:GetService("Debris"):AddItem(ref, 1)
      swait(10)
      attack = false
    end
VoidGather = function()
attack = true
  if stance == true then
    stance = false
	stanceattack = true
else
	stance = true
	stanceattack = false
  end
attack = false
end
do1 = function()
  if attack == true then
	if stanceattack == false then
 	   return 
	end
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[1] and (mana.Value >= 15 or stance == false) then
    attack = true
    if stance == true then
	  cooldowns[1] = 35
      cooldowns[1] = 0
      for i = 0, 1, 0.1 do
        swait()
        wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0), 0.3)
        Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0) * euler(0, 0, -0.4), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -0.5), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.1) * euler(0, -1.57, 0), 0.3)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-0.5, 0.8, -0.5) * euler(2.4, 0, 1), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, 0) * euler(0, 0, -0.4), 0.3)
        LH.C0 = clerp(LH.C0, cf(-0.9, -0.8, -0.1) * euler(0, -1.57, 0) * euler(0, 0.5, 0) * euler(0, 0, 0.1), 0.3)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
          end
        end
      end
      for i = 0, 1, 0.1 do
        swait()
        wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0), 0.3)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0) * euler(0, 0, 1.57), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -1.57), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 0.4) * euler(0, -1.57, 0), 0.3)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1.57), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(0.5, -1, -0.2) * euler(0, 1.57, 0) * euler(-0.4, 1.57, 0), 0.3)
        LH.C0 = clerp(LH.C0, cf(-0.5, -1, 0.2) * euler(0, -1.57, 0) * euler(0.2, 1.57, 0), 0.3)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
          end
        end
      end
      mana.Value = mana.Value - 15
      local dec = Instance.new("NumberValue", Decrease)
      dec.Name = "DecreaseMvmt"
      dec.Value = 10
      ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
      ref.Anchored = true
      game:GetService("Debris"):AddItem(ref, 10)
      local ringnum = 2
      local num = 5
      so("228343271", ref, 1, 1.4)
      local doing = 0
      local euld = 0
      for i = 0, 1, 0.1 do
        swait(1)
        if doing < 100 then
          if num >= 5 then
            num = 0
          end
          num = num + 1
          ref.CFrame = RootPart.CFrame * cf(0, 0, -3.2)
          hit, pos = rayCast(ref.Position, RootPart.CFrame.lookVector, 100, Character)
          local mag = (ref.Position - pos).magnitude
          MagicCylinder3(BrickColor.new(NewCol3), CFrame.new((ref.Position + pos) / 2, pos) * angles(1.57, 0, 0), 10, mag * 5, 10, 3, 1, 3, 0.1)
          MagicBlock(BrickColor.new(NewCol3), cf(pos), 5, 5, 5, 3, 3, 3, 0.1, 1, workspace)
          if ringnum >= 2 then
            ringnum = 0
            MagicRing(BrickColor.new(NewCol3), cf(pos) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 0, 0, 0.5, 1, 1, 0, 0.05)
          end
          if hit ~= nil then
            Damagefunc(hit, 14, 16, 0, "Normal", RootPart, 1, 1, (math.random(4, 7)), nil, nil, true, nil, nil, nil)
			swait()
          end
          ringnum = ringnum + 1
          if Stagger.Value ~= true and StunT.Value > Stun.Value then
            do
              if StaggerHit.Value == true then
                break
              end
              do
                do
                  local thedo = euld
                  for d = 1, 2 do
                    if d == 1 then
                      thedo = euld
                    else
                      thedo = -euld
                    end
                    if num >= 5 then
                      num = 0
                    end
                    num = num + 1
                    ref.CFrame = RootPart.CFrame * cf(0, 0, -3.2)
                    hit, pos = rayCast(ref.Position, RootPart.CFrame * euler(0, thedo, 0).lookVector, 100, Character)
                    local mag = (ref.Position - pos).magnitude
                    ringnum = ringnum + 1
                    if Stagger.Value ~= true and StunT.Value > Stun.Value then
                      do
                        if StaggerHit.Value == true then
                          break
                        end
                      end
                    end
					end
                  doing = doing + 1
                  euld = euld + 0.02
              end
            end
		end
	end
end
end
      triangparent = workspace
      dec.Parent = nil
      ref.Parent = nil
      wld1.Part1 = RightArm
      wld1.C0 = euler(1.3, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0)
      stance = true
    elseif stance == false then
        cooldowns[1] = 35
        cooldowns[1] = 0
        prechit = true
so("199146359", prt18, 1, 0.8)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(0.5, 5, 1)
  hitboxCF = prt18.CFrame
  hitbox.CFrame = hitboxCF
        for i = 0, 1, 0.3 do
    swait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * 60
    end
    hitboxCF = prt18.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 5, 5, 10, math.random(10, 20), "Normal", RootPart, 0.5, 2, (math.random(5, 8)), nil, true)
    wld1.C0 = clerp(wld1.C0, euler(3, 0, 0) * euler(0, 0, 0) * cf(0, 1, 0), 0.5)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57) * euler(0.2, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1.57), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.7) * euler(0, -1.57, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -1), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.4) * euler(0, 1.57, 0) * euler(0.2, -1.57, 0), 0.2)
    LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.4) * euler(0, -1.57, 0) * euler(-0.4, -1.57, 0), 0.2)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC478: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC478: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  for i = 0, 1, 0.3 do
    swait()
    hitboxCF = prt18.CFrame
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 5, 5, 10, math.random(10, 20), "Normal", RootPart, 0.5, 2, (math.random(5, 8)), nil, true)
    wld1.C0 = clerp(wld1.C0, euler(3, 0, 0) * euler(0, 0, 0) * cf(0, 1, 0), 0.5)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57) * euler(0.2, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 1.57), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.57, 0, 1.7) * euler(0, -1.57, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -1), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.4) * euler(0, 1.57, 0) * euler(0.2, -1.57, 0), 0.2)
    LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.4) * euler(0, -1.57, 0) * euler(-0.4, -1.57, 0), 0.2)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC712: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC712: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
end
		prechit = false
		stance = true
          attack = false
      end
    end
do2 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[2] and (mana.Value >= 15 or stance == false) then
    attack = true
    if stance == true then
	  cooldowns[2] = 70
      cooldowns[2] = 0
      for i = 0, 1, 0.1 do
        swait()
        wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0), 0.3)
        Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0) * euler(0, 0, -0.4), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -0.5), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.1) * euler(0, -1.57, 0), 0.3)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-0.5, 0.8, -0.5) * euler(2.4, 0, 1), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, 0) * euler(0, 0, -0.4), 0.3)
        LH.C0 = clerp(LH.C0, cf(-0.9, -0.8, -0.1) * euler(0, -1.57, 0) * euler(0, 0.5, 0) * euler(0, 0, 0.1), 0.3)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
          end
        end
      end
      for i = 0, 1, 0.2 do
        swait()
        wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0), 0.5)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.57) * euler(0, 0, 0), 0.5)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -1.57), 0.5)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 0.4) * euler(0, -1.57, 0), 0.5)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, -1.57), 0.5)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.5)
        RH.C0 = clerp(RH.C0, cf(0.6, -1, -0.4) * euler(0, 1.57, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.5)
        LH.C0 = clerp(LH.C0, cf(-0.6, -1, 0.4) * euler(0, -1.57, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.5)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
          end
        end
      end
      stance = true
      mana.Value = mana.Value - 15
      MagicCircle(BrickColor.new(NewCol3), LeftArm.CFrame * cf(0, -1, 0), 1, 1, 1, 2, 2, 2, 0.05)
      CF = LeftArm.CFrame * cf(0, -1, 0)
      ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
      ref.Anchored = true
      ref.CFrame = CF
      game:GetService("Debris"):AddItem(ref, 5)
      local hit, pos = nil, nil
      for i = 0, 1, 0.1 do
        swait()
        so("228343324", ref, 1, 1)
        MagicCircle(BrickColor.new(NewCol3), cf(ref.Position), 1, 1, 1, 4, 4, 4, 0.1)
        hit, pos = rayCast(ref.Position, RootPart.CFrame.lookVector, 8, Character)
        ref.CFrame = ref.CFrame * cf(0, -8, 0)
        if hit ~= nil then
          break
        end
      end
      do
        do
          MovePart = hit
          if hit ~= nil then
            so("228343304", hit, 1, 1)
            Damagefunc(hit, 9, 11, math.random(10, 20), "Normal", RootPart, 0, 1, (math.random(5, 10)), nil, nil, true, "Movement", 0.1, 200)
			MagicCircle(BrickColor.new(NewCol3), cf(hit.Position), 1, 1, 1, 4, 4, 4, 0.1)	
			if hit.Parent:FindFirstChild("Humanoid") ~= nil then
			if hit.Parent:FindFirstChild("Torso") ~= nil then
			Character:MoveTo(hit.Position)
			end
			end
            ref.Parent = nil
          else
            MovePart = ref
          end
end
end
elseif stance == false then
		local dec = Instance.new("NumberValue", Decrease)
        dec.Name = "DecreaseMvmt"
        dec.Value = 10
          cooldowns[2] = 70
          cooldowns[2] = 0
          Cloak()
          do
            target = findNearestTorso(Torso.Position)
            if target ~= nil then
              RootPart.CFrame = cf(RootPart.Position, target.Position)
            end
            MoveTo = RootPart.CFrame.lookVector * 80
            for i = 0, 1, 0.1 do
              swait()
              so("200632992", Torso, 1, 1)
              if Rooted.Value == false then
                Torso.Velocity = MoveTo
              end
              MagniDamage(RootPart, 20, 2, 3, math.random(20, 30), "Knockdown", RootPart, 0.3, 1, (math.random(5, 6)), nil, nil, false)
              eul = euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) * cf(math.random(-800, 800) / 100, math.random(-800, 800) / 100, math.random(-800, 800) / 100)
              MagicCircle(BrickColor.new("White"), cf(RootPart.Position) * eul, 2, 10, 2, -0.05, 5, -0.05, 0.05)
              MagicCircle(BrickColor.new("White"), cf(RootPart.Position) * eul * euler(1.57, 0, 0), 2, 10, 2, -0.05, 5, -0.05, 0.05)
            end
            UnCloak()
			dec.Parent = nil
			end
            wld1.C0 = euler(2.5, 0, 0) * euler(0, 0, 0) * cf(0, 1, 0)
            Neck.C0 = necko * euler(0, 0, -0.5) * euler(0.2, 0, 0)
            RootJoint.C0 = RootCF * euler(0, 0, 0.5)
            RW.C0 = cf(1.5, 0.5, 0) * euler(2, 0, 1) * euler(0, 2, 0)
            RW.C1 = cf(0, 0.5, 0) * euler(0, 0, 0)
            LW.C0 = cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4)
            LW.C1 = cf(0, 0.5, 0) * euler(0, 0, 0)
            RH.C0 = cf(0.9, -0.8, 0) * euler(0, 1.57, 0) * euler(-0.4, 0, 0)
            LH.C0 = cf(-0.9, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.4, 0, 0)
            swait(10)
	end
end
stance = true
attack = false
end
            
      --end
    --end
  --end
do3 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[3] and (mana.Value >= 15 or stance == false) then
    attack = true
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = 10
    if stance == true then
	  cooldowns[3] = 100
      cooldowns[3] = 0
      for i = 0, 1, 0.1 do
        swait()
        wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0), 0.3)
        Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0) * euler(0, 0, -0.4), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -0.5), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.1) * euler(0, -1.57, 0), 0.3)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-0.5, 0.8, -0.5) * euler(2.4, 0, 1), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, 0) * euler(0, 0, -0.4), 0.3)
        LH.C0 = clerp(LH.C0, cf(-0.9, -0.8, -0.1) * euler(0, -1.57, 0) * euler(0, 0.5, 0) * euler(0, 0, 0.1), 0.3)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC266: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC266: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      for i = 0, 1, 0.3 do
        swait()
        wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0), 0.4)
        Neck.C0 = clerp(Neck.C0, necko * euler(-0.1, 0, 0) * euler(0, 0, 0.8), 0.4)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1) * euler(0.4, 0, 0) * euler(0, 0, -0.8), 0.4)
        RW.C0 = clerp(RW.C0, cf(1.4, 0.4, 0) * euler(-1, 0, 0.8) * euler(0, -1.2, 0), 0.4)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1, 0, 0) * euler(0, -1.57, 0) * euler(-0.8, 0, 0), 0.4)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
        RH.C0 = clerp(RH.C0, cf(0.7, -0.8, -0.8) * euler(0, 1.57, 0) * euler(0, 0.5, 0) * euler(0, 0, -0.8), 0.4)
        LH.C0 = clerp(LH.C0, cf(-0.9, 0.1, 0.2) * euler(0, -1.57, 0) * euler(0, 0.8, 0) * euler(0, 0, -0.3), 0.4)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC518: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC518: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
      ref.Anchored = true
      ref.CFrame = RootPart.CFrame * cf(0, 0, -5)
      game:GetService("Debris"):AddItem(ref, 10)
      so("228343349", ref, 1, 1)
      table.insert(Effects, {ref, "VField", 50, RootPart.CFrame, 0})
      stance = true
      mana.Value = mana.Value - 15
      for i = 0, 1, 0.1 do
        swait()
        wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0), 0.4)
        Neck.C0 = clerp(Neck.C0, necko * euler(-0.1, 0, 0) * euler(0, 0, 0.8), 0.4)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1) * euler(0.4, 0, 0) * euler(0, 0, -0.8), 0.4)
        RW.C0 = clerp(RW.C0, cf(1.4, 0.4, 0) * euler(-1, 0, 0.8) * euler(0, -1.2, 0), 0.4)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1, 0, 0) * euler(0, -1, 0) * euler(-1.4, 0, 0), 0.4)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
        RH.C0 = clerp(RH.C0, cf(0.7, -0.8, -0.8) * euler(0, 1.57, 0) * euler(0, 0.5, 0) * euler(0, 0, -0.8), 0.4)
        LH.C0 = clerp(LH.C0, cf(-0.9, 0.1, 0.2) * euler(0, -1.57, 0) * euler(0, 0.8, 0) * euler(0, 0, -0.3), 0.4)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC831: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC831: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
    else
	  cooldowns[3] = 100
      cooldowns[3] = 0
      for i = 1, 3 do
        for i = 0, 1, 0.3 do
          swait()
          wld1.C0 = clerp(wld1.C0, euler(2, 0, 0) * euler(0, 0, 0) * cf(0, 1, 0), 0.6)
          Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.7) * euler(0.1, 0, 0), 0.6)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.7), 0.6)
          RW.C0 = clerp(RW.C0, cf(0.7, 0.5, -0.5) * euler(1.57, 0, -1.2) * euler(0, 2, 0) * euler(0, 0, -0.5), 0.6)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.6)
          LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.2), 0.6)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.6)
          RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.1) * euler(0, 1.57, 0) * euler(0, -0.7, 0), 0.6)
          LH.C0 = clerp(LH.C0, cf(-0.8, -1, -0.1) * euler(0, -1.57, 0) * euler(0, -0.7, 0), 0.6)
          if Stagger.Value ~= true and StunT.Value > Stun.Value then
            do
              if StaggerHit.Value == true then
                break
              end
              -- DECOMPILER ERROR at PC1050: LeaveBlock: unexpected jumping out IF_THEN_STMT

              -- DECOMPILER ERROR at PC1050: LeaveBlock: unexpected jumping out IF_STMT

            end
          end
        end
        CF = RootPart.CFrame * cf(0, 0, -15)
        ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
        ref.Anchored = true
        ref.CFrame = CF
        game:GetService("Debris"):AddItem(ref, 10)
        blcf = nil
        scfr = nil
        for i = 0, 1, 0.4 do
          swait()
          CF = RootPart.CFrame * cf(0, 0, -15)
          ref.CFrame = CF
          so("200632992", ref, 1, 1)
          MagniDamage(ref, 20, 4, 5, math.random(10, 20), "Normal", ref, 0.2, 1, (math.random(3, 8)), nil, nil, false)
          for i = 1, 2 do
            eul = euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) * cf(math.random(-800, 800) / 100, math.random(-800, 800) / 100, math.random(-800, 800) / 100)
            MagicCircle(BrickColor.new("White"), cf(ref.Position) * eul, 2, 10, 2, -0.05, 5, -0.05, 0.05)
            MagicCircle(BrickColor.new("White"), cf(ref.Position) * eul * euler(1.57, 0, 0), 2, 10, 2, -0.05, 5, -0.05, 0.05)
          end
          wld1.C0 = clerp(wld1.C0, euler(2.8, 0, 0) * euler(0, 0, 0) * cf(0, 1, 0), 0.8)
          Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.7) * euler(0, 0, 0), 0.8)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.7), 0.8)
          RW.C0 = clerp(RW.C0, cf(1.57, 0.5, 0) * euler(1.57, 0, 1.57) * euler(0, 2, 0) * euler(0, 0, 0.5), 0.8)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.8)
          LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.6, 0, -0.4), 0.8)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.8)
          RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.1) * euler(0, 1.57, 0) * euler(0, -0.7, 0), 0.8)
          LH.C0 = clerp(LH.C0, cf(-0.8, -1, -0.1) * euler(0, -1.57, 0) * euler(0, -0.7, 0), 0.8)
          if Stagger.Value ~= true and StunT.Value > Stun.Value then
            do
              if StaggerHit.Value == true then
                break
              end
              -- DECOMPILER ERROR at PC1430: LeaveBlock: unexpected jumping out IF_THEN_STMT

              -- DECOMPILER ERROR at PC1430: LeaveBlock: unexpected jumping out IF_STMT

            end
          end
        end
        ref.Parent = nil
      end
      for i = 1, 10 do
        swait()
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC1455: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC1455: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
    end
    dec.Parent = nil
    attack = false
stance = true
  end
end
do4 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[4] and mana.Value >= 40 then
    attack = true
	cooldowns[4] = 135
    cooldowns[4] = 0
    target = findNearestTorso(RootPart.Position)
    if --[[target ~= nil and distance <= 30--]] lol == lol then
      local dec = Instance.new("NumberValue", Decrease)
      dec.Name = "DecreaseMvmt"
      dec.Value = 10
      local BodGy = Instance.new("BodyGyro", RootPart)
      BodGy.maxTorque = Vector3.new(0, math.huge, 0)
      BodGy.P = 2000
      BodGy.D = 100
      BodGy.cframe = cf(Torso.Position, target.Position)
      removeControl()
      for i = 0, 1, 0.1 do
        swait()
        BodGy.cframe = cf(Torso.Position, target.Position)
        wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0), 0.3)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.57) * euler(0, 0, 0), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -1.57), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 0.4) * euler(0, -1.57, 0), 0.3)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, -1.57), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(0.6, -1, -0.4) * euler(0, 1.57, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
        LH.C0 = clerp(LH.C0, cf(-0.6, -1, 0.4) * euler(0, -1.57, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
      end
      shatterpos.P = 2000
      shatterpos.D = 100
      shatterpos.maxForce = Vector3.new(545000, 545000, 545000)
      shatterpos.position = target.Position
      shatterpos.Parent = target
      so("160867463", target, 1, 1)
      num = 0
      for i = 0, 1, 0.02 do
        swait()
        num = num + 1
        if num >= 4 then
          num = 0
          targfloor, targpos = rayCast(target.Position - vt(0, 4, 0), CFrame.new(target.Position, target.Position - Vector3.new(0, 5, 0)).lookVector, 100, Character)
          if targfloor ~= nil then
            MagicWave(BrickColor.new(NewCol2), cf(targpos), 5, 5, 5, 2, -0.1, 2, 0.1)
          end
        end
        MagicCircle2(BrickColor.new(NewCol2), cf(target.Position), 60, 60, 60, -5, -5, -5, 0.02)
        shatterpos.position = shatterpos.position + vt(0, 0.2, 0)
        BodGy.cframe = cf(Torso.Position, target.Position)
        wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0), 0.1)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.57) * euler(-0.4, 0, 0), 0.1)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 0.4) * euler(0, -1.57, 0), 0.1)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.1)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(3, 0, 0) * euler(0, 0, -1), 0.1)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.1)
        RH.C0 = clerp(RH.C0, cf(0.6, -1, -0.4) * euler(0, 1.57, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.1)
        LH.C0 = clerp(LH.C0, cf(-0.6, -1, 0.4) * euler(0, -1.57, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.1)
      end
      so("160867437", target, 1, 1.2)
      for i = 0, 1, 0.1 do
        swait()
        num = num + 1
        if num >= 4 then
          num = 0
          targfloor = rayCast(target.Position - vt(0, 4, 0), CFrame.new(target.Position, target.Position - Vector3.new(0, 5, 0)).lookVector, 100, Character)
          if targfloor ~= nil then
            MagicWave(BrickColor.new(NewCol2), cf(targpos), 5, 5, 5, 2, -0.1, 2, 0.1)
          end
        end
        MagicCircle2(BrickColor.new(NewCol2), cf(target.Position), 60, 60, 60, -5, -5, -5, 0.02)
        MagicBlock(BrickColor.new(NewCol2), cf(target.Position) * cf(math.random(-600, 600) / 100, math.random(-600, 600) / 100, math.random(-600, 600) / 100) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 5, 5, 5, -1, -1, -1, 0.1, 1, workspace)
        BodGy.cframe = cf(Torso.Position, target.Position)
        wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0), 0.3)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.57) * euler(-0.4, 0, 0), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 0.4) * euler(0, -1.57, 0), 0.3)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-1.3, 0.9, 0) * euler(3.14, 0, 0) * euler(0, 0, -0.4), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(0.6, -1, -0.4) * euler(0, 1.57, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
        LH.C0 = clerp(LH.C0, cf(-0.6, -1, 0.4) * euler(0, -1.57, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
      end
      for i = 0, 1, 0.1 do
        swait()
        MagicCircle2(BrickColor.new(NewCol2), cf(target.Position), 60, 60, 60, -5, -5, -5, 0.02)
        MagicBlock(BrickColor.new(NewCol2), cf(target.Position) * cf(math.random(-600, 600) / 100, math.random(-600, 600) / 100, math.random(-600, 600) / 100) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 5, 5, 5, -1, -1, -1, 0.1, 1, workspace)
        BodGy.cframe = cf(Torso.Position, target.Position)
        wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0), 0.3)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 1.57) * euler(0.1, 0, 0), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 0.4) * euler(0, -1.57, 0), 0.3)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.2, 0) * euler(3.14, 0, 0) * euler(0, 0, -0.1), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(0.6, -1, -0.4) * euler(0, 1.57, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
        LH.C0 = clerp(LH.C0, cf(-0.6, -1, 0.4) * euler(0, -1.57, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
      end
      shatterpos.Parent = nil
      Damagefunc(target, 10, 10, math.random(40, 60), "Knockdown", RootPart, 0, 1, 0, nil, nil, false, "Movement", 0.2, 300)
      MagniDamage(target, 10, 12, 14, math.random(40, 60), "Knockdown", target, 0, 1, (math.random(20, 30)), nil, nil, false, "Shatter", 0.1, 300)
      CF = cf(target.Position)
      ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
      ref.Anchored = true
      ref.CFrame = CF
      game:GetService("Debris"):AddItem(ref, 1)
      so("183763506", ref, 1, 0.6)
      so("178452221", ref, 1, 0.6)
      so("87767777", ref, 1, 1)
      so("87784452", ref, 1, 0.8)
      so("183763515", ref, 1, 1)
      MagicCircle(BrickColor.new(NewCol2), CF, 60, 60, 60, 15, 15, 15, 0.05)
      for i = 1, 2 do
        MagicRing(BrickColor.new(NewCol2), CF * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 15, 15, 0.2, 2, 2, 0, 0.02)
      end
      for i = 1, 5 do
        BreakEffect(BrickColor.new(NewCol2), CF, math.random(50, 100) / 100, math.random(500, 1000) / 100, math.random(50, 100) / 100)
      end
      for i = 1, 5 do
        swait()
        for i = 1, 2 do
          BreakEffect(BrickColor.new(NewCol2), CF, math.random(50, 100) / 100, math.random(500, 1000) / 100, math.random(50, 100) / 100)
          MagicCircle3(BrickColor.new(NewCol2), CF * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) * cf(0, 5, 0), 4, 30, 4, -0.05, 1, -0.05, 0.01)
        end
      end
      MagniDamage(target, 20, 16, 20, math.random(40, 60), "Knockdown", target, 0, 1, (math.random(20, 30)), nil, nil, false, "Shatter", 0.2, 300)
      MagicCircle(BrickColor.new(NewCol2), CF, 200, 200, 200, 2, 2, 2, 0.02)
      swait(10)
      resumeControl()
      BodGy.Parent = nil
      dec.Parent = nil
    end
    do
	  stance = true
      attack = false
    end
  end
end
Cloak = function()
  Face.Face = "Bottom"
  for _,v in pairs(Torso.Parent:children()) do
    if v.className == "Part" and v.Name ~= "HumanoidRootPart" then
      v.Transparency = 1
    end
    if v.className == "Hat" then
      hatp = v.Handle
      hatp.Transparency = 1
    end
  end
  for _,v in pairs(modelzorz:children()) do
    if v.className == "Part" then
      v.Transparency = 1
    end
  end
end
UnCloak = function()
  Face.Face = "Front"
  for _,v in pairs(Torso.Parent:children()) do
    if v.className == "Part" and v.Name ~= "HumanoidRootPart" then
      v.Transparency = 0
    end
    if v.className == "Hat" then
      hatp = v.Handle
      hatp.Transparency = 0
    end
  end
  for _,v in pairs(modelzorz:children()) do
    if v.className == "Part" and v.Name ~= "Hitbox" and v.Name ~= "Hitbox2" and v.Name ~= "Parta01" then
      v.Transparency = 0
    end
  end
end
DecreaseStat = function(Model, Stat, Amount, Duration)
  if Model:findFirstChild("Stats") ~= nil and Model.Stats[Stat] ~= nil then
    Model.Stats[Stat].Value = Model.Stats[Stat].Value - Amount
    d = Instance.new("NumberValue", Model.Stats.Decrease)
    dur = Instance.new("NumberValue", d)
    dur.Name = "Duration"
    dur.Value = Duration
    game:GetService("Debris"):AddItem(d, 20)
    if Stat == "Damage" then
      d.Name = "DecreaseAtk"
    else
      if Stat == "Defense" then
        d.Name = "DecreaseDef"
      else
        if Stat == "Movement" then
          d.Name = "DecreaseMvmt"
        end
      end
    end
    if Model:findFirstChild("Torso") ~= nil then
      display = ""
      if Stat == "Damage" then
        if Amount > 0 then
          display = "-Damage"
        else
          display = "+Damage"
        end
      else
        if Stat == "Defense" then
          if Amount > 0 then
            display = "-Defense"
          else
            display = "+Defense"
          end
        else
          if Stat == "Movement" then
            if Amount > 0 then
              display = "-Movement"
            else
              display = "+Movement"
            end
          end
        end
      end
      showDamage(Model, display, "Debuff")
    end
    d.Value = Amount
  end
end
GetDist = function(Part1, Part2, magni)
  local targ = Part1.Position - Part2.Position
  local mag = targ.magnitude
  if mag <= magni then
    return true
  else
    return false
  end
end
MagniDamage = function(Part, magni, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
  for _,c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = nil
      for _,d in pairs(c:children()) do
        if d.className == "Model" and ranged ~= true then
          head = d:findFirstChild("Hitbox")
          if d.Parent == Character then
            break
          end
          if head ~= nil then
            local targ = head.Position - Part.Position
            local mag = targ.magnitude
            if mag <= magni and c.Name ~= Player.Name then
              ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
              ref.Anchored = true
              ref.CFrame = cf(head.Position)
              game:GetService("Debris"):AddItem(ref, 1)
              hitnum = math.random(1, 5)
              if hitnum == 1 then
                so("199148971", ref, 1, 1)
              else
                if hitnum == 2 then
                  so("199149025", ref, 1, 1)
                else
                  if hitnum == 3 then
                    so("199149072", ref, 1, 1)
                  else
                    if hitnum == 4 then
                      so("199149109", ref, 1, 1)
                    else
                      if hitnum == 5 then
                        so("199149119", ref, 1, 1)
                      end
                    end
                  end
                end
              end
              StaggerHit.Value = true
            end
          end
        end
        do
          if d.className == "Part" and d.Name=="Torso" then
            head = d
            if head ~= nil and head.Name=="Torso" then
              local targ = head.Position - Part.Position
              local mag = targ.magnitude
              if mag <= magni and c.Name ~= Player.Name then
                if stun == nil then
                  stun = math.random(5, 10)
                end
                local Rang = nil
                if Ranged == false then
                  Rang = true
                end
                local stag = nil
                if shbash == true then
                  stag = true
                end
                Damagefunc(head, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
              end
            end
          end
          do
          end
        end
      end
    end
  end
end
rayCast = function(Pos, Dir, Max, Ignore)
  return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
end
findNearestTorso = function(pos)
  local list = (game.Workspace:children())
  local torso = nil
  local dist = 1000
  local temp, human, temp2 = nil, nil, nil
  for x = 1, #list do
    temp2 = list[x]
    if temp2.className == "Model" and temp2.Name ~= Character.Name then
      temp = temp2:findFirstChild("Torso")
      human = temp2:findFirstChild("Humanoid")
      if temp ~= nil and human ~= nil and human.Health > 0 and (temp.Position - pos).magnitude < dist then
        local dohit = true
        if Player.Neutral == false and game.Players:GetPlayerFromCharacter(temp.Parent) ~= nil and game.Players:GetPlayerFromCharacter(temp.Parent).TeamColor == Player.TeamColor then
          dohit = false
        end
        if dohit == true then
          torso = temp
          dist = (temp.Position - pos).magnitude
        end
      end
    end
  end
  return torso, dist
end
local Point = Torso.CFrame * cf(0, Torso.Size.Y, 0)
LastPoint = Point
effect = function(Color, Ref, LP, P1, returnn)
  if LP == nil or P1 == nil then
    return 
  end
  local effectsmsh = Instance.new("CylinderMesh")
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  effectsmsh.Name = "Mesh"
  local effectsg = Instance.new("Part")
  NoOutline(effectsg)
  effectsg.formFactor = 3
  effectsg.CanCollide = false
  effectsg.Name = "Eff"
  effectsg.Locked = true
  effectsg.Anchored = true
  effectsg.Size = Vector3.new(0.5, 1, 0.5)
  effectsg.Parent = workspace
  effectsmsh.Parent = effectsg
  effectsg.BrickColor = BrickColor.new(Color)
  effectsg.Reflectance = Ref
  local point1 = P1
  local mg = (LP.p - point1.p).magnitude
  effectsg.Size = Vector3.new(0.5, mg, 0.5)
  effectsg.CFrame = cf((LP.p + point1.p) / 2, point1.p) * CFrame.Angles(math.rad(90), 0, 0)
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  game:GetService("Debris"):AddItem(effectsg, 2)
  if returnn then
    return effectsg
  end
  if not returnn then
    table.insert(Effects, {effectsg, "Cylinder", 0.2, 0.01, 0, 0.01, effectsmsh})
  end
end
MagicBlock = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type, parent, prt2)
  local prt = (part(3, parent, 0, 0, brickcolor, "Effect", vt()))
  local wld = nil
  prt.CFrame = cframe
  prt.Anchored = true
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  if Type == 1 or Type == nil then
    table.insert(Effects, {prt, "Block1", delay, x3, y3, z3, msh})
  else
    if Type == 2 then
      table.insert(Effects, {prt, "Block2", delay, x3, y3, z3, msh})
    else
      if Type == 3 then
        table.insert(Effects, {prt, "Block3", delay, x3, y3, z3, msh, cframe, prt2})
      end
    end
  end
end
MagicSkull = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, goe)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("SpecialMesh", prt, "FileMesh", "4770583", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Skull", delay, x3, y3, z3, msh, goe})
end
MagicCircle = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicCircle2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0.8, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicCircle3 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Blood", delay, x3, y3, z3, msh, math.random(50, 150) / 100})
end
MagicCylinder = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicCylinder3 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, modelzorz, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Head", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicCylinder2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, goe)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder2", delay, x3, y3, z3, msh, goe})
end
MagicHead = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Head", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
ClangEffect = function(brickcolor, cframe, duration, decrease, size, power)
  local prt = part(3, workspace, 0, 1, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(5, 5, 5))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "CylinderClang", duration, decrease, size, power, prt.CFrame, nil})
end
MagicWave = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "FileMesh", "20329976", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicRing = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
  prt.Anchored = true
  prt.CFrame = cframe * cf(x2, y2, z2)
  local msh = mesh("SpecialMesh", prt, "FileMesh", "3270017", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicRing2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Material = "Neon"
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "FileMesh", "3270017", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
if Type == 1 or Type == nil then
    table.insert(Effects, {prt, "Block1", delay, x3, y3, z3, msh})
  else
    if Type == 2 then
      table.insert(Effects, {prt, "Block2", delay, x3, y3, z3, msh})
    else
      if Type == 3 then
        table.insert(Effects, {prt, "Block3", delay, x3, y3, z3, msh, prt.CFrame})
      end
    end
  end
end
BreakEffect = function(brickcolor, cframe, x1, y1, z1)
  local prt = part(3, workspace, 0, 0.2, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
  prt.Anchored = true
  prt.CFrame = cframe * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
  game:GetService("Debris"):AddItem(prt, 10)
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  local num = math.random(10, 50) / 1000
  table.insert(Effects, {prt, "Shatter", num, prt.CFrame, math.random() - math.random(), 0, math.random(10, 100) / 100})
end
ElecEffect = function(cff, x, y, z)
  local prt = part(3, workspace, 0, 0, BrickColor.new("Bright red"), "Part", vt(1, 1, 1))
  prt.Anchored = true
  prt.CFrame = cff * cf(math.random(-x, x), math.random(-y, y), math.random(-z, z))
  prt.CFrame = cf(prt.Position)
  game:GetService("Debris"):AddItem(prt, 10)
  xval = math.random() / 3
  yval = math.random() / 3
  zval = math.random() / 3
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(xval, yval, zval))
  Effects[#Effects + 1] = {prt, "Elec", 0.2, x, y, z, xval, yval, zval, msh}
end
Damagefunc = function(hit, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
  if hit.Parent == nil then
    return 
  end
  if hit == MovePart then
    Fly = false
  end
  if hit.Name == "Hitbox" and hit.Parent ~= modelzorz and ranged ~= true then
    ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
    ref.Anchored = true
    ref.CFrame = cf(hit.Position)
    game:GetService("Debris"):AddItem(ref, 1)
    hitnum = math.random(1, 5)
    if hitnum == 1 then
      so("199148971", ref, 1, 1)
    else
      if hitnum == 2 then
        so("199149025", ref, 1, 1)
      else
        if hitnum == 3 then
          so("199149072", ref, 1, 1)
        else
          if hitnum == 4 then
            so("199149109", ref, 1, 1)
          else
            if hitnum == 5 then
              so("199149119", ref, 1, 1)
            end
          end
        end
      end
    end
    StaggerHit.Value = true
  end
  h = hit.Parent:FindFirstChild("Humanoid")
  if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
    if hit.Parent:findFirstChild("DebounceHit") ~= nil then
      return 
    end
    c = Instance.new("ObjectValue")
    c.Name = "creator"
    c.Value = game:service("Players").LocalPlayer
    c.Parent = h
    RecentEnemy.Value = hit.Parent
    game:GetService("Debris"):AddItem(c, 0.5)
    minim = minim * Atk.Value
    maxim = maxim * Atk.Value
    Damage = 0
    if minim == maxim then
      Damage = maxim
    else
      Damage = math.random(minim, maxim)
    end
    blocked = false
    enblock = nil
    Stats = hit.Parent:findFirstChild("Stats")
    if Stats ~= nil then
      enblock = Stats:findFirstChild("Block")
      if enblock ~= nil and enblock.Value == true then
        blocked = true
      end
      if Stats:findFirstChild("Defense") ~= nil then
        if prechit == false then
          Damage = Damage / Stats.Defense.Value
        else
          Val = Stats.Defense.Value
          if Val >= 2 then
            Val = 2
          end
          Damage = Damage * Val
        end
        if Damage <= 3 and (ranged == false or ranged == nil) and blocked ~= true then
          hitnum = math.random(1, 5)
          if hitnum == 1 then
            so("199149321", hit, 1, 1)
          else
            if hitnum == 2 then
              so("199149338", hit, 1, 1)
            else
              if hitnum == 3 then
                so("199149367", hit, 1, 1)
              else
                if hitnum == 4 then
                  so("199149409", hit, 1, 1)
                else
                  if hitnum == 5 then
                    so("199149452", hit, 1, 1)
                  end
                end
              end
            end
          end
        else
          if ranged == false or ranged == nil and blocked ~= true then
            hitnum = math.random(1, 6)
            if hitnum == 1 then
              so("199149137", hit, 1, 1)
            else
              if hitnum == 2 then
                so("199149186", hit, 1, 1)
              else
                if hitnum == 3 then
                  so("199149221", hit, 1, 1)
                else
                  if hitnum == 4 then
                    so("199149235", hit, 1, 1)
                  else
                    if hitnum == 5 then
                      so("199149269", hit, 1, 1)
                    else
                      if hitnum == 6 then
                        so("199149297", hit, 1, 1)
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if Damage <= 3 and staghit == true and ranged ~= true then
          StaggerHit.Value = true
        end
      end
      if Stats:findFirstChild("Stun") ~= nil then
        if blocked == true then
          incstun = incstun / 2
        end
        --[[if Stats.Stun.Value < Stats.StunThreshold.Value then
          Stats.Stun.Value = Stats.Stun.Value + incstun
        end]]
      end
      if Stats:findFirstChild("Stagger") ~= nil and stagger == true then
        Stats.Stagger.Value = true
      end
    end
    if blocked == true then
      showDamage(hit.Parent, "Block", "Damage")
      if ranged ~= true then
        enblock.Value = false
        Stagger.Value = true
        hitnum = math.random(1, 2)
        if hitnum == 1 then
          so("199148933", hit, 1, 1)
        else
          if hitnum == 2 then
            so("199148947", hit, 1, 1)
          end
        end
      end
    else
      Damage = math.floor(Damage)
      coroutine.resume(coroutine.create(function(Hum, Dam)
	hit.Parent.Humanoid:TakeDamage(Damage)
  end
), h, Damage)
      showDamage(hit.Parent, Damage, "Damage")
      if prechit == true then
        eul = euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
        MagicCircle(BrickColor.new("White"), cf(hit.Position) * eul, 5, 5, 5, -0.1, 5, -0.1, 0.02)
        MagicCircle(BrickColor.new("White"), cf(hit.Position) * eul * euler(1.57, 0, 0), 5, 5, 5, -0.1, 5, -0.1, 0.02)
      end
      if DecreaseState ~= nil then
        if DecreaseState == "Shatter" then
          DecreaseStat(hit.Parent, "Damage", DecreaseAmount, Duration)
          DecreaseStat(hit.Parent, "Defense", DecreaseAmount, Duration)
        else
          DecreaseStat(hit.Parent, DecreaseState, DecreaseAmount, Duration)
        end
      end
      if Type == "Knockdown" then
        hum = hit.Parent.Humanoid
        hum.PlatformStand = true
        coroutine.resume(coroutine.create(function(HHumanoid)
    swait(1)
    HHumanoid.PlatformStand = false
  end), hum)
        local angle=(hit.Position-(Property.Position+Vector3.new(0,0,0))).unit
        local bodvol=Instance.new("BodyVelocity")
bodvol.velocity=angle*knockback
bodvol.P=5000
bodvol.maxForce=Vector3.new(8000, 100, 8000)
bodvol.Parent=hit
rl=Instance.new("BodyAngularVelocity")
rl.P=3000
rl.maxTorque=Vector3.new(8000,100,8000)
rl.angularvelocity=Vector3.new(math.random(-10,10),math.random(-10,10),math.random(-10,10))
rl.Parent=hit
        game:GetService("Debris"):AddItem(bodvol, 0.5)
        game:GetService("Debris"):AddItem(rl, 0.5)
      elseif Type == "Knockdown2" then
            hum = hit.Parent.Humanoid
            local angle=(hit.Position-(Property.Position+Vector3.new(0,0,0))).unit
        local bodvol=Instance.new("BodyVelocity")
bodvol.velocity=angle*knockback
bodvol.P=5000
bodvol.maxForce=Vector3.new(8000, 100, 8000)
bodvol.Parent=hit
            game:GetService("Debris"):AddItem(bodvol, 0.5)
          else
            do
              if Type == "Normal" or Type == "NormalDecreaseMvmt1" then
                vp = Instance.new("BodyVelocity")
                vp.P = 500
                vp.maxForce = Vector3.new(8000, 100, 8000)
                if KnockbackType == 1 then
                  vp.velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
                else
                  if KnockbackType == 2 then
                    vp.velocity = Property.CFrame.lookVector * knockback
                  end
                end
                game:GetService("Debris"):AddItem(vp, 0.5)
                if knockback > 0 then
                  vp.Parent = hit.Parent.Torso
                end
              end
              debounce = Instance.new("BoolValue")
              debounce.Name = "DebounceHit"
              debounce.Parent = hit.Parent
              debounce.Value = true
              game:GetService("Debris"):AddItem(debounce, Delay)
              c = Instance.new("ObjectValue")
              c.Name = "creator"
              c.Value = Player
              c.Parent = h
              game:GetService("Debris"):AddItem(c, 0.5)
              CRIT = false
            end
          end
        end
      end
    end
showDamage = function(Char, Dealt, Type)
  m = Instance.new("Model")
  m.Name = "Effect"
  c = Instance.new("Part")
  c.Transparency = 1
  c.Name = "Head"
  c.TopSurface = 0
  c.BottomSurface = 0
  c.formFactor = "Plate"
  c.Size = Vector3.new(1, 0.4, 1)
  b = Instance.new("BillboardGui", c)
  b.Size = UDim2.new(5, 0, 5, 0)
  b.AlwaysOnTop = true
  damgui = gui("TextLabel", b, tostring(Dealt), 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
  if Type == "Damage" then
    damgui.Font = "SourceSans"
    if Dealt == "Block" then
      damgui.TextColor3 = BrickColor.new("Bright blue").Color
    else
      if Dealt < 3 then
        damgui.TextColor3 = BrickColor.new("White").Color
      else
        if Dealt >= 3 and Dealt < 20 then
          damgui.TextColor3 = BrickColor.new("Bright yellow").Color
        else
          damgui.TextColor3 = BrickColor.new("Really red").Color
          damgui.Font = "SourceSansBold"
        end
      end
    end
  else
    if Type == "Debuff" then
      damgui.TextColor3 = BrickColor.new("White").Color
    else
      if Type == "Interrupt" then
        damgui.TextColor3 = BrickColor.new("New Yeller").Color
      end
    end
  end
  damgui.TextScaled = true
  ms = Instance.new("CylinderMesh")
  ms.Scale = Vector3.new(0.8, 0.8, 0.8)
  ms.Parent = c
  c.Reflectance = 0
  Instance.new("BodyGyro").Parent = c
  c.Parent = m
  if Char:findFirstChild("Head") ~= nil then
    c.CFrame = cf(Char.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
  else
    if Char.Parent:findFirstChild("Head") ~= nil then
      c.CFrame = cf(Char.Parent.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
    end
  end
  f = Instance.new("BodyPosition")
  f.P = 2000
  f.D = 100
  f.maxForce = Vector3.new(545000, 545000, 545000)
  if Type == "Damage" then
    f.position = c.Position + Vector3.new(0, 3, 0)
  else
    if Type == "Debuff" or Type == "Interrupt" then
      f.position = c.Position + Vector3.new(0, 5, 0)
    end
  end
  f.Parent = c
  game:GetService("Debris"):AddItem(m, 5)
  table.insert(Effects, {m, "showDamage", damgui, f, 10, 1, 15, 50, 100})
  c.CanCollide = false
  m.Parent = workspace
  c.CanCollide = false
end
combo = 0
ob1d = function(mouse)
  if attack == true or equipped == false then
    return 
  end
  hold = true
  if combo == 0 then
    combo = 1
    attackone()
  else
    if combo == 1 then
      combo = 2
      attacktwo()
    else
      if combo == 2 then
        combo = 3
        attackthree()
      else
        if combo == 3 then
          combo = 0
          attackfour()
        end
      end
    end
  end
  coroutine.resume(coroutine.create(function()
    for i = 1, 50 do
      if attack == false then
        swait()
      end
    end
    if attack == false then
      combo = 0
    end
  end))
end
ob1u = function(mouse)
  hold = false
end
buttonhold = false
fenbarmove1.MouseButton1Click:connect(do1)
fenbarmove2.MouseButton1Click:connect(do2)
fenbarmove3.MouseButton1Click:connect(do3)
fenbarmove4.MouseButton1Click:connect(do4)
eul = 0
equipped = false
key = function(key)
  if attack == true then
    return 
  end
  if key == "f" then
    pressedf = true
    fnumb = 0
    attack = true
	stance = true
    if equipped == false then
      equipped = true
      RSH = ch.Torso["Right Shoulder"]
      LSH = ch.Torso["Left Shoulder"]
      RSH.Parent = nil
      LSH.Parent = nil
      RW.Name = "Right Shoulder"
      RW.Part0 = ch.Torso
      RW.C0 = cf(1.5, 0.5, 0)
      RW.C1 = cf(0, 0.5, 0)
      RW.Part1 = ch["Right Arm"]
      RW.Parent = ch.Torso
      LW.Name = "Left Shoulder"
      LW.Part0 = ch.Torso
      LW.C0 = cf(-1.5, 0.5, 0)
      LW.C1 = cf(0, 0.5, 0)
      LW.Part1 = ch["Left Arm"]
      LW.Parent = ch.Torso
      Animate.Parent = nil
      equipanim()
    else
      equipped = false
      hideanim()
      LH.C1 = LHC1
      RH.C1 = RHC1
      Animate.Parent = Humanoid
      swait(0)
      RW.Parent = nil
      LW.Parent = nil
      RSH.Parent = player.Character.Torso
      LSH.Parent = player.Character.Torso
    end
    attack = false
  end
  if equipped == false then
    return 
  end
  if key == "e" then
    VoidGather()
  end
  if key == "z" then
    do1()
  end
  if key == "x" then
    do2()
  end
  if key == "c" then
    do3()
  end
  if key == "v" then
    do4()
  end
end
key2 = function(key)
end
s = function(mouse)
  mouse.Button1Down:connect(function()
    ob1d(mouse)
  end)
  mouse.Button1Up:connect(function()
    ob1u(mouse)
  end)
  mouse.KeyDown:connect(key)
  mouse.KeyUp:connect(key2)
  player = Player
  ch = Character
end
ds = function(mouse)
end
Bin.Selected:connect(s)
Bin.Deselected:connect(ds)
print("Nether loaded.")
local mananum = 0
local donum = 0
local stunnum = 0
local staggeranim = false
local stunanim = false
local Point, LastPoint = nil, nil
local handef = 0
local walk = 0
local walkforw = true
while true do
  swait()
  if mananum < 15 then
  mananum = mananum + 1
  elseif mananum == 15 then
  mananum = 0
  end
  if Humanoid.Health <= 0 then
    attack = true
    resumeControl()
    modelzorz.Parent = workspace
    modelzorz.Name = "Weapon Model"
    game:GetService("Debris"):AddItem(modelzorz, 30)
    for i = 1, #Weapon do
      Weapon[i].Parent = modelzorz
      Weapon[i].CanCollide = true
    end
    for i = 1, #Welds do
      if Welds[i].Part0.Parent == Character or Welds[i].Part1.Parent == Character then
        Welds[i].Parent = nil
      else
        Welds[i].Parent = prt1
      end
    end
  end
  do
    if fnumb < 21 then
      fnumb = fnumb + 1
      if pressedf == false then
        fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency - 0.025
        tellbar.TextTransparency = tellbar.TextTransparency - 0.05
        tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency - 0.05
      else
        if fnumb == 20 then
          fenframe5.Parent = nil
          print("daigui")
        end
        fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency + 0.025
        tellbar.TextTransparency = tellbar.TextTransparency + 0.05
        tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency + 0.05
      end
    end
    if stance == true then
      MagicBlock(BrickColor.new(NewCol3), LeftArm.CFrame, 1, 1, 1, 1, 1, 1, 0.3, 1, modelzorz, LeftArm)
    end
    if hbwld.Parent == nil then
      hitbox2.Name = "Hitbox"
    else
      hitbox2.Name = "Hitbox2"
    end
    hitbox2.Parent = hitbox.Parent
    hitbox2.Size = hitbox.Size
    hitbox2.CFrame = hitboxCF
    hboxpos.position = hitbox2.Position + vt(math.random(-100, 100) / 100, math.random(-100, 100) / 100, math.random(-100, 100) / 100)
    passive2.Value = (100 - Humanoid.Health) / (Humanoid.Health * 8)
    if 0.5 <= passive2.Value then
      passive2.Value = 0.5
    end
    if LeftArm.Transparency < 1 then
      if handef % 2 == 0 then
        MagicBlock(BrickColor.new(NewCol3), LeftArm.CFrame * cf(0, -1, 0), 5, 5, 5, 0.5, 0.5, 0.5, 0.2, 1, modelzorz, prta1)
      end
      if 20 <= handef then
        handef = 0
		MagicRing2(BrickColor.new(NewCol3), LeftArm.CFrame * cf(0, -1, 0), 1, 1, 1, 0.5, 0.5, 0.1, 0.1, 1)
        --MagicRing2(BrickColor.new(NewCol3), LeftArm.CFrame * cf(0, -1, 0), 1, 1, 1, 0.5, 0.5, 0.1, 0.1, prta1)
      end
    end
    handef = handef + 1
    if Stagger.Value == true and staggeranim == false then
      coroutine.resume(coroutine.create(function()
  staggeranim = true
  while attack == true do
    swait()
  end
  StaggerAnim()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end))
    end
    if StaggerHit.Value == true and staggeranim == false then
      coroutine.resume(coroutine.create(function()
  staggeranim = true
  while attack == true do
    swait()
  end
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end))
    end
    if Mvmt.Value < 0 or Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true or Rooted.Value == true then
      Humanoid.WalkSpeed = 0
    else
      Humanoid.WalkSpeed = 16 * Mvmt.Value
    end
    if StunT.Value <= Stun.Value and stunanim == false then
      coroutine.resume(coroutine.create(function()
  stunanim = true
  while attack == true do
    swait()
  end
  StunAnim()
  Stun.Value = 0
  stunanim = false
end))
    end
    local stunnum2 = 30
    if stunnum2 <= stunnum then
      if 0 < Stun.Value then
        Stun.Value = Stun.Value - 1
      end
      stunnum = 0
    end
    stunnum = stunnum + 1
    if 0.5 <= donum then
      handidle = true
    else
      if donum <= 0 then
        handidle = false
      end
    end
    if handidle == false then
      donum = donum + 0.003
    else
      donum = donum - 0.003
    end
    local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
    local velderp = RootPart.Velocity.y
    hitfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
    if equipped == true then
      if attack == false then
        idle = idle + 1
      else
        idle = 0
      end
      if (500 <= idle and attack ~= false) or Anim == "Walk" then
        if walkforw == true then
          RH.C1 = clerp(RH.C1, RHC1 * cf(0.2, -0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
          LH.C1 = clerp(LH.C1, LHC1 * cf(0.1, 0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
        else
          RH.C1 = clerp(RH.C1, RHC1 * cf(-0.1, 0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
          LH.C1 = clerp(LH.C1, LHC1 * cf(-0.2, -0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
        end
      else
        RH.C1 = clerp(RH.C1, RHC1, 0.2)
        LH.C1 = clerp(LH.C1, LHC1, 0.2)
      end
      if stance == true then
        passive3.Parent = Decrease
        fenbarmove1.Text = "(Z)\nVoid Buster"
        fenbarmove2.Text = "(X)\nVoid Portal"
        fenbarmove3.Text = "(C)\nVoid Field"
        fenbarmove1b.BackgroundColor3 = BrickColor.new(NewCol3).Color
        fenbarmove2b.BackgroundColor3 = BrickColor.new(NewCol3).Color
        fenbarmove3b.BackgroundColor3 = BrickColor.new(NewCol3).Color
      else
        passive3.Parent = nil
        fenbarmove1.Text = "(Z)\nPrecise Hit"
        fenbarmove2.Text = "(X)\nSlice Wave"
        fenbarmove3.Text = "(C)\nSonic Strike"
        fenbarmove1b.BackgroundColor3 = BrickColor.new("Medium stone grey").Color
        fenbarmove2b.BackgroundColor3 = BrickColor.new("Medium stone grey").Color
        fenbarmove3b.BackgroundColor3 = BrickColor.new("Medium stone grey").Color
      end
      if 1 < RootPart.Velocity.y and hitfloor == nil then
        Anim = "Jump"
        if stance == true and attack == false then
          wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0), 0.2)
          Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0), 0.2)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
          RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.6, 0, 0.4) * euler(0, -1.57, 0), 0.2)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
          LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-1, 0, -0.2), 0.2)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
          RH.C0 = clerp(RH.C0, cf(1, -1, -0.3) * euler(-0.5, 1.57, 0) * euler(-0.2, 0, 0), 0.2)
          LH.C0 = clerp(LH.C0, cf(-1, -1, -0.3) * euler(-0.5, -1.57, 0) * euler(-0.2, 0, 0), 0.2)
		elseif stance == false and attack == false then
		  wld1.C0 = clerp(wld1.C0, euler(1.5, 0.15, 0) * euler(0, 0, 0) * cf(0, 1, 0), 0.5)
  		  Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.7) * euler(0.2, 0, 0), 0.4)
  		  RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.7), 0.4)
  		  RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -1) * euler(0, -1.4, 0), 0.4)
  		  RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
   		  LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, 0.8), 0.4)
  		  LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
		  RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.1) * euler(0, 1.57, 0) * euler(0, -0.7, 0), 0.4)
  		  LH.C0 = clerp(LH.C0, cf(-0.8, -1, -0.1) * euler(0, -1.57, 0) * euler(0, -0.7, 0), 0.4)
        end
      else
        if RootPart.Velocity.y < -1 and hitfloor == nil then
          Anim = "Fall"
          if stance == true and attack == false then
            wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0), 0.2)
            Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, 0), 0.2)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.6, 0, 0.4) * euler(0, -1.57, 0), 0.2)
            RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.3, 0, -0.2), 0.2)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
            RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0.4, 1.57, 0), 0.2)
            LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(-0.2, -1.57, 0), 0.2)
		elseif stance == false and attack == false then
		  	wld1.C0 = clerp(wld1.C0, euler(1.5, 0.15, 0) * euler(0, 0, 0) * cf(0, 1, 0), 0.5)
  		  	Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.7) * euler(0.2, 0, 0), 0.4)
  		 	RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.7), 0.4)
  		  	RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -1) * euler(0, -1.4, 0), 0.4)
  		  	RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
   		  	LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, 0.8), 0.4)
  		  	LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
		  	RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.1) * euler(0, 1.57, 0) * euler(0, -0.7, 0), 0.4)
  		  	LH.C0 = clerp(LH.C0, cf(-0.8, -1, -0.1) * euler(0, -1.57, 0) * euler(0, -0.7, 0), 0.4)
        end
        else
          if torvel < 1 and hitfloor ~= nil then
            Anim = "Idle"
            if stance == true and attack == false then
              wld1.C0 = clerp(wld1.C0, euler(1.5, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0), 0.2)
              Neck.C0 = clerp(Neck.C0, necko * euler(0.1, 0, 0) * euler(0, 0, 0.5), 0.2)
              RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.2) * euler(0, 0, -0.5), 0.2)
              RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.6 + (donum) / 5, 0, 0.4) * euler(0, -1.57, 0), 0.2)
              RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
              LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.2 - (donum) / 5, 0, -0.4), 0.2)
              LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
              RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, 0) * euler(0, 0, -0.4), 0.2)
              LH.C0 = clerp(LH.C0, cf(-0.9, -0.8, -0.1) * euler(0, -1.57, 0) * euler(0, 0.5, 0) * euler(0, 0, 0.1), 0.2)
			elseif stance == false and attack == false then
		  		wld1.C0 = clerp(wld1.C0, euler(1.5, 0.15, 0) * euler(0, 0, 0) * cf(0, 1, 0), 0.5)
  		  		Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.7) * euler(0.2, 0, 0), 0.4)
  		 		RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.7), 0.4)
  		  		RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -1) * euler(0, -1.4, 0), 0.4)
  		  		RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
   		  		LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, 0.8), 0.4)
  		  		LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
		  		RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.1) * euler(0, 1.57, 0) * euler(0, -0.7, 0), 0.4)
  		  		LH.C0 = clerp(LH.C0, cf(-0.8, -1, -0.1) * euler(0, -1.57, 0) * euler(0, -0.7, 0), 0.4)
            end
          else
            if 2 < torvel and torvel < 30 and hitfloor ~= nil then
              Anim = "Walk"
              walk = walk + 1
              if 10 <= walk then
                walk = 0
                if walkforw == true then
                  walkforw = false
                else
                  if walkforw == false then
                    walkforw = true
                  end
                end
              end
              if stance == true and attack == false then
                wld1.C0 = clerp(wld1.C0, euler(1.57, 0, 0) * euler(0, 3.14, 0) * cf(0, 1, 0), 0.2)
                Neck.C0 = clerp(Neck.C0, necko * euler(0.2 - (donum) / 5, 0, 0), 0.2)
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
                RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1 + (donum) / 5, 0, 0.2) * euler(0, -1.57, 0), 0.2)
                RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2 + (donum) / 3, 0, -0.4 + (donum) / 3), 0.2)
                LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0), 0.2)
                LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0), 0.2)
				elseif stance == false and attack == false then
		  	wld1.C0 = clerp(wld1.C0, euler(1.5, 0.15, 0) * euler(0, 0, 0) * cf(0, 1, 0), 0.5)
  		  	Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.7) * euler(0.2, 0, 0), 0.4)
  		 	RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.7), 0.4)
  		  	RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -1) * euler(0, -1.4, 0), 0.4)
  		  	RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
   		  	LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, 0.8), 0.4)
  		  	LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
		  	RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.1) * euler(0, 1.57, 0) * euler(0, -0.7, 0), 0.4)
  		  	LH.C0 = clerp(LH.C0, cf(-0.8, -1, -0.1) * euler(0, -1.57, 0) * euler(0, -0.7, 0), 0.4)
              end
            else
              if 30 <= torvel and hitfloor ~= nil then
                Anim = "Run"
                if stance == true and attack == false then
                  Neck.C0 = clerp(Neck.C0, necko * euler(0.2 - (donum) / 5, 0, 0), 0.2)
                  RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
                  RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.3 + (donum) / 3, 0, 0.5 - (donum) / 3), 0.2)
                  RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                  LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2 + (donum) / 3, 0, -0.4 + (donum) / 3), 0.2)
                  LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                  RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0), 0.2)
                  LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0), 0.2)
			elseif stance == false and attack == false then
		  	wld1.C0 = clerp(wld1.C0, euler(1.5, 0.15, 0) * euler(0, 0, 0) * cf(0, 1, 0), 0.5)
  		  	Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.7) * euler(0.2, 0, 0), 0.4)
  		 	RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.7), 0.4)
  		  	RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -1) * euler(0, -1.4, 0), 0.4)
  		  	RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
   		  	LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, 0.8), 0.4)
  		  	LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
		  	RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.1) * euler(0, 1.57, 0) * euler(0, -0.7, 0), 0.4)
  		  	LH.C0 = clerp(LH.C0, cf(-0.8, -1, -0.1) * euler(0, -1.57, 0) * euler(0, -0.7, 0), 0.4)
                end
              end
            end
          end
        end
      end
    end
   if 0 < #Effects then
      for e = 1, #Effects do
        if Effects[e] ~= nil then
          local Thing = Effects[e]
          if Thing ~= nil then
            local Part = Thing[1]
            local Mode = Thing[2]
            local Delay = Thing[3]
            local IncX = Thing[4]
            local IncY = Thing[5]
            local IncZ = Thing[6]
            if Thing[2] == "CylinderClang" then
                            if Thing[3] <= 1 then
                              Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, 2.5 * Thing[5], 0) * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
                              Thing[7] = Thing[1].CFrame
                              effect("New Yeller", 0, Thing[8], Thing[7], nil, 0.1, 2)
                              Thing[8] = Thing[7]
                              Thing[3] = Thing[3] + Thing[4]
                            else
                              Part.Parent = nil
                              table.remove(Effects, e)
                            end
                          end
                          if Thing[2] == "showDamage" then
                            if Thing[6] < Thing[5] then
                              Thing[6] = Thing[6] + 1
                            else
                              if Thing[6] < Thing[7] then
                                Thing[4].position = Thing[4].position + vt(0, -0.2, 0)
                                Thing[6] = Thing[6] + 1
                              else
                                if Thing[6] < Thing[8] then
                                  Thing[6] = Thing[6] + 1
                                else
                                  if Thing[6] < Thing[9] then
                                    Thing[6] = Thing[6] + 1
                                    Thing[4].position = Thing[4].position + vt(0, 0.2, 0)
                                    Thing[3].TextStrokeTransparency = Thing[3].TextStrokeTransparency + 0.1
                                    Thing[3].TextTransparency = Thing[3].TextTransparency + 0.1
                                  else
                                    Thing[1].Parent = nil
                                    table.remove(Effects, e)
                                  end
                                end
                              end
                            end
                          end
            if Thing[2] == "BlackHole" then
              if 0 < Thing[3] then
                Thing[3] = Thing[3] - 1
                MagicBlock(BrickColor.new(NewCol2), cf(Thing[1]), 1, 1, 1, 5, 5, 5, 0.1, 1, workspace)
                if 0 < Thing[4] then
                  Thing[4] = Thing[4] - 1
                else
                  ref2 = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
                  ref2.Anchored = true
                  ref2.CFrame = cf(Thing[1])
                  so("183763498", ref2, 0.8, 1)
                  game:GetService("Debris"):AddItem(ref2, 1)
                  spread = vt(math.random(-50, 50) / 100, math.random(-50, 50) / 100, math.random(-50, 50) / 100) * (Thing[1] - MMouse.Hit.p).magnitude / 100
                  local MouseLook = cf((Thing[1] + MMouse.Hit.p) / 2, MMouse.Hit.p + spread)
                  table.insert(Effects, {MouseLook.lookVector, "Shoot", 30, Thing[1], 5, 7, 0})
                  Thing[4] = 20
                end
              else
                do
                  table.remove(Effects, e)
                  if Thing[2] == "Shoot" then
                    local Look = Thing[1]
                    local hit, pos = rayCast(Thing[4], Look, 10, modelzorz)
                    local mag = Thing[4] - pos.magnitude
                    MagicCircle(BrickColor.new(NewCol2), CFrame.new((Thing[4] + pos) / 2, pos), 1, 1, 1, 4, 4, 4, 0.1)
                    Thing[4] = Thing[4] + Look * 10
                    Thing[3] = Thing[3] - 1
                    if hit ~= nil then
                      Thing[3] = 0
                      ref3 = part(3, workspace, 0, 1, BrickColor.new(NewCol2), "Reference", vt())
                      ref3.Anchored = true
                      ref3.CFrame = cf(pos)
                      so("183763506", ref3, 0.8, 1.5)
                      game:GetService("Debris"):AddItem(ref3, 0.2)
                      MagicBlock(BrickColor.new(NewCol2), cf(ref3.Position) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 8, 8, 8, 0.1, 1, workspace)
                      MagicCircle(BrickColor.new(NewCol2), cf(ref3.Position), 5, 5, 5, 5, 5, 5, 0.05)
                      MagniDamage(ref3, 10, Thing[5] / 1.5, Thing[6] / 1.5, 0, "Normal", ref3, 0, 1, 3, nil, nil, true, nil, nil, nil)
                      game:GetService("Debris"):AddItem(ref3, 1)
                    end
                    if Thing[3] <= 0 then
                      table.remove(Effects, e)
                    end
                  end
end
end
end
                  do
                    if Thing[2] == "VField" then
                      if 0 <= Thing[3] then
                        Thing[3] = Thing[3] - 1
                        Thing[1].CFrame = Thing[4] * cf(0, 0, -5 - Thing[5] * 2.5)
                        so("228343343", Thing[1], 1, 1)
                        hitfloor2, posfloor2 = rayCast(Thing[1].Position, CFrame.new(Thing[1].Position, Thing[1].Position - Vector3.new(0, 1, 0)).lookVector, 100, Character)
                        Thing[1].CFrame = cf(posfloor2)
                        MagniDamage(Thing[1], 2 + Thing[5] / 10, 8, 10, math.random(10, 20), "Knockdown", Thing[1], 0.3, 1, (math.random(6, 8)), nil, nil, true, "Damage", 0.1, 300)
                        MagicCircle(BrickColor.new(NewCol3), cf(posfloor2), 20 + Thing[5], 1, 20 + Thing[5], 1, 0, 1, 0.05)
                        MagicCircle(BrickColor.new(NewCol3), cf(posfloor2) * cf(0, 0, 0), 5, 10, 5, 1 + Thing[5] / 5, 10 + Thing[5] / 2, 1 + Thing[5] / 5, 0.1)
                        if Stagger.Value ~= true and StunT.Value > Stun.Value then
                          do
                            if StaggerHit.Value == true then
                              break
                            end
end
end
end
                            Thing[5] = Thing[5] + 0.2
                            Thing[1].Parent = nil
                            --table.remove(Effects, e)
end
                            if Thing[2] ~= "Shoot" and Thing[2] ~= "DecreaseStat" and Thing[2] ~= "showDamage" and Thing[2] ~= "BlackHole" and Thing[2] ~= "Shoot" and Thing[2] ~= "VField" then
                              if Thing[1].Transparency <= 1 then
                                if Thing[2] == "Block1" then
                                  Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                                  Mesh = Thing[7]
                                  Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                  Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                else
                                  if Thing[2] == "Block2" then
                                    Thing[1].CFrame = Thing[1].CFrame
                                    Mesh = Thing[7]
                                    Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                    Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                  else
                                    if Thing[2] == "Block3" then
                                      Thing[1].CFrame = Thing[9].CFrame * Thing[8] * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                                      Mesh = Thing[7]
                                      Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                      Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                    else
                                      if Thing[2] == "Cylinder" then
                                        Mesh = Thing[7]
                                        Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                        Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                      else
                                        if Thing[2] == "Cylinder2" then
                                          Thing[1].CFrame = Thing[1].CFrame * cf(0, Thing[8], 0)
                                          Mesh = Thing[7]
                                          Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                          Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                        else
                                          if Thing[2] == "Blood" then
                                            Mesh = Thing[7]
                                            Thing[1].CFrame = Thing[1].CFrame * cf(0, 0.5, 0)
                                            Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                            Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                          else
                                            if Thing[2] == "Elec" then
                                              Mesh = Thing[10]
                                              Mesh.Scale = Mesh.Scale + vt(Thing[7], Thing[8], Thing[9])
                                              Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                            else
                                              if Thing[2] == "Shatter" then
                                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                                Thing[4] = Thing[4] * cf(0, Thing[7], 0)
                                                Thing[1].CFrame = Thing[4] * euler(Thing[6], 0, 0)
                                                Thing[6] = Thing[6] + Thing[5]
                                              else
                                                if Thing[2] == "Disappear" then
                                                  Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                                end
                                              end
                                            end
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              else
                                Part.Parent = nil
                                table.remove(Effects, e)
                              end
                            end
                          end
                        end
                      end
                    end
              end
    fenbarmana2:TweenSize((UDim2.new(0.4, 0, -4 * mana.Value / 100, 0)), nil, 1, 0.4, true)
    fenbarmana4.Text = "Mana(" .. mana.Value .. ")"
    fenbarhp2.BackgroundColor3 = Color3.new(Humanoid.Health / Humanoid.MaxHealth, 0, 0)
    fenbarhp2:TweenSize((UDim2.new(Humanoid.Health / Humanoid.MaxHealth, 0, 1, 0)), nil, 1, 0.4, true)
    fenbarhp3.Text = "(" .. math.floor(Humanoid.Health) .. ")"
    fenbarmove1b:TweenSize((UDim2.new(1 * cooldowns[1] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
    fenbarmove2b:TweenSize((UDim2.new(1 * cooldowns[2] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
    fenbarmove3b:TweenSize((UDim2.new(1 * cooldowns[3] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
    fenbarmove4b:TweenSize((UDim2.new(1 * cooldowns[4] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
    for _,c in pairs(Decrease:children()) do
      if (c:findFirstChild("Duration")) ~= nil then
        c.Duration.Value = c.Duration.Value - 1
        if c.Duration.Value <= 0 then
          c.Parent = nil
        end
      end
      if c.Name == "DecreaseAtk" then
        decreaseatk = decreaseatk + c.Value
      else
        if c.Name == "DecreaseDef" then
          decreasedef = decreasedef + c.Value
        else
          if c.Name == "DecreaseMvmt" then
            decreasemvmt = decreasemvmt + c.Value
          end
        end
      end
    end
    Atk.Value = 1 - (decreaseatk)
    if Atk.Value <= 0 then
      Atk.Value = 0
    end
    Def.Value = 1 - (decreasedef)
    if Def.Value <= 0 then
      Def.Value = 0.01
    end
    Mvmt.Value = 1 - (decreasemvmt)
    if Mvmt.Value <= 0 then
      Mvmt.Value = 0
    end
    decreaseatk = 0
    decreasedef = 0
    decreasemvmt = 0
    AtkVal = Atk.Value * 100
    AtkVal = math.floor(AtkVal)
    AtkVal = AtkVal / 100
    fenbardamage.Text = "Damage\n(" .. AtkVal .. ")"
    DefVal = Def.Value * 100
    DefVal = math.floor(DefVal)
    DefVal = DefVal / 100
    fenbardef.Text = "Defense\n(" .. DefVal .. ")"
    MvmtVal = Mvmt.Value * 100
    MvmtVal = math.floor(MvmtVal)
    MvmtVal = MvmtVal / 100
    if Rooted.Value == true then
      MvmtVal = 0
    end
    fenbarmove.Text = "Walkspeed\n(" .. MvmtVal .. ")"
    if StunT.Value <= Stun.Value then
      fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4, 0)), nil, 1, 0.4, true)
    else
      fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4 * Stun.Value / StunT.Value, 0)), nil, 1, 0.4, true)
    end
    fenbarstun3.Text = "Stun(" .. Stun.Value .. ")"
    if mana.Value < 100 and mananum == 15 then
      mana.Value = mana.Value + 1
	end
    for i = 1, #cooldowns do
      if cooldownmax <= cooldowns[i] then
        cooldowns[i] = cooldownmax
      else
        cooldowns[i] = cooldowns[i] + cooldownsadd[i]
      end
    end
    -- DECOMPILER ERROR at PC5992: LeaveBlock: unexpected jumping out DO_STMT

  end
end

]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="HopperBin" referent="RBX2DF7613AAD764F46A9AD9FD4C7AAA562">
			<Properties>
				<bool name="Active">false</bool>
				<token name="BinType">0</token>
				<string name="Name">Commander</string>
				<Content name="TextureId"><null></null></Content>
			</Properties>
			<Item class="LocalScript" referent="RBX06A8A9573BF942CAAE909744349E907C">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LocalScript</string>
					<string name="ScriptGuid">{7B569D35-FE2D-42E4-939C-3C84BCA0FB12}</string>
					<ProtectedString name="Source"><![CDATA[Player = game:GetService("Players").LocalPlayer
Character = Player.Character
PlayerGui = Player.PlayerGui
Backpack = Player.Backpack
Torso = Character.Torso
Head = Character.Head
Humanoid = Character.Humanoid
LeftArm = Character["Left Arm"]
LeftLeg = Character["Left Leg"]
RightArm = Character["Right Arm"]
RightLeg = Character["Right Leg"]
LS = Torso["Left Shoulder"]
LH = Torso["Left Hip"]
RS = Torso["Right Shoulder"]
RH = Torso["Right Hip"]
Neck = Torso.Neck
it = Instance.new
vt = Vector3.new
cf = CFrame.new
euler = CFrame.fromEulerAnglesXYZ
angles = CFrame.Angles
necko = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
necko2 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
LHC0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
LHC1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
RHC0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RHC1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RootPart = Character.HumanoidRootPart
RootJoint = RootPart.RootJoint
RootCF = euler(-1.57, 0, 3.14)
attack = false
attackdebounce = false
blessdebounce = false
MMouse = nil
combo = 0
blessing = 0
local hitfloor, posfloor = nil, nil
local idle = 0
local Anim = "Idle"
local Effects = {}
local Weapon = {}
local Welds = {}
local decreaseatk = 0
local decreasedef = 0
local decreasemvmt = 0
local Mode = "Defensive"
local GuardStance = false
local Target = nil
local manualguardend = false
local Fly = false
local blessbuff = false
local prop = Instance.new("RocketPropulsion")
local move1 = "(Z)\nSupport Wave"
local move2 = "(X)\nGuardian Dash"
local move3 = "(C)\nInvoke"
local move4 = "(V)\nCritical Point"
local cooldowns = {}
local cooldown1 = 0
table.insert(cooldowns, cooldown1)
local cooldown2 = 0
table.insert(cooldowns, cooldown2)
local cooldown3 = 0
table.insert(cooldowns, cooldown3)
local cooldown4 = 0
table.insert(cooldowns, cooldown4)
local cooldownsadd = {}
local cooldownadd1 = 0.27
table.insert(cooldownsadd, cooldownadd1)
local cooldownadd2 = 0.2
table.insert(cooldownsadd, cooldownadd2)
local cooldownadd3 = 0.22
table.insert(cooldownsadd, cooldownadd3)
local cooldownadd4 = 0.06
table.insert(cooldownsadd, cooldownadd4)
local cooldownmax = 100
player = nil
RSH = nil
LW = Instance.new("Motor")
RW = Instance.new("Motor")
RW.Name = "Right Shoulder"
LW.Name = "Left Shoulder"
LH = Torso["Left Hip"]
RH = Torso["Right Hip"]
TorsoColor = Torso.BrickColor
TorsoRed = TorsoColor.Color.r
TorsoGreen = TorsoColor.Color.g
NewCol = Color3.new(TorsoRed, TorsoGreen, 1)
if Player:findFirstChild("Color1") ~= nil then
  NewCol = Player.Color1.Value
end
print(BrickColor.new(NewCol))
local mdec = Instance.new("NumberValue", Decrease)
mdec.Name = "DecreaseDef"
mdec.Value = 0.4
local mdec2 = Instance.new("NumberValue", Decrease)
mdec2.Name = "DecreaseMvmt"
mdec2.Value = 0.1
local Animate = Humanoid.Animator
local canjump = true
removeControl = function()
  canjump = false
end
resumeControl = function()
  canjump = true
end
Player.Character.Humanoid.Changed:connect(function()
  if canjump == false then
    Player.Character.Humanoid.Jump = false
  end
end)
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

frame = 1 / 40
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 0, num do
			ArtificialHB.Event:wait()
		end
	end
end
if Character:findFirstChild("Cherubim", true) ~= nil then
  Character:findFirstChild("Cherubim", true).Parent = nil
end
if Player.PlayerGui:findFirstChild("WeaponGUI", true) ~= nil then
  Player.PlayerGui:findFirstChild("WeaponGUI", true).Parent = nil
end
if Character:findFirstChild("Stats", true) ~= nil then
  Character:findFirstChild("Stats", true).Parent = nil
end
local Stats = Instance.new("BoolValue")
Stats.Name = "Stats"
Stats.Parent = Character
local Atk = Instance.new("NumberValue")
Atk.Name = "Damage"
Atk.Parent = Stats
Atk.Value = 1
local Def = Instance.new("NumberValue")
Def.Name = "Defense"
Def.Parent = Stats
Def.Value = 1
local Mvmt = Instance.new("NumberValue")
Mvmt.Name = "Movement"
Mvmt.Parent = Stats
Mvmt.Value = 1
local Block = Instance.new("BoolValue")
Block.Name = "Block"
Block.Parent = Stats
Block.Value = false
local Stun = Instance.new("NumberValue")
Stun.Name = "Stun"
Stun.Parent = Stats
Stun.Value = 0
local StunT = Instance.new("NumberValue")
StunT.Name = "StunThreshold"
StunT.Parent = Stats
StunT.Value = 100
local Rooted = Instance.new("BoolValue")
Rooted.Name = "Rooted"
Rooted.Parent = Stats
Rooted.Value = false
local Stunned = Instance.new("BoolValue")
Stunned.Name = "Stunned"
Stunned.Parent = Stats
Stunned.Value = false
local Stagger = Instance.new("BoolValue")
Stagger.Name = "Stagger"
Stagger.Parent = Stats
Stagger.Value = false
local StaggerHit = Instance.new("BoolValue")
StaggerHit.Name = "StaggerHit"
StaggerHit.Parent = Stats
StaggerHit.Value = false
local RecentEnemy = Instance.new("ObjectValue")
RecentEnemy.Name = "RecentEnemy"
RecentEnemy.Parent = Stats
RecentEnemy.Value = nil
local Decrease = Instance.new("BoolValue")
Decrease.Name = "Decrease"
Decrease.Parent = Stats
Decrease.Value = false
local mana = Instance.new("NumberValue")
mana.Name = "Mana"
mana.Parent = Stats
mana.Value = 0
NoOutline = function(Part)
  Part.TopSurface,Part.RightSurface,Part.LeftSurface,Part.BottomSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
end
part = function(formfactor, parent, reflectance, transparency, brickcolor, name, size)
  local fp = it("Part")
  fp.formFactor = formfactor
  fp.Parent = parent
  fp.Reflectance = reflectance
  fp.Transparency = transparency
  fp.CanCollide = false
  fp.Locked = true
  fp.BrickColor = brickcolor
  fp.Name = name
  fp.Size = size
  fp.Position = Torso.Position
  NoOutline(fp)
  fp.Material = "SmoothPlastic"
  fp:BreakJoints()
  return fp
end
mesh = function(Mesh, part, meshtype, meshid, offset, scale)
  local mesh = it(Mesh)
  mesh.Parent = part
  if Mesh == "SpecialMesh" then
    mesh.MeshType = meshtype
    if meshid ~= "nil" then
      mesh.MeshId = "http://www.roblox.com/asset/?id=" .. meshid
    end
  end
  mesh.Offset = offset
  mesh.Scale = scale
  return mesh
end
weld = function(parent, part0, part1, c0)
  local weld = it("Motor")
  weld.Parent = parent
  weld.Part0 = part0
  weld.Part1 = part1
  weld.C0 = c0
  return weld
end
gui = function(GuiType, parent, text, backtrans, backcol, pos, size)
  local gui = it(GuiType)
  gui.Parent = parent
  gui.Text = text
  gui.BackgroundTransparency = backtrans
  gui.BackgroundColor3 = backcol
  gui.SizeConstraint = "RelativeXY"
  gui.TextXAlignment = "Center"
  gui.TextYAlignment = "Center"
  gui.Position = pos
  gui.Size = size
  gui.Font = "SourceSans"
  gui.FontSize = "Size14"
  gui.TextWrapped = false
  gui.TextStrokeTransparency = 0
  gui.TextColor = BrickColor.new("White")
  return gui
end
local Color1 = Torso.BrickColor
local fengui = it("GuiMain")
fengui.Parent = Player.PlayerGui
fengui.Name = "WeaponGUI"
local fenframe = it("Frame")
fenframe.Parent = fengui
fenframe.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe.BackgroundTransparency = 1
fenframe.BorderColor3 = Color3.new(17, 17, 17)
fenframe.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe.Position = UDim2.new(0.95, 0, 0.7, 0)
local fenframe2 = it("Frame")
fenframe2.Parent = fengui
fenframe2.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe2.BackgroundTransparency = 1
fenframe2.BorderColor3 = Color3.new(17, 17, 17)
fenframe2.Size = UDim2.new(0.2, 0, 0.1, 0)
fenframe2.Position = UDim2.new(0.4, 0, 0.85, 0)
local fenframe3 = it("Frame")
fenframe3.Parent = fengui
fenframe3.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe3.BackgroundTransparency = 1
fenframe3.BorderColor3 = Color3.new(17, 17, 17)
fenframe3.Size = UDim2.new(0.2, 0, 0.2, 0)
fenframe3.Position = UDim2.new(0.8, 0, 0.8, 0)
local fenframe4 = it("Frame")
fenframe4.Parent = fengui
fenframe4.BackgroundColor3 = Color3.new(255, 255, 255)
fenframe4.BackgroundTransparency = 1
fenframe4.BorderColor3 = Color3.new(17, 17, 17)
fenframe4.Size = UDim2.new(0.1, 0, 0.1, 0)
fenframe4.Position = UDim2.new(0, 0, 0.7, 0)
local pressedf = false
local fenframe5 = it("Frame")
fenframe5.Parent = fengui
fenframe5.BackgroundColor3 = Color3.new(0, 0, 0)
fenframe5.BackgroundTransparency = 1
fenframe5.BorderColor3 = Color3.new(0, 0, 0)
fenframe5.Size = UDim2.new(1, 0, 1, 0)
fenframe5.Position = UDim2.new(0, 0, 0, 0)
fenframe5.ZIndex = 2
local tellbar = gui("TextLabel", fenframe5, "-Commander gains a new bar called Blessing that is used for a new E ability called Guardia\'s Blessing where if active, every melee attack Commander uses will create an orb that will create a holy wave that deals AOE damage and heals nearby allies. Every orb uses up Blessing (+)\n-Defensive Wave increases more defense, but has a longer cooldown (+)\n-Decimate changed to Invoke which makes Commander fly in the air, then create a holy explosion similar to Critical Point, except buffing allies\' defense, and dealing very minimal damage to enemies, but knocks them back really far, and decreases enemies\' damage (+)\n-Guardian Dash cooldown has been slightly reduced, but it only works on allies or pressing the button again (+/-)\n-Critical Point changed such that Commander charges the Gungnir, then shoots a slow moving orb forward, which then creates the Critical Point explosion (+/-)\n-Only defensive mode is useable (-)\n-Overall damage reduced (-)", 1, Color3.new(0, 0, 0), UDim2.new(0.25, 0, 0.25, 0), UDim2.new(0.5, 0, 0.5, 0))
tellbar.Font = "Arial"
tellbar.TextScaled = true
tellbar.TextTransparency = 1
tellbar.TextStrokeTransparency = 1
tellbar.ZIndex = 2
local fnumb = 0
local fenbarmana1 = gui("TextLabel", fenframe, "", 0, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarmana2 = gui("TextLabel", fenframe, "", 0, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarmana4 = gui("TextLabel", fenframe, "Mana(" .. mana.Value .. ")", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbarblock1 = gui("TextLabel", fenframe, "", 0, Color3.new(0, 0, 0), UDim2.new(-0.6, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarblock2 = gui("TextLabel", fenframe, "", 0, BrickColor.new("White").Color, UDim2.new(-0.6, 0, 0, 0), UDim2.new(0.4, 0, -2, 0))
local fenbarblock3 = gui("TextLabel", fenframe, "Blessing(" .. blessing .. ")", 1, Color3.new(0, 0, 0), UDim2.new(-0.6, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbardamage = gui("TextLabel", fenframe2, "Damage", 0.55, Color3.new(0.6078431372549, 0, 0), UDim2.new(-0.23, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbardef = gui("TextLabel", fenframe2, "Defense", 0.55, Color3.new(0, 0, 0.6078431372549), UDim2.new(-0.46, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarmove = gui("TextLabel", fenframe2, "Walkspeed", 0.55, Color3.new(0, 0.6078431372549, 0), UDim2.new(1.03, 0, 0, 0), UDim2.new(0.2, 0, 1, 0))
local fenbarhp1 = gui("TextLabel", fenframe2, "", 0, Color3.new(0, 0, 0), UDim2.new(-0.46, 0, 1, 0), UDim2.new(1.92, 0, 0.4, 0))
local fenbarhp2 = gui("TextLabel", fenbarhp1, "", 0, Color3.new(1, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarhp3 = gui("TextLabel", fenbarhp1, "(100)", 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
local fenbarstun1 = gui("TextLabel", fenframe4, "", 0, Color3.new(0, 0, 0), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, -4, 0))
local fenbarstun2 = gui("TextLabel", fenframe4, "", 0, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0, 0), UDim2.new(0.4, 0, 0, 0))
local fenbarstun3 = gui("TextLabel", fenframe4, "Stun(" .. Stun.Value .. ")", 1, Color3.new(0.960784, 0.803922, 0.188235), UDim2.new(0.2, 0, 0.2, 0), UDim2.new(0.4, 0, 0.2, 0))
local fenbarmove1 = gui("TextButton", fenframe3, move1, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove1.ZIndex = 2
local fenbarmove1b = gui("TextLabel", fenbarmove1, "", 0.55, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove2 = gui("TextButton", fenframe3, move2, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.1, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove2.ZIndex = 2
local fenbarmove2b = gui("TextLabel", fenbarmove2, "", 0.55, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove3 = gui("TextButton", fenframe3, move3, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.1, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove3.ZIndex = 2
local fenbarmove3b = gui("TextLabel", fenbarmove3, "", 0.55, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local fenbarmove4 = gui("TextButton", fenframe3, move4, 0.55, Color3.new(0.5, 0.5, 0.5), UDim2.new(0.6, 0, 0.6, 0), UDim2.new(0.4, 0, 0.4, 0))
fenbarmove4.ZIndex = 2
local fenbarmove4b = gui("TextLabel", fenbarmove4, "", 0.55, BrickColor.new(NewCol).Color, UDim2.new(0, 0, 0, 0), UDim2.new(0, 0, 1, 0))
local modelzorz = Instance.new("Model")
modelzorz.Parent = Character
modelzorz.Name = "Cherubim"
local handle = part(3, modelzorz, 0, 0.5, TorsoColor, "Handle", vt())
local prt1 = part(3, modelzorz, 0, 0, TorsoColor, "Part01", vt())
local prt2 = part(3, modelzorz, 0, 0, BrickColor.new("Black"), "Part02", vt())
local prt3 = part(3, modelzorz, 0, 0, BrickColor.new("Bright green"), "Part03", vt())
local prt4 = part(3, modelzorz, 0, 0, BrickColor.new("Teal"), "Part04", vt())
local prt5 = part(3, modelzorz, 0, 0, BrickColor.new("Bright green"), "Part05", vt())
local prt6 = part(3, modelzorz, 0, 0, BrickColor.new("Bright green"), "Part06", vt())
local prt7 = part(3, modelzorz, 0, 0, BrickColor.new("Bright green"), "Part07", vt())
local prt11 = part(3, modelzorz, 0, 0, BrickColor.new("Teal"), "Part11", vt())
local prt12 = part(3, modelzorz, 0, 0, BrickColor.new("Teal"), "Part12", vt())
local prt13 = part(3, modelzorz, 0, 0, BrickColor.new("Teal"), "Part13", vt())
local prt14 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part14", vt())
local prt15 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part15", vt())
local prt16 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part16", vt())
local prt17 = part(3, modelzorz, 0, 0, BrickColor.new(NewCol), "Part17", vt())
local msh1 = mesh("SpecialMesh", prt1, "Head", "nil", vt(0, 0, 0), vt(2, 25, 2))
local msh2 = mesh("BlockMesh", prt2, "", "", vt(0, 0, 0), vt(1, 30, 1))
local msh3 = mesh("SpecialMesh", prt3, "Head", "nil", vt(0, 0, 0), vt(2.5, 4, 2.5))
local msh4 = mesh("CylinderMesh", prt4, "", "", vt(0, 0, 0), vt(2.7, 1.5, 2.7))
local msh5 = mesh("BlockMesh", prt5, "", "", vt(0, 0, 0), vt(3, 5, 8))
local msh6 = mesh("SpecialMesh", prt6, "Wedge", "nil", vt(0, 0, 0), vt(3, 3, 4))
local msh7 = mesh("SpecialMesh", prt7, "Wedge", "nil", vt(0, 0, 0), vt(3, 3, 4))
local msh11 = mesh("SpecialMesh", prt11, "Sphere", "nil", vt(0, 0, 0), vt(4, 4, 3.5))
local msh12 = mesh("SpecialMesh", prt12, "Sphere", "nil", vt(0, 0, 0), vt(2, 4, 2))
local msh13 = mesh("SpecialMesh", prt13, "Sphere", "nil", vt(0, 0, 0), vt(2, 4, 2))
local msh14 = mesh("SpecialMesh", prt14, "FileMesh", "92135508", vt(0, 0, 0), vt(0.5, 0.5, 0.5))
local msh15 = mesh("SpecialMesh", prt15, "FileMesh", "92135508", vt(0, 0, 0), vt(0.5, 0.5, 0.5))
local msh16 = mesh("SpecialMesh", prt16, "FileMesh", "92135524", vt(0, 0, 0), vt(0.5, 0.5, 0.5))
local msh17 = mesh("SpecialMesh", prt17, "FileMesh", "92135524", vt(0, 0, 0), vt(0.5, 0.5, 0.5))
local handlewld = weld(prt1, handle, Torso, euler(2.1, 1.57, 0) * cf(1, -1, -0.5))
local wld1 = weld(prt1, prt1, handle, cf(0, 0, 0) * euler(0, 0, 0))
local wld2 = weld(prt1, prt2, prt1, euler(0, 0, 0) * cf(0, 0, 0))
local wld3 = weld(prt1, prt3, prt1, euler(0, 0, 0) * cf(0, 3, 0))
local wld4 = weld(prt1, prt4, prt3, euler(0, 0, 0) * cf(0, 0.25, 0))
local wld5 = weld(prt1, prt5, prt1, euler(0, 0, 0) * cf(0, -2.8, 0))
local wld6 = weld(prt1, prt6, prt5, euler(0, 0, 0) * cf(0, -0.8, 0.4))
local wld7 = weld(prt1, prt7, prt5, euler(0, 3.14, 0) * cf(0, -0.8, -0.4))
local wld11 = weld(prt1, prt11, prt5, euler(0, 0, 1.57) * cf(0, -0.2, 0))
local wld12 = weld(prt1, prt12, prt5, euler(0, 0, 1.57) * cf(0, 0.1, 0.5))
local wld13 = weld(prt1, prt13, prt5, euler(0, 0, 1.57) * cf(0, 0.1, -0.5))
local wld14 = weld(prt1, prt14, prt5, euler(3.14, 1.57, 0) * cf(0.4, 0.6, -2))
local wld15 = weld(prt1, prt15, prt5, euler(3.14, -1.57, 0) * cf(-0.4, 0.6, 2))
local wld16 = weld(prt1, prt16, prt5, euler(3.14, 1.57, 0) * cf(0.4, 0.6, 2))
local wld17 = weld(prt1, prt17, prt5, euler(3.14, -1.57, 0) * cf(-0.4, 0.6, -2))
num = 0
num2 = 0
num3 = 0
num4 = 0
num5 = 2
for i = 1, 4 do
  local prt8 = part(3, modelzorz, 0.7, 0, BrickColor.new("Teal"), "Part08", vt())
  local prt9 = part(3, modelzorz, 0.7, 0, BrickColor.new("Teal"), "Part09", vt())
  local prt10 = part(3, modelzorz, 0.7, 0, BrickColor.new("Teal"), "Part10", vt())
  local msh8 = mesh("BlockMesh", prt8, "", "", vt(0, 0, 0), vt(1 + num4, 5 + num, 6 + num3))
  local msh9 = mesh("SpecialMesh", prt9, "Wedge", "nil", vt(0, 0, 0), vt(1 + num4, 4, 3 + num3 / 2))
  local msh10 = mesh("SpecialMesh", prt10, "Wedge", "nil", vt(0, 0, 0), vt(1 + num4, 4, 3 + num3 / 2))
  local wld8 = weld(prt1, prt8, prt5, euler(0, 0, 0) * cf(0, -0.8 - num2, 0))
  local wld9 = weld(prt1, prt9, prt8, euler(0, 0, 0) * cf(0, -0.9 - num * 0.1, 0.3 + num3 * 0.1 / 2))
  local wld10 = weld(prt1, prt10, prt8, euler(0, 3.14, 0) * cf(0, -0.9 - num * 0.1, -0.3 - num3 * 0.1 / 2))
  num = num + 0.6
  num2 = num2 + 0.3 * num5
  num3 = num3 - 0.5
  num4 = num4 - 0.2
  num5 = num5 + 1
end
local wing1 = part(3, nil, 0, 1, BrickColor.new(NewCol), "Wing", vt())
local wmsh1 = mesh("SpecialMesh", wing1, "FileMesh", "92135508", vt(0, 0, 0), vt(0.8, 0.8, 0.8))
local wing2 = part(3, nil, 0, 1, BrickColor.new(NewCol), "Wing", vt())
local wmsh2 = mesh("SpecialMesh", wing2, "FileMesh", "92135524", vt(0, 0, 0), vt(0.8, 0.8, 0.8))
local nr = NumberRange.new
local ns = NumberSequence.new
local cs = ColorSequence.new
local parti = it("ParticleEmitter")
parti.Color = cs(NewCol, NewCol)
parti.LightEmission = 0
parti.Size = ns(1)
parti.Texture = "http://www.roblox.com/asset/?id=242842525"
sizeseq = ns({NumberSequenceKeypoint.new(0, 0.5), NumberSequenceKeypoint.new(1, 0.2)})
transseq = ns({NumberSequenceKeypoint.new(0, 0.5), NumberSequenceKeypoint.new(1, 1)})
parti.Transparency = transseq
parti.Size = sizeseq
parti.Acceleration = vt(0, -0.5, 0)
parti.Lifetime = nr(5, 7)
parti.Rate = 1
parti.RotSpeed = nr(30)
parti.Speed = nr(2)
parti.VelocitySpread = 90
parti.Parent = hitbox
parti.Enabled = true
parti.Parent = wing1
parti2 = parti:Clone()
parti2.Parent = wing2
for _,c in pairs(modelzorz:children()) do
  table.insert(Weapon, c)
end
for _,c in pairs(prt1:children()) do
  if c.className == "Motor" then
    table.insert(Welds, c)
  end
end
-- DECOMPILER ERROR at PC2354: Overwrote pending register: R144 in 'AssignReg'

local hitbox = part(3, modelzorz, 0, 1, BrickColor.new("Black"), "Hitbox2", Vector3.new())
hitbox.Anchored = false
local hbwld = weld(hitbox, hitbox, RootPart, euler(0, 0, 0) * cf(0, 0, 0))
local hitbox2 = part(3, nil, 0, 1, BrickColor.new("Black"), "Hitbox", vt(1, 1, 1))
hitbox2.Anchored = true
local hitboxCF = cf(0, 0, 0)
hboxpos = Instance.new("BodyPosition", nil)
hboxpos.P = 2000
hboxpos.D = 100
hboxpos.maxForce = Vector3.new(545000, 545000, 545000)
hitboxweld = function()
  hbwld.Parent = modelzorz
  hbwld.Part0 = hitbox
  hbwld.Part1 = prt5
end
if script.Parent.className ~= "HopperBin" then
  Tool = Instance.new("HopperBin")
  Tool.Parent = Backpack
  Tool.Name = "Cherubim"
  script.Parent = Tool
end
Bin = script.Parent
if Bin.Name == "Commander: Celestial Bulwark" then
  Bin.Name = "Cherubim"
end
local bodvel = Instance.new("BodyVelocity")
local bg = Instance.new("BodyGyro")
so = function(id, par, vol, pit)
  local sou = Instance.new("Sound", par or workspace)
  sou.Volume = vol
  sou.Pitch = pit or 1
  sou.SoundId = "http://www.roblox.com/asset/?id=" .. id
  coroutine.resume(coroutine.create(function(Sound)
    swait()
    Sound:play()
  end), sou)
  game:GetService("Debris"):AddItem(sou, 6)
end
function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end
hideanim = function()
  equipped = false
  for i = 0, 1, 0.1 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(1.5, 1.4, 0) * euler(0, 0, -0.8) * cf(0, 1, 0), 0.3)
    wld1.C0 = clerp(wld1.C0, cf(0, -1, 0) * euler(0, 0, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0.4), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 0.2), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(3.4, 0, -0.4), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0), 0.3)
  end
  mdec.Parent = nil
  handlewld.Part1 = Torso
  handlewld.C0 = euler(2.1, 1.57, 0) * cf(1, -1, -0.5)
  wld1.C0 = cf(0, 0, 0) * euler(0, 0, 0)
  for i = 0, 1, 0.3 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
  end
  mdec.Parent = Decrease
  mdec2.Parent = nil
end
mdec.Parent = Decrease
equipanim = function()
  equipped = true
  mdec.Parent = nil
  for i = 0, 1, 0.1 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0.4), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 0.2), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(3.3, 0, -0.4), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
  end
  handlewld.Part1 = LeftArm
  handlewld.C0 = euler(1.5, 1.4, 0) * euler(0, 0, -1) * cf(0, 1, 0)
  wld1.C0 = cf(0, -1, 0) * euler(0, 0, 0)
  mdec2.Parent = Decrease
end
StaggerAnim = function()
  attack = true
  removeControl()
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.35 do
    swait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -40
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.7) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, 0.6), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.4, 0, 0.4) * euler(0, 0.4, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.9) * euler(0, 0.7, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.7, 0) * euler(0, 1.57, 0) * euler(-0.4, -0.2, 0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, 0.4), 0.3)
  end
  for i = 0, 1, 0.2 do
    swait()
    if Rooted.Value == false then
      Torso.Velocity = RootPart.CFrame.lookVector * -40
    end
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.7) * euler(0.3, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.4, 0, 0.6), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.6, 0, 0.6) * euler(0, 0.4, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.6, 0, -0.9) * euler(0, 0.7, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.7, 0) * euler(0, 1.57, 0) * euler(-0.5, -0.2, 0.5), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, 0.4), 0.3)
  end
  for i = 0, 1, 0.1 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
    wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0) * euler(0.1, 0, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.7) * euler(0.3, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -1.8) * euler(-0.2, 0, 0.4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(0.6, 0, -0.4), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4) * euler(0, 0.3, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.2, 0) * euler(-0.4, 0, 1.2), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, 0.4, -0.8) * euler(0, -1.57, 0) * euler(0, 0.2, -0.1), 0.3)
  end
  for i = 1, 40 do
    swait()
    if StunT.Value <= Stun.Value then
      break
    end
  end
  do
    resumeControl()
    combo = 0
    attack = false
  end
end
StaggerHitt = function()
  attack = true
  for i = 1, math.random(2, 4) do
    ClangEffect(BrickColor.new("New Yeller"), cf(hitbox.Position) * euler(math.random(-50, 50) / 100, math.random(-50, 50), math.random(-50, 50) / 100), 0, 0.1, 0.2, math.random(150, 300) / 1000)
  end
  for i = 0, 1, 0.1 do
    swait()
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.7) * euler(0.1, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(-0.2, 0, 0.6), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.4) * euler(0, 0.4, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.9) * euler(0, 0.7, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.2, -0.2), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, 0.4), 0.3)
  end
  attack = false
end
StunAnim = function()
  attack = true
  removeControl()
  Stunned.Value = true
  showDamage(Character, "Stunned", "Interrupt")
  local dec = Instance.new("NumberValue", Decrease)
  dec.Name = "DecreaseMvmt"
  dec.Value = 10
  for i = 0, 1, 0.3 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
    wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0), 0.2)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.2, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1, 0, 0.4) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.3), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, 0), 0.25)
  end
  for i = 0, 1, 0.3 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
    wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0), 0.2)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -0.5), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0.8, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.4) * euler(1.2, 0, 0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.5, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(0.1, 0, 0.7), 0.25)
  end
  for i = 0, 1, 0.3 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
    wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0), 0.2)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.3, 0, -1), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1.57, 0, -3), 0.2)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.8, 0, 1.3), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, -0.8) * euler(0, -0.1, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -0.6, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.6), 0.25)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8, 0) * euler(0, -1.57, 0) * euler(-0.1, 0, 0.3), 0.25)
  end
  local gairost = Instance.new("BodyGyro")
  gairost.Parent = RootPart
  gairost.maxTorque = Vector3.new(400000, 0, 400000) * math.huge
  gairost.P = 20000
  gairost.cframe = cf(0, 0, 0)
  for i = 0, 1, 0.1 do
    swait()
    if hitfloor ~= nil then
      Torso.Velocity = vt(0, 0, 0)
    end
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
    wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0), 0.2)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2.5) * euler(1.57, 0, -3.14), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1.5) * euler(0.2, 0, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.5, 0, -1.57) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 0), 0.3)
  end
  for i = 1, 70 do
    swait()
    gairost.cframe = RootPart.CFrame
    if hitfloor ~= nil then
      Torso.Velocity = vt(0, 0, 0)
    end
  end
  for i = 0, 1, 0.2 do
    swait()
    Stun.Value = 0
    gairost.cframe = RootPart.CFrame
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
    wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0), 0.2)
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -2) * euler(1, 0, -4), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-1.57, 0, 1) * euler(0.2, -1, 0), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, 0.2) * euler(0, 0, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(-0.3, 0.5, 0.4), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, -1) * euler(0, -1.57, 0) * euler(-0.1, 0.2, 1), 0.3)
  end
  resumeControl()
  gairost.Parent = nil
  dec.Parent = nil
  Stun.Value = 0
  combo = 0
  Stunned.Value = false
  attack = false
  for i = 1, 10 do
    swait()
    Stun.Value = 0
  end
end
dattackone = function()
  attack = true
  for i = 0, 1, 0.15 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
    wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0) * euler(-1, 0, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.5), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.5), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1, 0, 0.2), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(2, 0, -0.4), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.5, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, -0.5, 0), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC207: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC207: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("199145095", prt5, 1, 1)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(1, 5, 1.7)
  hitboxCF = prt5.CFrame * cf(0, 2.8, 0)
  hitbox.CFrame = hitboxCF
  blcf = nil
  scfr = nil
  for i = 0, 1, 0.1 do
    swait()
    hitboxCF = prt5.CFrame * cf(0, 2.8, 0)
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 5, 4, 6, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(4, 8)), nil, true)
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.35)
    wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0) * euler(0.8, 0, 0), 0.35)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5), 0.35)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.5), 0.35)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.2), 0.35)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.35)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.3) * euler(0.5, 0, -0.1) * euler(0, 0.5, 0), 0.35)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.35)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, 0), 0.35)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.5, 0), 0.35)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC490: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC490: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
dattacktwo = function()
  attack = true
  for i = 0, 1, 0.15 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
    wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0) * euler(-1, 0, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.8), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.8), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.2, 0, 0.5), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-1, 0, -0.8) * euler(0, -0.5, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.4) * euler(0, 1.57, 0) * euler(0, -0.8, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-0.8, -1, -0.4) * euler(0, -1.57, 0) * euler(0, -0.8, 0), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC213: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC213: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("199145146", prt5, 1, 1)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(1, 5, 1.7)
  hitboxCF = prt5.CFrame * cf(0, 2.8, 0)
  hitbox.CFrame = hitboxCF
  blcf = nil
  scfr = nil
  for i = 0, 1, 0.1 do
    swait()
    hitboxCF = prt5.CFrame * cf(0, 2.8, 0)
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 5, 4, 6, math.random(20, 25), "Normal", RootPart, 0.5, 2, (math.random(4, 8)), nil, true)
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
    wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0) * euler(1, 0, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.8), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.8), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.5, 0, 0.2), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.3) * euler(1, 0, -0.5) * euler(0, 0.5, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(0.8, -1, -0.4) * euler(0, 1.57, 0) * euler(0, 0.8, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-0.8, -1, 0.4) * euler(0, -1.57, 0) * euler(0, 0.8, 0), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC496: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC496: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
dattackthree = function()
  attack = true
  for i = 0, 1, 0.15 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
    wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0) * euler(-0.5, 0, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.5), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.5), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.2), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-0.5, 0.5, -0.5) * euler(2, 0, 1) * euler(0, -1, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0.5, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0.5, 0), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC213: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC213: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  so("199145204", prt5, 1, 1)
  hbwld.Parent = nil
  hboxpos.Parent = hitbox
  hitbox.Parent = modelzorz
  hitbox.Size = vt(1, 5, 1.7)
  hitboxCF = prt5.CFrame * cf(0, 2.8, 0)
  hitbox.CFrame = hitboxCF
  blcf = nil
  scfr = nil
  for i = 0, 1, 0.1 do
    swait()
    hitboxCF = prt5.CFrame * cf(0, 2.8, 0)
    hitbox.CFrame = hitboxCF
    MagniDamage(hitbox, 5, 4, 6, math.random(5, 10), "Normal", RootPart, 0.5, 1, (math.random(4, 8)), nil, true)
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
    wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0) * euler(0.5, 0, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.5), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.5), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.6, 0, 0.4), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.5, 0, -1) * euler(0, -0.6, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.5, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, -0.5, 0), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC496: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC496: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitbox.Parent = modelzorz
  hitbox.Size = vt()
  hitboxweld()
  hboxpos.Parent = nil
  attack = false
end
dattackfour = function()
  attack = true
  blcf = nil
  scfr = nil
  so("199145327", prt5, 1, 1)
  for i = 0, 1, 0.1 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
    wld1.C0 = cf(0, -0.5 + 1.5 * i, 0) * euler(-0.57 + 7 * i, 0, 0)
    Neck.C0 = clerp(Neck.C0, necko * euler(-0.4, 0, 0.2), 0.2)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
    RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1, 0, -1), 0.2)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(2.8, 0, 0), 0.2)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
    RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.3)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC214: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC214: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  local dec = Instance.new("NumberValue", Decrease)
  dec.Name = "DecreaseMvmt"
  dec.Value = 1
  for i = 0, 1, 0.15 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.4)
    wld1.C0 = clerp(wld1.C0, cf(0, 0.2, 0) * euler(0, 0, 0), 0.4)
    Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.2), 0.4)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.2), 0.4)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.57, 0, 0), 0.4)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC379: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC379: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  hitfloor = rayCast(prt4.Position, CFrame.new(prt4.Position, prt4.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
  if hitfloor ~= nil then
    so("199145264", prt4, 1, 1)
    MagicWave(BrickColor.new("Teal"), cf(prt4.Position), 1, 1, 1, 1.2, 0.4, 1.2, 0.05)
    MagicBlock(BrickColor.new("Teal"), cf(prt4.Position), 1, 1, 1, 1, 1, 1, 0.05, 1)
    MagniBuff(RootPart, 20, "Defense", -0.1, 100)
    MagniDamage(prt4, 20, 4, 6, math.random(30, 40), "Snare", RootPart, 0, 1, (math.random(10, 15)), nil, nil, true, nil, nil, nil)
  end
  swait(10)
  dec.Parent = nil
  attack = false
end
GuardiaBlessing = function()
  attack = true
  for i = 0, 1, 0.1 do
    swait()
    handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
    wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0) * euler(0.3, 0, 0), 0.3)
    Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, -0.4), 0.3)
    RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
    RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.3, 0, 0.4), 0.3)
    RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, 0.2) * euler(0, -1.3, 0), 0.3)
    LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
    RH.C0 = clerp(RH.C0, RHC0, 0.2)
    LH.C0 = clerp(LH.C0, LHC0, 0.2)
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      do
        if StaggerHit.Value == true then
          break
        end
        -- DECOMPILER ERROR at PC181: LeaveBlock: unexpected jumping out IF_THEN_STMT

        -- DECOMPILER ERROR at PC181: LeaveBlock: unexpected jumping out IF_STMT

      end
    end
  end
  if blessbuff == false then
    blessbuff = true
  else
    blessbuff = false
  end
  attack = false
end
do1 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[1] and mana.Value >= 15 then
    attack = true
    cooldowns[1] = 0
    mana.Value = mana.Value - 15
    if Mode == "Defensive" then
      blcf = nil
      scfr = nil
      for i = 0, 1, 0.1 do
        swait()
        handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
        wld1.C0 = cf(0, -0.5 + 1.5 * i, 0) * euler(-0.57 + 7 * i, 0, 0)
        Neck.C0 = clerp(Neck.C0, necko * euler(-0.4, 0, 0.2), 0.2)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
        RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1, 0, -1), 0.2)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(2.8, 0, 0), 0.2)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
        RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
        LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.3)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC246: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC246: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      for i = 0, 1, 0.15 do
        swait()
        handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0.785) * cf(0, 1, 0), 0.4)
        wld1.C0 = clerp(wld1.C0, cf(0, 0.2, 0) * euler(0, 0, 0), 0.4)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.4)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.4)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.2), 0.4)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
        LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.57, 0, 0.785), 0.4)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC404: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC404: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      while hitfloor == nil do
        swait()
      end
      so("199145350", prt5, 1, 0.8)
      MagniDamage(RootPart, 40, 4, 8, math.random(5, 10), "Knockdown2", RootPart, 0, 1, 0, nil, nil, true)
      MagniBuff(RootPart, 40, "Defense", -0.4, 600)
      MagicWave(BrickColor.new("Teal"), cf(RootPart.Position) * cf(0, -2, 0), 1, 1, 1, 1, 0.2, 1, 0.02)
      MagicBlock(BrickColor.new("Teal"), cf(prt4.Position), 1, 1, 1, 1, 1, 1, 0.05, 1)
      ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
      ref.Anchored = true
      game:GetService("Debris"):AddItem(ref, 10)
      for i = 1, 50 do
        swait()
        ref.CFrame = cf(RootPart.Position) * cf(math.random(-2000, 2000) / 100, 0, math.random(-2000, 2000) / 100)
        hit,pos = rayCast(ref.Position, CFrame.new(ref.Position, ref.Position - Vector3.new(0, 1, 0)).lookVector, 20, Character)
        if hit ~= nil then
          MagicCircle(BrickColor.new("White"), cf(pos), 1, 1, 1, 0.5, 7, 0.5, 0.1)
        end
      end
      ref.Parent = nil
    else
      blcf = nil
      scfr = nil
      for i = 0, 1, 0.1 do
        swait()
        handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
        wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0) * euler(1, 0, 0), 0.2)
        Neck.C0 = clerp(Neck.C0, necko * euler(-0.4, 0, 0.2), 0.2)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.2), 0.2)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(2.8, 0, 0), 0.2)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
        RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, 0, 0), 0.3)
        LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, 0, 0), 0.3)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC790: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC790: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      so("199145350", prt5, 1, 0.8)
      MagniDamage(RootPart, 40, 5, 10, math.random(30, 40), "Knockdown2", 0, 1, 0, nil, nil, true)
      MagniBuff(RootPart, 40, "Damage", -0.2, 600)
      MagicBlock(BrickColor.new("Teal"), cf(prt5.Position), 1, 1, 1, 2, 2, 2, 0.02, 1)
      ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
      ref.Anchored = true
      game:GetService("Debris"):AddItem(ref, 10)
      for i = 1, 50 do
        swait()
        ref.CFrame = cf(RootPart.Position) * cf(math.random(-2000, 2000) / 100, 0, math.random(-2000, 2000) / 100)
        hit,pos = rayCast(ref.Position, CFrame.new(ref.Position, ref.Position - Vector3.new(0, 1, 0)).lookVector, 20, Character)
        if hit ~= nil then
          MagicCircle(BrickColor.new("White"), cf(pos), 1, 1, 1, 0.5, 7, 0.5, 0.1)
        end
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC948: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC948: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      ref.Parent = nil
    end
    attack = false
  end
end
do2 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[2] and mana.Value >= 10 and Rooted.Value == false then
    attack = true
    so("199145446", RootPart, 1, 1)
    manualguardend = false
    local con1 = nil
    do
      Fly = false
      Target = nil
      local dec = Instance.new("NumberValue", Decrease)
      dec.Name = "DecreaseMvmt"
      dec.Value = 0.5
      wing1.Parent = modelzorz
      wing1.Transparency = 1
      wing2.Parent = modelzorz
      wing2.Transparency = 1
      local wwld1 = weld(wing1, wing1, RootPart, euler(0, 1.2, 0) * cf(-2, -1, -3))
      local wwld2 = weld(wing2, wing2, RootPart, euler(0, -1.2, 0) * cf(2, -1, -3))
      for i = 1, 0.5, -0.05 do
        swait()
        wing1.Transparency = i
        wing2.Transparency = i
        wwld1.C0 = clerp(wwld1.C0, euler(0, 0.8, 0) * cf(-3, -1, -2), 0.3)
        wwld2.C0 = clerp(wwld2.C0, euler(0, -0.8, 0) * cf(3, -1, -2), 0.3)
        handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
        wld1.C0 = clerp(wld1.C0, cf(0, 1, 0) * euler(0.5, 0, 0), 0.3)
        Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.5), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0.1, 0, 0.5), 0.3)
        RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.4), 0.3)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(0.5, 0, -1) * euler(0, -0.6, 0), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(1.3, -0.6, 0) * euler(0, 1.57, 0) * euler(0, -0.5, -0.3), 0.3)
        LH.C0 = clerp(LH.C0, cf(-1, -0.9, 0) * euler(0, -1.57, 0) * euler(0, -0.5, 0.4), 0.3)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC349: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC349: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
      GuardStance = true
      while GuardStance == true do
        swait()
      end
      if manualguardend == true then
        mana.Value = mana.Value - 10
        so("199145404", RootPart, 1, 1)
        so("199145433", RootPart, 1, 1)
        hbwld.Parent = nil
        hboxpos.Parent = hitbox
        hitbox.Parent = modelzorz
        hitbox.Size = vt(0.5, 4.5, 1.2)
        hitboxCF = prt5.CFrame * cf(0, 2.8, 0)
        hitbox.CFrame = hitboxCF
        blcf = nil
        scfr = nil
        for i = 0, 1, 0.1 do
          swait()
          hitboxCF = prt5.CFrame * cf(0, 2.8, 0)
          hitbox.CFrame = hitboxCF
          MagniDamage(hitbox, 4.5, 5, 10, math.random(5, 10), "Normal", RootPart, 0.5, 2, math.random(10, 15), false, false)
          if Rooted.Value == false then
            Torso.Velocity = RootPart.CFrame.lookVector * 70
          end
          wwld1.C0 = clerp(wwld1.C0, euler(0, 0.6, 0) * cf(-3, -1, -1.5), 0.3)
          wwld2.C0 = clerp(wwld2.C0, euler(0, -0.6, 0) * cf(3, -1, -1.5), 0.3)
          handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
          wld1.C0 = clerp(wld1.C0, cf(0, -1, 0) * euler(1.4, 0, 0), 0.3)
          Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57), 0.3)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0.1, 0, 1.57), 0.3)
          RW.C0 = clerp(RW.C0, cf(1.3, 0.5, -0.2) * euler(0, 0, 1.57) * euler(0.4, 0, 0), 0.3)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
          LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.57, 0, 1.4) * euler(0, -1.57, 0), 0.3)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
          RH.C0 = clerp(RH.C0, cf(0.5, -0.6, 0.4) * euler(0, 1.57, 0) * euler(0, -1.57, -0.3), 0.3)
          LH.C0 = clerp(LH.C0, cf(-0.5, -0.9, -0.3) * euler(0, -1.57, 0) * euler(0, -1.57, 0.4), 0.3)
          if Stagger.Value ~= true and StunT.Value > Stun.Value then
            do
              if StaggerHit.Value == true then
                break
              end
              -- DECOMPILER ERROR at PC708: LeaveBlock: unexpected jumping out IF_THEN_STMT

              -- DECOMPILER ERROR at PC708: LeaveBlock: unexpected jumping out IF_STMT

            end
          end
        end
        for i = 0, 1, 0.1 do
          swait()
          hitboxCF = prt5.CFrame * cf(0, 2.8, 0)
          hitbox.CFrame = hitboxCF
          MagniDamage(hitbox, 4.5, 5, 10, math.random(5, 10), "Normal", RootPart, 0.5, 2, math.random(10, 15), false, false)
          if Rooted.Value == false then
            Torso.Velocity = RootPart.CFrame.lookVector * 70
          end
          if Stagger.Value ~= true and StunT.Value > Stun.Value then
            do
              if StaggerHit.Value == true then
                break
              end
              -- DECOMPILER ERROR at PC774: LeaveBlock: unexpected jumping out IF_THEN_STMT

              -- DECOMPILER ERROR at PC774: LeaveBlock: unexpected jumping out IF_STMT

            end
          end
        end
        hitbox.Parent = modelzorz
        hitbox.Size = vt()
        hitboxweld()
        hboxpos.Parent = nil
        DecreaseStat(Character, "Defense", -0.2, 400)
      else
        mana.Value = mana.Value - 10
        so("199145404", RootPart, 1, 1)
        so("199145433", RootPart, 1, 1)
        Fly = true
        prop.ThrustP = 50
        prop.MaxSpeed = 100
        prop.TurnP = 1500
        prop.MaxThrust = 7000
        prop.CartoonFactor = 1
        prop.Parent = RootPart
        prop.Target = Target.Torso
        Humanoid.Jump = true
        Humanoid.PlatformStand = true
        prop:Fire()
        con2 = hitbox.Touched:connect(function(hit)
    if hit.Parent == Target then
      prop.Parent = nil
      Fly = false
    end
  end)
        hbwld.Parent = nil
        hboxpos.Parent = hitbox
        hitbox.Parent = modelzorz
        hitbox.Size = vt(0.5, 4.5, 1.2)
        hitboxCF = prt5.CFrame * cf(0, 2.8, 0)
        hitbox.CFrame = hitboxCF
        blcf = nil
        scfr = nil
        for i = 0, 1, 0.1 do
          swait()
          mana.Value = mana.Value - 1
          hitboxCF = prt5.CFrame * cf(0, 2.8, 0)
          hitbox.CFrame = hitboxCF
          MagniDamage(hitbox, 5, 5, 10, math.random(5, 10), "Normal", RootPart, 0.5, 2, math.random(10, 15), true, true)
          if Rooted.Value == false then
            Torso.Velocity = RootPart.CFrame.lookVector * 70
          end
          wwld1.C0 = clerp(wwld1.C0, euler(0, 1, 0) * cf(-2.5, -1, -1.5), 0.3)
          wwld2.C0 = clerp(wwld2.C0, euler(0, -1, 0) * cf(2.5, -1, -1.5), 0.3)
          handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
          wld1.C0 = clerp(wld1.C0, cf(0, -1, 0) * euler(1.4, 0, 0), 0.3)
          Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1.57), 0.3)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0.1, 0, 1.57), 0.3)
          RW.C0 = clerp(RW.C0, cf(1.3, 0.5, -0.2) * euler(0, 0, 1.57) * euler(0.4, 0, 0), 0.3)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
          LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.57, 0, 1.4) * euler(0, -1.57, 0), 0.3)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
          RH.C0 = clerp(RH.C0, cf(0.5, -0.6, 0.4) * euler(0, 1.57, 0) * euler(0, -1.57, -0.3), 0.3)
          LH.C0 = clerp(LH.C0, cf(-0.5, -0.9, -0.3) * euler(0, -1.57, 0) * euler(0, -1.57, 0.4), 0.3)
          if Stagger.Value ~= true and StunT.Value > Stun.Value then
            do
              if StaggerHit.Value == true then
                break
              end
              -- DECOMPILER ERROR at PC1180: LeaveBlock: unexpected jumping out IF_THEN_STMT

              -- DECOMPILER ERROR at PC1180: LeaveBlock: unexpected jumping out IF_STMT

            end
          end
        end
        drain = 0
        manadec = 1
        while 1 do
          if Fly == true and mana.Value > 0 then
            swait()
            drain = drain + 1
            if drain >= 30 then
              drain = 0
              manadec = manadec + 1
            end
            mana.Value = mana.Value - manadec
            if Target ~= nil then
              local mag = (RootPart.Position - Target.Torso.Position).magnitude
              if mag <= 5 then
                Fly = false
              end
            else
              do
                print("no moar")
                hitboxCF = prt5.CFrame * cf(0, 2.8, 0)
                hitbox.CFrame = hitboxCF
                MagniDamage(hitbox, 5, 5, 10, math.random(5, 10), "Normal", RootPart, 0.5, 2, math.random(10, 15), true, true)
                Humanoid.PlatformStand = true
                if Stagger.Value ~= true and StunT.Value > Stun.Value and StaggerHit.Value == true then
                  break
                end
                -- DECOMPILER ERROR at PC1280: LeaveBlock: unexpected jumping out DO_STMT

                -- DECOMPILER ERROR at PC1280: LeaveBlock: unexpected jumping out IF_ELSE_STMT

                -- DECOMPILER ERROR at PC1280: LeaveBlock: unexpected jumping out IF_STMT

                -- DECOMPILER ERROR at PC1280: LeaveBlock: unexpected jumping out IF_THEN_STMT

                -- DECOMPILER ERROR at PC1280: LeaveBlock: unexpected jumping out IF_STMT

              end
            end
          end
        end
        Humanoid.PlatformStand = false
        hitbox.Parent = modelzorz
        hitbox.Size = vt()
        hitboxweld()
        hboxpos.Parent = nil
        prop.Parent = nil
        DecreaseStat(Character, "Defense", -0.2, 400)
        if Target ~= nil then
          if game.Players:GetPlayerFromCharacter(Target) ~= nil then
            if game.Players:GetPlayerFromCharacter(Target).TeamColor == Player.TeamColor then
              if Player.Neutral == false then
                DecreaseStat(Target, "Defense", -0.2, 400)
              else
                DecreaseStat(Target, "Defense", 0.2, 400)
              end
            else
              DecreaseStat(Target, "Defense", 0.2, 400)
            end
          else
            DecreaseStat(Target, "Defense", 0.2, 400)
          end
        end
        Humanoid.Jump = true
        Humanoid.PlatformStand = false
      end
      coroutine.resume(coroutine.create(function()
    for i = 0.5, 1, 0.05 do
      swait()
      wing1.Transparency = i
      wing2.Transparency = i
    end
    wing1.Parent = nil
    wing2.Parent = nil
    wwld1.Parent = nil
    wwld2.Parent = nil
  end))
      dec.Parent = nil
      cooldowns[2] = 0
      attack = false
    end
  end
end
do3 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[3] and mana.Value >= 25 then
    attack = true
    cooldowns[3] = 0
    mana.Value = mana.Value - 25
    do
      for i = 0, 1, 0.1 do
        swait()
        handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
        wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0) * euler(-0.57, 0, 0), 0.3)
        Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0), 0.3)
        RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0.1, 0, 0), 0.3)
        RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(0.6, 0, -0.4), 0.3)
        RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(0.6, 0, 0.4) * euler(0, 0, 0), 0.3)
        LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
        RH.C0 = clerp(RH.C0, cf(1, -0.6, -0.2) * euler(0, 1.57, 0) * euler(-0.2, 0, -0.2), 0.3)
        LH.C0 = clerp(LH.C0, cf(-1, -0.6, -0.2) * euler(0, -1.57, 0) * euler(-0.2, 0, 0.2), 0.3)
        if Stagger.Value ~= true and StunT.Value > Stun.Value then
          do
            if StaggerHit.Value == true then
              break
            end
            -- DECOMPILER ERROR at PC254: LeaveBlock: unexpected jumping out IF_THEN_STMT

            -- DECOMPILER ERROR at PC254: LeaveBlock: unexpected jumping out IF_STMT

          end
        end
      end
    end
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = 10
    so("199145327", RootPart, 1, 1)
    so("199145446", RootPart, 1, 1)
    Humanoid.Jump = true
    wing1.Parent = modelzorz
    wing1.Transparency = 1
    wing2.Parent = modelzorz
    wing2.Transparency = 1
    local wwld1 = weld(wing1, wing1, Torso, euler(1, -0.4, 0) * cf(-2, -1, 0.5))
    local wwld2 = weld(wing2, wing2, Torso, euler(1, 0.4, 0) * cf(2, -1, 0.5))
    for i = 0, 1, 0.1 do
      swait()
      wing1.Transparency = wing1.Transparency - 0.05
      wing2.Transparency = wing2.Transparency - 0.05
      if Rooted.Value == false then
        Torso.Velocity = vt(0, 1, 0) * 30
      end
      wwld1.C0 = clerp(wwld1.C0, euler(0, 0.5, 0) * cf(-3, -1, -1), 0.3)
      wwld2.C0 = clerp(wwld2.C0, euler(0, -0.5, 0) * cf(3, -1, -1), 0.3)
      handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
      wld1.C0 = clerp(wld1.C0, cf(0, 0.2, 0) * euler(0, 0, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.3)
      RootJoint.C0 = RootCF * cf(0, 0, -0.5 + 2.5 * i) * euler(0.1 + 6.28 * i, 0, 0)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 1.3), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -1.3) * euler(0, 0, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(1, -0.6, -0.2) * euler(0, 1.57, 0) * euler(-0.2, 0, -0.2), 0.3)
      LH.C0 = clerp(LH.C0, cf(-1, -0.6, -0.2) * euler(0, -1.57, 0) * euler(-0.2, 0, 0.2), 0.3)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC586: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC586: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    if Stagger.Value ~= true and StunT.Value > Stun.Value then
      if StaggerHit.Value ~= true then
        eul = euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
        MagniDamage(Torso, 30, 20, 34, math.random(50, 60), "Snare", Torso, 0, 1, (math.random(10, 15)), nil, nil, true, "Damage", 0.2, 300)
        MagniBuff(Torso, 30, "Defense", -0.3, 300, true)
        MagicCircle(BrickColor.new("Teal"), cf(Torso.Position) * euler(0, 0, 1.57), 1, 1, 1, 10, 10, 10, 0.03)
        MagicCircle(BrickColor.new("White"), cf(Torso.Position) * euler(0, 0, 1.57), 200, 200, 200, 1, 1, 1, 0.1)
        MagicRing(BrickColor.new("Teal"), cf(Torso.Position) * eul, 1, 1, 1, 2, 2, 0.1, 0.02)
        MagicRing(BrickColor.new("Teal"), cf(Torso.Position) * eul * euler(0, -1.57, 0), 1, 1, 1, 2, 2, 0.1, 0.02)
        so("200633455", Torso, 1, 0.6)
        for i = 0, 1, 0.02 do
          swait()
          Torso.Velocity = vt(0, 0, 0)
          if Stagger.Value ~= true and StunT.Value > Stun.Value then
            do
              if StaggerHit.Value == true then
                break
              end
              -- DECOMPILER ERROR at PC777: LeaveBlock: unexpected jumping out IF_THEN_STMT

              -- DECOMPILER ERROR at PC777: LeaveBlock: unexpected jumping out IF_STMT

            end
          end
        end
        dec.Parent = nil
        coroutine.resume(coroutine.create(function()
    for i = 0.5, 1, 0.05 do
      swait()
      wing1.Transparency = i
      wing2.Transparency = i
    end
    wing1.Parent = nil
    wing2.Parent = nil
    wwld1.Parent = nil
    wwld2.Parent = nil
  end))
        attack = false
      end
    end
  end
end
do4 = function()
  if attack == true then
    return 
  end
  if Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true then
    return 
  end
  if cooldownmax <= cooldowns[4] and mana.Value >= 50 then
    attack = true
    cooldowns[4] = 0
    mana.Value = mana.Value - 50
    local dec = Instance.new("NumberValue", Decrease)
    dec.Name = "DecreaseMvmt"
    dec.Value = 10
    for i = 0, 1, 0.1 do
      swait()
      handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
      wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0) * euler(0.3, 0, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, -0.4), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.3, 0, 0.4), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1.2, 0, 0.2) * euler(0, -1.3, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, RHC0, 0.2)
      LH.C0 = clerp(LH.C0, LHC0, 0.2)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC223: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC223: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    ref = part(3, workspace, 0, 0, BrickColor.new("Teal"), "Reference", vt())
    ref.Anchored = true
    ref.CFrame = cf(prt5.Position)
    local rmsh = mesh("SpecialMesh", ref, "Sphere", "nil", vt(0, 0, 0), vt(5, 5, 5))
    game:GetService("Debris"):AddItem(ref, 10)
    so("199145659", ref, 1, 0.6)
    for i = 0, 1, 0.15 do
      swait()
      ref.CFrame = cf(prt5.Position)
      MagicCircle(BrickColor.new("Teal"), cf(ref.Position) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 0.5, 5, 0.5, 0.05)
      handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.3)
      wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0) * euler(-1, 0, 0), 0.3)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.8), 0.3)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0.8), 0.3)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(1.2, 0, 0.5), 0.3)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-1, 0, -0.8) * euler(0, -0.5, 0), 0.3)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.3)
      RH.C0 = clerp(RH.C0, cf(0.8, -1, 0.4) * euler(0, 1.57, 0) * euler(0, -0.8, 0), 0.3)
      LH.C0 = clerp(LH.C0, cf(-0.8, -1, -0.4) * euler(0, -1.57, 0) * euler(0, -0.8, 0), 0.3)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC528: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC528: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    blcf = nil
    scfr = nil
    for i = 0, 1, 0.15 do
      swait()
      ref.CFrame = cf(prt5.Position)
      MagicCircle(BrickColor.new("Teal"), cf(ref.Position) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 0.5, 5, 0.5, 0.05)
      handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.4)
      wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0) * euler(1, 0, 0), 0.4)
      Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0.8), 0.4)
      RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, -0.8), 0.4)
      RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.5, 0, 0.2), 0.4)
      RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      LW.C0 = clerp(LW.C0, cf(-1.2, 0.5, -0.3) * euler(1, 0, -0.5) * euler(0, 0.5, 0), 0.4)
      LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
      RH.C0 = clerp(RH.C0, cf(0.8, -1, -0.4) * euler(0, 1.57, 0) * euler(0, 0.8, 0), 0.4)
      LH.C0 = clerp(LH.C0, cf(-0.8, -1, 0.4) * euler(0, -1.57, 0) * euler(0, 0.8, 0), 0.4)
      if Stagger.Value ~= true and StunT.Value > Stun.Value then
        do
          if StaggerHit.Value == true then
            break
          end
          -- DECOMPILER ERROR at PC785: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC785: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
    ref.CFrame = prt5.CFrame
    dec.Parent = nil
    attack = false
    for i = 0, 1, 0.02 do
      swait()
      MagicCircle(BrickColor.new("Teal"), cf(ref.Position) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 0.5, 5, 0.5, 0.05)
      ref.CFrame = ref.CFrame * cf(0, 0.5, 0)
    end
    so("199145534", ref, 1, 1)
    MagniDamage(ref, 10, 8, 15, math.random(50, 70), "Snare", ref, 2, 1, 100, nil, nil, false)
    MagicCircle(BrickColor.new("Teal"), cf(ref.Position) * euler(0, 0, 0), 10, 1, 10, -0.1, 6, -0.1, 0.01)
    MagicCircle(BrickColor.new("Teal"), cf(ref.Position) * euler(1.57, 0, 0), 10, 1, 10, -0.1, 6, -0.1, 0.01)
    MagicCircle(BrickColor.new("Teal"), cf(ref.Position) * euler(0, 0, 1.57), 10, 1, 10, -0.1, 6, -0.1, 0.01)
    MagicCircle(BrickColor.new("Teal"), cf(ref.Position) * euler(0, 0, 1.57), 1, 1, 1, 16, 16, 16, 0.04)
    ref.Transparency = 1
    swait(10)
    MagniDamage(ref, 30, 8, 15, math.random(50, 70), "Snare", RootPart, 2, 1, 100, nil, true, false, nil, nil, nil)
    swait(10)
    MagniDamage(ref, 40, 8, 15, math.random(50, 70), "Snare", RootPart, 2, 1, 100, nil, true, false, nil, nil, nil)
    ref.Parent = nil
    ref.Parent = nil
  end
end
DecreaseStat = function(Model, Stat, Amount, Duration)
  if Model:findFirstChild("Stats") ~= nil and Model.Stats[Stat] ~= nil then
    Model.Stats[Stat].Value = Model.Stats[Stat].Value - Amount
    d = Instance.new("NumberValue", Model.Stats.Decrease)
    dur = Instance.new("NumberValue", d)
    dur.Name = "Duration"
    dur.Value = Duration
    game:GetService("Debris"):AddItem(d, 20)
    if Stat == "Damage" then
      d.Name = "DecreaseAtk"
    else
      if Stat == "Defense" then
        d.Name = "DecreaseDef"
      else
        if Stat == "Movement" then
          d.Name = "DecreaseMvmt"
        end
      end
    end
    if Model:findFirstChild("Torso") ~= nil then
      display = ""
      if Stat == "Damage" then
        if Amount > 0 then
          display = "-Damage"
        else
          display = "+Damage"
        end
      else
        if Stat == "Defense" then
          if Amount > 0 then
            display = "-Defense"
          else
            display = "+Defense"
          end
        else
          if Stat == "Movement" then
            if Amount > 0 then
              display = "-Movement"
            else
              display = "+Movement"
            end
          end
        end
      end
      showDamage(Model, display, "Debuff")
    end
    d.Value = Amount
  end
end
GetDist = function(Part1, Part2, magni)
  local targ = Part1.Position - Part2.Position
  local mag = targ.magnitude
  if mag <= magni then
    return true
  else
    return false
  end
end
MagniDamage = function(Part, magni, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
  for _,c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = nil
      for _,d in pairs(c:children()) do
        if d.className == "Model" and ranged ~= true then
          head = d:findFirstChild("Hitbox")
          if d.Parent == Character then
            break
          end
          if head ~= nil then
            local targ = head.Position - Part.Position
            local mag = targ.magnitude
            if mag <= magni and c.Name ~= Player.Name then
              ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
              ref.Anchored = true
              ref.CFrame = cf(head.Position)
              game:GetService("Debris"):AddItem(ref, 1)
              hitnum = math.random(1, 5)
              if hitnum == 1 then
                so("199148971", ref, 1, 1)
              else
                if hitnum == 2 then
                  so("199149025", ref, 1, 1)
                else
                  if hitnum == 3 then
                    so("199149072", ref, 1, 1)
                  else
                    if hitnum == 4 then
                      so("199149109", ref, 1, 1)
                    else
                      if hitnum == 5 then
                        so("199149119", ref, 1, 1)
                      end
                    end
                  end
                end
              end
              StaggerHit.Value = true
            end
          end
        end
        do
          if d.className == "Part" then
            head = d
            if head ~= nil then
              local targ = head.Position - Part.Position
              local mag = targ.magnitude
              if mag <= magni and c.Name ~= Player.Name then
                if stun == nil then
                  stun = math.random(5, 10)
                end
                local Rang = nil
                if Ranged == false then
                  Rang = true
                end
                local stag = nil
                if shbash == true then
                  stag = true
                end
				if head.Parent:FindFirstChild("DebounceHit") == nil and attackdebounce == false then
                Damagefunc(head, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
end
end
            end
          end
          do
            -- DECOMPILER ERROR at PC183: LeaveBlock: unexpected jumping out DO_STMT

          end
        end
      end
    end
  end
end
MagniBuff = function(Part, magni, Dec, DecAm, Dur)
  if Player.Neutral == true then
    DecreaseStat(Character, Dec, DecAm / 2, Dur)
  end
  for _,c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        cando = true
        if mag <= magni then
          if Player.Neutral == false then
            if game.Players:GetPlayerFromCharacter(head.Parent) ~= nil then
              if game.Players:GetPlayerFromCharacter(head.Parent).TeamColor == Player.TeamColor then
                cando = true
              else
                cando = false
              end
            else
              cando = false
            end
            if head.Parent:findFirstChild("Alignment") ~= nil and head.Parent.Alignment.Value == Player.TeamColor.Color then
              cando = true
            end
          else
            cando = false
          end
          if cando == true then
            DecreaseStat(head.Parent, Dec, DecAm, Dur)
          end
        end
      end
    end
  end
end
MagniHeal = function(Part, magni, mindam, maxdam)
  for _,c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        local cando = true
        if mag <= magni then
          if Player.Neutral == false then
            if game.Players:GetPlayerFromCharacter(head.Parent) ~= nil then
              if game.Players:GetPlayerFromCharacter(head.Parent).TeamColor == Player.TeamColor then
                cando = true
              else
                cando = false
              end
            else
              cando = false
            end
            if head.Parent:findFirstChild("Alignment") ~= nil and head.Parent.Alignment.Value == Player.TeamColor.Color then
              cando = true
            end
          else
            cando = false
          end
          if cando == true then
            Heal = math.random(mindam, maxdam)
            if c.Parent == Character then
              Heal = math.floor(math.random(mindam / 2, maxdam / 2))
            end
            hum.Health = hum.Health + Heal
            showDamage(c, Heal, "Heal")
          end
        end
      end
    end
  end
end
rayCast = function(Pos, Dir, Max, Ignore)
  return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
end
local Point = Torso.CFrame * cf(0, Torso.Size.Y, 0)
LastPoint = Point
effect = function(Color, Ref, LP, P1, returnn)
  if LP == nil or P1 == nil then
    return 
  end
  local effectsmsh = Instance.new("CylinderMesh")
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  effectsmsh.Name = "Mesh"
  local effectsg = Instance.new("Part")
  NoOutline(effectsg)
  effectsg.formFactor = 3
  effectsg.CanCollide = false
  effectsg.Name = "Eff"
  effectsg.Locked = true
  effectsg.Anchored = true
  effectsg.Size = Vector3.new(0.5, 1, 0.5)
  effectsg.Parent = workspace
  effectsmsh.Parent = effectsg
  effectsg.BrickColor = BrickColor.new(Color)
  effectsg.Reflectance = Ref
  local point1 = P1
  local mg = (LP.p - point1.p).magnitude
  effectsg.Size = Vector3.new(0.5, mg, 0.5)
  effectsg.CFrame = cf((LP.p + point1.p) / 2, point1.p) * CFrame.Angles(math.rad(90), 0, 0)
  effectsmsh.Scale = Vector3.new(0.2, 1, 0.2)
  game:GetService("Debris"):AddItem(effectsg, 2)
  if returnn then
    return effectsg
  end
  if not returnn then
    table.insert(Effects, {effectsg, "Cylinder", 0.2, 0.01, 0, 0.01, effectsmsh})
  end
end
local CFrameFromTopBack = function(at, top, back)
  local right = top:Cross(back)
  return CFrame.new(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end
Triangle = function(a, b, c)
  local edg1 = c - a:Dot(b - a.unit)
  local edg2 = a - b:Dot(c - b.unit)
  local edg3 = b - c:Dot(a - c.unit)
  if edg1 <= b - a.magnitude and edg1 >= 0 then
    a = a
  else
    -- DECOMPILER ERROR at PC35: Overwrote pending register: R1 in 'AssignReg'

    if edg2 <= c - b.magnitude and edg2 >= 0 then
      a = b
    else
      -- DECOMPILER ERROR at PC46: Overwrote pending register: R2 in 'AssignReg'

      -- DECOMPILER ERROR at PC47: Overwrote pending register: R1 in 'AssignReg'

      if edg3 <= a - c.magnitude and edg3 >= 0 then
        a = c
      else
        assert(false, "unreachable")
      end
    end
  end
  local len1 = c - a:Dot(b - a.unit)
  local len2 = b - a.magnitude - len1
  local width = a + b - a.unit * len1 - c.magnitude
  local maincf = CFrameFromTopBack(a, b - a:Cross(c - b).unit, -b - a.unit)
  local list = {}
  if len1 > 0.01 then
    local w1 = Instance.new("WedgePart", m)
    w1.Name = "Triangle"
    game:GetService("Debris"):AddItem(w1, 5)
    w1.Material = "SmoothPlastic"
    w1.FormFactor = "Custom"
    w1.BrickColor = BrickColor.new("Teal")
    w1.Transparency = 0
    w1.Reflectance = 0
    w1.Material = "SmoothPlastic"
    w1.CanCollide = false
    NoOutline(w1)
    local sz = Vector3.new(0.2, width, len1)
    w1.Size = sz
    local sp = Instance.new("SpecialMesh", w1)
    sp.MeshType = "Wedge"
    sp.Scale = Vector3.new(0, 1, 1) * sz / w1.Size
    w1:BreakJoints()
    w1.Anchored = true
    w1.Parent = workspace
    w1.Transparency = 0.7
    table.insert(Effects, {w1, "Disappear", 0.05})
    w1.CFrame = maincf * CFrame.Angles(math.pi, 0, math.pi / 2) * CFrame.new(0, width / 2, len1 / 2)
    table.insert(list, w1)
  end
  do
    if len2 > 0.01 then
      local w2 = Instance.new("WedgePart", m)
      w2.Name = "Triangle"
      game:GetService("Debris"):AddItem(w2, 5)
      w2.Material = "SmoothPlastic"
      w2.FormFactor = "Custom"
      w2.BrickColor = BrickColor.new("Teal")
      w2.Transparency = 0
      w2.Reflectance = 0
      w2.Material = "SmoothPlastic"
      w2.CanCollide = false
      NoOutline(w2)
      local sz = Vector3.new(0.2, width, len2)
      w2.Size = sz
      local sp = Instance.new("SpecialMesh", w2)
      sp.MeshType = "Wedge"
      sp.Scale = Vector3.new(0, 1, 1) * sz / w2.Size
      w2:BreakJoints()
      w2.Anchored = true
      w2.Parent = workspace
      w2.Transparency = 0.7
      table.insert(Effects, {w2, "Disappear", 0.05})
      w2.CFrame = maincf * CFrame.Angles(math.pi, math.pi, -math.pi / 2) * CFrame.new(0, width / 2, -len1 - len2 / 2)
      table.insert(list, w2)
    end
    do
      return unpack(list)
    end
  end
end
MagicBlock = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  if Type == 1 or Type == nil then
    table.insert(Effects, {prt, "Block1", delay, x3, y3, z3, msh})
  else
    if Type == 2 then
      table.insert(Effects, {prt, "Block2", delay, x3, y3, z3, msh})
    end
  end
end
MagicCircle = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicCircle2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder2", delay, x3, y3, z3, msh})
end
MagicCylinder = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicHead = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "Head", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
ClangEffect = function(brickcolor, cframe, duration, decrease, size, power)
  local prt = part(3, workspace, 0, 1, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(5, 5, 5))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "CylinderClang", duration, decrease, size, power, prt.CFrame, nil})
end
MagicWave = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  local msh = mesh("SpecialMesh", prt, "FileMesh", "20329976", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicRing = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
  local prt = part(3, workspace, 0, 0, brickcolor, "Effect", vt(0.5, 0.5, 0.5))
  prt.Anchored = true
  prt.CFrame = cframe * cf(x2, y2, z2)
  local msh = mesh("SpecialMesh", prt, "FileMesh", "3270017", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3, msh})
end
MagicOrb = function(brickcolor, cframe, x1, y1, z1)
  local prt = part(3, workspace, 0, 0.5, brickcolor, "Effect", vt())
  prt.Anchored = true
  prt.CFrame = cframe
  so("153092315", prt, 1, 1)
  local msh = mesh("SpecialMesh", prt, "Sphere", "nil", vt(0, 0, 0), vt(x1, y1, z1))
  game:GetService("Debris"):AddItem(prt, 10)
  table.insert(Effects, {prt, "Orb", msh, 30})
end
Damagefunc = function(hit, minim, maxim, knockback, Type, Property, Delay, KnockbackType, incstun, stagger, staghit, ranged, DecreaseState, DecreaseAmount, Duration)
  if hit.Parent == nil then
    return 
  end
  if blessbuff == true and hit.Name ~= "Hitbox" and hit.Name ~= "Hitbox2" and hit.Name ~= "Effect" and hit.Name ~= "Triangle" and hit.Name ~= "Reference" and hit.Parent ~= modelzorz and hit.Parent ~= Character and ranged ~= true and hit.Parent:findFirstChild("BlessDebounce") == nil then
    blessing = blessing - 5
    MagicOrb(BrickColor.new("White"), prt5.CFrame * cf(0, 2.5, 0), 5, 5, 5)
    debounce = Instance.new("BoolValue")
    debounce.Name = "BlessDebounce"
    debounce.Parent = hit.Parent
    debounce.Value = true
    game:GetService("Debris"):AddItem(debounce, 0.5)
  end
  if hit.Name == "Hitbox" and hit.Parent ~= modelzorz and ranged ~= true then
    ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
    ref.Anchored = true
    ref.CFrame = cf(hit.Position)
    game:GetService("Debris"):AddItem(ref, 1)
    hitnum = math.random(1, 5)
    if hitnum == 1 then
      so("199148971", ref, 1, 1)
    else
      if hitnum == 2 then
        so("199149025", ref, 1, 1)
      else
        if hitnum == 3 then
          so("199149072", ref, 1, 1)
        else
          if hitnum == 4 then
            so("199149109", ref, 1, 1)
          else
            if hitnum == 5 then
              so("199149119", ref, 1, 1)
            end
          end
        end
      end
    end
    StaggerHit.Value = true
  end
  h = hit.Parent:FindFirstChild("Humanoid")
  if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
    if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
      return 
    end
    if Player.Neutral == false then
      if hit.Parent:findFirstChild("Alignment") ~= nil and hit.Parent.Alignment.Value == Player.TeamColor.Color then
        return 
      end
      if game.Players:GetPlayerFromCharacter(hit.Parent) ~= nil and game.Players:GetPlayerFromCharacter(hit.Parent).TeamColor == Player.TeamColor then
        return 
      end
    end
    c = Instance.new("ObjectValue")
    c.Name = "creator"
    c.Value = game:service("Players").LocalPlayer
    c.Parent = h
    RecentEnemy.Value = hit.Parent
    game:GetService("Debris"):AddItem(c, 0.5)
    minim = minim * Atk.Value
    maxim = maxim * Atk.Value
    Damage = 0
    if minim == maxim then
      Damage = maxim
    else
      Damage = math.random(minim, maxim)
    end
    blocked = false
    enblock = nil
    Stats = hit.Parent:findFirstChild("Stats")
    if Stats ~= nil then
      invis = Stats:findFirstChild("Invisibility")
      isinvis = Stats:findFirstChild("IsInvisible")
      if (ranged == false or ranged == nil) and invis ~= nil and isinvis.Value == true then
        invis.Value = 0
      end
      enblock = Stats:findFirstChild("Block")
      if enblock ~= nil and enblock.Value == true then
        blocked = true
      end
      if Stats:findFirstChild("Defense") ~= nil then
        Damage = Damage / Stats.Defense.Value
        if Damage <= 3 and (ranged == false or ranged == nil) and blocked ~= true then
          hitnum = math.random(1, 5)
          if hitnum == 1 then
            so("199149321", hit, 1, 1)
          else
            if hitnum == 2 then
              so("199149338", hit, 1, 1)
            else
              if hitnum == 3 then
                so("199149367", hit, 1, 1)
              else
                if hitnum == 4 then
                  so("199149409", hit, 1, 1)
                else
                  if hitnum == 5 then
                    so("199149452", hit, 1, 1)
                  end
                end
              end
            end
          end
        else
          if ranged == false or ranged == nil and blocked ~= true then
            hitnum = math.random(1, 6)
            if hitnum == 1 then
              so("199149137", hit, 1, 1)
            else
              if hitnum == 2 then
                so("199149186", hit, 1, 1)
              else
                if hitnum == 3 then
                  so("199149221", hit, 1, 1)
                else
                  if hitnum == 4 then
                    so("199149235", hit, 1, 1)
                  else
                    if hitnum == 5 then
                      so("199149269", hit, 1, 1)
                    else
                      if hitnum == 6 then
                        so("199149297", hit, 1, 1)
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if Damage <= 3 and staghit == true and ranged ~= true then
          StaggerHit.Value = true
        end
      end
      if Stats:findFirstChild("Stun") ~= nil then
        if blocked == true then
          incstun = incstun / 2
        end
        if Stats.Stun.Value < Stats.StunThreshold.Value then
          Stats.Stun.Value = Stats.Stun.Value + incstun
        end
      end
      if Stats:findFirstChild("Stagger") ~= nil and stagger == true then
        Stats.Stagger.Value = true
      end
    end
    if blocked == true then
      showDamage(hit.Parent, "Block", "Damage")
      if ranged ~= true then
        enblock.Value = false
        Stagger.Value = true
        hitnum = math.random(1, 2)
        if hitnum == 1 then
          so("199148933", hit, 1, 1)
        else
          if hitnum == 2 then
            so("199148947", hit, 1, 1)
          end
        end
      end
    else
      Damage = math.floor(Damage)
      coroutine.resume(coroutine.create(function(Hum, Dam)
	if Hum.Parent:FindFirstChild("DebounceHit") == nil and attackdebounce == false then
		attackdebounce = true
    Hum:TakeDamage(Damage)
wait(0.5)
attackdebounce = false
end
  end), h, Damage)
      showDamage(hit.Parent, Damage, "Damage")
      if DecreaseState ~= nil then
        DecreaseStat(hit.Parent, DecreaseState, DecreaseAmount, Duration)
      end
      if Type == "NormalDecreaseMvmt1" then
        DecreaseStat(hit.Parent, "Movement", 0.1, 200)
      end
      if Type == "Knockdown" then
        hum = hit.Parent.Humanoid
        hum.PlatformStand = true
        coroutine.resume(coroutine.create(function(HHumanoid)
    swait(1)
    HHumanoid.PlatformStand = false
  end), hum)
        local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
        local bodvol = Instance.new("BodyVelocity")
        bodvol.velocity = angle * knockback
        bodvol.P = 5000
        bodvol.maxForce = Vector3.new(8000, 8000, 8000)
        bodvol.Parent = hit
        rl = Instance.new("BodyAngularVelocity")
        rl.P = 3000
        rl.maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000
        rl.angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10))
        rl.Parent = hit
        game:GetService("Debris"):AddItem(bodvol, 0.2)
        game:GetService("Debris"):AddItem(rl, 0.2)
      else
        do
          if Type == "Knockdown2" then
            hum = hit.Parent.Humanoid
            local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
            local bodvol = Instance.new("BodyVelocity")
            bodvol.velocity = angle * knockback
            bodvol.P = 5000
            bodvol.maxForce = Vector3.new(8000, 8000, 8000)
            bodvol.Parent = hit
            game:GetService("Debris"):AddItem(bodvol, 0.2)
          else
            do
              if Type == "Normal" or Type == "NormalDecreaseMvmt1" then
                vp = Instance.new("BodyVelocity")
                vp.P = 500
                vp.maxForce = Vector3.new(math.huge, 0, math.huge)
                if KnockbackType == 1 then
                  vp.velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
                else
                  if KnockbackType == 2 then
                    vp.velocity = Property.CFrame.lookVector * knockback
                  end
                end
                game:GetService("Debris"):AddItem(vp, 0.2)
                if knockback > 0 then
                  vp.Parent = hit.Parent.Torso
                end
              end
              debounce = Instance.new("BoolValue")
              debounce.Name = "DebounceHit"
              debounce.Parent = hit.Parent
              debounce.Value = true
              game:GetService("Debris"):AddItem(debounce, Delay)
              c = Instance.new("ObjectValue")
              c.Name = "creator"
              c.Value = Player
              c.Parent = h
              game:GetService("Debris"):AddItem(c, 0.5)
              CRIT = false
            end
          end
        end
      end
    end
  end
end
showDamage = function(Char, Dealt, Type)
  m = Instance.new("Model")
  m.Name = "Effect"
  c = Instance.new("Part")
  c.Transparency = 1
  c.Name = "Head"
  c.TopSurface = 0
  c.BottomSurface = 0
  c.formFactor = "Plate"
  c.Size = Vector3.new(1, 0.4, 1)
  b = Instance.new("BillboardGui", c)
  b.Size = UDim2.new(5, 0, 5, 0)
  b.AlwaysOnTop = true
  damgui = gui("TextLabel", b, tostring(Dealt), 1, Color3.new(0, 0, 0), UDim2.new(0, 0, 0, 0), UDim2.new(1, 0, 1, 0))
  if Type == "Damage" then
    damgui.Font = "SourceSans"
    if Dealt == "Block" then
      damgui.TextColor3 = BrickColor.new("Bright blue").Color
    else
      if Dealt < 3 then
        damgui.TextColor3 = BrickColor.new("White").Color
      else
        if Dealt >= 3 and Dealt < 20 then
          damgui.TextColor3 = BrickColor.new("Bright yellow").Color
        else
          damgui.TextColor3 = BrickColor.new("Really red").Color
          damgui.Font = "SourceSansBold"
        end
      end
    end
  else
    if Type == "Debuff" then
      damgui.TextColor3 = BrickColor.new("White").Color
    else
      if Type == "Interrupt" then
        damgui.TextColor3 = BrickColor.new("New Yeller").Color
      end
    end
  end
  damgui.TextScaled = true
  ms = Instance.new("CylinderMesh")
  ms.Scale = Vector3.new(0.8, 0.8, 0.8)
  ms.Parent = c
  c.Reflectance = 0
  Instance.new("BodyGyro").Parent = c
  c.Parent = m
  if Char:findFirstChild("Head") ~= nil then
    c.CFrame = cf(Char.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
  else
    if Char.Parent:findFirstChild("Head") ~= nil then
      c.CFrame = cf(Char.Parent.Head.CFrame.p + Vector3.new(math.random(-100, 100) / 100, 3, math.random(-100, 100) / 100))
    end
  end
  f = Instance.new("BodyPosition")
  f.P = 2000
  f.D = 100
  f.maxForce = Vector3.new(545000, 545000, 545000)
  if Type == "Damage" then
    f.position = c.Position + Vector3.new(0, 3, 0)
  else
    if Type == "Debuff" or Type == "Interrupt" then
      f.position = c.Position + Vector3.new(0, 5, 0)
    end
  end
  f.Parent = c
  game:GetService("Debris"):AddItem(m, 5)
  table.insert(Effects, {m, "showDamage", damgui, f, 10, 1, 15, 50, 100})
  c.CanCollide = false
  m.Parent = workspace
  c.CanCollide = false
end
combo = 0
ob1d = function(mouse)
  if GuardStance == true and MMouse.Target ~= nil then
    if game.Players:GetPlayerFromCharacter(MMouse.Target.Parent) ~= nil and game.Players:GetPlayerFromCharacter(MMouse.Target.Parent).TeamColor == Player.TeamColor and Player.Neutral == false and MMouse.Target.Parent.Parent:findFirstChild("Humanoid") ~= nil and MMouse.Target.Parent.Parent:findFirstChild("Torso") ~= nil then
      Target = MMouse.Target.Parent.Parent
      GuardStance = false
    end
    if game.Players:GetPlayerFromCharacter(MMouse.Target.Parent) ~= nil and game.Players:GetPlayerFromCharacter(MMouse.Target.Parent).TeamColor == Player.TeamColor and Player.Neutral == false and MMouse.Target.Parent:findFirstChild("Humanoid") ~= nil and MMouse.Target.Parent:findFirstChild("Torso") ~= nil then
      Target = MMouse.Target.Parent
      GuardStance = false
    end
  end
  if attack == true or equipped == false then
    return 
  end
  hold = true
  if Mode == "Defensive" then
    if combo == 0 then
      combo = 1
      dattackone()
    else
      if combo == 1 then
        combo = 2
        dattacktwo()
      else
        if combo == 2 then
          combo = 3
          dattackthree()
        else
          if combo == 3 then
            combo = 0
            dattackfour()
          end
        end
      end
    end
  else
    if combo == 0 then
      combo = 1
      oattackone()
    else
      if combo == 1 then
        combo = 2
        oattacktwo()
      else
        if combo == 2 then
          combo = 3
          oattackthree()
        else
          if combo == 3 then
            combo = 0
            oattackfour()
          end
        end
      end
    end
  end
  coroutine.resume(coroutine.create(function()
    for i = 1, 50 do
      if attack == false then
        swait()
      end
    end
    if attack == false then
      combo = 0
    end
  end))
end
ob1u = function(mouse)
  hold = false
end
buttonhold = false
fenbarmove1.MouseButton1Click:connect(do1)
fenbarmove2.MouseButton1Click:connect(do2)
fenbarmove3.MouseButton1Click:connect(do3)
fenbarmove4.MouseButton1Click:connect(do4)
eul = 0
equipped = false
key = function(key)
  if key == "x" and Fly == true then
    Fly = false
    Target = nil
  end
  if key == string.char(8) and Fly == true then
    Fly = false
    Target = nil
  end
  if key == "x" and GuardStance == true then
    manualguardend = true
    GuardStance = false
  end
  if attack == true then
    return 
  end
  if key == "f" then
    pressedf = true
    fnumb = 0
    attack = true
    if equipped == false then
      equipped = true
      RSH = ch.Torso["Right Shoulder"]
      LSH = ch.Torso["Left Shoulder"]
      RSH.Parent = nil
      LSH.Parent = nil
      RW.Name = "Right Shoulder"
      RW.Part0 = ch.Torso
      RW.C0 = cf(1.5, 0.5, 0)
      RW.C1 = cf(0, 0.5, 0)
      RW.Part1 = ch["Right Arm"]
      RW.Parent = ch.Torso
      LW.Name = "Left Shoulder"
      LW.Part0 = ch.Torso
      LW.C0 = cf(-1.5, 0.5, 0)
      LW.C1 = cf(0, 0.5, 0)
      LW.Part1 = ch["Left Arm"]
      LW.Parent = ch.Torso
      Animate.Parent = nil
      equipanim()
    else
      equipped = false
      hideanim()
      LH.C1 = LHC1
      RH.C1 = RHC1
      Animate.Parent = Humanoid
      swait(0)
      RW.Parent = nil
      LW.Parent = nil
      RSH.Parent = player.Character.Torso
      LSH.Parent = player.Character.Torso
    end
    attack = false
  end
  if equipped == false then
    return 
  end
  if key == "e" then
    GuardiaBlessing()
  end
  if key == "z" then
    do1()
  end
  if key == "x" then
    do2()
  end
  if key == "c" then
    do3()
  end
  if key == "v" then
    do4()
  end
  -- DECOMPILER ERROR at PC183: Unhandled construct in 'MakeBoolean' P1

  if key ~= "h" or attack == false then
    RecentEnemy.Value = nil
  end
end
key2 = function(key)
end
s = function(mouse)
  mouse.Button1Down:connect(function()
    ob1d(mouse)
  end)
  mouse.Button1Up:connect(function()
    ob1u(mouse)
  end)
  mouse.KeyDown:connect(key)
  mouse.KeyUp:connect(key2)
  player = Player
  ch = Character
  MMouse = mouse
end
ds = function(mouse)
end
Bin.Selected:connect(s)
Bin.Deselected:connect(ds)
print("Commander loaded.")
con1 = hitbox.Touched:connect(function(hit)
  if attack == true and blessbuff == true and hit.Name ~= "Hitbox" and hit.Name ~= "Hitbox2" and hit.Name ~= "Effect" and hit.Name ~= "Triangle" and hit.Name ~= "Reference" and hit.Parent ~= modelzorz and hit.Parent ~= Character and ranged ~= true and hit.Parent:findFirstChild("BlessDebounce") == nil then
    blessing = blessing - 5
    MagicOrb(BrickColor.new("White"), prt5.CFrame * cf(0, 2.5, 0), 5, 5, 5)
    debounce = Instance.new("BoolValue")
    debounce.Name = "BlessDebounce"
    debounce.Parent = hit.Parent
    debounce.Value = true
    game:GetService("Debris"):AddItem(debounce, 0.5)
  end
end)
local mananum = 0
local donum = 0
local stunnum = 0
local staggeranim = false
local stunanim = false
local passivenum = 0
local walk = 0
local walkforw = true
local blessnum = 0
while 1 do
  swait()
  if Humanoid.Health <= 0 then
    attack = true
    resumeControl()
    modelzorz.Parent = workspace
    game:GetService("Debris"):AddItem(modelzorz, 30)
    for i = 1, #Weapon do
      Weapon[i].Parent = modelzorz
      Weapon[i].CanCollide = true
    end
    for i = 1, #Welds do
      if Welds[i].Part0.Parent == Character or Welds[i].Part1.Parent == Character then
        Welds[i].Parent = nil
      else
        Welds[i].Parent = prt1
      end
    end
  end
  do
    if fnumb < 21 then
      fnumb = fnumb + 1
      if pressedf == false then
        fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency - 0.025
        tellbar.TextTransparency = tellbar.TextTransparency - 0.05
        tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency - 0.05
      else
        if fnumb == 20 then
          fenframe5.Parent = nil
          print("daigui")
        end
        fenframe5.BackgroundTransparency = fenframe5.BackgroundTransparency + 0.025
        tellbar.TextTransparency = tellbar.TextTransparency + 0.05
        tellbar.TextStrokeTransparency = tellbar.TextStrokeTransparency + 0.05
      end
    end
    if hbwld.Parent == nil then
      hitbox2.Name = "Hitbox"
    else
      hitbox2.Name = "Hitbox2"
    end
    hitbox2.Parent = hitbox.Parent
    hitbox2.Size = hitbox.Size
    hitbox2.CFrame = hitboxCF
    hboxpos.position = hitbox2.Position + vt(math.random(-20, 20) / 100, math.random(-100, 100) / 100, math.random(-100, 100) / 100)
    if blessing <= 0 then
      blessbuff = false
      blessing = 0
    end
    if 5 <= blessnum then
      if blessbuff == false then
        if 100 <= blessing then
          blessing = 100
        else
          blessing = blessing + 1
        end
      else
        MagicCircle2(BrickColor.new("White"), prt5.CFrame * cf(math.random(-100, 100) / 100, 2.8 + math.random(-200, 200) / 100, math.random(-100, 100) / 100), 0, 0, 0, 0.5, 0.5, 0.5, 0.1)
      end
      blessnum = 0
    end
    blessnum = blessnum + 1
    if 300 <= passivenum then
      passivenum = 0
      Max = Humanoid.MaxHealth
      Cur = Humanoid.Health
      Val = ((Max - Cur) / 250 + 1) * (Max / Cur * (Cur / 100))
      Val = Val - 1
      print(Val)
      if 0 < Val then
        if Mode == "Defensive" then

        else

        end
      end
    else
      passivenum = passivenum + 1
    end
    if Stagger.Value == true and staggeranim == false then
      coroutine.resume(coroutine.create(function()
  staggeranim = true
  while attack == true do
    swait()
  end
  StaggerAnim()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end))
    end
    if StaggerHit.Value == true and staggeranim == false then
      coroutine.resume(coroutine.create(function()
  staggeranim = true
  while attack == true do
    swait()
  end
  StaggerHitt()
  StaggerHit.Value = false
  Stagger.Value = false
  staggeranim = false
end))
    end
    if Mvmt.Value < 0 or Stagger.Value == true or StunT.Value <= Stun.Value or StaggerHit.Value == true or Rooted.Value == true then
      Humanoid.WalkSpeed = 0
    else
      Humanoid.WalkSpeed = 16 * Mvmt.Value
    end
    if StunT.Value <= Stun.Value and stunanim == false then
      coroutine.resume(coroutine.create(function()
  stunanim = true
  while attack == true do
    swait()
  end
  StunAnim()
  Stun.Value = 0
  stunanim = false
end))
    end
    local stunnum2 = 20
    if Mode == "Defensive" then
      stunnum2 = 20
    else
      stunnum2 = 60
    end
    if stunnum2 <= stunnum then
      if 0 < Stun.Value then
        Stun.Value = Stun.Value - 1
      end
      stunnum = 0
    end
    stunnum = stunnum + 1
    if 0.5 <= donum then
      handidle = true
    else
      if donum <= 0 then
        handidle = false
      end
    end
    if handidle == false then
      donum = donum + 0.003
    else
      donum = donum - 0.003
    end
    local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
    local velderp = RootPart.Velocity.y
    hitfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
    if equipped == true then
      if attack == false then
        idle = idle + 1
      else
        idle = 0
      end
      if (500 <= idle and attack ~= false) or Anim == "Walk" then
        if walkforw == true then
          RH.C1 = clerp(RH.C1, RHC1 * cf(0.2, -0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
          LH.C1 = clerp(LH.C1, LHC1 * cf(0.1, 0.2, 0) * euler(0, 0, 1), Mvmt.Value * 10 / 50)
        else
          RH.C1 = clerp(RH.C1, RHC1 * cf(-0.1, 0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
          LH.C1 = clerp(LH.C1, LHC1 * cf(-0.2, -0.2, 0) * euler(0, 0, -1), Mvmt.Value * 10 / 50)
        end
      else
        RH.C1 = clerp(RH.C1, RHC1, 0.2)
        LH.C1 = clerp(LH.C1, LHC1, 0.2)
      end
      if 1 < RootPart.Velocity.y and hitfloor == nil then
        Anim = "Jump"
        if attack == false then
          handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
          wld1.C0 = clerp(wld1.C0, cf(0, 0, 0), 0.2)
          Neck.C0 = clerp(Neck.C0, necko * euler(-0.2, 0, 0), 0.2)
          Neck.C1 = clerp(Neck.C1, necko2 * euler(0, 0, 0), 0.2)
          RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
          RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.4, 0, 0.2), 0.2)
          RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
          LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.4, 0, -0.2), 0.2)
          LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
          RH.C0 = clerp(RH.C0, cf(1, -1, -0.3) * euler(-0.5, 1.57, 0) * euler(-0.2, 0, 0), 0.2)
          LH.C0 = clerp(LH.C0, cf(-1, -1, -0.3) * euler(-0.5, -1.57, 0) * euler(-0.2, 0, 0), 0.2)
        end
      else
        if RootPart.Velocity.y < -1 and hitfloor == nil then
          Anim = "Fall"
          if attack == false then
            handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
            wld1.C0 = clerp(wld1.C0, cf(0, 0, 0), 0.2)
            Neck.C0 = clerp(Neck.C0, necko * euler(0.4, 0, 0), 0.2)
            Neck.C1 = clerp(Neck.C1, necko2 * euler(0, 0, 0), 0.2)
            RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.2)
            RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(-0.2, 0, 0.8), 0.2)
            RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
            LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.8), 0.2)
            LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
            RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0.4, 1.57, 0), 0.2)
            LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(-0.2, -1.57, 0), 0.2)
          end
        else
          if torvel < 1 and hitfloor ~= nil then
            Anim = "Idle"
            if attack == false then
              if Mode == "Defensive" then
                handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.15)
                wld1.C0 = clerp(wld1.C0, cf(0, -0.5, 0) * euler(-0.57, 0, 0), 0.15)
                Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, 0), 0.15)
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0, 0, 0), 0.15)
                RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0, 0, 0.2 + (donum) / 3), 0.15)
                RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.15)
                LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(1, 0, 0 - (donum) / 2) * euler(0, 0 + (donum) / 1.5, 0), 0.15)
                LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.15)
                RH.C0 = clerp(RH.C0, RHC0, 0.2)
                LH.C0 = clerp(LH.C0, LHC0, 0.2)
              else
                handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
                wld1.C0 = clerp(wld1.C0, cf(0, 1, 0) * euler(-0.2, 0, 0), 0.2)
                Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -0.5), 0.2)
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.1, 0, 0.5), 0.2)
                RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * euler(0.5 - (donum) / 2, 0, 0.5 - (donum) / 2), 0.2)
                RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.4 + (donum) / 2), 0.2)
                LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                RH.C0 = clerp(RH.C0, cf(1, -1, 0) * euler(0, 1.57, 0) * euler(0, -0.5, 0), 0.2)
                LH.C0 = clerp(LH.C0, cf(-1, -1, 0) * euler(0, -1.57, 0) * euler(0, -0.5, 0), 0.2)
              end
            end
          else
            if 2 < torvel and torvel < 30 and hitfloor ~= nil then
              Anim = "Walk"
              walk = walk + 1
              if 15 - 5 * Mvmt.Value <= walk then
                walk = 0
                if walkforw == true then
                  walkforw = false
                else
                  if walkforw == false then
                    walkforw = true
                  end
                end
              end
              if attack == false then
                handlewld.C0 = clerp(handlewld.C0, euler(1.57, 0, 0) * cf(0, 1, 0), 0.2)
                wld1.C0 = clerp(wld1.C0, cf(0, 1.5, 0), 0.2)
                Neck.C0 = clerp(Neck.C0, necko * euler(0, 0, -1), 0.2)
                RootJoint.C0 = clerp(RootJoint.C0, RootCF * euler(0.1, 0, 1), 0.2)
                RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.57, 0, -1), 0.2)
                RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * euler(-0.2, 0, -0.2), 0.2)
                LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.2)
                RH.C0 = clerp(RH.C0, cf(0.6, -1, 0.5) * euler(0, 1.57, 0) * euler(0, -1, -0.2), 0.2)
                LH.C0 = clerp(LH.C0, cf(-0.6, -1, -0.5) * euler(0, -1.57, 0) * euler(0, -1, -0.2), 0.2)
              end
            else
              if 30 <= torvel and hitfloor ~= nil then
                Anim = "Run"
                if attack == false then
                  handlewld.C0 = clerp(handlewld.C0, euler(-1.57, 0, 0) * cf(0, 1, 0), 0.4)
                  wld1.C0 = clerp(wld1.C0, cf(0, 1.5, 0), 0.4)
                  Neck.C0 = clerp(Neck.C0, necko * euler(0.2, 0, 0), 0.4)
                  RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.5) * euler(0.3, 0, 0), 0.4)
                  RW.C0 = clerp(RW.C0, cf(1, 0.5, -0.5) * euler(1.87, 0, -0.8) * euler(0, 0, 0), 0.4)
                  RW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
                  LW.C0 = clerp(LW.C0, cf(-1, 0.5, -0.5) * euler(1.87, 0, 0.8) * euler(0, 0, 0), 0.4)
                  LW.C1 = clerp(LW.C1, cf(0, 0.5, 0) * euler(0, 0, 0), 0.4)
                  RH.C0 = clerp(RH.C0, cf(1, -0.7, 0) * euler(0, 1.57, 0) * euler(-0.2, 0, 0.2), 0.4)
                  LH.C0 = clerp(LH.C0, cf(-1, -0.7, 0) * euler(0, -1.57, 0) * euler(-0.2, 0, -0.2), 0.4)
                end
              end
            end
          end
        end
      end
    end
    if 0 < #Effects then
      for e = 1, #Effects do
        if Effects[e] ~= nil then
          local Thing = Effects[e]
          if Thing ~= nil then
            local Part = Thing[1]
            local Mode = Thing[2]
            local Delay = Thing[3]
            local IncX = Thing[4]
            local IncY = Thing[5]
            local IncZ = Thing[6]
            if Thing[2] == "CylinderClang" then
              if Thing[3] <= 1 then
                Thing[1].CFrame = Thing[1].CFrame * CFrame.new(0, 2.5 * Thing[5], 0) * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
                Thing[7] = Thing[1].CFrame
                effect("New Yeller", 0, Thing[8], Thing[7])
                Thing[8] = Thing[7]
                Thing[3] = Thing[3] + Thing[4]
              else
                Part.Parent = nil
                table.remove(Effects, e)
              end
            end
            if Thing[2] == "showDamage" then
              if Thing[6] < Thing[5] then
                Thing[6] = Thing[6] + 1
              else
                if Thing[6] < Thing[7] then
                  Thing[4].position = Thing[4].position + vt(0, -0.2, 0)
                  Thing[6] = Thing[6] + 1
                else
                  if Thing[6] < Thing[8] then
                    Thing[6] = Thing[6] + 1
                  else
                    if Thing[6] < Thing[9] then
                      Thing[6] = Thing[6] + 1
                      Thing[4].position = Thing[4].position + vt(0, 0.2, 0)
                      Thing[3].TextStrokeTransparency = Thing[3].TextStrokeTransparency + 0.1
                      Thing[3].TextTransparency = Thing[3].TextTransparency + 0.1
                    else
                      Thing[1].Parent = nil
                      table.remove(Effects, e)
                    end
                  end
                end
              end
            end
            if Thing[2] == "Orb" then
              Thing[4] = Thing[4] - 1
              if Thing[4] % 2 == 0 then
                MagicBlock(BrickColor.new("White"), cf(Thing[1].Position), 1, 1, 1, 2, 2, 2, 0.2, 1)
              end
              if Thing[4] <= 0 then
                print("end")
                MagicCircle(BrickColor.new("White"), cf(Thing[1].Position), 5, 5000, 5, 1, 10, 1, 0.05)
                hitfloor2,posfloor2 = rayCast(Thing[1].Position, CFrame.new(Thing[1].Position, Thing[1].Position - Vector3.new(0, 1, 0)).lookVector, 900, Character)
                ref = part(3, workspace, 0, 1, BrickColor.new("Black"), "Reference", vt())
                ref.Anchored = true
                ref.CFrame = cf(posfloor2)
                game:GetService("Debris"):AddItem(ref, 1)
                so("1369158", ref, 1, 2)
                MagniHeal(ref, 10, 1, 3)
                MagniDamage(ref, 10, 3, 4, 0, "Normal", ref, 0, 1, 0, nil, nil, true)
                MagicBlock(BrickColor.new("White"), cf(posfloor2) * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 1, 1, 5, 5, 5, 0.1, 2)
                eul = euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                MagicRing(BrickColor.new("White"), cf(posfloor2) * eul, 0, 0, 0, 2, 2, 0.1, 0.08)
                MagicRing(BrickColor.new("White"), cf(posfloor2) * eul * euler(0, -1.57, 0), 0, 0, 0, 2, 2, 0.1, 0.08)
                Thing[1].Parent = nil
                table.remove(Effects, e)
              end
            end
            if Thing[2] ~= "DecreaseStat" and Thing[2] ~= "showDamage" and Thing[2] ~= "Orb" then
              if Thing[1].Transparency <= 1 then
                if Thing[2] == "Block1" then
                  Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                  Mesh = Thing[7]
                  Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                  Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                else
                  if Thing[2] == "Block2" then
                    Thing[1].CFrame = Thing[1].CFrame
                    Mesh = Thing[7]
                    Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                    Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                  else
                    if Thing[2] == "Cylinder" then
                      Mesh = Thing[7]
                      Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                      Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                    else
                      if Thing[2] == "Cylinder2" then
                        Mesh = Thing[7]
                        Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                        if 0.5 <= Thing[1].Transparency then
                          Mesh.Scale = Mesh.Scale - vt(Thing[4] / 2, Thing[5] / 2, Thing[6] / 2)
                        else
                          Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                        end
                      else
                        if Thing[2] == "Blood" then
                          Mesh = Thing[7]
                          Thing[1].CFrame = Thing[1].CFrame * cf(0, 0.5, 0)
                          Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                          Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                        else
                          if Thing[2] == "Elec" then
                            Mesh = Thing[7]
                            Mesh.Scale = Mesh.Scale + vt(Thing[7], Thing[8], Thing[9])
                            Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                          else
                            if Thing[2] == "Disappear" then
                              Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            end
                          end
                        end
                      end
                    end
                  end
                end
              else
                Part.Parent = nil
                table.remove(Effects, e)
              end
            end
          end
        end
      end
    end
    do
      fenbarmana2:TweenSize((UDim2.new(0.4, 0, -4 * mana.Value / 100, 0)), nil, 1, 0.4, true)
      fenbarmana4.Text = "Mana(" .. mana.Value .. ")"
      fenbarhp2.BackgroundColor3 = Color3.new(Humanoid.Health / Humanoid.MaxHealth, 0, 0)
      fenbarhp2:TweenSize((UDim2.new(Humanoid.Health / Humanoid.MaxHealth, 0, 1, 0)), nil, 1, 0.4, true)
      fenbarhp3.Text = "(" .. math.floor(Humanoid.Health) .. ")"
      fenbarblock2:TweenSize((UDim2.new(0.4, 0, -4 * blessing / 100, 0)), nil, 1, 0.4, true)
      fenbarblock3.Text = "Blessing(" .. math.floor(blessing) .. ")"
      fenbarmove1b:TweenSize((UDim2.new(1 * cooldowns[1] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
      fenbarmove2b:TweenSize((UDim2.new(1 * cooldowns[2] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
      fenbarmove3b:TweenSize((UDim2.new(1 * cooldowns[3] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
      fenbarmove4b:TweenSize((UDim2.new(1 * cooldowns[4] / cooldownmax, 0, 1, 0)), nil, 1, 0.4, true)
      for _,c in pairs(Decrease:children()) do
        if (c:findFirstChild("Duration")) ~= nil then
          c.Duration.Value = c.Duration.Value - 1
          if c.Duration.Value <= 0 then
            c.Parent = nil
          end
        end
        if c.Name == "DecreaseAtk" then
          decreaseatk = decreaseatk + c.Value
        else
          if c.Name == "DecreaseDef" then
            decreasedef = decreasedef + c.Value
          else
            if c.Name == "DecreaseMvmt" then
              decreasemvmt = decreasemvmt + c.Value
            end
          end
        end
      end
      Atk.Value = 1 - (decreaseatk)
      if Atk.Value <= 0 then
        Atk.Value = 0
      end
      Def.Value = 1 - (decreasedef)
      if Def.Value <= 0 then
        Def.Value = 0.01
      end
      Mvmt.Value = 1 - (decreasemvmt)
      if Mvmt.Value <= 0 then
        Mvmt.Value = 0
      end
      decreaseatk = 0
      decreasedef = 0
      decreasemvmt = 0
      AtkVal = Atk.Value * 100
      AtkVal = math.floor(AtkVal)
      AtkVal = AtkVal / 100
      fenbardamage.Text = "Damage\n(" .. AtkVal .. ")"
      DefVal = Def.Value * 100
      DefVal = math.floor(DefVal)
      DefVal = DefVal / 100
      fenbardef.Text = "Defense\n(" .. DefVal .. ")"
      MvmtVal = Mvmt.Value * 100
      MvmtVal = math.floor(MvmtVal)
      MvmtVal = MvmtVal / 100
      if Rooted.Value == true then
        MvmtVal = 0
      end
      fenbarmove.Text = "Walkspeed\n(" .. MvmtVal .. ")"
      if StunT.Value <= Stun.Value then
        fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4, 0)), nil, 1, 0.4, true)
      else
        fenbarstun2:TweenSize((UDim2.new(0.4, 0, -4 * Stun.Value / StunT.Value, 0)), nil, 1, 0.4, true)
      end
      fenbarstun3.Text = "Stun(" .. Stun.Value .. ")"
      if 100 <= mana.Value then
        mana.Value = 100
      else
        if mananum <= 9 then
          mananum = mananum + 1
        else
          mananum = 0
          mana.Value = mana.Value + 1
        end
      end
      for i = 1, #cooldowns do
        if cooldownmax <= cooldowns[i] then
          cooldowns[i] = cooldownmax
        else
          cooldowns[i] = cooldowns[i] + cooldownsadd[i]
        end
      end
      -- DECOMPILER ERROR at PC5865: LeaveBlock: unexpected jumping out DO_STMT

      -- DECOMPILER ERROR at PC5865: LeaveBlock: unexpected jumping out DO_STMT

    end
  end
end

]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="HopperBin" referent="RBX7E1E3482B83345988984B29820C24DD9">
			<Properties>
				<bool name="Active">false</bool>
				<token name="BinType">0</token>
				<string name="Name">Ichor</string>
				<Content name="TextureId"><null></null></Content>
			</Properties>
			<Item class="LocalScript" referent="RBX0DF804083E1E46659BFCCDD5652A86FA">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LocalScript</string>
					<string name="ScriptGuid">{47AFD804-20FC-4CC5-AC71-75DDDA234B36}</string>
					<ProtectedString name="Source"><![CDATA[--[[
Made by Fenrier.
]] 
wait(1/60)
Player=game:GetService("Players").LocalPlayer
Character=Player.Character 
PlayerGui=Player.PlayerGui 
Backpack=Player.Backpack 
Torso=Character.Torso 
Head=Character.Head 
Humanoid=Character.Humanoid
LeftArm=Character["Left Arm"] 
LeftLeg=Character["Left Leg"] 
RightArm=Character["Right Arm"] 
RightLeg=Character["Right Leg"] 
LS=Torso["Left Shoulder"] 
LH=Torso["Left Hip"] 
RS=Torso["Right Shoulder"] 
RH=Torso["Right Hip"] 
Neck=Torso.Neck
it=Instance.new
vt=Vector3.new
cf=CFrame.new
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootPart=Character.HumanoidRootPart
RootJoint=RootPart.RootJoint
RootCF=euler(-1.57,0,3.14)
attack = false 
attackdebounce = false 
MMouse=nil
combo=0
local idle=0
local Anim="Idle"
local Effects={}
local Weapon={}
local Welds={}
local blood=0
local BloodAllies={}
local BoundTarget=nil
local hitted=false
local HitTarget=nil
local isjugg=false
local decreaseatk=0
local decreasedef=0
local decreasemvmt=0
local doing2=false
local doing4=false
local move1="(Z)\
Fury Hit"
local move2="(X)\
Blood Bind"
local move3="(C)\
Impact Fist"
local move4="(V)\
Punishing Blow"
local cooldowns={}
local cooldown1=0 table.insert(cooldowns,cooldown1)
local cooldown2=0 table.insert(cooldowns,cooldown2)
local cooldown3=0 table.insert(cooldowns,cooldown3)
local cooldown4=0 table.insert(cooldowns,cooldown4)
local cooldownsadd={}
local cooldownadd1=.3 table.insert(cooldownsadd,cooldownadd1)
local cooldownadd2=.2 table.insert(cooldownsadd,cooldownadd2)
local cooldownadd3=.15 table.insert(cooldownsadd,cooldownadd3)
local cooldownadd4=.1 table.insert(cooldownsadd,cooldownadd4)
local cooldownmax=100
--local damageFunc=workspace.damageFunc
--blocknum=100
local manualguardend=false
--player 
player=nil 
--save shoulders 
RSH, LSH=nil, nil 
--welds 
RW, LW=Instance.new("Motor"), Instance.new("Motor") 
RW.Name="Right Shoulder" LW.Name="Left Shoulder"
LH=Torso["Left Hip"]
RH=Torso["Right Hip"]
TorsoColor=Torso.BrickColor
TorsoRed=TorsoColor.Color.r
TorsoGreen=TorsoColor.Color.g
TorsoBlue=TorsoColor.Color.b
NewCol=BrickColor.new("Really black").Color
print(BrickColor.new(NewCol))
local mdec=Instance.new("NumberValue",Decrease)
mdec.Name="DecreaseDef"
mdec.Value=.4
local mdec2=Instance.new("NumberValue",Decrease)
mdec2.Name="DecreaseMvmt"
mdec2.Value=.1

local Animate=Character.Animate
local animation=Instance.new("Animation")
animation.AnimationId="http://www.roblox.com/Asset?ID=180435571"
local animTrack=Humanoid:LoadAnimation(animation)
local canjump=true
function removeControl()
canjump=false
end
function resumeControl()
canjump=true
end
Player.Character.Humanoid.Changed:connect(function()
if canjump==false then
Player.Character.Humanoid.Jump=false
end
end)

function swait(num)
if num==0 or num==nil then
--if Stagger.Value==false or Stun.Value<=100 then
game:service'RunService'.Heartbeat:wait(0)
--end
else
for i=0,num do
game:service'RunService'.Heartbeat:wait(0)
--[[if Stagger.Value==true or Stun.Value>=StunT.Value then
break
end]]
end
end
end

if Character:findFirstChild("Ichor Gauntlets",true) ~= nil then 
Character:findFirstChild("Ichor Gauntlets",true).Parent = nil 
end 
if Player.PlayerGui:findFirstChild("WeaponGUI",true) ~= nil then 
Player.PlayerGui:findFirstChild("WeaponGUI",true).Parent = nil 
end 
if Character:findFirstChild("Stats",true) ~= nil then 
Character:findFirstChild("Stats",true).Parent = nil 
end 
local Stats=Instance.new("BoolValue")
Stats.Name="Stats"
Stats.Parent=Character
local Atk=Instance.new("NumberValue")
Atk.Name="Damage"
Atk.Parent=Stats
Atk.Value=1
local Def=Instance.new("NumberValue")
Def.Name="Defense"
Def.Parent=Stats
Def.Value=1
local Mvmt=Instance.new("NumberValue")
Mvmt.Name="Movement"
Mvmt.Parent=Stats
Mvmt.Value=1
local Block=Instance.new("BoolValue")
Block.Name="Block"
Block.Parent=Stats
Block.Value=false
local Stun=Instance.new("NumberValue")
Stun.Name="Stun"
Stun.Parent=Stats
Stun.Value=0
local StunT=Instance.new("NumberValue")
StunT.Name="StunThreshold"
StunT.Parent=Stats
StunT.Value=100
local Rooted=Instance.new("BoolValue")
Rooted.Name="Rooted"
Rooted.Parent=Stats
Rooted.Value=false
local Decrease=Instance.new("BoolValue")
Decrease.Name="Decrease"
Decrease.Parent=Stats
Decrease.Value=false
local Stunned=Instance.new("BoolValue")
Stunned.Name="Stunned"
Stunned.Parent=Stats
Stunned.Value=false
local Stagger=Instance.new("BoolValue")
Stagger.Name="Stagger"
Stagger.Parent=Stats
Stagger.Value=false
local StaggerHit=Instance.new("BoolValue")
StaggerHit.Name="StaggerHit"
StaggerHit.Parent=Stats
StaggerHit.Value=false
local RecentEnemy=Instance.new("ObjectValue")
RecentEnemy.Name="RecentEnemy"
RecentEnemy.Parent=Stats
RecentEnemy.Value=nil
local mana=Instance.new("NumberValue")
mana.Name="Mana"
mana.Parent=Stats
mana.Value=0
local passive1=Instance.new("NumberValue",Decrease)
passive1.Name="DecreaseAtk"
passive1.Value=0
local passive2=Instance.new("NumberValue",Decrease)
passive2.Name="DecreaseDef"
passive2.Value=0
local passive3=Instance.new("NumberValue",Decrease)
passive3.Name="DecreaseMvmt"
passive3.Value=0
local passive4=Instance.new("NumberValue",Decrease)
passive4.Name="DecreaseAtk"
passive4.Value=.1

function NoOutline(Part)
Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
end

function part(formfactor,parent,reflectance,transparency,brickcolor,name,size)
local fp=it("Part")
fp.formFactor=formfactor 
fp.Parent=parent
fp.Reflectance=reflectance
fp.Transparency=transparency
fp.CanCollide=false 
fp.Locked=true
fp.BrickColor=brickcolor
fp.Name=name
fp.Size=size
fp.Position=Torso.Position 
NoOutline(fp)
fp.Material="SmoothPlastic"
fp:BreakJoints()
return fp 
end 

function mesh(Mesh,part,meshtype,meshid,offset,scale)
local mesh=it(Mesh) 
mesh.Parent=part
if Mesh=="SpecialMesh" then
mesh.MeshType=meshtype
if meshid~="nil" then
mesh.MeshId="http://www.roblox.com/asset/?id="..meshid
end
end
mesh.Offset=offset
mesh.Scale=scale
return mesh
end

function weld(parent,part0,part1,c0)
local weld=it("Motor") 
weld.Parent=parent
weld.Part0=part0 
weld.Part1=part1 
weld.C0=c0
return weld
end

function gui(GuiType,parent,text,backtrans,backcol,pos,size)
local gui=it(GuiType) 
gui.Parent=parent
gui.Text=text
gui.BackgroundTransparency=backtrans
gui.BackgroundColor3=backcol
gui.SizeConstraint="RelativeXY" 
gui.TextXAlignment="Center" 
gui.TextYAlignment="Center" 
gui.Position=pos
gui.Size=size
gui.Font="SourceSans"
gui.FontSize="Size14"
gui.TextWrapped=false
gui.TextStrokeTransparency=0
gui.TextColor=BrickColor.new("White")
return gui
end

local Color1=Torso.BrickColor

local fengui=it("GuiMain") 
fengui.Parent=Player.PlayerGui 
fengui.Name="WeaponGUI" 
local fenframe=it("Frame") 
fenframe.Parent=fengui
fenframe.BackgroundColor3=Color3.new(255,255,255) 
fenframe.BackgroundTransparency=1 
fenframe.BorderColor3=Color3.new(17,17,17) 
fenframe.Size=UDim2.new(0.1,0,0.1,0)
fenframe.Position=UDim2.new(0.95,0,0.7,0)
local fenframe2=it("Frame") 
fenframe2.Parent=fengui
fenframe2.BackgroundColor3=Color3.new(255,255,255) 
fenframe2.BackgroundTransparency=1 
fenframe2.BorderColor3=Color3.new(17,17,17) 
fenframe2.Size=UDim2.new(0.2,0,0.1,0)
fenframe2.Position=UDim2.new(0.4,0,0.85,0)
local fenframe3=it("Frame") 
fenframe3.Parent=fengui
fenframe3.BackgroundColor3=Color3.new(255,255,255) 
fenframe3.BackgroundTransparency=1 
fenframe3.BorderColor3=Color3.new(17,17,17) 
fenframe3.Size=UDim2.new(0.2,0,0.2,0)
fenframe3.Position=UDim2.new(0.8,0,0.8,0)
fenframe3.Name="MoveFrame"
local fenframe4=it("Frame") 
fenframe4.Parent=fengui
fenframe4.BackgroundColor3=Color3.new(255,255,255) 
fenframe4.BackgroundTransparency=1 
fenframe4.BorderColor3=Color3.new(17,17,17) 
fenframe4.Size=UDim2.new(0.1,0,0.1,0)
fenframe4.Position=UDim2.new(0,0,0.7,0)
local pressedf=false
local fenframe5=it("Frame") 
fenframe5.Parent=fengui
fenframe5.BackgroundColor3=Color3.new(0,0,0) 
fenframe5.BackgroundTransparency=1 
fenframe5.BorderColor3=Color3.new(0,0,0) 
fenframe5.Size=UDim2.new(1,0,1,0)
fenframe5.Position=UDim2.new(0,0,0,0)
fenframe5.ZIndex=2
local tellbar=gui("TextLabel",fenframe5,"Press 'F' to equip your weapon.",1,Color3.new(0,0,0),UDim2.new(.25,0,.25,0),UDim2.new(.5,0,.5,0))
tellbar.Font="Arial"
tellbar.TextScaled=true
tellbar.TextTransparency=1
tellbar.TextStrokeTransparency=1
tellbar.ZIndex=2
local fnumb=0
--gui(GuiType,parent,text,backtrans,backcol,pos,size)
local fenbarmana1=gui("TextLabel",fenframe,"",0,Color3.new(0,0,0),UDim2.new(0,0,0,0),UDim2.new(.4,0,-4,0))
local fenbarmana2=gui("TextLabel",fenframe,"",0,BrickColor.new(NewCol).Color,UDim2.new(0,0,0,0),UDim2.new(.4,0,0,0))
local fenbarmana4=gui("TextLabel",fenframe,"Mana("..mana.Value..")",1,Color3.new(0,0,0),UDim2.new(0,0,.2,0),UDim2.new(.4,0,.2,0))
local fenbarblock1=gui("TextLabel",fenframe,"",0,Color3.new(0,0,0),UDim2.new(-.6,0,0,0),UDim2.new(.4,0,-4,0))
local fenbarblock2=gui("TextLabel",fenframe,"",0,BrickColor.new("Really red").Color,UDim2.new(-.6,0,0,0),UDim2.new(.4,0,0,0))
local fenbarblock3=gui("TextLabel",fenframe,"Blood("..blood..")",1,Color3.new(0,0,0),UDim2.new(-.6,0,.2,0),UDim2.new(.4,0,.2,0))
local fenbardamage=gui("TextLabel",fenframe2,"Damage",.55,Color3.new(155/255,0,0),UDim2.new(-.23,0,0,0),UDim2.new(.2,0,1,0))
local fenbardef=gui("TextLabel",fenframe2,"Defense",0.55,Color3.new(0,0,155/255),UDim2.new(-.46,0,0,0),UDim2.new(.2,0,1,0))
local fenbarmove=gui("TextLabel",fenframe2,"Walkspeed",0.55,Color3.new(0,155/255,0),UDim2.new(1.03,0,0,0),UDim2.new(.2,0,1,0))
local fenbarhp1=gui("TextLabel",fenframe2,"",0,Color3.new(0,0,0),UDim2.new(-.46,0,1,0),UDim2.new(1.92,0,.4,0))
local fenbarhp2=gui("TextLabel",fenbarhp1,"",0,Color3.new(1,0,0),UDim2.new(0,0,0,0),UDim2.new(0,0,1,0))
local fenbarhp3=gui("TextLabel",fenbarhp1,"(100)",1,Color3.new(0,0,0),UDim2.new(0,0,0,0),UDim2.new(1,0,1,0))
local fenbarstun1=gui("TextLabel",fenframe4,"",0,Color3.new(0,0,0),UDim2.new(.2,0,0,0),UDim2.new(.4,0,-4,0))
local fenbarstun2=gui("TextLabel",fenframe4,"",0,Color3.new(0.960784,0.803922,0.188235),UDim2.new(.2,0,0,0),UDim2.new(.4,0,0,0))
local fenbarstun3=gui("TextLabel",fenframe4,"Stun("..Stun.Value..")",1,Color3.new(0.960784,0.803922,0.188235),UDim2.new(.2,0,.2,0),UDim2.new(.4,0,.2,0))
local fenbarmove1=gui("TextButton",fenframe3,move1,.55,Color3.new(.5,.5,.5),UDim2.new(0.1,0,0.1,0),UDim2.new(.4,0,.4,0))
fenbarmove1.ZIndex=2
local fenbarmove1b=gui("TextLabel",fenbarmove1,"",.55,BrickColor.new(NewCol).Color,UDim2.new(0,0,0,0),UDim2.new(0,0,1,0))
local fenbarmove2=gui("TextButton",fenframe3,move2,.55,Color3.new(.5,.5,.5),UDim2.new(0.6,0,0.1,0),UDim2.new(.4,0,.4,0))
fenbarmove2.ZIndex=2
local fenbarmove2b=gui("TextLabel",fenbarmove2,"",.55,BrickColor.new(NewCol).Color,UDim2.new(0,0,0,0),UDim2.new(0,0,1,0))
local fenbarmove3=gui("TextButton",fenframe3,move3,.55,Color3.new(.5,.5,.5),UDim2.new(0.1,0,0.6,0),UDim2.new(.4,0,.4,0))
fenbarmove3.ZIndex=2
local fenbarmove3b=gui("TextLabel",fenbarmove3,"",.55,BrickColor.new(NewCol).Color,UDim2.new(0,0,0,0),UDim2.new(0,0,1,0))
local fenbarmove4=gui("TextButton",fenframe3,move4,.55,Color3.new(.5,.5,.5),UDim2.new(0.6,0,0.6,0),UDim2.new(.4,0,.4,0))
fenbarmove4.ZIndex=2
local fenbarmove4b=gui("TextLabel",fenbarmove4,"",.55,BrickColor.new(NewCol).Color,UDim2.new(0,0,0,0),UDim2.new(0,0,1,0))

local modelzorz=Instance.new("Model") 
modelzorz.Parent=Character 
modelzorz.Name="Ichor Gauntlets" 

local rprt1=part(3,modelzorz,0,0,TorsoColor,"Right Part01",vt())
local rprt2=part(3,modelzorz,0,0,BrickColor.new(NewCol),"Right Part02",vt())
local rprt4=part(3,modelzorz,0,0,BrickColor.new(NewCol),"Right Part04",vt())
local rprt5=part(3,modelzorz,0,0,BrickColor.new("Black"),"Right Part05",vt())
local lprt1=part(3,modelzorz,0,0,TorsoColor,"Left Part01",vt())
local lprt2=part(3,modelzorz,0,0,BrickColor.new(NewCol),"Left Part02",vt())
local lprt4=part(3,modelzorz,0,0,BrickColor.new(NewCol),"Left Part04",vt())
local lprt5=part(3,modelzorz,0,0,BrickColor.new("Black"),"Left Part05",vt())

rmsh1=mesh("BlockMesh",rprt1,"","",vt(0,0,0),vt(5.1,3,5.1))
rmsh2=mesh("SpecialMesh",rprt2,"Wedge","nil",vt(0,0,0),vt(5.5,6,5.5))
rmsh4=mesh("SpecialMesh",rprt4,"FileMesh","3270017",vt(0,0,0),vt(1.2,1.2,2))
rmsh5=mesh("BlockMesh",rprt5,"","",vt(0,0,0),vt(5.6,1,1))
lmsh1=mesh("BlockMesh",lprt1,"","",vt(0,0,0),vt(5.1,3,5.1))
lmsh2=mesh("SpecialMesh",lprt2,"Wedge","nil",vt(0,0,0),vt(5.5,6,5.5))
lmsh4=mesh("SpecialMesh",lprt4,"FileMesh","3270017",vt(0,0,0),vt(1.2,1.2,2))
lmsh5=mesh("BlockMesh",lprt5,"","",vt(0,0,0),vt(5.6,1,1))

local rwld1=weld(rprt1,rprt1,RightArm,euler(0,0,0)*cf(0,.7,0))
local rwld2=weld(rprt1,rprt2,rprt1,euler(0,-1.57,0)*cf(0,-.29,0))
local rwld4=weld(rprt1,rprt4,rprt1,euler(1.57,0,0)*cf(0,-1.2,0))
local rwld5=weld(rprt1,rprt5,rprt2,euler(0,0,0)*cf(0,.55,-.1))
local lwld1=weld(rprt1,lprt1,LeftArm,euler(0,3.14,0)*cf(0,.7,0))
local lwld2=weld(rprt1,lprt2,lprt1,euler(0,-1.57,0)*cf(0,-.29,0))
local lwld4=weld(rprt1,lprt4,lprt1,euler(1.57,0,0)*cf(0,-1.2,0))
local lwld5=weld(rprt1,lprt5,lprt2,euler(0,0,0)*cf(0,.55,-.1))

for i=.3,-.4,-.6 do
local rprt3=part(3,modelzorz,0,0,TorsoColor,"Right Part03",vt())
rmsh3=mesh("SpecialMesh",rprt3,"Wedge","nil",vt(0,0,0),vt(1,4,2))
local rwld3=weld(rprt1,rprt3,rprt2,euler(.1,0,0)*cf(i,-.8,-.35))
local lprt3=part(3,modelzorz,0,0,TorsoColor,"Left Part03",vt())
lmsh3=mesh("SpecialMesh",lprt3,"Wedge","nil",vt(0,0,0),vt(1,4,2))
local lwld3=weld(rprt1,lprt3,lprt2,euler(.1,0,0)*cf(i,-.8,-.35))
end

for i=.35,-.35,-.35 do
local rprt6=part(3,modelzorz,0,0,BrickColor.new("Black"),"Right Part03",vt())
rmsh6=mesh("SpecialMesh",rprt6,"Wedge","nil",vt(0,0,0),vt(1,3,2))
local rwld6=weld(rprt1,rprt6,rprt2,euler(.1,0,0)*cf(i,.35,-.4))
local lprt6=part(3,modelzorz,0,0,BrickColor.new("Black"),"Right Part03",vt())
lmsh6=mesh("SpecialMesh",lprt6,"Wedge","nil",vt(0,0,0),vt(1,3,2))
local lwld6=weld(rprt1,lprt6,lprt2,euler(.1,0,0)*cf(i,.35,-.4))
end

for _,c in pairs(modelzorz:children()) do
table.insert(Weapon,c)
end
for _,c in pairs(rprt1:children()) do
if c.className=="Motor" then
table.insert(Welds,c)
end
end
local hitbox=part(3,modelzorz,0,1,BrickColor.new("Black"),"Hitbox2",vt())
hitbox.Anchored=false
local hbwld=weld(hitbox,hitbox,RootPart,euler(0,0,0)*cf(0,0,0))
local hitbox2=part(3,nil,0,1,BrickColor.new("Black"),"Hitbox",vt(1,1,1))
hitbox2.Anchored=true
local hitboxCF=cf(0,0,0)

hboxpos=Instance.new("BodyPosition",nil)
hboxpos.P=2000
hboxpos.D=100
hboxpos.maxForce=Vector3.new(math.huge,math.huge,math.huge)

function hitboxweld()
hbwld.Parent=modelzorz
hbwld.Part0=hitbox
hbwld.Part1=RightArm
end

if (script.Parent.className~="HopperBin") then 
Tool=Instance.new("HopperBin") 
Tool.Parent=Backpack 
Tool.Name="Ichor Gauntlets" 
script.Parent=Tool 
end 
Bin=script.Parent 
if Bin.Name=="Ichor" then
Bin.Name="Ichor Gauntlets"
end

local bodvel=Instance.new("BodyVelocity")
local bg=Instance.new("BodyGyro")

so = function(id,par,vol,pit) 
local sou = Instance.new("Sound",par or workspace)
sou.Volume=vol
sou.Pitch=pit or 1
sou.SoundId="http://www.roblox.com/asset/?id="..id
coroutine.resume(coroutine.create(function(Sound)
swait() 
Sound:play() 
end),sou)
game:GetService("Debris"):AddItem(sou,6)
end

function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 

function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end

function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end

function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

function hideanim() 
equipped=false
for i=0,1,0.1 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(0,0,0),.4)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(0,0,0),.4)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(0,0,0),.4)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(0,0,0),.4)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
RH.C0=clerp(RH.C0,RHC0,.4)
RH.C1=clerp(RH.C1,RHC1,.4)
LH.C0=clerp(LH.C0,LHC0,.4)
LH.C1=clerp(LH.C1,LHC1,.4)
end
mdec2.Parent=nil
mdec.Parent=Decrease
end 

mdec.Parent=Decrease
function equipanim() 
equipped=true
mdec.Parent=nil
mdec2.Parent=Decrease
local dec=Instance.new("NumberValue",Decrease)
dec.Name="DecreaseMvmt"
dec.Value=10
for i=0,1,0.3 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(-.2,0,0),.4)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(0,0,0),.4)
RW.C0=clerp(RW.C0,cf(1,0.5,-.5)*euler(2.5,0,-.8),.4)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
LW.C0=clerp(LW.C0,cf(-1,0.5,-.5)*euler(2.7,0,1),.4)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
end
for i=0,1,0.1 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(-.2,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(-.2,0,0),.3)
RW.C0=clerp(RW.C0,cf(.8,0.5,-.6)*euler(2.8,0,-.8),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-.8,0.5,-.6)*euler(3,0,.6),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*euler(0,1.57,0)*euler(0,0,-.2),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*euler(0,-1.57,0)*euler(0,0,.2),.3)
end
dec.Parent=nil
end 

function StaggerAnim()
attack=true
removeControl()
for i=1,math.random(2,4) do
ClangEffect(BrickColor.new("New Yeller"),cf(hitbox.Position)*euler(math.random(-50,50)/100,math.random(-50,50),math.random(-50,50)/100),0,.1,.2,math.random(150,300)/1000)
end
for i=0,1,0.35 do
swait()
if Rooted.Value==false then Torso.Velocity=RootPart.CFrame.lookVector*-40 end
Neck.C0=clerp(Neck.C0,necko*euler(0,0,.5)*euler(.1,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(-.2,0,-.4),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(-.2,0,.7)*euler(0,-.7,0),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-.2,0,-.4)*euler(0,.4,0),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(1,-.8,0)*euler(0,1.57,0)*euler(-.5,0,.6),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*euler(0,-1.57,0)*euler(0,.2,.2),.3)
end
for i=0,1,0.2 do
swait()
if Rooted.Value==false then Torso.Velocity=RootPart.CFrame.lookVector*-40 end
Neck.C0=clerp(Neck.C0,necko*euler(0,0,.5)*euler(.1,0,0),.4)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.2)*euler(-.5,0,-.4),.4)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(-.2,0,.7)*euler(0,-.7,0),.4)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-.2,0,-.4)*euler(0,.4,0),.4)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
RH.C0=clerp(RH.C0,cf(1,-.8,0)*euler(0,1.57,0)*euler(-.5,0,.6),.4)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*euler(0,-1.57,0)*euler(0,.2,.5),.4)
end
for i=0,1,0.1 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(0,0,.4)*euler(.5,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-1.8)*euler(-.2,0,-.4),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(-.5,0,.2)*euler(0,-.4,0),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-.5,0,-.2)*euler(0,.4,0),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(1,-.8,0)*euler(0,1.57,0)*euler(-.5,0,1.2),.3)
LH.C0=clerp(LH.C0,cf(-1,0,-1)*euler(0,-1.57,0)*euler(0,.2,.2),.3)
end
for i=1,40 do
swait()
if Stun.Value>=StunT.Value then
break
end
end
resumeControl()
combo=0
attack=false
end

function StaggerHitt()
attack=true
for i=1,math.random(2,4) do
ClangEffect(BrickColor.new("New Yeller"),cf(hitbox.Position)*euler(math.random(-50,50)/100,math.random(-50,50),math.random(-50,50)/100),0,.1,.2,math.random(150,300)/1000)
end
for i=0,1,0.1 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*euler(.1,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(-.2,0,0),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(-.4,0,.9),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-.2,0,-.6),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(1,-.8,0)*euler(0,1.57,0)*euler(-.2,0,-.4),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*euler(0,-1.57,0)*euler(0,.2,.2),.3)
end
attack=false
end

function StunAnim()
attack=true
removeControl()
Stunned.Value=true
showDamage(Character,"Stunned","Interrupt")
local dec=Instance.new("NumberValue",Decrease)
dec.Name="DecreaseMvmt"
dec.Value=10
for i=0,1,0.3 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(-.2,0,-.5),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(.2,0,-3),.2)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(-.2,0,1.3),.2)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.2)
LW.C0=clerp(LW.C0,cf(-1.2,0.5,-.4)*euler(1,0,.4)*euler(0,-.1,0),.2)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.2)
RH.C0=clerp(RH.C0,cf(1,-.6,0)*euler(0,1.57,0)*euler(-.5,0,.3),.25)
LH.C0=clerp(LH.C0,cf(-1,-.8,0)*euler(0,-1.57,0)*euler(-.2,0,0),.25)
end
for i=0,1,0.3 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(-.3,0,-.5),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.5)*euler(.8,0,-3),.2)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(-.8,0,1.3),.2)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.2)
LW.C0=clerp(LW.C0,cf(-1.2,0.5,-.4)*euler(1.2,0,.8)*euler(0,-.1,0),.2)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.2)
RH.C0=clerp(RH.C0,cf(1,-.6,0)*euler(0,1.57,0)*euler(-.5,0,.6),.25)
LH.C0=clerp(LH.C0,cf(-1,-.8,0)*euler(0,-1.57,0)*euler(.1,0,.7),.25)
end
for i=0,1,0.3 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(-.3,0,-1),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-2)*euler(1.57,0,-3),.2)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(-.8,0,1.3),.2)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.2)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1.2,0,-.8)*euler(0,-.1,0),.2)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.2)
RH.C0=clerp(RH.C0,cf(1,-.6,0)*euler(0,1.57,0)*euler(-.2,0,.6),.25)
LH.C0=clerp(LH.C0,cf(-1,-.8,0)*euler(0,-1.57,0)*euler(-.1,0,.3),.25)
end
local gairost=Instance.new("BodyGyro") 
gairost.Parent=RootPart
gairost.maxTorque=Vector3.new(4e+005,0,4e+005)*math.huge 
gairost.P=20e+003 
gairost.cframe=cf(0,0,0)
for i=0,1,0.1 do
swait()
if hitfloor~=nil then
Torso.Velocity=vt(0,0,0)
end
Neck.C0=clerp(Neck.C0,necko*euler(0,0,-1.57),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-2.5)*euler(1.57,0,-3.14),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(-1.57,0,1.5)*euler(.2,0,0),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1.5,0,-1.57)*euler(0,0,0),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*euler(0,1.57,0)*euler(-.3,.5,0),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*euler(0,-1.57,0)*euler(-.1,.2,0),.3)
end
for i=1,70 do
swait()
gairost.cframe=RootPart.CFrame
if hitfloor~=nil then
Torso.Velocity=vt(0,0,0)
end
end
for i=0,1,0.2 do
swait()
Stun.Value=0
gairost.cframe=RootPart.CFrame
Neck.C0=clerp(Neck.C0,necko*euler(.2,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-2)*euler(1,0,-4),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(-1.57,0,1)*euler(.2,-1,0),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1.2,0,.2)*euler(0,0,0),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*euler(0,1.57,0)*euler(-.3,.5,.4),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,-1)*euler(0,-1.57,0)*euler(-.1,.2,1),.3)
end
resumeControl()
gairost.Parent=nil
dec.Parent=nil
Stun.Value=0
combo=0
Stunned.Value=false
attack=false
for i=1,10 do
swait()
Stun.Value=0
end
end

function attackone()
attack=true
--[[
Neck.C0=clerp(Neck.C0,necko*euler(-.1,0,0)*euler(0,0,-.2),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.2)*euler(.2,0,0)*euler(0,0,.2),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(1.7,0,.2)*euler(0,1.57,0),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1.5,0,.1)*euler(0,-1.57,0),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(1.1,-.8,-.2)*euler(0,1.57,0)*euler(-.1,0,.2)*euler(0,0,0),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*euler(0,-1.57,0)*euler(0,0,.1),.2)
]]
if Rooted.Value==false then Torso.Velocity=RootPart.CFrame.lookVector*30 end
so("200632136",RightArm,1,1)
--con1=hitbox.Touched:connect(function(hit) Damagefunc(hit,6,8,math.random(5,10),"Normal",RootPart,.5,1,math.random(8,10),nil,true) end) 
hbwld.Parent=nil
hboxpos.Parent=hitbox
hitbox.Parent=modelzorz
hitbox.Size=vt(1.5,2.5,1.5)
hitboxCF=RightArm.CFrame
hitbox.CFrame=hitboxCF
for i=0,1,0.4 do
swait()
hitboxCF=RightArm.CFrame
hitbox.CFrame=hitboxCF
MagniDamage(hitbox,3,6,8,math.random(5,10),"Normal",RootPart,.5,1,math.random(8,10),nil,true)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*euler(0,0,-1.2),.5)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.2)*euler(.1,0,0)*euler(0,0,1.2),.5)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(1.7,0,1)*euler(0,1.57,0),.5)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.5)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1,0,-.1)*euler(0,-1.57,0),.5)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.5)
RH.C0=clerp(RH.C0,cf(.8,-.8,.4)*euler(0,1.57,0)*euler(.1,0,0)*euler(0,-1.2,0),.5)
LH.C0=clerp(LH.C0,cf(-.8,-1,-.4)*euler(0,-1.57,0)*euler(0,0,0)*euler(0,-1,0),.5)
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
for i=0,1,0.1 do
swait()
hitboxCF=RightArm.CFrame
hitbox.CFrame=hitboxCF
MagniDamage(hitbox,3,6,8,math.random(5,10),"Normal",RootPart,.5,1,math.random(8,10),nil,true)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,0)*euler(0,0,-1.4),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.2)*euler(.1,0,0)*euler(0,0,1.4),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(1.7,0,1.4)*euler(0,1.57,0),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(.5,0,-.5)*euler(0,-1.57,0),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(.8,-.8,.4)*euler(0,1.57,0)*euler(.1,0,0)*euler(0,-1.4,0),.3)
LH.C0=clerp(LH.C0,cf(-.8,-1,-.4)*euler(0,-1.57,0)*euler(0,0,0)*euler(0,-1.2,0),.3)
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
--con1:disconnect()
hitbox.Parent=modelzorz
hitbox.Size=vt()
hitboxweld()
hboxpos.Parent=nil
attack=false
end

function attacktwo()
attack=true
for i=0,1,0.2 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(.2,0,0)*euler(0,0,.2),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.2)*euler(.2,0,0)*euler(0,0,.4),.3)
RW.C0=clerp(RW.C0,cf(1,0.5,-.5)*euler(1.5,0,-1)*euler(0,1.57,0),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1,0,-.3)*euler(0,-1.57,0),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(1.1,-.8,-.2)*euler(0,1.57,0)*euler(-.2,0,.4)*euler(0,0,0),.2)
LH.C0=clerp(LH.C0,cf(-1,0,-.6)*euler(0,-1.57,0)*euler(0,0,.4)*euler(-.1,0,0),.2)
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
if Rooted.Value==false then Torso.Velocity=RootPart.CFrame.lookVector*40 end
local dec=Instance.new("NumberValue",Decrease)
dec.Name="DecreaseMvmt"
dec.Value=10
so("200632211",LeftLeg,1,1)
--con1=hitbox.Touched:connect(function(hit) Damagefunc(hit,6,10,math.random(5,10),"Normal",RootPart,.5,1,math.random(8,10),nil,true,false,"Movement",.1,100) end) 
hbwld.Parent=nil
hboxpos.Parent=hitbox
hitbox.Parent=modelzorz
hitbox.Size=vt(1.5,2.5,1.5)
hitboxCF=LeftLeg.CFrame
hitbox.CFrame=hitboxCF
for i=0,1,0.1 do
swait()
hitboxCF=LeftLeg.CFrame
hitbox.CFrame=hitboxCF
MagniDamage(hitbox,3,6,10,math.random(5,10),"Normal",RootPart,.5,1,math.random(8,10),nil,true,false,"Movement",.1,100)
Neck.C0=clerp(Neck.C0,necko*euler(-.2,0,0)*euler(0,0,.4),.5)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-.8,-.2)*euler(.2,0,0)*euler(0,0,-.4),.5)
RW.C0=clerp(RW.C0,cf(1.2,0.5,-.3)*euler(1,0,-.8)*euler(0,1.57,0),.5)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.5)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-1,0,-.5)*euler(0,0,0),.5)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.5)
RH.C0=clerp(RH.C0,cf(1.1,-.6,-.6)*euler(0,1.57,0)*euler(0,0,-.1)*euler(-.1,0,0),.5)
LH.C0=clerp(LH.C0,cf(-1,-.5,-.5)*euler(0,-1.57,0)*euler(0,0,-2.2)*euler(-.1,0,0),.5)
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
--con1:disconnect()
hitbox.Parent=modelzorz
hitbox.Size=vt()
hitboxweld()
hboxpos.Parent=nil
dec.Parent=nil
attack=false
end

function attackthree()
attack=true
if Rooted.Value==false then Torso.Velocity=RootPart.CFrame.lookVector*30 end
so("200632136",LeftArm,1,1.1)
--con1=hitbox.Touched:connect(function(hit) Damagefunc(hit,6,8,math.random(5,10),"Normal",RootPart,.5,1,math.random(8,10),nil,true) end) 
hbwld.Parent=nil
hboxpos.Parent=hitbox
hitbox.Parent=modelzorz
hitbox.Size=vt(1.5,2.5,1.5)
hitboxCF=LeftArm.CFrame
hitbox.CFrame=hitboxCF
for i=0,1,0.5 do
swait()
hitboxCF=LeftArm.CFrame
hitbox.CFrame=hitboxCF
MagniDamage(hitbox,3,6,8,math.random(5,10),"Normal",RootPart,.5,1,math.random(8,10),nil,true)
Neck.C0=clerp(Neck.C0,necko*euler(.3,0,1.2)*euler(.2,0,0),.5)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.2)*euler(0,0,-1.57),.5)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(.6,0,-.2)*euler(0,1.5,0),.5)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.5)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1.5,0,-1.2)*euler(0,-1,0),.5)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.5)
RH.C0=clerp(RH.C0,cf(.6,-1,-.4)*euler(0,1.57,0)*euler(0,1.2,-.1),.3)
LH.C0=clerp(LH.C0,cf(-.6,-.9,.4)*euler(0,-1.57,0)*euler(0,1.2,.1),.3)
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
for i=0,1,0.1 do
swait()
hitboxCF=LeftArm.CFrame
hitbox.CFrame=hitboxCF
MagniDamage(hitbox,3,6,8,math.random(5,10),"Normal",RootPart,.5,1,math.random(8,10),nil,true)
Neck.C0=clerp(Neck.C0,necko*euler(.3,0,1.2)*euler(.2,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.2)*euler(0,0,-1.57),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(.6,0,.6)*euler(0,1.5,0),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1,0,.3)*euler(0,-1.5,0),.2)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(.6,-1,-.4)*euler(0,1.57,0)*euler(0,1.2,-.1),.4)
LH.C0=clerp(LH.C0,cf(-.6,-.9,.4)*euler(0,-1.57,0)*euler(0,1.2,.1),.4)
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
--con1:disconnect()
hitbox.Parent=modelzorz
hitbox.Size=vt()
hitboxweld()
hboxpos.Parent=nil
attack=false
end

function attackfour()
attack=true
for i=0,1,0.2 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(-.1,0,0)*euler(0,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.2)*euler(.2,0,0)*euler(0,0,0),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,.3)*euler(1.7,0,-.2)*euler(0,1.57,0),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,.3)*euler(1.7,0,.2)*euler(0,-1.57,0),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(1.1,-.8,-.2)*euler(0,1.57,0)*euler(-.1,0,.2)*euler(0,0,0),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*euler(0,-1.57,0)*euler(0,0,.1),.2)
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
if Rooted.Value==false then Torso.Velocity=RootPart.CFrame.lookVector*50 end
so("200632370",Torso,1,1)
--con1=hitbox.Touched:connect(function(hit) Damagefunc(hit,6,8,math.random(5,10),"Normal",RootPart,.5,1,math.random(10,13),nil,true) end) 
hbwld.Parent=nil
hboxpos.Parent=hitbox
hitbox.Parent=modelzorz
hitbox.Size=vt(1.5,2.5,1.5)
hitboxCF=LeftArm.CFrame
hitbox.CFrame=hitboxCF
hitboxCF=RightArm.CFrame
hitbox.CFrame=hitboxCF
for i=0,1,0.1 do
swait()
hitboxCF=LeftArm.CFrame
hitbox.CFrame=hitboxCF
MagniDamage(hitbox,3,6,8,math.random(5,10),"Normal",RootPart,.5,1,math.random(10,13),nil,true)
hitboxCF=RightArm.CFrame
hitbox.CFrame=hitboxCF
MagniDamage(hitbox,3,6,8,math.random(5,10),"Normal",RootPart,.5,1,math.random(10,13),nil,true)
Neck.C0=clerp(Neck.C0,necko*euler(.1,0,0)*euler(0,0,0),.5)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.2)*euler(.2,0,0)*euler(0,0,0),.5)
RW.C0=clerp(RW.C0,cf(1,0.5,-.5)*euler(1.7,0,-.2)*euler(0,1.57,0),.5)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.5)
LW.C0=clerp(LW.C0,cf(-1,0.5,-.5)*euler(1.7,0,.2)*euler(0,-1.57,0),.5)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.5)
RH.C0=clerp(RH.C0,cf(1.1,-.8,-.2)*euler(0,1.57,0)*euler(-.1,0,.2)*euler(0,0,0),.5)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*euler(0,-1.57,0)*euler(0,0,.1),.5)
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
--con1:disconnect()
hitbox.Parent=modelzorz
hitbox.Size=vt()
hitboxweld()
hboxpos.Parent=nil
attack=false
end

function Transposition()
attack=true
targ=nil
hum=nil
if MMouse.Target~=nil then
if MMouse.Target.Parent:findFirstChild("Humanoid")~=nil and MMouse.Target.Parent:findFirstChild("Torso")~=nil then
print(MMouse.Target.Parent)
targ=MMouse.Target.Parent.Torso
hum=MMouse.Target.Parent.Humanoid
for i=1,#BloodAllies do
if BloodAllies[i][1]==targ.Parent then
targ=nil
hum=nil
break
end
end
end
end
if targ~=nil then
local BodGy=Instance.new("BodyGyro",RootPart)
BodGy.maxTorque=Vector3.new(0,math.huge,0)
BodGy.P=2000
BodGy.D=100
BodGy.cframe=cf(Torso.Position,targ.Position)
for i=0,1,0.1 do
swait()
BodGy.cframe=cf(Torso.Position,targ.Position)
Neck.C0=clerp(Neck.C0,necko*euler(.1,0,0)*euler(0,0,0),.5)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.2)*euler(.2,0,0)*euler(0,0,0),.5)
RW.C0=clerp(RW.C0,cf(1,0.5,-.5)*euler(1.7,0,-.2)*euler(0,1.57,0),.5)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.5)
LW.C0=clerp(LW.C0,cf(-1,0.5,-.5)*euler(1.7,0,.2)*euler(0,-1.57,0),.5)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.5)
RH.C0=clerp(RH.C0,cf(1.1,-.8,-.2)*euler(0,1.57,0)*euler(-.1,0,.2)*euler(0,0,0),.5)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*euler(0,-1.57,0)*euler(0,0,.1),.5)
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
ref=part(3,workspace,0,1,BrickColor.new("Black"),"Reference",vt())
ref.Anchored=true
ref.CFrame=cf(RootPart.Position)
game:GetService("Debris"):AddItem(ref,10)
healthdam=math.floor(Humanoid.Health*.2)
if isjugg==false then
Humanoid:TakeDamage(healthdam)
showDamage(Character,healthdam,"Damage")
end
so("206082357",RootPart,1,1)
so("206082357",targ,1,1)
if MMouse.Target~=nil then
if game.Players:GetPlayerFromCharacter(MMouse.Target.Parent)~=nil and Player.Neutral==false then --check
if game.Players:GetPlayerFromCharacter(MMouse.Target.Parent).TeamColor==Player.TeamColor then 
hum.Health=hum.Health+healthdam
showDamage(targ.Parent,healthdam,"Heal")
DecreaseStat(targ.Parent,"Defense",-.2,1000)
else
hum.Health=hum.Health-healthdam
showDamage(targ.Parent,healthdam,"Damage")
end
end
end
table.insert(BloodAllies,{targ.Parent,hum.Health})
for i=0,50 do
swait()
local mag=(RootPart.Position-targ.Position).magnitude
ref.CFrame=cf(RootPart.Position,targ.Position)
BodGy.cframe=cf(Torso.Position,targ.Position)
MagicBlock(BrickColor.new(NewCol),cf(targ.Position)*cf(math.random(-500,500)/100,math.random(-500,500)/100,math.random(-500,500)/100),1,1,1,.5,.5,.5,.05,1)
MagicCircle2(BrickColor.new(NewCol),ref.CFrame*euler(1.57,0,0)*cf(math.random(-400,400)/100,0,math.random(-400,400)/100),2,10,2,-.1,mag/20,-.1,.05,-mag/20)
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
ref.Parent=nil
BodGy.Parent=nil
end
attack=false
end

function do1()
if attack==true then return end
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then return end
if cooldowns[1]>=cooldownmax and mana.Value>=20 then
--if true then
attack=true
cooldowns[1]=0
mana.Value=mana.Value-20
bloodtrue=false
if blood>=40 then
bloodtrue=true
blood=blood-40
end
for di=1,2 do
for i=0,1,0.2 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(0,0,-1.2)*euler(.2,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(0,0,1.2),.45)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(.2,0,1)*euler(0,0,0),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-.2,0,-1.5)*euler(0,0,0),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(.9,-1,.3)*euler(0,1.57,0)*euler(0,-1.2,-.1),.4)
LH.C0=clerp(LH.C0,cf(-.9,-1,-.3)*euler(0,-1.57,0)*euler(0,-1.2,.1),.4)
end
so("200632370",LeftArm,.6,1)
if Rooted.Value==false then Torso.Velocity=RootPart.CFrame.lookVector*40 end
--con1=hitbox.Touched:connect(function(hit) Damagefunc(hit,6,7,math.random(5,10),"Normal",RootPart,.2,2,math.random(8,10),nil,true,false,"Defense",.05,200) end) 
hbwld.Parent=nil
hboxpos.Parent=hitbox
hitbox.Parent=modelzorz
hitbox.Size=vt(3,5,3)
hitboxCF=LeftArm.CFrame
hitbox.CFrame=hitboxCF
for i=0,1,0.15 do
swait()
MagicBlock(BrickColor.new(NewCol),LeftArm.CFrame*cf(0,-1,0),1,1,1,1,1,1,.1,2)
hitboxCF=LeftArm.CFrame
hitbox.CFrame=hitboxCF
MagniDamage(hitbox,4,6,7,math.random(5,10),"Normal",RootPart,.4,2,math.random(8,10),nil,true,false,"Defense",.05,200)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,1)*euler(.2,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(0,0,-1),.45)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(-.2,0,1)*euler(0,0,0),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1.57,0,-.3)*euler(0,-1.57,0),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(.9,-1,-.3)*euler(0,1.57,0)*euler(0,1,-.1),.4)
LH.C0=clerp(LH.C0,cf(-.9,-1,.3)*euler(0,-1.57,0)*euler(0,1,.1),.4)
if di==2 then
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
end
if bloodtrue==true then
ref=part(3,workspace,0,1,BrickColor.new("Black"),"Reference",vt())
ref.Anchored=true
ref.CFrame=LeftArm.CFrame*cf(0,-1,0)
so("206082273",ref,1,1)
game:GetService("Debris"):AddItem(ref,1)
MagniDamage(ref,10,6,7,math.random(10,15),"Knockdown2",ref,0,1,math.random(10,15),nil,nil,true,"Defense",.05,200)
MagicBlock(BrickColor.new(NewCol),cf(ref.Position),5,5,5,3,3,3,.05,1)
MagicCircle(BrickColor.new(NewCol),cf(ref.Position),5,5,5,10,10,10,.1,1)
for i=1,5 do
BreakEffect(BrickColor.new(NewCol),cf(ref.Position),.5,math.random(500,1000)/100,.5)
end
end
--con1:disconnect()
hitbox.Parent=modelzorz
hitbox.Size=vt()
hitboxweld()
hboxpos.Parent=nil
for i=0,1,0.2 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(0,0,1.2)*euler(.2,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(0,0,-1.2),.45)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(.2,0,1.5)*euler(0,0,0),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-.2,0,-1)*euler(0,0,0),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(.9,-1,-.3)*euler(0,1.57,0)*euler(0,1.2,-.1),.4)
LH.C0=clerp(LH.C0,cf(-.9,-1,.3)*euler(0,-1.57,0)*euler(0,1.2,.1),.4)
end
so("200632370",RightArm,.6,1)
if Rooted.Value==false then Torso.Velocity=RootPart.CFrame.lookVector*40 end
--con1=hitbox.Touched:connect(function(hit) Damagefunc(hit,6,7,math.random(5,10),"Normal",RootPart,.2,2,math.random(8,10),nil,true,false,"Defense",.05,200) end) 
hbwld.Parent=nil
hboxpos.Parent=hitbox
hitbox.Parent=modelzorz
hitbox.Size=vt(3,5,3)
hitboxCF=RightArm.CFrame
hitbox.CFrame=hitboxCF
for i=0,1,0.15 do
swait()
MagicBlock(BrickColor.new(NewCol),RightArm.CFrame*cf(0,-1,0),1,1,1,1,1,1,.1,2)
hitboxCF=RightArm.CFrame
hitbox.CFrame=hitboxCF
MagniDamage(hitbox,4,6,7,math.random(5,10),"Normal",RootPart,.4,2,math.random(8,10),nil,true,false,"Defense",.05,200)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,-1)*euler(.2,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(0,0,1),.45)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(1.57,0,.3)*euler(0,1.57,0),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-.2,0,-1)*euler(0,0,0),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(.9,-1,.3)*euler(0,1.57,0)*euler(0,-1,-.1),.4)
LH.C0=clerp(LH.C0,cf(-.9,-1,-.3)*euler(0,-1.57,0)*euler(0,-1,.1),.4)
if di==2 then
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
end

if bloodtrue==true then
ref=part(3,workspace,0,1,BrickColor.new("Black"),"Reference",vt())
ref.Anchored=true
ref.CFrame=RightArm.CFrame*cf(0,-1,0)
so("206082273",ref,1,1)
game:GetService("Debris"):AddItem(ref,1)
MagniDamage(ref,10,6,7,math.random(10,15),"Knockdown2",ref,0,1,math.random(10,15),nil,nil,true,"Defense",.05,200)
MagicBlock(BrickColor.new(NewCol),cf(ref.Position),5,5,5,3,3,3,.05,1)
MagicCircle(BrickColor.new(NewCol),cf(ref.Position),5,5,5,10,10,10,.1,1)
for i=1,5 do
BreakEffect(BrickColor.new(NewCol),cf(ref.Position),.5,math.random(500,1000)/100,.5)
end
end
--con1:disconnect()
hitbox.Parent=modelzorz
hitbox.Size=vt()
hitboxweld()
hboxpos.Parent=nil
end
attack=false
end
end

function MUDAMUDAMUDAMUDAMUDAMUDA()
if attack==true then return end
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then return end
bloodtrue=true
local s = so("316900066",workspace,1,1)
wait(2.7)
attack=true
for di=1,21 do
for i=0,1,0.7 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(0,0,-1.2)*euler(.2,0,0),.7)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(0,0,1.2),.7)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(.2,0,1)*euler(0,0,0),.7)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.7)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-.2,0,-1.5)*euler(0,0,0),.7)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.7)
RH.C0=clerp(RH.C0,cf(.9,-1,.3)*euler(0,1.57,0)*euler(0,-1.2,-.1),.7)
LH.C0=clerp(LH.C0,cf(-.9,-1,-.3)*euler(0,-1.57,0)*euler(0,-1.2,.1),.7)
end
so("200632370",LeftArm,.6,1)
--if Rooted.Value==false then Torso.Velocity=RootPart.CFrame.lookVector*40 end
--con1=hitbox.Touched:connect(function(hit) Damagefunc(hit,6,7,math.random(5,10),"Normal",RootPart,.2,2,math.random(8,10),nil,true,false,"Defense",.05,200) end) 
hbwld.Parent=nil
hboxpos.Parent=hitbox
hitbox.Parent=modelzorz
hitbox.Size=vt(3,5,3)
hitboxCF=LeftArm.CFrame
hitbox.CFrame=hitboxCF
for i=0,1,0.7 do
swait()
MagicBlock(BrickColor.new(NewCol),LeftArm.CFrame*cf(0,-1,0),1,1,1,1,1,1,.1,2)
hitboxCF=LeftArm.CFrame
hitbox.CFrame=hitboxCF
MagniDamage(hitbox,4,6,7,math.random(5,10),"Normal",RootPart,.4,2,math.random(8,10),nil,true,false,"Defense",.05,200)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,1)*euler(.2,0,0),.7)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(0,0,-1),.7)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(-.2,0,1)*euler(0,0,0),.7)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.7)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1.57,0,-.3)*euler(0,-1.57,0),.7)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.7)
RH.C0=clerp(RH.C0,cf(.9,-1,-.3)*euler(0,1.57,0)*euler(0,1,-.1),.7)
LH.C0=clerp(LH.C0,cf(-.9,-1,.3)*euler(0,-1.57,0)*euler(0,1,.1),.7)
if di==2 then
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
end
if bloodtrue==true then
ref=part(3,workspace,0,1,BrickColor.new("Black"),"Reference",vt())
ref.Anchored=true
ref.CFrame=LeftArm.CFrame*cf(0,-1,0)
so("206082273",ref,1,1)
game:GetService("Debris"):AddItem(ref,1)
MagniDamage(ref,10,6,7,math.random(10,15),"Knockdown2",ref,0,1,math.random(10,15),nil,nil,true,"Defense",.05,200)
MagicBlock(BrickColor.new(NewCol),cf(ref.Position),5,5,5,3,3,3,.05,1)
MagicCircle(BrickColor.new(NewCol),cf(ref.Position),5,5,5,10,10,10,.1,1)
for i=1,5 do
BreakEffect(BrickColor.new(NewCol),cf(ref.Position),.5,math.random(500,1000)/100,.5)
end
end
--con1:disconnect()
hitbox.Parent=modelzorz
hitbox.Size=vt()
hitboxweld()
hboxpos.Parent=nil
for i=0,1,0.7 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(0,0,1.2)*euler(.2,0,0),.7)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(0,0,-1.2),.7)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(.2,0,1.5)*euler(0,0,0),.7)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.7)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-.2,0,-1)*euler(0,0,0),.7)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.7)
RH.C0=clerp(RH.C0,cf(.9,-1,-.3)*euler(0,1.57,0)*euler(0,1.2,-.1),.7)
LH.C0=clerp(LH.C0,cf(-.9,-1,.3)*euler(0,-1.57,0)*euler(0,1.2,.1),.7)
end
so("200632370",RightArm,.6,1)
--if Rooted.Value==false then Torso.Velocity=RootPart.CFrame.lookVector*40 end
--con1=hitbox.Touched:connect(function(hit) Damagefunc(hit,6,7,math.random(5,10),"Normal",RootPart,.2,2,math.random(8,10),nil,true,false,"Defense",.05,200) end) 
hbwld.Parent=nil
hboxpos.Parent=hitbox
hitbox.Parent=modelzorz
hitbox.Size=vt(3,5,3)
hitboxCF=RightArm.CFrame
hitbox.CFrame=hitboxCF
for i=0,1,0.7 do
swait()
MagicBlock(BrickColor.new(NewCol),RightArm.CFrame*cf(0,-1,0),1,1,1,1,1,1,.1,2)
hitboxCF=RightArm.CFrame
hitbox.CFrame=hitboxCF
MagniDamage(hitbox,4,6,7,math.random(5,10),"Normal",RootPart,.4,2,math.random(8,10),nil,true,false,"Defense",.05,200)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,-1)*euler(.2,0,0),.7)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(0,0,1),.7)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(1.57,0,.3)*euler(0,1.57,0),.7)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.7)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-.2,0,-1)*euler(0,0,0),.7)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.7)
RH.C0=clerp(RH.C0,cf(.9,-1,.3)*euler(0,1.57,0)*euler(0,-1,-.1),.7)
LH.C0=clerp(LH.C0,cf(-.9,-1,-.3)*euler(0,-1.57,0)*euler(0,-1,.1),.7)
if di==2 then
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
end
if bloodtrue==true then
ref=part(3,workspace,0,1,BrickColor.new("Black"),"Reference",vt())
ref.Anchored=true
ref.CFrame=RightArm.CFrame*cf(0,-1,0)
so("206082273",ref,1,1)
game:GetService("Debris"):AddItem(ref,1)
MagniDamage(ref,10,6,7,math.random(10,15),"Knockdown2",ref,0,1,math.random(10,15),nil,nil,true,"Defense",.05,200)
MagicBlock(BrickColor.new(NewCol),cf(ref.Position),5,5,5,3,3,3,.05,1)
MagicCircle(BrickColor.new(NewCol),cf(ref.Position),5,5,5,10,10,10,.1,1)
for i=1,5 do
BreakEffect(BrickColor.new(NewCol),cf(ref.Position),.5,math.random(500,1000)/100,.5)
end
end
--con1:disconnect()
hitbox.Parent=modelzorz
hitbox.Size=vt()
hitboxweld()
hboxpos.Parent=nil
end
for i=0,1,0.008 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(0,0,-1.2)*euler(.2,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(0,0,1.2),.45)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(.2,0,1)*euler(0,0,0),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-.2,0,-1.5)*euler(0,0,0),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(.9,-1,.3)*euler(0,1.57,0)*euler(0,-1.2,-.1),.4)
LH.C0=clerp(LH.C0,cf(-.9,-1,-.3)*euler(0,-1.57,0)*euler(0,-1.2,.1),.4)
end
local dec=Instance.new("NumberValue",Decrease)
dec.Name="DecreaseMvmt"
dec.Value=0
local dec2=Instance.new("NumberValue")
hbwld.Parent=nil
hboxpos.Parent=hitbox
hitbox.Parent=modelzorz
hitbox.Size=vt(3,5,3)
hitboxCF=LeftArm.CFrame
hitbox.CFrame=hitboxCF
for i=0,1,0.06 do
swait()
hitboxCF=LeftArm.CFrame
hitbox.CFrame=hitboxCF
MagniDamage(hitbox,5,5,10,1,"Normal",RootPart,0,2,math.random(5,10),nil,true,false,nil,nil,nil)
Neck.C0=clerp(Neck.C0,necko*euler(.3,0,1.2)*euler(.2,0,0),.4)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.2)*euler(0,0,-1.57),.4)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(.6,0,.2)*euler(0,0,0),.4)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1.5,0,-1.2)*euler(0,-1,0),.4)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
RH.C0=clerp(RH.C0,cf(.6,-1,-.4)*euler(0,1.57,0)*euler(0,1.2,-.1),.3)
LH.C0=clerp(LH.C0,cf(-.6,-.9,.4)*euler(0,-1.57,0)*euler(0,1.2,.1),.3)
if HitTarget~=nil then break end
if bloodtrue==true then
ref=part(3,workspace,0,1,BrickColor.new("Black"),"Reference",vt())
ref.Anchored=true
ref.CFrame=LeftArm.CFrame*cf(0,-1,0)
so("206082273",ref,1,1)
game:GetService("Debris"):AddItem(ref,1)
MagniDamage(ref,10,6,7,math.random(10,15),"Knockdown2",ref,0,1,math.random(10,15),nil,nil,true,"Defense",.05,200)
MagicBlock(BrickColor.new(NewCol),cf(ref.Position),5,5,5,3,3,3,.05,1)
MagicCircle(BrickColor.new(NewCol),cf(ref.Position),5,5,5,10,10,10,.1,1)
for i=1,5 do
BreakEffect(BrickColor.new(NewCol),cf(ref.Position),.5,math.random(500,1000)/100,.5)
end
end
end
for i=0,1,0.1 do
swait()
if HitTarget~=nil then
RootPart.CFrame=cf(RootPart.Position,HitTarget.Torso.Position)
end
Neck.C0=clerp(Neck.C0,necko*euler(.2,0,0)*euler(0,0,0),.4)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.5)*euler(.1,0,0),.4)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(1,0,1)*euler(0,0,0),.4)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1,0,-1)*euler(0,0,0),.4)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
RH.C0=clerp(RH.C0,cf(1,-.6,-.4)*euler(0,1.57,0)*euler(0,0,.2),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*euler(0,-1.57,0)*euler(0,0,.5),.3)
end
for i=0,1,0.3 do
swait()
if HitTarget~=nil then
RootPart.CFrame=cf(RootPart.Position,HitTarget.Torso.Position)
end
Neck.C0=clerp(Neck.C0,necko*euler(-.2,0,0)*euler(0,0,0),.5)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-2,0)*euler(-1.57,0,0),.5)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(1,0,1.57)*euler(0,0,0),.5)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.5)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1,0,-1.57)*euler(0,0,0),.5)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.5)
RH.C0=clerp(RH.C0,cf(1,-1,0)*euler(0,1.57,0)*euler(0,0,0),.5)
LH.C0=clerp(LH.C0,cf(-1,-.8,-.2)*euler(0,-1.57,0)*euler(0,0,1),.5)
end
cooldowns[4]=0
mana.Value=mana.Value-40
dam=((Humanoid.MaxHealth-Humanoid.Health)/5)+blood/3
dam2=dam/1.5
print(dam2)
print(dam)
so("206082327",Torso,1,1)
so("199145534",Torso,1,.8)
blood=0
for i=1,2 do
MagicBlock(BrickColor.new("Really red"),cf(Torso.Position),1,1,1,5,5,5,.05,1)
MagicRing(BrickColor.new("Really red"),cf(Torso.Position)*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,1,.1,.5,.5,.1,.01)
end
MagicCircle(BrickColor.new("Really red"),cf(Torso.Position),1,1,1,2,2,2,.02)
local num=0
local eul=CFrame.fromEulerAnglesXYZ(math.random(-50,50),math.random(-50,50),math.random(-50,50))
for i=1,6 do
MagicCircle2(BrickColor.new("Really red"),cf(Torso.Position)*eul*euler(num,0,0),3,20,3,-.02,3,-.02,0.02,1)
MagicCircle2(BrickColor.new("Really red"),cf(Torso.Position)*eul*euler(0,1.57,0)*euler(num,0,0),3,20,3,-.02,3,-.02,0.02,1)
num=num+1.046
end
if Rooted.Value==false then Torso.Velocity=(RootPart.CFrame.lookVector*-50)+(vt(0,1,0)*100) end
for i=0,1,0.2 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(-.2,0,0)*euler(0,0,0),.4)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*euler(-4,0,0),.4)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(1,0,1.57)*euler(0,0,0),.4)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1,0,-1.57)*euler(0,0,0),.4)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
RH.C0=clerp(RH.C0,cf(1,-1,0)*euler(0,1.57,0)*euler(0,0,0),.3)
LH.C0=clerp(LH.C0,cf(-1,-.8,-.2)*euler(0,-1.57,0)*euler(0,0,1),.3)
end
attack=false
end

function do2()
if attack==true then return end
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then return end
condition=false
if cooldowns[2]>=cooldownmax and mana.Value>=25 then
--if true then
condition=true
end
doing2=true
if move2=="(X)\
Assault" then
condition=true
end
if condition==true then
attack=true
if BoundTarget==nil then
mana.Value=mana.Value-20
for i=0,1,0.1 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(0,0,-.7)*euler(.2,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(-.2,0,.6),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(.4,0,.4)*euler(0,.4,0),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-1,0,-1.5)*euler(0,2.5,0),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(1,-.7,0)*euler(0,1.57,0)*euler(-.2,-.2,.2),.3)
LH.C0=clerp(LH.C0,cf(-1,-.8,0)*euler(0,-1.57,0)*euler(-.2,0,.4),.3)
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
cooldowns[2]=0
local hit=nil
--[[con1=hitbox.Touched:connect(function(hit) 
h=hit.Parent:FindFirstChild("Humanoid")
for _,v in pairs(hit.Parent:children()) do
if v:IsA("Humanoid") then
h=v
end
end
if hit.Parent.Parent:FindFirstChild("Torso")~=nil then
h=hit.Parent.Parent:FindFirstChild("Humanoid")
end
if hit.Parent.className=="Hat" then
hit=hit.Parent.Parent:findFirstChild("Head")
end
if h~=nil and hit.Parent.Name~=Character.Name and hit.Parent:FindFirstChild("Torso")~=nil then
if hit.Parent:findFirstChild("DebounceHit")~=nil then if hit.Parent.DebounceHit.Value==true then return end end
if Player.Neutral==false and game.Players:GetPlayerFromCharacter(hit.Parent)~=nil then
if game.Players:GetPlayerFromCharacter(hit.Parent).TeamColor==Player.TeamColor then return end
end
if BoundTarget==nil then
so("200632875",hit,1,1)
cooldownsadd[2]=.1
Damagefunc(hit,6,8,math.random(20,40),"Normal",RootPart,.5,1,math.random(5,10),nil,true,false,"Movement",.2,200)
BoundTarget=hit.Parent
table.insert(Effects,{BoundTarget,"BloodBind",0,BoundTarget.Torso,cf(0,0,0)})
--table.insert(Effects,{BoundTarget,"BloodBind",0,BoundTarget.Torso,cf(0,0,0)})
local num=0
local eul=CFrame.fromEulerAnglesXYZ(math.random(-50,50),math.random(-50,50),math.random(-50,50))
for i=1,6 do
MagicCircle2(BrickColor.new(NewCol),cf(hit.Position)*eul*euler(num,0,0),1,10,1,-.02,.3,-.02,0.05,.6)
MagicCircle2(BrickColor.new(NewCol),cf(hit.Position)*eul*euler(0,1.57,0)*euler(num,0,0),1,10,1,-.02,.3,-.02,0.05,.6)
num=num+1.046
end
move2="(X)\
Assault"
end
end
end) ]]
hbwld.Parent=nil
hboxpos.Parent=hitbox
hitbox.Parent=modelzorz
hitbox.Size=vt(1.5,2.5,1.5)
hitboxCF=LeftArm.CFrame
hitbox.CFrame=hitboxCF
for i=0,1,.2 do
swait()
hitboxCF=LeftArm.CFrame
hitbox.CFrame=hitboxCF
MagniDamage(hitbox,4,6,8,math.random(20,40),"Normal",RootPart,.5,1,math.random(5,10),nil,true,false,"Movement",.2,200)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,1)*euler(-.1,0,0),.4)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(.2,0,-1),.4)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(-.4,0,.4),.4)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1.5,0,-1),.4)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
RH.C0=clerp(RH.C0,cf(1,-1,0)*euler(0,1.57,0)*euler(-.2,.2,-.4),.4)
LH.C0=clerp(LH.C0,cf(-.8,-.8,.4)*euler(0,-1.57,0)*euler(-.2,1,-.1),.4)
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
for i=0,1,.05 do
swait()
hitboxCF=LeftArm.CFrame
hitbox.CFrame=hitboxCF
MagniDamage(hitbox,4,6,8,math.random(20,40),"Normal",RootPart,.5,1,math.random(5,10),nil,true,false,"Movement",.2,200)
Neck.C0=clerp(Neck.C0,necko*euler(0,0,1)*euler(-.1,0,0),.15)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(.2,0,-1.2),.15)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(-.4,0,.4),.15)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.15)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1.5,0,-.5),.15)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.15)
RH.C0=clerp(RH.C0,cf(1,-1,0)*euler(0,1.57,0)*euler(-.2,.2,-.4),.15)
LH.C0=clerp(LH.C0,cf(-.8,-.8,.5)*euler(0,-1.57,0)*euler(-.2,1.2,-.1),.15)
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
--con1:disconnect()
hitbox.Parent=modelzorz
hitbox.Size=vt()
hitboxweld()
hboxpos.Parent=nil
print(hit)
else
move2="(X)\
Blood Bind"
for i=0,1,0.2 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(-.4,0,-.2),.4)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-1.5)*euler(.8,0,.5),.4)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(1.4,0,.5),.4)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-0.2,0,-0.4),.4)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
RH.C0=clerp(RH.C0,RHC0*cf(0,0,0)*euler(0,-.5,-.5),.4)
LH.C0=clerp(LH.C0,LHC0*cf(-0.5,1,0)*euler(.5,0,-.5),.4)
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
cooldownsadd[2]=.2
cooldowns[2]=cooldownmax
if BoundTarget~=nil then
if blood>=30 then
blood=blood-30
DecreaseStat(BoundTarget,"Damage",.2,400)
for i=1,10 do
BreakEffect(BrickColor.new(NewCol),cf(BoundTarget.Torso.Position),.5,math.random(500,1000)/100,.5)
end
end
Damagefunc(BoundTarget.Torso,8,8,math.random(-30,-20),"Knockdown2",RootPart,.5,1,math.random(5,10),nil,true,false,"Movement",.2,200)
if BoundTarget:findFirstChild("Torso")~=nil then
so("199145477",RootPart,1,1.5)
MagicSpecial(BrickColor.new(NewCol),cf(Torso.Position),3,3,3,1,1,1,.05)
RootPart.CFrame=cf(BoundTarget.Torso.Position)*cf(math.random(-500,500)/100,math.random(50,100)/100,math.random(-500,500)/100)
RootPart.Velocity=vt(0,0,0)
MagicSpecial(BrickColor.new(NewCol),cf(Torso.Position),3,3,3,1,1,1,.05)
end
end
BoundTarget=nil
swait(10)
cooldowns[2]=0
end
attack=false
end
doing2=false
end

function do3()
if attack==true then return end
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then return end
if cooldowns[3]>=cooldownmax and mana.Value>=40 then
--if true then
attack=true
cooldowns[3]=0
mana.Value=mana.Value-40
for i=0,1,0.1 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(0,0,1)*euler(0,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.2)*euler(0,0,-1),.3)
RW.C0=clerp(RW.C0,cf(1,0.5,-.5)*euler(1.57,0,-1.2),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1,0,-.1),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(.8,-1,-.4)*euler(0,1.57,0)*euler(0,1,-.1),.4)
LH.C0=clerp(LH.C0,cf(-.8,-.9,.4)*euler(0,-1.57,0)*euler(0,1,.1),.4)
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then
break
end
end
so("199145497",RootPart,1,1)
hitted=false
--con1=hitbox.Touched:connect(function(hit) Damagefunc(hit,10,10,math.random(20,40),"Knockdown2",RootPart,.5,2,math.random(20,20),true,true) end) 
hbwld.Parent=nil
hboxpos.Parent=hitbox
hitbox.Parent=modelzorz
hitbox.Size=vt(1.5,2.5,1.5)
hitboxCF=RightArm.CFrame
hitbox.CFrame=hitboxCF
for i=0,40 do
swait()
if i%10==0 then
ref=part(3,workspace,0,1,BrickColor.new("Black"),"Reference",vt())
ref.Anchored=true
ref.CFrame=cf(RootPart.Position)
hitfloor2,posfloor2=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,50,Character)
if hitfloor2~=nil then
so("199145477",ref,1,1.2)
ref.CFrame=cf(posfloor2)
MagniDamage(ref,10,6,8,math.random(10,20),"Knockdown2",ref,0,1,math.random(10,15),nil,nil,true,"Damage",.1,200)
col=hitfloor2.BrickColor
MagicWave(col,cf(posfloor2),1,3,1,2,.5,2,.1)
for i=1,5 do
local groundpart=part(3,workspace,0,0,col,"Ground",vt(math.random(50,200)/100,math.random(50,200)/100,math.random(50,200)/100))
groundpart.Anchored=true
groundpart.Material=hitfloor2.Material
groundpart.CanCollide=true
groundpart.CFrame=cf(ref.Position)*cf(math.random(-500,500)/100,0,math.random(-500,500)/100)*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
game:GetService("Debris"):AddItem(groundpart,5)
end
end
game:GetService("Debris"):AddItem(ref,1)
end
hitboxCF=RightArm.CFrame
hitbox.CFrame=hitboxCF
MagniDamage(hitbox,3,10,10,math.random(20,40),"Knockdown2",RootPart,.5,2,math.random(20,20),true,true)
if Rooted.Value==false then Torso.Velocity=RootPart.CFrame.lookVector*60 end
Neck.C0=clerp(Neck.C0,necko*euler(0,0,-1.57)*euler(0,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.2)*euler(0,0,1.57),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(1.57,0,1.57)*euler(0,1.57,0),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(.5,0,-1),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(.6,-1,.4)*euler(0,1.57,0)*euler(.2,-1.57,0),.2)
LH.C0=clerp(LH.C0,cf(-.6,-1,-.4)*euler(0,-1.57,0)*euler(-.4,-1.57,0),.2)
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true or hitted==true then
break
end
end
--con1:disconnect()
hitbox.Parent=modelzorz
hitbox.Size=vt()
hitboxweld()
hboxpos.Parent=nil
attack=false
end
end

function do4()
if attack==true then return end
if Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true then return end
if cooldowns[4]>=cooldownmax and mana.Value>=40 and blood>=25 then
--if true then
doing4=true
attack=true
for i=0,1,0.1 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(0,0,-1.2)*euler(.2,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(0,0,1.2),.45)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(.2,0,1)*euler(0,0,0),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-.2,0,-1.5)*euler(0,0,0),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(.9,-1,.3)*euler(0,1.57,0)*euler(0,-1.2,-.1),.4)
LH.C0=clerp(LH.C0,cf(-.9,-1,-.3)*euler(0,-1.57,0)*euler(0,-1.2,.1),.4)
end
local dec=Instance.new("NumberValue",Decrease)
dec.Name="DecreaseMvmt"
dec.Value=0
local dec2=Instance.new("NumberValue")
hbwld.Parent=nil
hboxpos.Parent=hitbox
hitbox.Parent=modelzorz
hitbox.Size=vt(3,5,3)
hitboxCF=LeftArm.CFrame
hitbox.CFrame=hitboxCF
for i=0,1,0.05 do
swait()
hitboxCF=LeftArm.CFrame
hitbox.CFrame=hitboxCF
MagniDamage(hitbox,5,5,10,1,"Normal",RootPart,0,2,math.random(5,10),nil,true,false,nil,nil,nil)
Neck.C0=clerp(Neck.C0,necko*euler(.3,0,1.2)*euler(.2,0,0),.4)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.2)*euler(0,0,-1.57),.4)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(.6,0,.2)*euler(0,0,0),.4)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1.5,0,-1.2)*euler(0,-1,0),.4)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
RH.C0=clerp(RH.C0,cf(.6,-1,-.4)*euler(0,1.57,0)*euler(0,1.2,-.1),.3)
LH.C0=clerp(LH.C0,cf(-.6,-.9,.4)*euler(0,-1.57,0)*euler(0,1.2,.1),.3)
if HitTarget~=nil then break end
end
--con1:disconnect()
hitbox.Parent=modelzorz
hitbox.Size=vt()
hitboxweld()
hboxpos.Parent=nil
if HitTarget~=nil then
dec.Value=10
if HitTarget:findFirstChild("Stats")~=nil then
dec2.Parent=HitTarget.Stats.Decrease
dec2.Name="DecreaseMvmt"
dec2.Value=10
end
for i=0,1,0.1 do
swait()
if HitTarget~=nil then
RootPart.CFrame=cf(RootPart.Position,HitTarget.Torso.Position)
end
Neck.C0=clerp(Neck.C0,necko*euler(.2,0,0)*euler(0,0,0),.4)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.5)*euler(.1,0,0),.4)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(1,0,1)*euler(0,0,0),.4)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1,0,-1)*euler(0,0,0),.4)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
RH.C0=clerp(RH.C0,cf(1,-.6,-.4)*euler(0,1.57,0)*euler(0,0,.2),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*euler(0,-1.57,0)*euler(0,0,.5),.3)
end
for i=0,1,0.3 do
swait()
if HitTarget~=nil then
RootPart.CFrame=cf(RootPart.Position,HitTarget.Torso.Position)
end
Neck.C0=clerp(Neck.C0,necko*euler(-.2,0,0)*euler(0,0,0),.5)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-2,0)*euler(-1.57,0,0),.5)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(1,0,1.57)*euler(0,0,0),.5)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.5)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1,0,-1.57)*euler(0,0,0),.5)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.5)
RH.C0=clerp(RH.C0,cf(1,-1,0)*euler(0,1.57,0)*euler(0,0,0),.5)
LH.C0=clerp(LH.C0,cf(-1,-.8,-.2)*euler(0,-1.57,0)*euler(0,0,1),.5)
end
cooldowns[4]=0
mana.Value=mana.Value-40
dam=((Humanoid.MaxHealth-Humanoid.Health)/5)+blood/3
dam2=dam/1.5
print(dam2)
print(dam)
Damagefunc(HitTarget.Torso,dam2,dam,50,"Knockdown2",RootPart,1,2,50,nil,true,false)
so("206082327",HitTarget.Torso,1,1)
so("199145534",HitTarget.Torso,1,.8)
blood=0
for i=1,2 do
MagicBlock(BrickColor.new("Really red"),cf(HitTarget.Torso.Position),1,1,1,5,5,5,.05,1)
MagicRing(BrickColor.new("Really red"),cf(HitTarget.Torso.Position)*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,1,.1,.5,.5,.1,.01)
end
MagicCircle(BrickColor.new("Really red"),cf(HitTarget.Torso.Position),1,1,1,2,2,2,.02)
local num=0
local eul=CFrame.fromEulerAnglesXYZ(math.random(-50,50),math.random(-50,50),math.random(-50,50))
for i=1,6 do
MagicCircle2(BrickColor.new("Really red"),cf(HitTarget.Torso.Position)*eul*euler(num,0,0),3,20,3,-.02,3,-.02,0.02,1)
MagicCircle2(BrickColor.new("Really red"),cf(HitTarget.Torso.Position)*eul*euler(0,1.57,0)*euler(num,0,0),3,20,3,-.02,3,-.02,0.02,1)
num=num+1.046
end
if Rooted.Value==false then Torso.Velocity=(RootPart.CFrame.lookVector*-50)+(vt(0,1,0)*100) end
for i=0,1,0.2 do
swait()
Neck.C0=clerp(Neck.C0,necko*euler(-.2,0,0)*euler(0,0,0),.4)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*euler(-4,0,0),.4)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(1,0,1.57)*euler(0,0,0),.4)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1,0,-1.57)*euler(0,0,0),.4)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
RH.C0=clerp(RH.C0,cf(1,-1,0)*euler(0,1.57,0)*euler(0,0,0),.3)
LH.C0=clerp(LH.C0,cf(-1,-.8,-.2)*euler(0,-1.57,0)*euler(0,0,1),.3)
end
Stagger.Value=false
StaggerHit.Value=false
else
cooldowns[4]=80
end
dec2.Parent=nil
dec.Parent=nil
HitTarget=nil
doing4=false
attack=false
end
end

function DecreaseStat(Model,Stat,Amount,Duration)
if Model:findFirstChild("Stats")~=nil then
if Model.Stats[Stat]~=nil then
Model.Stats[Stat].Value=Model.Stats[Stat].Value-Amount
d=Instance.new("NumberValue",Model.Stats.Decrease)
dur=Instance.new("NumberValue",d)
dur.Name="Duration"
dur.Value=Duration
game:GetService("Debris"):AddItem(d,20)
if Stat=="Damage" then
d.Name="DecreaseAtk"
elseif Stat=="Defense" then
d.Name="DecreaseDef"
elseif Stat=="Movement" then
d.Name="DecreaseMvmt"
end
if Model:findFirstChild("Torso")~=nil then
display=""
if Stat=="Damage" then
if Amount>0 then
display="-Damage"
else
display="+Damage"
end
elseif Stat=="Defense" then
if Amount>0 then
display="-Defense"
else
display="+Defense"
end
elseif Stat=="Movement" then
if Amount>0 then
display="-Movement"
else
display="+Movement"
end
end
showDamage(Model,display,"Debuff")
end
d.Value=Amount
end
end
end

function GetDist(Part1,Part2,magni)
local targ=Part1.Position-Part2.Position
local mag=targ.magnitude
if mag<=magni then 
return true
else
return false
end
end

function MagniDamage(Part,magni,minim,maxim,knockback,Type,Property,Delay,KnockbackType,incstun,stagger,staghit,ranged,DecreaseState,DecreaseAmount,Duration,Sound)
for _,c in pairs(workspace:children()) do
local hum=c:findFirstChild("Humanoid")
if hum~=nil then
local head=nil
for _,d in pairs(c:children()) do
--if d.Name=="Torso" or d.Name=="Head" or d.Name=="HumanoidRootPart" or d.Name=="HitPart" then
if d.className=="Model" and ranged~=true then
head=d:findFirstChild("Hitbox")
if d.Parent==Character then break end
if head~=nil then
local targ=head.Position-Part.Position
local mag=targ.magnitude
if mag<=magni and c.Name~=Player.Name then 
ref=part(3,workspace,0,1,BrickColor.new("Black"),"Reference",vt())
ref.Anchored=true
ref.CFrame=cf(head.Position)
game:GetService("Debris"):AddItem(ref,1)
hitnum=math.random(1,5)
if hitnum==1 then so("199148971",ref,1,1)
elseif hitnum==2 then so("199149025",ref,1,1)
elseif hitnum==3 then so("199149072",ref,1,1)
elseif hitnum==4 then so("199149109",ref,1,1)
elseif hitnum==5 then so("199149119",ref,1,1)
end
StaggerHit.Value=true
end
end
end
if d.className=="Part" then
head=d
if head~=nil then
local targ=head.Position-Part.Position
local mag=targ.magnitude
if mag<=magni and c.Name~=Player.Name then 
if stun==nil then
stun=math.random(5,10)
end
local Rang=nil
if Ranged==false then
Rang=true
end
local stag=nil
if shbash==true then
stag=true
end
Damagefunc(head,minim,maxim,knockback,Type,Property,Delay,KnockbackType,incstun,stagger,staghit,ranged,DecreaseState,DecreaseAmount,Duration,Sound)
--Damagefunc(hit,minim,maxim,knockback,Type,Property,Delay,KnockbackType,incstun,stagger,staghit,DecreaseState,DecreaseAmount,Duration)
end
end
end
end
end
end
end

function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
end 

local Point=Torso.CFrame*cf(0,Torso.Size.Y,0)
LastPoint=Point
function effect(Color,Ref,LP,P1,returnn)
if LP==nil or P1==nil then return end
local effectsmsh=Instance.new("CylinderMesh")
effectsmsh.Scale=Vector3.new(0.2,1,0.2)
effectsmsh.Name="Mesh"
local effectsg=Instance.new("Part")
NoOutline(effectsg)
effectsg.formFactor=3
effectsg.CanCollide=false
effectsg.Name="Eff"
effectsg.Locked=true
effectsg.Anchored=true
effectsg.Size=Vector3.new(0.5,1,0.5)
effectsg.Parent=workspace
effectsmsh.Parent=effectsg
effectsg.BrickColor=BrickColor.new(Color)
effectsg.Reflectance=Ref
local point1=P1
local mg=(LP.p - point1.p).magnitude
effectsg.Size=Vector3.new(0.5,mg,0.5)
effectsg.CFrame=cf((LP.p+point1.p)/2,point1.p) * CFrame.Angles(math.rad(90),0,0)
effectsmsh.Scale=Vector3.new(0.2,1,0.2)
game:GetService("Debris"):AddItem(effectsg,2)
if returnn then return effectsg end
if not returnn then
table.insert(Effects,{effectsg,"Cylinder",0.2,0.01,0,0.01,effectsmsh})
end
end

local function CFrameFromTopBack(at, top, back)
local right = top:Cross(back)
return CFrame.new(at.x, at.y, at.z,
right.x, top.x, back.x,
right.y, top.y, back.y,
right.z, top.z, back.z)
end

function Triangle(a, b, c)
local edg1 = (c-a):Dot((b-a).unit)
local edg2 = (a-b):Dot((c-b).unit)
local edg3 = (b-c):Dot((a-c).unit)
if edg1 <= (b-a).magnitude and edg1 >= 0 then
a, b, c = a, b, c
elseif edg2 <= (c-b).magnitude and edg2 >= 0 then
a, b, c = b, c, a
elseif edg3 <= (a-c).magnitude and edg3 >= 0 then
a, b, c = c, a, b
else 
assert(false, "unreachable")
end

local len1 = (c-a):Dot((b-a).unit)
local len2 = (b-a).magnitude - len1
local width = (a + (b-a).unit*len1 - c).magnitude

local maincf = CFrameFromTopBack(a, (b-a):Cross(c-b).unit, -(b-a).unit)

local list = {}

if len1 > 0.01 then
local w1 = Instance.new('WedgePart', m)
game:GetService("Debris"):AddItem(w1,5)
w1.Material = "SmoothPlastic"
w1.FormFactor = 'Custom'
w1.BrickColor = BrickColor.new("Medium blue")
w1.Transparency = 0
w1.Reflectance = 0
w1.Material = "SmoothPlastic"
w1.CanCollide = false
NoOutline(w1)
local sz = Vector3.new(0.2, width, len1)
w1.Size = sz
local sp = Instance.new("SpecialMesh",w1)
sp.MeshType = "Wedge"
sp.Scale = Vector3.new(0,1,1) * sz/w1.Size
w1:BreakJoints()
w1.Anchored = true
w1.Parent = workspace
w1.Transparency = 0.7
table.insert(Effects,{w1,"Disappear",.05})
w1.CFrame = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)
table.insert(list,w1)
end

if len2 > 0.01 then
local w2 = Instance.new('WedgePart', m)
game:GetService("Debris"):AddItem(w2,5)
w2.Material = "SmoothPlastic"
w2.FormFactor = 'Custom'
w2.BrickColor = BrickColor.new("Medium blue")
w2.Transparency = 0
w2.Reflectance = 0
w2.Material = "SmoothPlastic"
w2.CanCollide = false
NoOutline(w2)
local sz = Vector3.new(0.2, width, len2)
w2.Size = sz
local sp = Instance.new("SpecialMesh",w2)
sp.MeshType = "Wedge"
sp.Scale = Vector3.new(0,1,1) * sz/w2.Size
w2:BreakJoints()
w2.Anchored = true
w2.Parent = workspace
w2.Transparency = 0.7
table.insert(Effects,{w2,"Disappear",.05})
w2.CFrame = maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2)
table.insert(list,w2)
end
return unpack(list)
end

function MagicBlock(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,Type)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt())
prt.Anchored=true
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,10)
if Type==1 or Type==nil then
table.insert(Effects,{prt,"Block1",delay,x3,y3,z3,msh})
elseif Type==2 then
table.insert(Effects,{prt,"Block2",delay,x3,y3,z3,msh})
end
end

function MagicCircle(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt())
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("SpecialMesh",prt,"Sphere","nil",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,10)
table.insert(Effects,{prt,"Cylinder",delay,x3,y3,z3,msh})
end

function MagicCircle2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,push)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt())
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("SpecialMesh",prt,"Sphere","nil",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,10)
table.insert(Effects,{prt,"Blood",delay,x3,y3,z3,msh,push})
end

function MagicRing(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe*cf(x2,y2,z2)
local msh=mesh("SpecialMesh",prt,"FileMesh","3270017",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,10)
table.insert(Effects,{prt,"Cylinder",delay,x3,y3,z3,msh})
end

function MagicCylinder(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt())
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("CylinderMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,10)
table.insert(Effects,{prt,"Cylinder",delay,x3,y3,z3,msh})
end

function ClangEffect(brickcolor,cframe,duration,decrease,size,power)
local prt=part(3,workspace,0,1,brickcolor,"Effect",vt())
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(5,5,5))
game:GetService("Debris"):AddItem(prt,10)
table.insert(Effects,{prt,"CylinderClang",duration,decrease,size,power,prt.CFrame,nil})
end

function MagicWave(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt())
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("SpecialMesh",prt,"FileMesh","20329976",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,10)
table.insert(Effects,{prt,"Cylinder",delay,x3,y3,z3,msh})
end

function MagicSpecial(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt())
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("SpecialMesh",prt,"FileMesh","24388358",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,10)
table.insert(Effects,{prt,"Cylinder",delay,x3,y3,z3,msh})
end

function BreakEffect(brickcolor,cframe,x1,y1,z1)
local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
local msh=mesh("SpecialMesh",prt,"Sphere","nil",vt(0,0,0),vt(x1,y1,z1))
local num=math.random(10,50)/1000
game:GetService("Debris"):AddItem(prt,10)
table.insert(Effects,{prt,"Shatter",num,prt.CFrame,math.random()-math.random(),0,math.random(50,100)/100})
end

Damagefunc=function(hit,minim,maxim,knockback,Type,Property,Delay,KnockbackType,incstun,stagger,staghit,ranged,DecreaseState,DecreaseAmount,Duration,Sound)
if hit.Parent==nil then
return
end
if hit.Name=="Hitbox" and hit.Parent~=modelzorz and ranged~=true then
ref=part(3,workspace,0,1,BrickColor.new("Black"),"Reference",vt())
ref.Anchored=true
ref.CFrame=cf(hit.Position)
game:GetService("Debris"):AddItem(ref,1)
hitnum=math.random(1,5)
if hitnum==1 then so("199148971",ref,1,1)
elseif hitnum==2 then so("199149025",ref,1,1)
elseif hitnum==3 then so("199149072",ref,1,1)
elseif hitnum==4 then so("199149109",ref,1,1)
elseif hitnum==5 then so("199149119",ref,1,1)
end
StaggerHit.Value=true
end
h=hit.Parent:FindFirstChild("Humanoid")
if h~=nil and hit.Parent.Name~=Character.Name and hit.Parent:FindFirstChild("Torso")~=nil then
if hit.Parent:findFirstChild("DebounceHit")~=nil then if hit.Parent.DebounceHit.Value==true then return end end
if Player.Neutral==false then
if hit.Parent:findFirstChild("Alignment")~=nil then
if hit.Parent.Alignment.Value==Player.TeamColor.Color then return end
end
if game.Players:GetPlayerFromCharacter(hit.Parent)~=nil then
if game.Players:GetPlayerFromCharacter(hit.Parent).TeamColor==Player.TeamColor then return end
end
end
if doing2==true then
if BoundTarget==nil then
so("200632875",hit,1,1)
cooldownsadd[2]=.1
--Damagefunc(hit,6,8,math.random(20,40),"Normal",RootPart,.5,1,math.random(5,10),nil,true,false,"Movement",.2,200)
BoundTarget=hit.Parent
table.insert(Effects,{BoundTarget,"BloodBind",0,BoundTarget.Torso,cf(0,0,0)})
--table.insert(Effects,{BoundTarget,"BloodBind",0,BoundTarget.Torso,cf(0,0,0)})
local num=0
local eul=CFrame.fromEulerAnglesXYZ(math.random(-50,50),math.random(-50,50),math.random(-50,50))
for i=1,6 do
MagicCircle2(BrickColor.new(NewCol),cf(hit.Position)*eul*euler(num,0,0),1,10,1,-.02,.3,-.02,0.05,.6)
MagicCircle2(BrickColor.new(NewCol),cf(hit.Position)*eul*euler(0,1.57,0)*euler(num,0,0),1,10,1,-.02,.3,-.02,0.05,.6)
num=num+1.046
end
move2="(X)\
Assault"
end
end
if doing4==true then
if HitTarget==nil then
--Damagefunc(hit,5,10,1,"Normal",RootPart,.5,2,math.random(5,10),nil,true,false,"Movement",10,100)
HitTarget=hit.Parent
MagicBlock(BrickColor.new(NewCol),cf(HitTarget.Torso.Position),1,1,1,3,3,3,.1,1)
end
end
if Sound=="Impact" then
so("200632875",hit,1,1)
end
hitted=true
if Sound=="Shatter" then
so("199146069",hit,1,1)
end
c=Instance.new("ObjectValue")
c.Name="creator"
c.Value=game:service("Players").LocalPlayer
c.Parent=h
RecentEnemy.Value=hit.Parent
game:GetService("Debris"):AddItem(c,.5)
minim=minim*Atk.Value
maxim=maxim*Atk.Value
Damage=0
if minim==maxim then
Damage=maxim
else
Damage=math.random(minim,maxim)
end
blocked=false
enblock=nil
Stats=hit.Parent:findFirstChild("Stats")
if Stats~=nil then
invis=Stats:findFirstChild("Invisibility")
isinvis=Stats:findFirstChild("IsInvisible")
if (ranged==false or ranged==nil) and invis~=nil and isinvis.Value==true then
invis.Value=0
end
enblock=Stats:findFirstChild("Block")
if enblock~=nil then
if enblock.Value==true then
blocked=true
end
end
if Stats:findFirstChild("Defense")~=nil then
Damage=Damage/(Stats.Defense.Value)
if Damage<=3 and (ranged==false or ranged==nil) and blocked~=true then
hitnum=math.random(1,5)
if hitnum==1 then so("199149321",hit,1,1)
elseif hitnum==2 then so("199149338",hit,1,1)
elseif hitnum==3 then so("199149367",hit,1,1)
elseif hitnum==4 then so("199149409",hit,1,1)
elseif hitnum==5 then so("199149452",hit,1,1)
end
elseif ranged==false or ranged==nil and blocked~=true then
hitnum=math.random(1,6)
if hitnum==1 then so("199149137",hit,1,1)
elseif hitnum==2 then so("199149186",hit,1,1)
elseif hitnum==3 then so("199149221",hit,1,1)
elseif hitnum==4 then so("199149235",hit,1,1)
elseif hitnum==5 then so("199149269",hit,1,1)
elseif hitnum==6 then so("199149297",hit,1,1)
end
end
if Damage<=3 and staghit==true then
StaggerHit.Value=true
end
end
blood=blood+Damage*.3
if Stats:findFirstChild("Stun")~=nil then
if blocked==true then
incstun=incstun/2
end
if Stats.Stun.Value<Stats.StunThreshold.Value then
Stats.Stun.Value=Stats.Stun.Value+incstun
end
end
if Stats:findFirstChild("Stagger")~=nil then
if stagger==true then
Stats.Stagger.Value=true
end
end
end
if blocked==true then
showDamage(hit.Parent,"Block","Damage")
if ranged~=true then
enblock.Value=false
Stagger.Value=true
hitnum=math.random(1,2)
if hitnum==1 then so("199148933",hit,1,1)
elseif hitnum==2 then so("199148947",hit,1,1)
end
end
else
Damage=math.floor(Damage)
coroutine.resume(coroutine.create(function(Hum,Dam)
Hum:TakeDamage(Damage)
end),h,Damage)
showDamage(hit.Parent,Damage,"Damage")
if DecreaseState~=nil then
if DecreaseState=="Shatter" then
DecreaseStat(hit.Parent,"Movement",DecreaseAmount,Duration)
DecreaseStat(hit.Parent,"Damage",DecreaseAmount,Duration)
else
DecreaseStat(hit.Parent,DecreaseState,DecreaseAmount,Duration)
end
end
if Type=="Knockdown" then
hum=hit.Parent.Humanoid
hum.PlatformStand=true
coroutine.resume(coroutine.create(function(HHumanoid)
swait(1)
HHumanoid.PlatformStand=false
end),hum)
local angle=(hit.Position-(Property.Position+Vector3.new(0,0,0))).unit
--hit.CFrame=cf(hit.Position,Vector3.new(angle.x,hit.Position.y,angle.z))*CFrame.fromEulerAnglesXYZ(math.pi/4,0,0)
local bodvol=Instance.new("BodyVelocity")
bodvol.velocity=angle*knockback
bodvol.P=5000
bodvol.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)
bodvol.Parent=hit
rl=Instance.new("BodyAngularVelocity")
rl.P=3000
rl.maxTorque=Vector3.new(500000,500000,500000)*50000000000000
rl.angularvelocity=Vector3.new(math.random(-10,10),math.random(-10,10),math.random(-10,10))
rl.Parent=hit
game:GetService("Debris"):AddItem(bodvol,.5)
game:GetService("Debris"):AddItem(rl,.5)
elseif Type=="Shatter" then
for i=1,10 do
BreakEffect(BrickColor.new("Cyan"),hit.CFrame,math.random(20,80)/100,math.random(2,10),math.random(20,80)/100)
end
elseif Type=="Knockdown2" then
hum=hit.Parent.Humanoid
local angle=(hit.Position-(Property.Position+Vector3.new(0,0,0))).unit
local bodvol=Instance.new("BodyVelocity")
bodvol.velocity=angle*knockback
bodvol.P=5000
bodvol.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)
bodvol.Parent=hit
game:GetService("Debris"):AddItem(bodvol,.5)
elseif Type=="Normal" then
vp=Instance.new("BodyVelocity")
vp.P=500
vp.maxForce=Vector3.new(math.huge,0,math.huge)
if KnockbackType==1 then
vp.velocity=Property.CFrame.lookVector*knockback+Property.Velocity/1.05
elseif KnockbackType==2 then
vp.velocity=Property.CFrame.lookVector*knockback
end
game:GetService("Debris"):AddItem(vp,.5)
if knockback>0 then
vp.Parent=hit.Parent.Torso
end
end
end
debounce=Instance.new("BoolValue")
debounce.Name="DebounceHit"
debounce.Parent=hit.Parent
debounce.Value=true
game:GetService("Debris"):AddItem(debounce,Delay)
c=Instance.new("ObjectValue")
c.Name="creator"
c.Value=Player
c.Parent=h
game:GetService("Debris"):AddItem(c,.5)
CRIT=false
end
end

showDamage=function(Char,Dealt,Type)
m=Instance.new("Model")
m.Name="Effect"
c=Instance.new("Part")
c.Transparency=1
c.Name="Head"
c.TopSurface=0
c.BottomSurface=0
c.formFactor="Plate"
c.Size=Vector3.new(1,.4,1)
b=Instance.new("BillboardGui",c)
b.Size=UDim2.new(5,0,5,0)
b.AlwaysOnTop=true
damgui=gui("TextLabel",b,tostring(Dealt),1,Color3.new(0,0,0),UDim2.new(0,0,0,0),UDim2.new(1,0,1,0))
if Type=="Damage" then
damgui.Font="SourceSans"
if Dealt=="Block" then
damgui.TextColor3=BrickColor.new("Bright blue").Color
elseif Dealt<3 then
damgui.TextColor3=BrickColor.new("White").Color
elseif Dealt>=3 and Dealt<20 then
damgui.TextColor3=BrickColor.new("Bright yellow").Color
else
damgui.TextColor3=BrickColor.new("Really red").Color
damgui.Font="SourceSansBold"
end
elseif Type=="Debuff" then
damgui.TextColor3=BrickColor.new("White").Color
elseif Type=="Interrupt" then
damgui.TextColor3=BrickColor.new("New Yeller").Color
elseif Type=="Heal" then
damgui.TextColor3=BrickColor.new("Bright green").Color
end
--damgui.FontSize="Size48"
damgui.TextScaled=true
ms=Instance.new("CylinderMesh")
ms.Scale=Vector3.new(.8,.8,.8)
ms.Parent=c
c.Reflectance=0
Instance.new("BodyGyro").Parent=c
c.Parent=m
if Char:findFirstChild("Head")~=nil then
c.CFrame=cf(Char["Head"].CFrame.p+Vector3.new(math.random(-100,100)/100,3,math.random(-100,100)/100))
elseif Char.Parent:findFirstChild("Head")~=nil then
c.CFrame=cf(Char.Parent["Head"].CFrame.p+Vector3.new(math.random(-100,100)/100,3,math.random(-100,100)/100))
end
f=Instance.new("BodyPosition")
f.P=2000
f.D=100
f.maxForce=Vector3.new(math.huge,math.huge,math.huge)
if Type=="Damage" or Type=="Heal" then
f.position=c.Position+Vector3.new(0,3,0)
elseif Type=="Debuff" or Type=="Interrupt" then
f.position=c.Position+Vector3.new(0,5,0)
end
f.Parent=c
game:GetService("Debris"):AddItem(m,5)
table.insert(Effects,{m,"showDamage",damgui,f,10,1,15,50,100})
c.CanCollide=false
m.Parent=workspace
c.CanCollide=false
end

combo=0
function ob1d(mouse) 
if attack==true or equipped==false then return end
hold=true
if combo==0 then
combo=1
attackone()
elseif combo==1 then
combo=2
attacktwo()
elseif combo==2 then
combo=3
attackthree()
elseif combo==3 then
combo=0
attackfour()
end
coroutine.resume(coroutine.create(function() 
for i=1,50 do
if attack==false then
swait()
end
end
if attack==false then
combo=0
end
end))
end 

function ob1u(mouse) 
hold = false 
end 

buttonhold = false 

fenbarmove1.MouseButton1Click:connect(do1)
fenbarmove2.MouseButton1Click:connect(do2)
fenbarmove3.MouseButton1Click:connect(do3)
fenbarmove4.MouseButton1Click:connect(do4)
eul=0
equipped=false
function key(key) 
if attack==true then return end
if key=="f" then
pressedf=true
fnumb=0
attack=true
if equipped==false then
equipped=true
RSH=ch.Torso["Right Shoulder"] 
LSH=ch.Torso["Left Shoulder"] 
-- 
RSH.Parent=nil 
LSH.Parent=nil 
-- 
RW.Name="Right Shoulder"
RW.Part0=ch.Torso 
RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
RW.C1=cf(0, 0.5, 0) 
RW.Part1=ch["Right Arm"] 
RW.Parent=ch.Torso 
-- 
LW.Name="Left Shoulder"
LW.Part0=ch.Torso 
LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
LW.C1=cf(0, 0.5, 0) 
LW.Part1=ch["Left Arm"] 
LW.Parent=ch.Torso 
--
Animate.Parent=nil
animTrack:Play()
equipanim() 
else
equipped=false
hideanim() 
LH.C1=LHC1
RH.C1=RHC1
animTrack:Stop()
Animate.Parent=Character
swait(0) 
RW.Parent=nil 
LW.Parent=nil 
RSH.Parent=player.Character.Torso 
LSH.Parent=player.Character.Torso 
end
attack=false
end
if equipped==false then return end
if key=="g" then
--MUDAMUDAMUDAMUDAMUDAMUDA()
end
if key=="e" then
Transposition()
end
if key=="z" then
do1()
end
if key=="x" then
do2()
end
if key=="c" then
do3()
end
if key=="v" then
do4()
end
end 

function key2(key) 


end 

function s(mouse) 
mouse.Button1Down:connect(function() ob1d(mouse) end) 
mouse.Button1Up:connect(function() ob1u(mouse) end) 
mouse.KeyDown:connect(key) 
mouse.KeyUp:connect(key2) 

player=Player 
ch=Character 
MMouse=mouse 
end 

function ds(mouse) 
end 

Bin.Selected:connect(s) 
Bin.Deselected:connect(ds) 
print("Ichor loaded.")

local mananum=0
local blocknum2=0
local donum=0
local stunnum=0
local staggeranim=false
local stunanim=false
local Point=nil
local LastPoint=nil
local oldhealth=Humanoid.Health
local walk=0
local walkforw=true
while true do
swait()
if Humanoid.Health<=0 then
attack=true
resumeControl()
modelzorz.Parent=workspace
game:GetService("Debris"):AddItem(modelzorz,30)
for i=1,#Weapon do
Weapon[i].Parent=modelzorz
Weapon[i].CanCollide=true
end
for i=1,#Welds do
if Welds[i].Part0.Parent==Character or Welds[i].Part1.Parent==Character then
Welds[i].Parent=nil
else
Welds[i].Parent=rprt1
end
end
end
--isjugg
col=Player.TeamColor
--[[for _,c in pairs(game.Teams:children()) do
if c.TeamColor==col and c.Name=="Juggernaut" then
isjugg=true
end
end]]--
if fnumb<21 then
fnumb=fnumb+1
if pressedf==false then
fenframe5.BackgroundTransparency=fenframe5.BackgroundTransparency-.025
tellbar.TextTransparency=tellbar.TextTransparency-.05
tellbar.TextStrokeTransparency=tellbar.TextStrokeTransparency-.05
else
if fnumb==20 then
fenframe5.Parent=nil
print("daigui")
end
fenframe5.BackgroundTransparency=fenframe5.BackgroundTransparency+.025
tellbar.TextTransparency=tellbar.TextTransparency+.05
tellbar.TextStrokeTransparency=tellbar.TextStrokeTransparency+.05
end
end
if hbwld.Parent==nil then
hitbox2.Name="Hitbox"
else
hitbox2.Name="Hitbox2"
end
hitbox2.Parent=hitbox.Parent
hitbox2.Size=hitbox.Size
hitbox2.CFrame=hitboxCF
hboxpos.position=hitbox2.Position+vt(math.random(-100,100)/100,math.random(-100,100)/100,math.random(-100,100)/100)
if oldhealth>Humanoid.Health then
damage=oldhealth-Humanoid.Health
blood=blood+damage*.5
end
if blood>=100 then
blood=100
end
oldhealth=Humanoid.Health
--[[passive1.Value=-blood/400
passive2.Value=-blood/300
passive3.Value=blood/400]]
--[[passive1.Value=-.3*(blood/100)
passive2.Value=-.6*(blood/100)
passive3.Value=.2*(blood/100)]]
--[[passive1.Value=-(1.5*((blood*2)/100))/(10*(100/blood)) --max val should be -.3
passive2.Value=(-.6*(blood/150))*(-.6*(blood/150)) --max val should be -.6
passive3.Value=(.2*(blood/150))*(.2*(blood/150)) --max val should be .2]]

--thanks math
passive1.Value=-.1*(math.sin((math.pi*blood/100) / 2))
passive2.Value=-.6*(math.sin((math.pi*blood/100) / 2))
passive3.Value=.3*(math.sin((math.pi*blood/100) / 2))
if #BloodAllies>0 then
--table.insert(BloodAllies,{targ.Parent,hum.Health})
for e=1,#BloodAllies do
local Thing2=BloodAllies[e]
--[[if Thing[1].Parent==nil or Thing[1]:findFirstChild("Humanoid")==nil then
print("ded")
table.remove(BloodAllies,e)
end]]
if Thing2==nil then
table.remove(BloodAllies,e)
else
local Tors=Thing2[1]:findFirstChild("Torso")
if Tors==nil then
table.remove(BloodAllies,e)
end
if Thing2[1].Humanoid.Health<Thing2[2] then
print("TAKEN DAMAGE")
refd=part(3,workspace,0,1,BrickColor.new("Black"),"Reference",vt())
refd.Anchored=true
refd.CFrame=cf(RootPart.Position)
game:GetService("Debris"):AddItem(refd,10)
refd.CFrame=cf(RootPart.Position,Thing2[1].Torso.Position)
table.insert(Effects,{Thing2[1],"Transposition",50,refd})
table.remove(BloodAllies,e)
else
Thing2[2]=Thing2[1].Humanoid.Health
end
end
end
end
if Stagger.Value==true and staggeranim==false then
coroutine.resume(coroutine.create(function()
staggeranim=true
while attack==true do
swait()
end
StaggerAnim()
StaggerHit.Value=false
Stagger.Value=false
staggeranim=false
end))
end
if StaggerHit.Value==true and staggeranim==false then
coroutine.resume(coroutine.create(function()
staggeranim=true
while attack==true do
swait()
end
StaggerHitt()
StaggerHit.Value=false
Stagger.Value=false
staggeranim=false
end))
end
if Mvmt.Value<0 or Stagger.Value==true or Stun.Value>=StunT.Value or StaggerHit.Value==true or Rooted.Value==true then
Humanoid.WalkSpeed=0
else
Humanoid.WalkSpeed=16*Mvmt.Value
end
if Stun.Value>=StunT.Value and stunanim==false then
coroutine.resume(coroutine.create(function()
stunanim=true
while attack==true do
swait()
end
StunAnim()
Stun.Value=0
stunanim=false
end))
end
local stunnum2=20
if stunnum>=stunnum2 then
if Stun.Value>0 then
Stun.Value=Stun.Value-1
end
stunnum=0
end
stunnum=stunnum+1
if donum>=.5 then
handidle=true
elseif donum<=0 then
handidle=false
end
if handidle==false then
donum=donum+0.006
else
donum=donum-0.006
end
local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
local velderp=RootPart.Velocity.y
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
if equipped==true then
if attack==false then
idle=idle+1
else
idle=0
end
if idle>=500 then
if attack==false then
--Sheath()
end
end
if Anim=="Walk" then
if walkforw==true then
RH.C1=clerp(RH.C1,RHC1*cf(.2,-.2,0)*euler(0,0,1),(Mvmt.Value*10)/50)
LH.C1=clerp(LH.C1,LHC1*cf(.1,.2,0)*euler(0,0,1),(Mvmt.Value*10)/50)
else
RH.C1=clerp(RH.C1,RHC1*cf(-.1,.2,0)*euler(0,0,-1),(Mvmt.Value*10)/50)
LH.C1=clerp(LH.C1,LHC1*cf(-.2,-.2,0)*euler(0,0,-1),(Mvmt.Value*10)/50)
end
else
RH.C1=clerp(RH.C1,RHC1,.2)
LH.C1=clerp(LH.C1,LHC1,.2)
end
if RootPart.Velocity.y > 1 and hitfloor==nil then 
Anim="Jump"
if attack==false then
Neck.C0=clerp(Neck.C0,necko*euler(-0.2,0,0),.2)
Neck.C1=clerp(Neck.C1,necko2*euler(0,0,0),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(-.2,0,0),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(-.8,0,.2),.2)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.2)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-.8,0,-.2),.2)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.2)
RH.C0=clerp(RH.C0,cf(1,-1,-.3)*euler(-0.5,1.57,0)*euler(-.2,0,0),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,-.3)*euler(-0.5,-1.57,0)*euler(-.2,0,0),.2)
end
elseif RootPart.Velocity.y < -1 and hitfloor==nil then 
Anim="Fall"
if attack==false then
Neck.C0=clerp(Neck.C0,necko*euler(0.4,0,0),.2)
Neck.C1=clerp(Neck.C1,necko2*euler(0,0,0),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(.2,0,0),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(.1,0,1),.2)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.2)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(.1,0,-1),.2)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.2)
RH.C0=clerp(RH.C0,cf(1,-1,0)*euler(0.4,1.57,0),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*euler(-0.2,-1.57,0),.2)
end
elseif torvel<1 and hitfloor~=nil then
Anim="Idle"
if attack==false then
Neck.C0=clerp(Neck.C0,necko*euler(-.1,0,0)*euler(0,0,-.2),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-.2)*euler(.2,0,0)*euler(0,0,.2),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(1.7-(donum/5),0,.2+(donum/5))*euler(0,1.57,0),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(1.5-(donum/5),0,.1-(donum/5))*euler(0,-1.57,0),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(1.1,-.8,-.2)*euler(0,1.57,0)*euler(-.1,0,.2)*euler(0,0,0),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*euler(0,-1.57,0)*euler(0,0,.1),.2)
end
elseif torvel>2 and torvel<30 and hitfloor~=nil then
Anim="Walk"
walk=walk+1
if walk>=15-(5*Mvmt.Value) then
walk=0
if walkforw==true then
walkforw=false
elseif walkforw==false then
walkforw=true
end
end
if attack==false then
Neck.C0=clerp(Neck.C0,necko*euler(-.2,0,0),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*euler(.2,0,0),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(-.5,0,.2),.3)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-.5,0,-.3),.3)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.3)
RH.C0=clerp(RH.C0,cf(1,-1,0)*euler(0,1.57,0),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*euler(0,-1.57,0),.2)
end
elseif torvel>=30 and hitfloor~=nil then
Anim="Run"
if attack==false then
Neck.C0=clerp(Neck.C0,necko*euler(-.2,0,-.2),.4)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-1.5)*euler(.8,0,.2),.4)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*euler(1,0,.2),.4)
RW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*euler(-0.2,0,-0.4),.4)
LW.C1=clerp(LW.C1,cf(0,0.5,0)*euler(0,0,0),.4)
RH.C0=clerp(RH.C0,RHC0*cf(1,1,.2)*euler(0,-.2,-.5),.4)
LH.C0=clerp(LH.C0,LHC0*cf(-0.5,1,0)*euler(.2,0,-.5),.4)
end
end
end
if #Effects>0 then
--table.insert(Effects,{prt,"Block1",delay})
for e=1,#Effects do
if Effects[e]~=nil then
--for j=1,#Effects[e] do
local Thing=Effects[e]
if Thing~=nil then
local Part=Thing[1]
local Mode=Thing[2]
local Delay=Thing[3]
local IncX=Thing[4]
local IncY=Thing[5]
local IncZ=Thing[6]
if Thing[2]=="CylinderClang" then
if Thing[3]<=1 then
Thing[1].CFrame=Thing[1].CFrame*CFrame.new(0,2.5*Thing[5],0)*CFrame.fromEulerAnglesXYZ(Thing[6],0,0) 
Thing[7]=Thing[1].CFrame
effect("New Yeller",0,Thing[8],Thing[7])
Thing[8]=Thing[7]
Thing[3]=Thing[3]+Thing[4]
else
Part.Parent=nil
table.remove(Effects,e)
end
--[[Mesh=Thing[7]
Mesh.Scale=Mesh.Scale+vt(Thing[4],Thing[5],Thing[6])
Thing[1].Transparency=Thing[1].Transparency+Thing[3]]
end
if Thing[2]=="showDamage" then
if Thing[6]<Thing[5] then
Thing[6]=Thing[6]+1
elseif Thing[6]<Thing[7] then
Thing[4].position=Thing[4].position+vt(0,-.2,0)
Thing[6]=Thing[6]+1
elseif Thing[6]<Thing[8] then
Thing[6]=Thing[6]+1
elseif Thing[6]<Thing[9] then
Thing[6]=Thing[6]+1
Thing[4].position=Thing[4].position+vt(0,.2,0)
Thing[3].TextStrokeTransparency=Thing[3].TextStrokeTransparency+.1
Thing[3].TextTransparency=Thing[3].TextTransparency+.1
else
Thing[1].Parent=nil
table.remove(Effects,e)
end
end
if Thing[2]=="Transposition" then
--table.insert(Effects,{Thing[1],"Transposition",50,refd})
if Thing[3]>0 or hitfloor==nil then
Thing[3]=Thing[3]-1
Thing[4].CFrame=cf(Thing[1].Torso.Position,RootPart.Position)
local mag=(RootPart.Position-Thing[1].Torso.Position).magnitude
MagicCircle2(BrickColor.new(NewCol),Thing[4].CFrame*euler(1.57,0,0)*cf(math.random(-400,400)/100,0,math.random(-400,400)/100),2,10,2,-.1,mag/20,-.1,.05,-mag/15)
else
CF1=cf(Thing[1].Torso.Position)*cf(0,3,0)
CF2=cf(RootPart.Position)*cf(0,3,0)

cantele=true
if Rooted.Value==true then 
cantele=false
end
if Thing[1]:findFirstChild("Stats")~=nil then
if Thing[1].Stats:findFirstChild("Rooted")~=nil then
if Thing[1].Stats.Rooted.Value==true then
cantele=false
end
end
end

if cantele==true then
RootPart.CFrame=CF1
Thing[1].Torso.CFrame=CF2
RootPart.Velocity=vt(0,0,0)
Thing[1].Torso.Velocity=vt(0,0,0)
so("206082368",RootPart,1,1)
so("206082368",Thing[1].Torso,1,1)
MagicSpecial(BrickColor.new(NewCol),CF1,3,3,3,1,1,1,.05)
MagicSpecial(BrickColor.new(NewCol),CF2,3,3,3,1,1,1,.05)
local num=0
local eul=CFrame.fromEulerAnglesXYZ(math.random(-50,50),math.random(-50,50),math.random(-50,50))
for i=1,6 do
MagicCircle2(BrickColor.new(NewCol),CF1*eul*euler(num,0,0),3,20,3,-.02,.5,-.02,0.02,.6)
MagicCircle2(BrickColor.new(NewCol),CF1*eul*euler(0,1.57,0)*euler(num,0,0),3,20,3,-.02,.5,-.02,0.02,.6)
num=num+1.046
end
end
table.remove(Effects,e)
end
end
if Thing[2]=="BloodBind" then
--table.insert(Effects,{BoundTarget,"BloodBind",0,BoundTarget.Torso,cf(0,0,0)})
if Thing[4].Parent==nil or Thing[4]==nil or Thing[4].Parent.Parent==nil then
table.remove(Effects,e)
BoundTarget=nil
move2="(X)\
Blood Bind"
else
Thing[5]=Thing[5]*euler(0,.2,0)
if Thing[3]>=5 then
Thing[3]=0
for i=1.57,6.28,1.57 do
MagicBlock(BrickColor.new(NewCol),cf(Thing[4].Position)*Thing[5]*euler(0,i,0)*cf(0,0,5),1,1,1,1,1,1,.1,1)
end
end
Thing[3]=Thing[3]+1
if cooldowns[2]>cooldownmax/2 then
table.remove(Effects,e)
cooldownsadd[2]=.2
BoundTarget=nil
move2="(X)\
Blood Bind"
end
end
end
if Thing[2]~="DecreaseStat" and Thing[2]~="showDamage" and Thing[2]~="Transposition" and Thing[2]~="BloodBind" then
if Thing[1].Transparency<=1 then
if Thing[2]=="Block1" then
Thing[1].CFrame=Thing[1].CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
Mesh=Thing[7]
Mesh.Scale=Mesh.Scale+vt(Thing[4],Thing[5],Thing[6])
Thing[1].Transparency=Thing[1].Transparency+Thing[3]
elseif Thing[2]=="Ice" then
--prt,"Ice",delay,msh,1,.2
if Thing[6]<=Thing[5] then
Thing[6]=Thing[6]+.3
Thing[1].CFrame=Thing[1].CFrame*cf(0,1,0)
else
Thing[1].Transparency=Thing[1].Transparency+Thing[3]
end
elseif Thing[2]=="Shatter" then
Thing[1].Transparency=Thing[1].Transparency+Thing[3]
Thing[4]=Thing[4]*cf(0,Thing[7],0)
Thing[1].CFrame=Thing[4]*euler(Thing[6],0,0)
--Thing[1].CFrame=Thing[1].CFrame
Thing[6]=Thing[6]+Thing[5]
elseif Thing[2]=="Block2" then
Thing[1].CFrame=Thing[1].CFrame
Mesh=Thing[7]
Mesh.Scale=Mesh.Scale+vt(Thing[4],Thing[5],Thing[6])
Thing[1].Transparency=Thing[1].Transparency+Thing[3]
elseif Thing[2]=="Cylinder" then
Mesh=Thing[7]
Mesh.Scale=Mesh.Scale+vt(Thing[4],Thing[5],Thing[6])
Thing[1].Transparency=Thing[1].Transparency+Thing[3]
elseif Thing[2]=="Blood" then
Mesh=Thing[7]
Thing[1].CFrame=Thing[1].CFrame*cf(0,Thing[8],0)
Mesh.Scale=Mesh.Scale+vt(Thing[4],Thing[5],Thing[6])
Thing[1].Transparency=Thing[1].Transparency+Thing[3]
elseif Thing[2]=="Elec" then
Mesh=Thing[7]
Mesh.Scale=Mesh.Scale+vt(Thing[7],Thing[8],Thing[9])
Thing[1].Transparency=Thing[1].Transparency+Thing[3]
elseif Thing[2]=="Disappear" then
Thing[1].Transparency=Thing[1].Transparency+Thing[3]
end
else
Part.Parent=nil
table.remove(Effects,e)
end
end
end
--end
end
end
end
fenbarmana2:TweenSize(UDim2.new(.4,0,-4*mana.Value/100,0),nil,1,0.4,true)
fenbarmana4.Text="Mana("..mana.Value..")"
fenbarhp2.BackgroundColor3=Color3.new(Humanoid.Health/Humanoid.MaxHealth,0,0)
fenbarhp2:TweenSize(UDim2.new(Humanoid.Health/Humanoid.MaxHealth,0,1,0),nil,1,0.4,true)
fenbarhp3.Text="("..math.floor(Humanoid.Health)..")"
fenbarblock2:TweenSize(UDim2.new(.4,0,-4*blood/100,0),nil,1,0.4,true)
fenbarblock3.Text="Blood("..math.floor(blood)..")"
fenbarmove1b:TweenSize(UDim2.new(1*cooldowns[1]/cooldownmax,0,1,0),nil,1,0.4,true)
fenbarmove2b:TweenSize(UDim2.new(1*cooldowns[2]/cooldownmax,0,1,0),nil,1,0.4,true)
fenbarmove2.Text=move2
fenbarmove3b:TweenSize(UDim2.new(1*cooldowns[3]/cooldownmax,0,1,0),nil,1,0.4,true)
fenbarmove4b:TweenSize(UDim2.new(1*cooldowns[4]/cooldownmax,0,1,0),nil,1,0.4,true)
for _,c in pairs(Decrease:children()) do
if c:findFirstChild("Duration")~=nil then
c.Duration.Value=c.Duration.Value-1
if c.Duration.Value<=0 then
c.Parent=nil
end
end
if c.Name=="DecreaseAtk" then
decreaseatk=decreaseatk+c.Value
elseif c.Name=="DecreaseDef" then
decreasedef=decreasedef+c.Value
elseif c.Name=="DecreaseMvmt" then
decreasemvmt=decreasemvmt+c.Value
end
end
Atk.Value=1-decreaseatk
if Atk.Value<=0 then
Atk.Value=0
end
Def.Value=1-decreasedef
if Def.Value<=0 then
Def.Value=0.01
end
Mvmt.Value=1-decreasemvmt
if Mvmt.Value<=0 then
Mvmt.Value=0
end
decreaseatk=0
decreasedef=0
decreasemvmt=0
AtkVal=Atk.Value*100
AtkVal=math.floor(AtkVal)
AtkVal=AtkVal/100
fenbardamage.Text="Damage\
("..(AtkVal)..")"
DefVal=Def.Value*100
DefVal=math.floor(DefVal)
DefVal=DefVal/100
fenbardef.Text="Defense\
("..(DefVal)..")"
MvmtVal=Mvmt.Value*100
MvmtVal=math.floor(MvmtVal)
MvmtVal=MvmtVal/100
if Rooted.Value==true then MvmtVal=0 end
fenbarmove.Text="Walkspeed\
("..(MvmtVal)..")"
if Stun.Value>=StunT.Value then
fenbarstun2:TweenSize(UDim2.new(.4,0,-4,0),nil,1,0.4,true)
else
fenbarstun2:TweenSize(UDim2.new(.4,0,-4*Stun.Value/StunT.Value,0),nil,1,0.4,true)
end
fenbarstun3.Text="Stun("..Stun.Value..")"
if mana.Value>=100 then
mana.Value=100
else
if mananum<=9 then
mananum=mananum+1
elseif mananum>=8 then
mananum=0
mana.Value=mana.Value+1
end
end
--[[if cooldown1>=cooldownmax then
cooldown1=cooldownmax
else
cooldown1=cooldown1+cooldownadd1
end]]
for i=1,#cooldowns do
if cooldowns[i]>=cooldownmax then
cooldowns[i]=cooldownmax
else
cooldowns[i]=cooldowns[i]+cooldownsadd[i]
end
end
end

--[[ 
Copyrighted (C) Fenrier 2015
]] ]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>