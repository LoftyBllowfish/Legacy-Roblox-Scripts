setfenv(assert(loadstring(table.concat({
"script.Parent=nil\n\n--- shortcuts\n\nv3 = Vector3.new\n\ncn = CFrame.new\n\nca2 = CFrame.Angles\n\nmf = math.floor\n\nmran = math.random\n\nmrad = math.rad\n\nmdeg = math.deg\n\nca = function(x,y,z) return ca2(mrad(x),mrad(y),mrad(z)) end \n\nmran2 = function(a,b) return mran(a*1000,b*1000)/1000 end \n\nud=UDim2.new\n\nbn = BrickColor.new\n\nc3 = Color3.new\n\n-----\n\n--Player='RobroxMasterDX'\n\nPlayers=game:service'Players'\n\nPlayer=Players.LocalPlayer --[Player] \n\nPChar=Player.Character\n\n \n\nas,so={},{'metal','Block','Slash','Slash2','Hit','Kick'}\n\nas.corner='11294911'\n\nas.cone='1033714'\n\nas.ring=\"3270017\"\n\nas.Chakram='47260990'\n\nas.ring2='18430887'\n\nas.blast='20329976'\n\nas.missile='10207677'\n\nas.fire='2693346'\n\nas.boom='3264793'\n\nas.slash='10209645'\n\nas.abscond='2767090'\n\nas.firelaser='13775494'\n\nas.diamond='9756362'\n\nas.metal='rbxasset://sounds\\\\unsheath.wav'\n\nas.Block = 'rbxasset://sounds\\"
,"\\metal.ogg'\n\nas.Slash = '10209645'\n\nas.Slash2 = '46760716'\n\nas.Hit='10209583'\n\nas.Kick='46153268'\n\nas.cast='2101137'\n\nas.rockhead= '21629626'\n\nas.rockheadt='21629620'\n\n \n\n \n\nfor i,v in pairs(as) do \n\nif type(tonumber(v:sub(1,3)))==\"number\" then\n\nas[i]=\"http://www.roblox.com/asset/?id=\"..v\n\nend\n\nend\n\n \n\nLastMade=nil\n\niNew=function(tab)\n\nlocal v=Instance.new(tab[1])\n\nfor Ind,Val in pairs(tab) do\n\nif Ind~=1 and Ind~=2 then \n\nv[Ind] = Val\n\nend\n\nend\n\nv.Parent=tab[2]==0 and LastMade or tab[2]\n\nLastMade=v\n\nreturn v\n\nend\n\niPart=function(tab)\n\nlocal v=Instance.new(tab.type or 'Part')\n\nif tab.type~='CornerWedgePart' then v.formFactor='Custom' end\n\nv.TopSurface=0 v.BottomSurface=0\n\nif tab.sc then\n\nv.Size=v3(tab[2]*tab.sc,tab[3]*tab.sc,tab[4]*tab.sc)\n\nelse\n\nv.Size=v3(tab[2],tab[3],tab[4])\n\nend\n\nif tab.co then v.BrickColor=bn(tab.co) end\n\nif tab.tr then v.Transparency=t"
,"ab.tr end\n\nif tab.rf then v.Reflectance=tab.rf end\n\nif tab.can then v.CanCollide=tab.can end\n\nif tab.cf then v.CFrame=tab.cf end\n\nif tab.an then v.Anchored=tab.an end\n\nif tab.na then v.Name=tab.na end\n\nv.Parent=tab[1]\n\nv:BreakJoints()\n\nLastMade=v\n\nreturn v\n\nend\n\nfunction getoutline(x,z,i)\n\n return math.sqrt(x^2+z^2)+(i or 0.05),mdeg(math.atan2(x,z))\n\nend\n\nfunction v32(cf)\n\nlocal x,y,z=cf:toEulerAnglesXYZ()\n\nreturn v3(mdeg(x),mdeg(y),mdeg(z))\n\nend\n\nWeldLib={}\n\nfunction GetWeld(weld,CO) \n\n    if not WeldLib[weld] then \n\n        local x0,y0,z0=weld.C0:toEulerAnglesXYZ()\n\n        local x1,y1,z1=weld.C1:toEulerAnglesXYZ()\n\n        WeldLib[weld]={[0]=v3(mdeg(x0),mdeg(y0),mdeg(z0)),[1]=v3(mdeg(x1),mdeg(y1),mdeg(z1))}\n\n    end  \n\n    return weld['C'..CO].p,WeldLib[weld][CO]\n\nend \n\nfunction ClearWeld(weld)\n\nif WeldLib[weld] then WeldLib[weld]=nil end \n\nend\n\nfunction TweenNum(i,loops,i1,"
,"i2,smooth)\n\n    smooth = smooth or 1 \n\n    local perc \n\n    if smooth == 1 then  perc = math.sin((math.pi/2)/loops*i) else perc = i/loops  end \n\n    local ton\n\n    if i1 > i2 then \n\n        ton = -math.abs(i1 - i2) *perc \n\n    else \n\n        ton = math.abs(i1 - i2) *perc \n\n    end \n\n    return i1+ton\n\nend\n\nfunction TweenV3(i,loops,v1,v2,smooth)\n\n    smooth = smooth or 1 \n\n    local perc \n\n    if smooth == 1 then  perc = math.sin((math.pi/2)/loops*i) else perc = i/loops  end \n\n    local tox2,toy2,toz2 = 0,0,0 \n\n    if v1.x > v2.x then \n\n        tox2 = -math.abs(v1.x - v2.x) *perc \n\n    else \n\n        tox2 = math.abs(v1.x - v2.x) *perc \n\n    end \n\n    if v1.y > v2.y then \n\n        toy2 = -math.abs(v1.y - v2.y) *perc \n\n    else \n\n        toy2 = math.abs(v1.y - v2.y) *perc \n\n    end \n\n    if v1.z > v2.z then \n\n        toz2 = -math.abs(v1.z - v2.z) *perc \n\n    else \n\n        toz2 = "
,"math.abs(v1.z - v2.z) *perc \n\n    end\n\n    return v3(v1.x + tox2,v1.y + toy2,v1.z + toz2)\n\nend\n\nfunction TweenCF(i,loops,origpos,origangle,nextpos,nextangle,smooth) \n\n    smooth = smooth or 1 \n\n    local perc \n\n    if smooth == 1 then  perc = math.sin((math.pi/2)/loops*i) else perc = i/loops  end \n\n    local tox,toy,toz = 0,0,0 \n\n    if origangle.x > nextangle.x then  tox = -math.abs(origangle.x - nextangle.x) *perc \n\n    else tox = math.abs(origangle.x - nextangle.x) *perc end \n\n    if origangle.y > nextangle.y then toy = -math.abs(origangle.y - nextangle.y) *perc \n\n    else toy = math.abs(origangle.y - nextangle.y) *perc end \n\n    if origangle.z > nextangle.z then toz = -math.abs(origangle.z - nextangle.z) *perc \n\n    else toz = math.abs(origangle.z - nextangle.z) *perc end \n\n    local tox2,toy2,toz2 = 0,0,0 \n\n    if origpos.x > nextpos.x then \n\n    tox2 = -math.abs(origpos.x - nextpos.x) *perc \n\n  "
,"  else tox2 = math.abs(origpos.x - nextpos.x) *perc end \n\n    if origpos.y > nextpos.y then \n\n    toy2 = -math.abs(origpos.y - nextpos.y) *perc \n\n    else toy2 = math.abs(origpos.y - nextpos.y) *perc end \n\n    if origpos.z > nextpos.z then \n\n    toz2 = -math.abs(origpos.z - nextpos.z) *perc \n\n    else toz2 = math.abs(origpos.z - nextpos.z) *perc end\n\n    return cn(origpos.x + tox2,origpos.y + toy2,origpos.z + toz2)*ca(origangle.x + tox,origangle.y + toy,origangle.z + toz) \n\nend \n\nfunction SetWeld(weld,CO,i, loops, origpos,origangle, nextpos,nextangle,smooth) \n\n    smooth = smooth or 1 \n\n    if not WeldLib[weld] then \n\n        local x0,y0,z0=weld.C0:toEulerAnglesXYZ()\n\n        local x1,y1,z1=weld.C1:toEulerAnglesXYZ()\n\n        WeldLib[weld]={[0]=v3(mdeg(x0),mdeg(y0),mdeg(z0)),[1]=v3(mdeg(x1),mdeg(y1),mdeg(z1))}\n\n    end  \n\n    local perc \n\n    if smooth == 1 then \n\n        perc = math.sin((math.pi/2)/l"
,"oops*i) \n\n    else \n\n        perc = i/loops \n\n    end \n\n    --print(weld.Part1)\n\n    local tox,toy,toz = 0,0,0 \n\n    if origangle.x > nextangle.x then \n\n        tox = -math.abs(origangle.x - nextangle.x) *perc \n\n    else \n\n        tox = math.abs(origangle.x - nextangle.x) *perc \n\n    end \n\n    if origangle.y > nextangle.y then \n\n        toy = -math.abs(origangle.y - nextangle.y) *perc \n\n    else \n\n        toy = math.abs(origangle.y - nextangle.y) *perc \n\n    end \n\n    if origangle.z > nextangle.z then \n\n        toz = -math.abs(origangle.z - nextangle.z) *perc \n\n    else \n\n        toz = math.abs(origangle.z - nextangle.z) *perc \n\n    end \n\n \n\n    local tox2,toy2,toz2 = 0,0,0 \n\n    if origpos.x > nextpos.x then \n\n        tox2 = -math.abs(origpos.x - nextpos.x) *perc \n\n    else \n\n        tox2 = math.abs(origpos.x - nextpos.x) *perc \n\n    end \n\n    if origpos.y > nextpos.y then \n\n   "
,"     toy2 = -math.abs(origpos.y - nextpos.y) *perc \n\n    else \n\n        toy2 = math.abs(origpos.y - nextpos.y) *perc \n\n    end \n\n    if origpos.z > nextpos.z then \n\n        toz2 = -math.abs(origpos.z - nextpos.z) *perc \n\n    else \n\n        toz2 = math.abs(origpos.z - nextpos.z) *perc \n\n    end\n\n         WeldLib[weld][CO] = v3(origangle.x + tox,origangle.y + toy,origangle.z + toz)\n\n    weld['C'..CO] = cn(origpos.x + tox2,origpos.y + toy2,origpos.z + toz2)*ca(origangle.x + tox,origangle.y + toy,origangle.z + toz) \n\nend \n\nfunction se(Key,Text) \n\nlocal Values = {} \n\nfor value in (Text..Key):gmatch(\"(.-)\"..Key) do \n\ntable.insert(Values,value)\n\nend \n\nlocal Values2={}\n\nfor i,v in pairs(Values) do Values2[i]=Values[i]:lower() end\n\nreturn Values,Values2\n\nend\n\nfindplayer=function(nn)\n\nif not nn then return nil end \n\nlocal found \n\nfor i,v in pairs(Players:GetPlayers()) do \n\nif string.find(v.Name:"
,"lower(),nn:lower()) and not found then found=v  end \n\nend\n\nreturn found\n\nend\n\nLoopFunctions={}\n\nfunction DoLoop(times,func)\n\nLoopFunctions[#LoopFunctions+1]={times,0,func}\n\nend\n\nfunction MeshEffect(times,cf1,cf2,scale1,scale2,tr1,tr2,col,type)\n\nlocal cf2=cf2 or cf1\n\nlocal v=iPart{Char,1,1,1,co=col,cf=cf1,na='Mesh',an=true,tr=tr1} \n\nlocal mesh=iNew{'SpecialMesh',v,Scale=scale1}\n\nif type=='Brick' or type=='Sphere' then \n\nmesh.MeshType=type\n\nelse\n\nmesh.MeshId=type\n\nend\n\nlocal x1,y1,z1 = cf1:toEulerAnglesXYZ()\n\nlocal x2,y2,z2 = cf2:toEulerAnglesXYZ()\n\nlocal count=0\n\nDoLoop(times,function(i)  count=count+1 \n\nmesh.Scale=TweenV3(count,times,scale1,scale2,1) \n\nv.Transparency=TweenNum(count,times,tr1,tr2,1) \n\nv.CFrame=TweenCF(count,times,cf1.p,v3(mdeg(x1),mdeg(y1),mdeg(z1)),cf2.p,v3(mdeg(x2),mdeg(y2),mdeg(z2)),1) \n\nif i==1 then v:Remove() end end)\n\nend\n\nDmgv={8,16}\n\nHitDebounce={}\n\nDamage=f"
,"unction(Hum,Mult,Sound) \n\nif not Hum or Hum.Parent==Char then return end \n\nif not Hum.Parent:findFirstChild'Torso' then return end \n\nlocal HName=Hum.Parent.Name\n\nif HitDebounce[HName] and HitDebounce[HName]>tick() then return end \n\nHitDebounce[HName]=tick()+0.5\n\nlocal Mult=Mult or 1\n\nlocal Dealt=mran(Dmgv[1],Dmgv[2])*Mult\n\nlocal col=''\n\nif Hum.Parent:findFirstChild'Block' and Hum.Parent.Block.Value>0 then \n\nHum.Parent.Block.Value=Hum.Parent.Block.Value-1\n\ncol='Bright blue'\n\nelse\n\nHum.Health=Hum.Health-Dealt\n\ncol='Bright red'\n\nend\n\nif Sound then so[col=='Bright blue' and 'Block' or 'Hit']:Play() end\n\nlocal DoH=iNew{'Model',Char,Name=col=='Bright blue' and 'Block' or Dealt}\n\niNew{'Humanoid',DoH,MaxHealth=1/0,Health=1/0,Name=''}\n\nlocal Doh=iPart{DoH,0.6,0.2,0.6,co=col,an=true} Doh.Name='Head' iNew{'CylinderMesh',Doh}\n\nlocal dofs=Hum.Parent.Torso.CFrame*cn(mran2(-1.5,1.5),2.5,mran2(-1,1)) Doh.CFrame=d"
,"ofs\n\nDoLoop(40,function(i) Doh.CFrame=dofs*cn(0,i*2,0) Doh.Transparency=i-0.5 if i==1 then DoH:Remove() end end)\n\nend\n\nAOEFind = function(pos,ra,f,f2) -- range get \n\n local p0,p1=pos-v3(ra/2,ra/2,ra/2),pos+v3(ra/2,ra/2,ra/2)\n\n pcall(function()\n\n for i,v in pairs(workspace:FindPartsInRegion3(Region3.new(p0,p1),nil,100))  do \n\n local Hum=v.Parent:findFirstChild'Humanoid' \n\n if v.Name=='Torso' and Hum and Hum.Health>0  then\n\n pcall(function()  f(Hum,v)  end) \n\n elseif f2 and not Hum then \n\n pcall(function()  f2(v)  end) \n\n end \n\n end\n\n end) \n\nend \n\nfunction FaceBG(pos)\n\nBG.maxTorque=v3(1,1,1)/0\n\nBG.cframe=cn(Torso.Position,v3(pos.x,Torso.Position.y,pos.z))*cn(0,0,-1)\n\nend\n\n \n\nCC={''}\n\nScale=5\n\nMat='Marble'\n\n \n\nSpawnPoint=PChar.Torso.CFrame*cn(0,1+Scale*3,-20-Scale*1.5)\n\nname='Brock'\n\npcall(function() _G.OldMod00:Remove() end)\n\n \n\n---------------\n\nUNDYING=function()\n\npcall(functi"
,"on() fUNDYING:disconnect() end)\n\npcall(function() local hum=Grabbing.Part1.Parent.Humanoid Grabbing:Remove() Grabbing=nil hum.PlatformStand=false end)\n\nTorso.Anchored=true Torso.Transparency=1 Torso.CanCollide=false\n\nStand:Remove() Head:Remove()\n\nlocal RespawnPos=cn(Torso.CFrame.p+v3(0,Scale*5,0))*ca(0,mran(-360,360),0)\n\nwait(4)\n\nAnim='Reviving'\n\nlocal oldChar=Char\n\nlocal oldRootLimbs=RootLimbs\n\nfor i,v in pairs(oldRootLimbs) do v.Anchored=true end\n\nfMarble(Char,function(v) v.Anchored=true end) \n\nMakeAI(RespawnPos)  Anim='Reviving' \n\nfMarble(Char,function(v) v.Transparency=1 end)  \n\nfor i,v in pairs(RootLimbs) do v.Transparency=1 end  \n\nwait(0.1) Torso.Anchored=true\n\nlocal Reconstruct={}  \n\nfMarble(oldChar,function(v) \n\nlocal x1,y1,z1=v.CFrame:toEulerAnglesXYZ()  \n\nlocal x2,y2,z2=Char[v.Parent.Name][v.Name].CFrame:toEulerAnglesXYZ()\n\nReconstruct[#Reconstruct+1]={v,Char[v.Parent.Name][v.Name],v.Posit"
,"ion,v3(mdeg(x1),mdeg(y1),mdeg(z1)),v3(mdeg(x2),mdeg(y2),mdeg(z2))} end) \n\nfor i,v in pairs(oldRootLimbs) do  \n\nlocal x1,y1,z1=v.CFrame:toEulerAnglesXYZ()  \n\nlocal x2,y2,z2=Char[v.Name].CFrame:toEulerAnglesXYZ()\n\nReconstruct[#Reconstruct+1]={v,Char[v.Name],v.Position,v3(mdeg(x1),mdeg(y1),mdeg(z1)),v3(mdeg(x2),mdeg(y2),mdeg(z2))} end\n\nlocal tweens=100\n\nfor tween=1,tweens do \n\nfor i,v in pairs(Reconstruct) do v[1].CFrame=TweenCF(tween,tweens,v[3],v[4],v[2].Position,v[5],1)*ca(360*(tween/tweens),720*(tween/tweens),0) end\n\nwait()\n\nend\n\noldChar:Remove()\n\nfMarble(Char,function(v) v.Transparency=0 end)\n\nfor i,v in pairs(RootLimbs) do v.Transparency=0 end\n\nTorso.Anchored=false wait()\n\nBG.maxTorque=v3(1,1,1)/0 BG.cframe=Torso.CFrame\n\nReturnAnim()\n\nwait(2)\n\nBG.maxTorque=nov3\n\nAnim,ArmAnim,LegAnim='None','None','None'\n\nend\n\n------\n\n \n\nfunction MakeAI(SpawnPoint2)\n\nChar=iNew{'Model',workspace,Name=name,a"
,"rchivable=false} _G.OldMod00=Char\n\nTorso=iPart{Char,2,2,1,sc=Scale,co=CC[1],cf=SpawnPoint2,na='Torso'} \n\npTorso=iPart{Char,2,2,1,sc=Scale,co=CC[1],cf=SpawnPoint2,na='pTorso'} \n\nHead=iPart{Char,1,1,1,sc=Scale,co=CC[1],na='Head'} \n\npHead=iPart{Char,1,1,1,sc=Scale,co=CC[1],na='pHead'} iNew{'SpecialMesh',pHead,Scale=v3(1,1,1)*Scale/1.4,VertexColor=v3(1,1,1)/1.65,MeshId=as.rockhead,TextureId=as.rockheadt}\n\nStand=iPart{Char,1.5,2.9,1.1,sc=Scale,co=CC[1],na='Stand'}\n\n \n\nfor i,n in pairs(so) do \n\nlocal v=iNew{'Sound',Torso,Volume=1,Pitch=1,Looped=false,Name=v,SoundId=as[n]}\n\nso[n]=v\n\nend\n\n \n\n \n\nLSho=iPart{Char,1,1.5,1,sc=Scale,co=CC[1],na='LSho'} \n\nLArm=iPart{Char,1,1.5,1,sc=Scale,co=CC[1],na='LArm'} \n\n \n\n RSho=iPart{Char,1,1.5,1,sc=Scale,co=CC[1],na='RSho'} \n\n RArm=iPart{Char,1,1.5,1,sc=Scale,co=CC[1],na='RArm'} \n\n \n\n LThi=iPart{Char,1,1.5,1,sc=Scale,co=CC[1],na='LThi'} \n\n LLeg=iPart{Char,1,1.5,1,sc=Scal"
,"e,co=CC[1],na='LLeg'} \n\n \n\n RThi=iPart{Char,1,1.5,1,sc=Scale,co=CC[1],na='RThi'} \n\n RLeg=iPart{Char,1,1.5,1,sc=Scale,co=CC[1],na='RLeg'} \n\n \n\n \n\n \n\nnov3=v3(0,0,0)\n\nMarble={}\n\nMarbleSpeed=0.2\n\nMarbleMax=12\n\nfor i,v in pairs({pTorso,LSho,RSho,LArm,RArm,LThi,RThi,LLeg,RLeg}) do \n\nv.Material=Mat \n\nlocal VS=v.Size\n\nlocal va=1.2\n\n--v.Size=v.Size/1.5\n\nlocal vv=v:Clone()\n\nfor x=-1,1,2 do \n\nfor y=-1,1,2 do \n\nfor z=-1,1,2 do\n\nlocal marb=vv:Clone() marb.Size=VS/mran2(1.8,2.2) marb.Parent=v marb.Name=x..y..z\n\nlocal wmarb=iNew{'Weld',Char,Part0=v,Part1=marb,C0=cn(VS.x/4*x/va,VS.y/4*y,VS.z/4*z/va)*ca(mran(-MarbleMax,MarbleMax),mran(-MarbleMax,MarbleMax),mran(-MarbleMax,MarbleMax))}\n\nMarble[#Marble+1]={wmarb,mran(-1,1),mran(-1,1),mran(-1,1)}\n\nend end end \n\niNew{'BlockMesh',v,Scale=v3(1,1,1)/1.5}\n\nv.Transparency=0 --.995\n\nend \n\n \n\nfor i,v in pairs(Char:children()) do if v:IsA'BasePart' and v.Name~"
,"='Torso' then v.CFrame=Torso.CFrame end end\n\n \n\nHead.Transparency=0.99\n\nHead.CanCollide=false\n\nNeck=iNew{'Weld',Torso,Part0=Torso,Part1=Head,C0=cn(0,0,0)}\n\npNeck=iNew{'Weld',Torso,Part0=pTorso,Part1=pHead,C0=cn(0,1.5*Scale,0)}\n\nHum=iNew{'Humanoid',Char} \n\n \n\n \n\nTorso.Transparency=1\n\nwTorso=iNew{'Weld',Torso,Part0=Torso,Part1=pTorso,C0=cn(0,-2.5*Scale,0)*ca(0,0,0)}\n\noTorso=cn(0,0,0)\n\n \n\nStand.Transparency=1\n\nwStand=iNew{'Weld',Torso,Part0=Torso,Part1=Stand,C0=cn(0,-2.5*Scale,0)}\n\n \n\nwLSho=iNew{'Weld',LSho,Part0=pTorso,Part1=LSho,C0=cn(-1.5*Scale,0.75*Scale,0),C1=cn(0,0.25*Scale,0)}\n\nwLArm=iNew{'Weld',LArm,Part0=LSho,Part1=LArm,C0=cn(0,-0.75*Scale,0),C1=cn(0,0.75*Scale,0)}\n\n \n\nwRSho=iNew{'Weld',RSho,Part0=pTorso,Part1=RSho,C0=cn(1.5*Scale,0.75*Scale,0),C1=cn(0,0.25*Scale,0)}\n\nwRArm=iNew{'Weld',RArm,Part0=RSho,Part1=RArm,C0=cn(0,-0.75*Scale,0),C1=cn(0,0.75*Scale,0)}\n\n \n\nwLThi=iNew{'Weld',LThi,Par"
,"t0=pTorso,Part1=LThi,C0=cn(-0.5*Scale,-1*Scale,0),C1=cn(0,0.75*Scale,0)}\n\nwLLeg=iNew{'Weld',LLeg,Part0=LThi,Part1=LLeg,C0=cn(1,-0.75*Scale,0),C1=cn(0,0.75*Scale,0)}\n\n \n\nwRThi=iNew{'Weld',RThi,Part0=pTorso,Part1=RThi,C0=cn(0.5*Scale,-1*Scale,0),C1=cn(0,0.75*Scale,0)}\n\nwRLeg=iNew{'Weld',RLeg,Part0=RThi,Part1=RLeg,C0=cn(0,-0.75*Scale,0),C1=cn(0,0.75*Scale,0)}\n\n \n\nwLSho.C0=cn(-1.5*Scale,0.75*Scale,0)*ca(0,0,-135) --a,b\n\nwLArm.C0=cn(0,-0.75*Scale,0)*ca(0,0,0) --c,d\n\nwRSho.C0=cn(1.5*Scale,0.75*Scale,0)*ca(0,0,135) --e,f\n\nwRArm.C0=cn(0,-0.75*Scale,0)*ca(0,0,0) --g,h\n\n----\n\nwLThi.C0=cn(-0.5*Scale,-1*Scale,0)*ca(0,0,-45) --i,j\n\nwLLeg.C0=cn(0,-0.75*Scale,0)*ca(0,0,0) --k,l\n\nwRThi.C0=cn(0.5*Scale,-1*Scale,0)*ca(0,0,45) --m,n\n\nwRLeg.C0=cn(0,-0.75*Scale,0)*ca(0,0,0) --o,p\n\n \n\nBG=iNew{'BodyGyro',Torso,maxTorque=nov3}\n\nBP=iNew{'BodyPosition',Torso,maxForce=nov3}\n\nfUNDYING=Hum.Died:connect(UNDYING)\n\nLimbNames={'LSh"
,"o','RSho','LArm','RArm','RThi','LThi','RLeg','LLeg'}\n\nfor i=1,8 do local v=LimbNames[i] LimbNames[v]=getfenv()[\"w\"..v] end \n\nRootLimbs={pHead,pTorso,LSho,RSho,LArm,RArm,RThi,LThi,RLeg,LLeg}\n\nAnim,LegAnim,ArmAnim='Sit','Sit','Sit'\n\nend\n\nMakeAI(SpawnPoint)\n\n \n\n \n\nfunction GetPose() \n\nlocal a,b=GetWeld(wLSho,0) \n\nlocal c,d=GetWeld(wLArm,0)\n\nlocal e,f=GetWeld(wRSho,0)\n\nlocal g,h=GetWeld(wRArm,0) \n\nlocal i,j=GetWeld(wLThi,0)\n\nlocal k,l=GetWeld(wLLeg,0)\n\nlocal m,n=GetWeld(wRThi,0)\n\nlocal o,p=GetWeld(wRLeg,0)\n\nlocal q,r=GetWeld(wTorso,0)\n\nreturn a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r\n\nend\n\n \n\n \n\nASpeed=28\n\ncoroutine.resume(coroutine.create(function()\n\nSetWeld(wLSho,0,1,1,nov3,nov3,wLSho.C0.p,v3(45,0,-10),1)   \n\nSetWeld(wLArm,0,1,1,nov3,nov3,wLArm.C0.p,v3(45,0,10),1)\n\nSetWeld(wRSho,0,1,1,nov3,nov3,wRSho.C0.p,v3(45,0,10),1) \n\nSetWeld(wRArm,0,1,1,nov3,nov3,wRArm.C0.p,v3(45,0,-10),1)   \n\nSetWe"
,"ld(wLThi,0,1,1,nov3,nov3,v3(-0.5*Scale,-0.6*Scale,-0.5*Scale),v3(125,0,-12),1) \n\nSetWeld(wLLeg,0,1,1,nov3,nov3,wLLeg.C0.p,v3(-70,0,12),1) \n\nSetWeld(wRThi,0,1,1,nov3,nov3,v3( 0.5*Scale,-0.6*Scale,-0.5*Scale),v3(125,0,12),1) \n\nSetWeld(wRLeg,0,1,1,nov3,nov3,wRLeg.C0.p,v3(-70,0,-12),1) \n\nSetWeld(wTorso,0,1,1,oTorso,nov3,v3(0,-3*Scale,0),nov3,1)\n\nwait(1)\n\nAnim='Standing'\n\nlocal a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p=GetPose() \n\nfor x=1,ASpeed do \n\n    SetWeld(wTorso,0,x,ASpeed,wTorso.C0.p,nov3,oTorso,nov3,1)  \n\n    SetWeld(wLSho,0,x,ASpeed,a,b,v3(-1.5*Scale,0.5*Scale,0),v3(0,0,-10),1)   \n\n    SetWeld(wLArm,0,x,ASpeed,c,d,v3(0,-0.75*Scale,0),v3(10,0,10),1)\n\n    SetWeld(wRSho,0,x,ASpeed,e,f,v3(1.5*Scale,0.5*Scale,0),v3(0,0,10),1)\n\n    SetWeld(wRArm,0,x,ASpeed,g,h,v3(0,-0.75*Scale,0),v3(10,0,-10),1) \n\n    SetWeld(wLThi,0,x,ASpeed,i,j,v3(-0.5*Scale,-1*Scale,0),v3(15,0,-5),1) \n\n    SetWeld(wLLeg,0,x,ASpeed,k,l,v3(0,-0.75*Sc"
,"ale,0),v3(-15,0,5),1)\n\n    SetWeld(wRThi,0,x,ASpeed,m,n,v3(0.5*Scale,-1*Scale,0),v3(15,0,5),1) \n\n    SetWeld(wRLeg,0,x,ASpeed,o,p,v3(0,-0.75*Scale,0),v3(-15,0,-5),1)\n\nwait() \n\nend \n\nOa,Ob,Oc,Od,Oe,Of,Og,Oh,Oi,Oj,Ok,Ol,Om,On,Oo,Op=GetPose() \n\nArmAnim='None'\n\nLegAnim='None'\n\nAnim='None'\n\nend))\n\n--Target=PChar\n\nfunction Stay(bool,cff)\n\nBG.maxTorque=bool and v3(1,1,1)/0 or nov3 BG.cframe=cff or Torso.CFrame\n\nBP.maxForce=BG.maxTorque BP.position=Torso.Position\n\nend\n\nfunction fMarble(Ch,func)\n\nfor i,v in pairs(Ch:children()) do \n\nfor x=-1,1,2 do \n\nfor y=-1,1,2 do \n\nfor z=-1,1,2 do \n\nif v:findFirstChild(x..y..z) then func(v[x..y..z]) end\n\nend end end \n\nend\n\nend\n\nfunction ReturnAnim()\n\n    local ne1,ne2=GetWeld(pNeck,0)\n\n    local wt1,wt2=GetWeld(wTorso,0)\n\n    local a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p=GetPose() \n\n    for x=1,ASpeed do \n\n    SetWeld(wLSho,0,x,ASpeed,a,b,Oa,Ob,1)   \n\n    Se"
,"tWeld(wLArm,0,x,ASpeed,c,d,Oc,Od,1)\n\n    SetWeld(wRSho,0,x,ASpeed,e,f,Oe,Of,1) \n\n    SetWeld(wRArm,0,x,ASpeed,g,h,Og,Oh,1)   \n\n    SetWeld(wLThi,0,x,ASpeed,i,j,Oi,Oj,1) \n\n    SetWeld(wLLeg,0,x,ASpeed,k,l,Ok,Ol,1) \n\n    SetWeld(wRThi,0,x,ASpeed,m,n,Om,On,1) \n\n    SetWeld(wRLeg,0,x,ASpeed,o,p,Oo,Op,1) \n\n    SetWeld(wTorso,0,x,ASpeed,wt1,wt2,oTorso,nov3,1) \n\n    SetWeld(pNeck,0,x,ASpeed,ne1,ne2,v3(0,1.5,0)*Scale,nov3,1)\n\n    wait()\n\n    end\n\nend\n\n \n\nChatConnection=Player.Chatted:connect(function(msg)\n\ncoroutine.resume(coroutine.create(function()\n\nif not Char.Parent then return end\n\nlocal Sep,sep=se(';',msg)\n\nlocal p1,p2=findplayer(Sep[2]),findplayer(Sep[3])\n\nlocal cmd=sep[1]\n\n--print(Sep[1])\n\n--print(LimbNames[Sep[1]])\n\nTt=(p1 and p1.Character and p1.Character:findFirstChild'Torso') and p1.Character.Torso or nil\n\nif cmd=='sit' and (Anim=='None' or Anim=='Follow') then \n\n    Anim='Sitting'\n\n  "
,"  Hum:MoveTo(Torso.Position,Torso)\n\n    LegAnim,ArmAnim='Sit','Sit'\n\n    for x=1,ASpeed do \n\n    SetWeld(wLSho,0,x,ASpeed,Oa,Ob,Oa,v3(45,0,-10),1)   \n\n    SetWeld(wLArm,0,x,ASpeed,Oc,Od,Oc,v3(45,0,10),1)\n\n    SetWeld(wRSho,0,x,ASpeed,Oe,Of,Oe,v3(45,0,10),1) \n\n    SetWeld(wRArm,0,x,ASpeed,Og,Oh,Og,v3(45,0,-10),1)   \n\n    SetWeld(wLThi,0,x,ASpeed,Oi,Oj,v3(-0.5*Scale,-0.6*Scale,-0.5*Scale),v3(125,0,-12),1) \n\n    SetWeld(wLLeg,0,x,ASpeed,Ok,Ol,Ok,v3(-70,0,12),1) \n\n    SetWeld(wRThi,0,x,ASpeed,Om,On,v3( 0.5*Scale,-0.6*Scale,-0.5*Scale),v3(125,0,12),1) \n\n    SetWeld(wRLeg,0,x,ASpeed,Oo,Op,Oo,v3(-70,0,-12),1) \n\n    SetWeld(wTorso,0,x,ASpeed,oTorso,nov3,v3(0,-3*Scale,0),nov3,1)  \n\n    wait()\n\n    end\n\n    Anim='Sit'\n\nelseif (cmd=='stand' or cmd=='stop') and (Anim=='Sit' or Anim=='Follow' or Anim=='Form' or Anim=='Dance' or Anim=='Grab') then \n\n    if Anim=='Sit' or Anim=='Form' or Anim=='Dance' then \n\n    Anim="
,"'Returning'\n\n    ReturnAnim()\n\n    else\n\n    Target=nil\n\n    wait(0.2)\n\n    Hum:MoveTo(Torso.Position,Torso)\n\n    end\n\nLegAnim,ArmAnim,Anim='None','None','None'\n\nelseif cmd=='follow' and Tt and Anim=='None' then \n\nAnim='Follow'\n\nTarget=p1.Character\n\nelseif cmd=='shoot' and Tt and RArm['1-11'].Transparency~=1 and ArmAnim=='None' then \n\nTarget=p1.Character\n\nArmAnim='Shoot'\n\nFaceBG(Tt.Position)\n\nwait(0.5) \n\nlocal cff=cn(pTorso.CFrame.p,v3(Tt.Position.x,pTorso.Position.y,Tt.Position.z))\n\nlocal ofs=cff:toObjectSpace(cn(cff.CFrame*cn(1.5*Scale,0.5*Scale,0).p,Tt.CFrame*cn(0,2,0).p)*ca(90,0,0)*cn(0,-0.25*Scale,0))\n\nlocal x,y,z=ofs:toEulerAnglesXYZ() \n\nlocal rot=v3(mdeg(x),mdeg(y),mdeg(z))\n\n    for q=1,ASpeed do \n\n    SetWeld(wRArm,0,q,ASpeed,Og,Oh,Og,nov3,1)\n\n    SetWeld(wRSho,0,q,ASpeed,Oe,Of,ofs.p,rot,1)\n\n    SetWeld(wRSho,1,q,ASpeed,v3(0,0.25*Scale,0),nov3,nov3,nov3,1) \n\n    wait()\n\n    end\n"
,"\nfor y=-1,1,2 do for x=-1,1,2 do  for z=-1,1,2 do \n\n    local new=RArm[x..y..z]:Clone() new.Parent=RArm game.Debris:AddItem(new,8) new.Touched:connect(function(hit) Damage(hit.Parent:findFirstChild'Humanoid') end)\n\n    new.CFrame=RArm[x..y..z].CFrame*cn(0,-Scale*1.5,0) new.CanCollide=true new.Velocity=cn(new.Position,Target.Torso.Position).lookVector*((new.Position-Target.Torso.Position).magnitude*2+90)\n\n    RArm[x..y..z].Transparency=1 so.Block:Play() wait(0.06)\n\nend end end\n\nRArm.Transparency=1\n\ndelay(1,function() \n\nfor x=-1,1,2 do for y=-1,1,2 do  for z=-1,1,2 do  local new=RArm[x..y..z]:Clone() new.Transparency=0 new.CanCollide=false new.Name='f'..new.Name new.Parent=RArm new.CFrame=RArm.CFrame*cn(Scale*x*2,Scale*-3,Scale*z*2)\n\niNew{'BodyPosition',new,maxForce=v3(1,1,1)/0,position=RArm[x..y..z].Position} wait(0.14) end end end\n\nDoLoop(35,function(i) for x=-1,1,2 do for y=-1,1,2 do  for z=-1,1,2 do  RArm['f'..x..y."
,".z].BodyPosition.position=RArm[x..y..z].Position if i==1 then RArm['f'..x..y..z]:Remove() RArm[x..y..z].Transparency=0 RArm.Transparency=0 end end end  end end)\n\nend)\n\n    for q=1,ASpeed do \n\n    SetWeld(wRArm,0,q,ASpeed,Og,nov3,Og,Oh,1)\n\n    SetWeld(wRSho,0,q,ASpeed,ofs.p,rot,Oe,Of,1) \n\n    SetWeld(wRSho,1,q,ASpeed,nov3,nov3,v3(0,0.25*Scale,0),nov3,1) \n\n    wait()\n\n    end\n\nBG.maxTorque=nov3\n\nArmAnim='None'\n\nelseif cmd=='slam' and (Anim=='None' or Anim=='Follow') and Tt then \n\nTarget=p1\n\nlocal lTt=Tt\n\nAnim='Follow'\n\nrepeat Hum:MoveTo(Tt.Position+v3(0.5,0.5,0.5),Tt) wait(0.2) until lTt~=Tt or (Tt.Position-pTorso.Position).magnitude<10+Scale*5.5 or Anim~='Follow'\n\nif Anim~='Follow' then BG.maxTorque=nov3 return end \n\nif lTt~=Tt then return end \n\nAnim,LegAnim,ArmAnim='Slam','',''\n\nHum:MoveTo(Torso.Position,Torso)\n\nFaceBG(Tt.Position) \n\nStay(true,BG.cframe)\n\n    local a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,"
,"p=GetPose() \n\n    ASpeed2=15\n\n    for x=1,ASpeed2 do \n\n    SetWeld(wLSho,0,x,ASpeed2,a,b,Oa,v3(180,0,0),1)   \n\n    SetWeld(wRSho,0,x,ASpeed2,e,f,Oe,v3(180,0,0),1) \n\n    SetWeld(wTorso,0,x,ASpeed2,nov3,nov3,v3(0,3,0)*Scale,nov3,1)   \n\n    wait()\n\n    end\n\n    for x=1,ASpeed2 do \n\n    SetWeld(wTorso,0,x,ASpeed2,v3(0,3,0)*Scale,nov3,v3(0,-3*Scale+2.5,-6*Scale),v3(-89,0,0),1)   \n\n    wait()\n\n    end\n\n    AOEFind(pTorso.Position,6.5*Scale,function(Hum) Damage(Hum,3,true) Hum.Sit=true end)\n\n    MeshEffect(35,Torso.CFrame*cn(0,-3.5*Scale,-6*Scale)*ca(90,0,0),nil,v3(2,2,1)*Scale,v3(12,12,5)*Scale,0.2,1,'Light stone grey',as.ring)\n\n    wait(0.5)\n\n    for x=1,ASpeed do \n\n    SetWeld(wTorso,0,x,ASpeed,v3(0,-3*Scale+2.5,-6*Scale),v3(-90,0,0),nov3,nov3,1) \n\n    SetWeld(wLSho,0,x,ASpeed,Oa,v3(180,0,0),Oa,Ob,1)   \n\n    SetWeld(wRSho,0,x,ASpeed,Oe,v3(180,0,0),Oe,Of,1)   \n\n    wait()\n\n    end\n\nStay(false)\n\nAni"
,"m,LegAnim,ArmAnim='None','None','None'\n\nelseif cmd=='boulder' and Anim=='None' then \n\nTarget=p1.Character\n\nAnim,LegAnim,ArmAnim='','',''\n\nStay(true)\n\nFaceBG(Tt.Position)\n\n    for x=1,ASpeed do \n\n    SetWeld(wLSho,0,x,ASpeed,Oa,Ob,Oa,v3(135,0,0),1)   \n\n    SetWeld(wLArm,0,x,ASpeed,Oc,Od,Oc,v3(0,0,0),1)\n\n    SetWeld(wRSho,0,x,ASpeed,Oe,Of,Oe,v3(135,0,0),1) \n\n    SetWeld(wRArm,0,x,ASpeed,Og,Oh,Og,v3(0,0,-10),1)   \n\n    SetWeld(wLThi,0,x,ASpeed,Oi,Oj,v3(-0.5,-0.5,0.25)*Scale,v3(45,0,-15),1) \n\n    SetWeld(wLLeg,0,x,ASpeed,Ok,Ol,Ok,v3(0,0,0),1) \n\n    SetWeld(wRThi,0,x,ASpeed,Om,On,v3( 0.5,-0.5,0.25)*Scale,v3(45,0,15),1) \n\n    SetWeld(wRLeg,0,x,ASpeed,Oo,Op,Oo,v3(0,0,0),1) \n\n    SetWeld(wTorso,0,x,ASpeed,oTorso,nov3,v3(0,-1.5,-1.5)*Scale,v3(-90,0,0),1)  \n\n    wait()\n\n    end\n\nwait(0.2)\n\nlocal boulder=iPart{Char,1,1,1,type='WedgePart'} boulder.Material=Mat \n\nlocal wm=iNew{'SpecialMesh',boulder,Scale=v3(4,"
,"3,4)*Scale,MeshType='Wedge'}\n\nlocal wb=iNew{'Weld',boulder,Part0=RArm,Part1=boulder,C0=cn(-1.5*Scale,-2.3*Scale,0)*ca(180,180,0)}\n\n    local a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r=GetPose() \n\n    for x=1,ASpeed*2 do \n\n    SetWeld(wLSho,0,x,ASpeed*2,a,b,a,v3(225,0,0),1)   \n\n    SetWeld(wLArm,0,x,ASpeed*2,c,d,c,v3(45,0,0),1)\n\n    SetWeld(wRSho,0,x,ASpeed*2,e,f,e,v3(225,0,0),1) \n\n    SetWeld(wRArm,0,x,ASpeed*2,g,h,g,v3(45,0,0),1)   \n\n    SetWeld(wLThi,0,x,ASpeed*2,i,j,Oi,v3(0,0,-15),1) \n\n    SetWeld(wLLeg,0,x,ASpeed*2,k,l,k,v3(0,0,0),1) \n\n    SetWeld(wRThi,0,x,ASpeed*2,m,n,Om,v3(0,0,15),1) \n\n    SetWeld(wRLeg,0,x,ASpeed*2,o,p,o,v3(0,0,0),1) \n\n    SetWeld(wTorso,0,x,ASpeed*2,q,r,nov3,nov3,1)  \n\n    wait()\n\n    end\n\n    FaceBG(Tt.Position)\n\n    for x=1,ASpeed/2 do \n\n    SetWeld(wLSho,0,x,math.floor(ASpeed/2),a,v3(225,0,0),a,v3(90,0,0),1)   \n\n    SetWeld(wLArm,0,x,math.floor(ASpeed/2),c,v3(45,0,0),c,v3(45,0,0)"
,",1)\n\n    SetWeld(wRSho,0,x,math.floor(ASpeed/2),e,v3(225,0,0),e,v3(90,0,0),1) \n\n    SetWeld(wRArm,0,x,math.floor(ASpeed/2),g,v3(45,0,0),g,v3(45,0,0),1)   \n\n    wait()\n\n    end\n\nlocal bcf=boulder.CFrame\n\nwb:Remove()\n\nwm:Remove() \n\nboulder.Size=wm.Scale \n\nboulder.CFrame=cn(boulder.Position,Target.Torso.Position)*cn(0,3,-1)*ca(0,180,0)\n\n--boulder.Friction=0.1\n\nboulder.Elasticity=0\n\nboulder.Velocity=(boulder.CFrame*ca(0,180,0)).lookVector*((boulder.Position-Target.Torso.Position).magnitude*1+90)\n\nboulder.RotVelocity=nov3\n\ngame.Debris:AddItem(boulder,8)\n\nStay(false)\n\nReturnAnim()\n\nAnim,LegAnim,ArmAnim='None','None','None'\n\nelseif cmd=='grab' and Tt and not Grabbing then \n\nTarget=p1\n\nlocal lTt=Tt\n\nAnim='Follow'\n\nrepeat Hum:MoveTo(Tt.Position+v3(0.5,0.5,0.5),Tt) wait(0.2) until lTt~=Tt or (Tt.Position-Stand.CFrame*cn(0,-Stand.Size.y/2+1,-2.8*Scale).p).magnitude<10 or Anim~='Follow'\n\nif Anim~='Follo"
,"w' then BG.maxTorque=nov3 return end \n\nif lTt~=Tt then return end \n\npcall(function() Tt.Parent.Humanoid.PlatformStand=true end)\n\nHum:MoveTo(Torso.Position,Torso) \n\nAnim,LegAnim,ArmAnim='Grab','',''\n\n    FaceBG(Tt.Position)\n\n    for x=1,ASpeed do \n\n    SetWeld(wLSho,0,x,ASpeed,Oa,Ob,Oa,v3(-30,0,-30),1)   \n\n    SetWeld(wLArm,0,x,ASpeed,Oc,Od,Oc,v3(0,0,0),1)\n\n    SetWeld(wRSho,0,x,ASpeed,Oe,Of,Oe,v3(145,0,-30),1) \n\n    SetWeld(wRArm,0,x,ASpeed,Og,Oh,Og,v3(0,0,0),1)   \n\n    SetWeld(wLThi,0,x,ASpeed,Oi,Oj,v3(-0.5,-0.5,0)*Scale,v3(90,0,0),1) \n\n    SetWeld(wLLeg,0,x,ASpeed,Ok,Ol,Ok,v3(0,0,0),1) \n\n    SetWeld(wRThi,0,x,ASpeed,Om,On,v3(0.5,-0.5,0)*Scale,v3(90,0,0),1) \n\n    SetWeld(wRLeg,0,x,ASpeed,Oo,Op,Oo,v3(0,0,0),1) \n\n    SetWeld(wTorso,0,x,ASpeed,oTorso,nov3,v3(0,-1.5,-1.5)*Scale,v3(-90,0,0),1)  \n\n    wait()\n\n    end\n\nlocal ofs=RArm.CFrame:toObjectSpace(Tt.CFrame)  \n\nTt.Parent.Humanoid.PlatformStand=true"
,"  \n\nGrabbing=iNew{'Weld',RArm,Part0=RArm,Part1=Tt,C0=ofs} \n\nlocal a,b=GetWeld(Grabbing,0) \n\nfor x=1,ASpeed do \n\nSetWeld(Grabbing,0,x,ASpeed,a,b,v3(0,-0.75*Scale-1,0),v3(-90,0,0),1)  \n\nwait()\n\nend\n\nStay(false)\n\nReturnAnim()\n\nAnim,LegAnim,ArmAnim='None','None','None'\n\nelseif cmd=='dance' and (Anim=='None' or Anim=='Follow') then \n\nHum:MoveTo(pTorso.Position,pTorso)\n\nAnim,ArmAnim,LegAnim='Dance','Dance','Dance'\n\nlocal ASpeed=math.floor(ASpeed/2)\n\nrepeat\n\n    local a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r=GetPose() \n\n    for x=1,ASpeed do \n\n    if Anim~='Dance' then break end \n\n    SetWeld(wLSho,0,x,ASpeed,a,b,v3(-1.2,0.5,-0.25)*Scale,v3(35,0,30),1)   \n\n    SetWeld(wLArm,0,x,ASpeed,c,d,c,v3(25,0,0),1)\n\n    SetWeld(wRSho,0,x,ASpeed,e,f,v3( 1.2,0.5,-0.25)*Scale,v3(45,0,-30),1) \n\n    SetWeld(wRArm,0,x,ASpeed,g,h,g,v3(25,0,0),1)   \n\n    SetWeld(wLThi,0,x,ASpeed,i,j,i,v3(0,0,0),1) \n\n    SetWeld(wLLeg,0,x,"
,"ASpeed,k,l,k,v3(0,0,0),1) \n\n    SetWeld(wRThi,0,x,ASpeed,m,n,m,v3(45,0,20),1) \n\n    SetWeld(wRLeg,0,x,ASpeed,o,p,o,v3(-45,0,-20),1) \n\n    wait()\n\n    end\n\n    local a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r=GetPose() \n\n    for x=1,ASpeed do \n\n    if Anim~='Dance' then break end \n\n    SetWeld(wLSho,0,x,ASpeed,a,b,v3(-1.2,0.5,-0.25)*Scale,v3(95,0,30),1)   \n\n    SetWeld(wLArm,0,x,ASpeed,c,d,c,v3(-10,0,0),1)\n\n    SetWeld(wRSho,0,x,ASpeed,e,f,v3( 1.2,0.5,-0.25)*Scale,v3(105,0,-30),1) \n\n    SetWeld(wRArm,0,x,ASpeed,g,h,g,v3(-10,0,0),1)   \n\n    SetWeld(wLThi,0,x,ASpeed,i,j,i,v3(45,0,-20),1) \n\n    SetWeld(wLLeg,0,x,ASpeed,k,l,k,v3(-45,0,20),1) \n\n    SetWeld(wRThi,0,x,ASpeed,m,n,m,v3(0,0,0),1) \n\n    SetWeld(wRLeg,0,x,ASpeed,o,p,o,v3(0,0,0),1) \n\n    wait()\n\n    end\n\n    until Anim~='Dance'\n\nelseif cmd=='roll' and (Anim=='None' or Anim=='Follow') then \n\nTarget=p1\n\nlocal lTt=Tt\n\nAnim,ArmAnim,LegAnim='Follow',''"
,",''\n\n    local a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r=GetPose() \n\n    local n1,n2=GetWeld(pNeck,0)\n\n    for x=1,ASpeed do \n\n    SetWeld(wLSho,0,x,ASpeed,a,b,v3(-1.5,0.5,0)*Scale,v3(0,0,-45),1)   \n\n    SetWeld(wLArm,0,x,ASpeed,c,d,c,v3(0,0,90),1)\n\n    SetWeld(wRSho,0,x,ASpeed,e,f,v3( 1.5,0.5,0)*Scale,v3(0,0,45),1)  \n\n    SetWeld(wRArm,0,x,ASpeed,g,h,g,v3(0,0,-90),1)   \n\n    SetWeld(wLThi,0,x,ASpeed,i,j,v3(0,1, 0.5)*Scale,v3(-30,0,0),1) \n\n    SetWeld(wLLeg,0,x,ASpeed,k,l,k,v3(60,0,0),1) \n\n    SetWeld(wRThi,0,x,ASpeed,m,n,v3(0,1,-0.5)*Scale,v3(30,0,0),1) \n\n    SetWeld(wRLeg,0,x,ASpeed,o,p,o,v3(-60,0,0),1) \n\n    SetWeld(pNeck,0,x,ASpeed,n1,n2,v3(0,0,0),n2,1) \n\n    SetWeld(wTorso,0,x,ASpeed,oTorso,nov3,v3(0,-2,0)*Scale,nov3,1)  \n\n    wait()\n\n    end\n\ntWS[2]=3\n\nrepeat \n\nlocal cf=Torso.CFrame*cn(mran2(-1,1)*Scale,-4*Scale,0.5*Scale)*ca(90+mran(-20,20),mran(-30,30),0)\n\nMeshEffect(24,cf,cf*cn(0,4*Scale,0),v3(0."
,"5,0.5,0.5)*Scale,v3(mran2(1,4),mran2(3,5),mran2(1,3))*Scale,0.1,1,'Dark stone grey','Brick') \n\nHum:MoveTo(Tt.Position+v3(0.5,0.5,0.5),Tt) wTorso.C0=wTorso.C0*ca(-20,0,0) wait(0.035) until lTt~=Tt or (Tt.Position-Stand.CFrame*cn(0,-Stand.Size.y/2+1,-2.8*Scale).p).magnitude<5 or Anim~='Follow'\n\ntWS[2]=1\n\nClearWeld(wTorso)\n\nif Anim~='Follow' then return end \n\nif lTt~=Tt then return end \n\nReturnAnim()\n\nHum:MoveTo(Torso.Position,Torso) \n\nAnim,LegAnim,ArmAnim='None','None','None'\n\n---------------------------------------------------------------------------=---\n\nelseif cmd=='eat' and Grabbing and (Anim=='None' or Anim=='Follow') then \n\nAnim,ArmAnim='Eat','Eat'\n\n   for x=1,ASpeed*2 do \n\n    SetWeld(wRSho,0,x,ASpeed*2,Oe,Of,Oe,v3(135,0,15),1) \n\n    SetWeld(wRArm,0,x,ASpeed*2,Og,Oh,Og,v3(45,-10,-100),1)   \n\n    wait()\n\n    end\n\n    wait(1)\n\n   for x=1,40 do \n\n    SetWeld(wRSho,0,1,1,Oe,Of,Oe,v3(135+mran(-3,3),"
,"0,15+mran(-3,3)),1) \n\n    SetWeld(wRArm,0,1,1,Og,Oh,Og,v3(45,-10+mran(-12,12),-100+mran(-3,3)),1)   \n\n    wait(0.05)\n\n    if x%2==0 then \n\n    local cf=Grabbing.Part1.CFrame*ca(180,mran(-180,180),mran(-40,40))*cn(0,1.5,0)\n\n    MeshEffect(24,cf,cf*cn(0,10,0),v3(0.2,2,0.2),v3(0.4,5,0.4),0.1,1,'Really red','Sphere') \n\n    end\n\n    end\n\nGrabbing.Part1:BreakJoints()\n\npcall(function() Grabbing.Part1.Parent.Head:Remove() end)\n\nGrabbing:Remove() Grabbing=nil\n\nwait(2)\n\nReturnAnim()\n\nAnim,ArmAnim='None','None'\n\nelseif cmd=='drop' and Grabbing then \n\nlocal hum=Grabbing.Part1.Parent.Humanoid Grabbing:Remove() Grabbing=nil hum.PlatformStand=false\n\nelseif LimbNames[Sep[1]] and (Anim=='None' or Anim=='Form') then\n\nAnim,ArmAnim,LegAnim='Form','Form','Form'\n\nlocal v1,v2=GetWeld(LimbNames[Sep[1]],0)\n\nlocal sepx=se(',',Sep[2])\n\nfor x=1,ASpeed*2 do \n\nSetWeld(LimbNames[Sep[1]],0,x,ASpeed*2,v1,v2,v1,v3(tonumber(sepx["
,"1]),tonumber(sepx[2]),tonumber(sepx[3])),1)   \n\nwait()\n\nend\n\nelseif cmd=='plode' then \n\nChar:BreakJoints() wait()\n\nlocal Pressure=tonumber(sep[2]) or 50\n\nfMarble(Char,function(v) v.Velocity=cn(Torso.Position,v.Position).lookVector*Pressure end)\n\nfor i,v in pairs(RootLimbs) do v.Velocity=cn(Torso.Position,v.Position).lookVector*Pressure end\n\nelseif cmd=='explode' then \n\niNew{'Explosion',pTorso,Position=pTorso.Position,BlastRadius=Scale*2}\n\nelseif cmd=='goto' then\n\npcall(function()\n\nHum:MoveTo(Player:GetMouse().Hit.p,Player:GetMouse().Target) end)\n\nelseif cmd=='die' then \n\nChar:BreakJoints()\n\nelseif cmd=='test' then \n\nlocal pt=Player.Character.Torso.CFrame\n\nMeshEffect(35,pt*cn(0,5,0)*ca(90,0,0),nil,v3(2,2,1)*Scale,v3(7,7,3)*Scale,0.2,1,'Light stone grey',as.ring)\n\nelse\n\n \n\nend\n\nend))\n\nend)\n\n \n\n \n\n \n\n \n\nWalkAnim=0\n\nWalking=false\n\nWalkMulp=1\n\nWalkMax=16\n\nHum.WalkSpeed=18\n\ntWS={"
,"1,1,1,1,1,1,1}\n\n \n\nMarbler=0\n\nlocal cou=0\n\nwhile Char.Parent do \n\ncou=cou+1\n\n--if cou%2==0 then print(cou) end \n\nif Hum.Health>0 then \n\nif Torso.Velocity.y>5 then Torso.Velocity=v3(Torso.Velocity.x,5,Torso.Velocity.z) end \n\nWalking=v3(Torso.Velocity.x,0,Torso.Velocity.z).magnitude>Hum.WalkSpeed-2 and true or false\n\nif Walking and LegAnim=='None' then \n\nWalkAnim=WalkAnim+WalkMulp\n\nend\n\nif WalkAnim>0 and not Walking then \n\nWalkAnim=WalkAnim-1 \n\nelseif WalkAnim<0 and not Walking then \n\nWalkAnim=WalkAnim+1 \n\nend\n\nif math.abs(WalkAnim)>=WalkMax then WalkMulp=WalkMulp*-1 end \n\n    local WalkAdj=26\n\n    Neck.C0=Torso.CFrame:toObjectSpace(pHead.CFrame)\n\n    if ArmAnim=='None' then \n\n    SetWeld(wLSho,0,WalkAnim,WalkMax,Oa,Ob,Oa,v3(-WalkAdj*1.5,0,-10),1)   \n\n    SetWeld(wLArm,0,WalkAnim,WalkMax,Oc,Od,Oc,v3(10+(WalkAnim>0 and WalkAdj or 0),0,10),1)\n\n    SetWeld(wRSho,0,WalkAnim,WalkMax,Oe,Of,Oe,v3(W"
,"alkAdj*1.5,0,10),1) \n\n    SetWeld(wRArm,0,WalkAnim,WalkMax,Og,Oh,Og,v3(10+(WalkAnim>0 and WalkAdj or 0),0,-10),1)   \n\n    end\n\n    if LegAnim=='None' then \n\n    SetWeld(wLThi,0,WalkAnim,WalkMax,Oi,Oj,Oi,v3(15+WalkAdj,0,-5),1) \n\n    SetWeld(wLLeg,0,WalkAnim,WalkMax,Ok,Ol,Ok,v3(-15+(WalkAnim>0 and -WalkAdj or 0),0,5),1) \n\n    SetWeld(wRThi,0,WalkAnim,WalkMax,Om,On,Om,v3(15-WalkAdj,0,5),1) \n\n    SetWeld(wRLeg,0,WalkAnim,WalkMax,Oo,Op,Oo,v3(-15+(WalkAnim<0 and WalkAdj or 0),0,-5),1) \n\n    end\n\n    --[[\n\nfor i,v in pairs(Marble) do \n\nv[1].C0=v[1].C0*ca(MarbleSpeed*v[2],MarbleSpeed*v[3],MarbleSpeed*v[4])\n\nMarbler=Marbler+(MarbleSpeed*v[2])\n\nif Marbler>MarbleMax then \n\nv[2]=v[2]*-1\n\nv[3]=v[3]*-1\n\nv[4]=v[4]*-1\n\nend\n\nend --]]\n\nif Anim=='Follow' and Target and Target:findFirstChild'Torso' and not BG.maxTorque~=v3(1,1,1)/0 then \n\nHum:MoveTo(Target.Torso.CFrame*cn(2.5*Scale,0,5*Scale).p,Target.Torso)\n\nend\n"
,"\nif Grabbing and (not Grabbing.Part1 or not Grabbing.Part1.Parent or Grabbing.Part1.Parent:findFirstChild'Humanoid'==nil or Grabbing.Part1.Parent.Humanoid.Health<1) then \n\nGrabbing:Remove() Grabbing=nil\n\nend\n\n    --DoLoop Package\n\n    for i,v in pairs(LoopFunctions) do \n\n    v[2]=v[2]+1\n\n    v[3](v[2]/v[1])\n\n    if v[1]<=v[2] then LoopFunctions[i]=nil end \n\n    end\n\nend\n\nlocal ws=18\n\nfor i=1,#tWS do ws=ws*tWS[i] end\n\nHum.WalkSpeed=ws\n\nwait(0.03)\n\nend\n\nChatConnection:disconnect()\n\ngame:service'Debris':AddItem(script,0.5)\n\nscript.Disabled=true"
}))), getfenv())()
